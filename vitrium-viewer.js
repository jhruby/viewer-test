/** @preserve  version: 1.1.403
  build time: 2016-09-22T15:19:19.913000
*/
/*! jQuery v1.9.1 | (c) 2005, 2012 jQuery Foundation, Inc. | jquery.org/license
*/(function(e,t){var n,r,i=typeof t,o=e.document,a=e.location,s=e.jQuery,u=e.$,l={},c=[],p="1.9.1",f=c.concat,d=c.push,h=c.slice,g=c.indexOf,m=l.toString,y=l.hasOwnProperty,v=p.trim,b=function(e,t){return new b.fn.init(e,t,r)},x=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,w=/\S+/g,T=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,N=/^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/,C=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,k=/^[\],:{}\s]*$/,E=/(?:^|:|,)(?:\s*\[)+/g,S=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,A=/"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,j=/^-ms-/,D=/-([\da-z])/gi,L=function(e,t){return t.toUpperCase()},H=function(e){(o.addEventListener||"load"===e.type||"complete"===o.readyState)&&(q(),b.ready())},q=function(){o.addEventListener?(o.removeEventListener("DOMContentLoaded",H,!1),e.removeEventListener("load",H,!1)):(o.detachEvent("onreadystatechange",H),e.detachEvent("onload",H))};b.fn=b.prototype={jquery:p,constructor:b,init:function(e,n,r){var i,a;if(!e)return this;if("string"==typeof e){if(i="<"===e.charAt(0)&&">"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:N.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof b?n[0]:n,b.merge(this,b.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:o,!0)),C.test(i[1])&&b.isPlainObject(n))for(i in n)b.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}if(a=o.getElementById(i[2]),a&&a.parentNode){if(a.id!==i[2])return r.find(e);this.length=1,this[0]=a}return this.context=o,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):b.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),b.makeArray(e,this))},selector:"",length:0,size:function(){return this.length},toArray:function(){return h.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=b.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return b.each(this,e,t)},ready:function(e){return b.ready.promise().done(e),this},slice:function(){return this.pushStack(h.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(b.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:d,sort:[].sort,splice:[].splice},b.fn.init.prototype=b.fn,b.extend=b.fn.extend=function(){var e,n,r,i,o,a,s=arguments[0]||{},u=1,l=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[1]||{},u=2),"object"==typeof s||b.isFunction(s)||(s={}),l===u&&(s=this,--u);l>u;u++)if(null!=(o=arguments[u]))for(i in o)e=s[i],r=o[i],s!==r&&(c&&r&&(b.isPlainObject(r)||(n=b.isArray(r)))?(n?(n=!1,a=e&&b.isArray(e)?e:[]):a=e&&b.isPlainObject(e)?e:{},s[i]=b.extend(c,a,r)):r!==t&&(s[i]=r));return s},b.extend({noConflict:function(t){return e.$===b&&(e.$=u),t&&e.jQuery===b&&(e.jQuery=s),b},isReady:!1,readyWait:1,holdReady:function(e){e?b.readyWait++:b.ready(!0)},ready:function(e){if(e===!0?!--b.readyWait:!b.isReady){if(!o.body)return setTimeout(b.ready);b.isReady=!0,e!==!0&&--b.readyWait>0||(n.resolveWith(o,[b]),b.fn.trigger&&b(o).trigger("ready").off("ready"))}},isFunction:function(e){return"function"===b.type(e)},isArray:Array.isArray||function(e){return"array"===b.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?l[m.call(e)]||"object":typeof e},isPlainObject:function(e){if(!e||"object"!==b.type(e)||e.nodeType||b.isWindow(e))return!1;try{if(e.constructor&&!y.call(e,"constructor")&&!y.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(n){return!1}var r;for(r in e);return r===t||y.call(e,r)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||o;var r=C.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=b.buildFragment([e],t,i),i&&b(i).remove(),b.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:"string"==typeof n&&(n=b.trim(n),n&&k.test(n.replace(S,"@").replace(A,"]").replace(E,"")))?Function("return "+n)():(b.error("Invalid JSON: "+n),t)},parseXML:function(n){var r,i;if(!n||"string"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName("parsererror").length||b.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&b.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(j,"ms-").replace(D,L)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,a=M(e);if(n){if(a){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(a){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:v&&!v.call("\ufeff\u00a0")?function(e){return null==e?"":v.call(e)}:function(e){return null==e?"":(e+"").replace(T,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(M(Object(e))?b.merge(n,"string"==typeof e?[e]:e):d.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(g)return g.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if("number"==typeof r)for(;r>o;o++)e[i++]=n[o];else while(n[o]!==t)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,a=M(e),s=[];if(a)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(s[s.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(s[s.length]=r);return f.apply([],s)},guid:1,proxy:function(e,n){var r,i,o;return"string"==typeof n&&(o=e[n],n=e,e=o),b.isFunction(e)?(r=h.call(arguments,2),i=function(){return e.apply(n||this,r.concat(h.call(arguments)))},i.guid=e.guid=e.guid||b.guid++,i):t},access:function(e,n,r,i,o,a,s){var u=0,l=e.length,c=null==r;if("object"===b.type(r)){o=!0;for(u in r)b.access(e,n,u,r[u],!0,a,s)}else if(i!==t&&(o=!0,b.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(b(e),n)})),n))for(;l>u;u++)n(e[u],r,s?i:i.call(e[u],u,n(e[u],r)));return o?e:c?n.call(e):l?n(e[0],r):a},now:function(){return(new Date).getTime()}}),b.ready.promise=function(t){if(!n)if(n=b.Deferred(),"complete"===o.readyState)setTimeout(b.ready);else if(o.addEventListener)o.addEventListener("DOMContentLoaded",H,!1),e.addEventListener("load",H,!1);else{o.attachEvent("onreadystatechange",H),e.attachEvent("onload",H);var r=!1;try{r=null==e.frameElement&&o.documentElement}catch(i){}r&&r.doScroll&&function a(){if(!b.isReady){try{r.doScroll("left")}catch(e){return setTimeout(a,50)}q(),b.ready()}}()}return n.promise(t)},b.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){l["[object "+t+"]"]=t.toLowerCase()});function M(e){var t=e.length,n=b.type(e);return b.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||"function"!==n&&(0===t||"number"==typeof t&&t>0&&t-1 in e)}r=b(o);var _={};function F(e){var t=_[e]={};return b.each(e.match(w)||[],function(e,n){t[n]=!0}),t}b.Callbacks=function(e){e="string"==typeof e?_[e]||F(e):b.extend({},e);var n,r,i,o,a,s,u=[],l=!e.once&&[],c=function(t){for(r=e.memory&&t,i=!0,a=s||0,s=0,o=u.length,n=!0;u&&o>a;a++)if(u[a].apply(t[0],t[1])===!1&&e.stopOnFalse){r=!1;break}n=!1,u&&(l?l.length&&c(l.shift()):r?u=[]:p.disable())},p={add:function(){if(u){var t=u.length;(function i(t){b.each(t,function(t,n){var r=b.type(n);"function"===r?e.unique&&p.has(n)||u.push(n):n&&n.length&&"string"!==r&&i(n)})})(arguments),n?o=u.length:r&&(s=t,c(r))}return this},remove:function(){return u&&b.each(arguments,function(e,t){var r;while((r=b.inArray(t,u,r))>-1)u.splice(r,1),n&&(o>=r&&o--,a>=r&&a--)}),this},has:function(e){return e?b.inArray(e,u)>-1:!(!u||!u.length)},empty:function(){return u=[],this},disable:function(){return u=l=r=t,this},disabled:function(){return!u},lock:function(){return l=t,r||p.disable(),this},locked:function(){return!l},fireWith:function(e,t){return t=t||[],t=[e,t.slice?t.slice():t],!u||i&&!l||(n?l.push(t):c(t)),this},fire:function(){return p.fireWith(this,arguments),this},fired:function(){return!!i}};return p},b.extend({Deferred:function(e){var t=[["resolve","done",b.Callbacks("once memory"),"resolved"],["reject","fail",b.Callbacks("once memory"),"rejected"],["notify","progress",b.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return b.Deferred(function(n){b.each(t,function(t,o){var a=o[0],s=b.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&b.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[a+"With"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?b.extend(e,r):r}},i={};return r.pipe=r.then,b.each(t,function(e,o){var a=o[2],s=o[3];r[o[1]]=a.add,s&&a.add(function(){n=s},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=a.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=h.call(arguments),r=n.length,i=1!==r||e&&b.isFunction(e.promise)?r:0,o=1===i?e:b.Deferred(),a=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?h.call(arguments):r,n===s?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},s,u,l;if(r>1)for(s=Array(r),u=Array(r),l=Array(r);r>t;t++)n[t]&&b.isFunction(n[t].promise)?n[t].promise().done(a(t,l,n)).fail(o.reject).progress(a(t,u,s)):--i;return i||o.resolveWith(l,n),o.promise()}}),b.support=function(){var t,n,r,a,s,u,l,c,p,f,d=o.createElement("div");if(d.setAttribute("className","t"),d.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",n=d.getElementsByTagName("*"),r=d.getElementsByTagName("a")[0],!n||!r||!n.length)return{};s=o.createElement("select"),l=s.appendChild(o.createElement("option")),a=d.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t={getSetAttribute:"t"!==d.className,leadingWhitespace:3===d.firstChild.nodeType,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/top/.test(r.getAttribute("style")),hrefNormalized:"/a"===r.getAttribute("href"),opacity:/^0.5/.test(r.style.opacity),cssFloat:!!r.style.cssFloat,checkOn:!!a.value,optSelected:l.selected,enctype:!!o.createElement("form").enctype,html5Clone:"<:nav></:nav>"!==o.createElement("nav").cloneNode(!0).outerHTML,boxModel:"CSS1Compat"===o.compatMode,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,boxSizingReliable:!0,pixelPosition:!1},a.checked=!0,t.noCloneChecked=a.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!l.disabled;try{delete d.test}catch(h){t.deleteExpando=!1}a=o.createElement("input"),a.setAttribute("value",""),t.input=""===a.getAttribute("value"),a.value="t",a.setAttribute("type","radio"),t.radioValue="t"===a.value,a.setAttribute("checked","t"),a.setAttribute("name","t"),u=o.createDocumentFragment(),u.appendChild(a),t.appendChecked=a.checked,t.checkClone=u.cloneNode(!0).cloneNode(!0).lastChild.checked,d.attachEvent&&(d.attachEvent("onclick",function(){t.noCloneEvent=!1}),d.cloneNode(!0).click());for(f in{submit:!0,change:!0,focusin:!0})d.setAttribute(c="on"+f,"t"),t[f+"Bubbles"]=c in e||d.attributes[c].expando===!1;return d.style.backgroundClip="content-box",d.cloneNode(!0).style.backgroundClip="",t.clearCloneStyle="content-box"===d.style.backgroundClip,b(function(){var n,r,a,s="padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",u=o.getElementsByTagName("body")[0];u&&(n=o.createElement("div"),n.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",u.appendChild(n).appendChild(d),d.innerHTML="<table><tr><td></td><td>t</td></tr></table>",a=d.getElementsByTagName("td"),a[0].style.cssText="padding:0;margin:0;border:0;display:none",p=0===a[0].offsetHeight,a[0].style.display="",a[1].style.display="none",t.reliableHiddenOffsets=p&&0===a[0].offsetHeight,d.innerHTML="",d.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",t.boxSizing=4===d.offsetWidth,t.doesNotIncludeMarginInBodyOffset=1!==u.offsetTop,e.getComputedStyle&&(t.pixelPosition="1%"!==(e.getComputedStyle(d,null)||{}).top,t.boxSizingReliable="4px"===(e.getComputedStyle(d,null)||{width:"4px"}).width,r=d.appendChild(o.createElement("div")),r.style.cssText=d.style.cssText=s,r.style.marginRight=r.style.width="0",d.style.width="1px",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),typeof d.style.zoom!==i&&(d.innerHTML="",d.style.cssText=s+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=3===d.offsetWidth,d.style.display="block",d.innerHTML="<div></div>",d.firstChild.style.width="5px",t.shrinkWrapBlocks=3!==d.offsetWidth,t.inlineBlockNeedsLayout&&(u.style.zoom=1)),u.removeChild(n),n=d=a=r=null)}),n=s=u=l=r=a=null,t}();var O=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,B=/([A-Z])/g;function P(e,n,r,i){if(b.acceptData(e)){var o,a,s=b.expando,u="string"==typeof n,l=e.nodeType,p=l?b.cache:e,f=l?e[s]:e[s]&&s;if(f&&p[f]&&(i||p[f].data)||!u||r!==t)return f||(l?e[s]=f=c.pop()||b.guid++:f=s),p[f]||(p[f]={},l||(p[f].toJSON=b.noop)),("object"==typeof n||"function"==typeof n)&&(i?p[f]=b.extend(p[f],n):p[f].data=b.extend(p[f].data,n)),o=p[f],i||(o.data||(o.data={}),o=o.data),r!==t&&(o[b.camelCase(n)]=r),u?(a=o[n],null==a&&(a=o[b.camelCase(n)])):a=o,a}}function R(e,t,n){if(b.acceptData(e)){var r,i,o,a=e.nodeType,s=a?b.cache:e,u=a?e[b.expando]:b.expando;if(s[u]){if(t&&(o=n?s[u]:s[u].data)){b.isArray(t)?t=t.concat(b.map(t,b.camelCase)):t in o?t=[t]:(t=b.camelCase(t),t=t in o?[t]:t.split(" "));for(r=0,i=t.length;i>r;r++)delete o[t[r]];if(!(n?$:b.isEmptyObject)(o))return}(n||(delete s[u].data,$(s[u])))&&(a?b.cleanData([e],!0):b.support.deleteExpando||s!=s.window?delete s[u]:s[u]=null)}}}b.extend({cache:{},expando:"jQuery"+(p+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(e){return e=e.nodeType?b.cache[e[b.expando]]:e[b.expando],!!e&&!$(e)},data:function(e,t,n){return P(e,t,n)},removeData:function(e,t){return R(e,t)},_data:function(e,t,n){return P(e,t,n,!0)},_removeData:function(e,t){return R(e,t,!0)},acceptData:function(e){if(e.nodeType&&1!==e.nodeType&&9!==e.nodeType)return!1;var t=e.nodeName&&b.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),b.fn.extend({data:function(e,n){var r,i,o=this[0],a=0,s=null;if(e===t){if(this.length&&(s=b.data(o),1===o.nodeType&&!b._data(o,"parsedAttrs"))){for(r=o.attributes;r.length>a;a++)i=r[a].name,i.indexOf("data-")||(i=b.camelCase(i.slice(5)),W(o,i,s[i]));b._data(o,"parsedAttrs",!0)}return s}return"object"==typeof e?this.each(function(){b.data(this,e)}):b.access(this,function(n){return n===t?o?W(o,e,b.data(o,e)):null:(this.each(function(){b.data(this,e,n)}),t)},null,n,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){b.removeData(this,e)})}});function W(e,n,r){if(r===t&&1===e.nodeType){var i="data-"+n.replace(B,"-$1").toLowerCase();if(r=e.getAttribute(i),"string"==typeof r){try{r="true"===r?!0:"false"===r?!1:"null"===r?null:+r+""===r?+r:O.test(r)?b.parseJSON(r):r}catch(o){}b.data(e,n,r)}else r=t}return r}function $(e){var t;for(t in e)if(("data"!==t||!b.isEmptyObject(e[t]))&&"toJSON"!==t)return!1;return!0}b.extend({queue:function(e,n,r){var i;return e?(n=(n||"fx")+"queue",i=b._data(e,n),r&&(!i||b.isArray(r)?i=b._data(e,n,b.makeArray(r)):i.push(r)),i||[]):t},dequeue:function(e,t){t=t||"fx";var n=b.queue(e,t),r=n.length,i=n.shift(),o=b._queueHooks(e,t),a=function(){b.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),o.cur=i,i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return b._data(e,n)||b._data(e,n,{empty:b.Callbacks("once memory").add(function(){b._removeData(e,t+"queue"),b._removeData(e,n)})})}}),b.fn.extend({queue:function(e,n){var r=2;return"string"!=typeof e&&(n=e,e="fx",r--),r>arguments.length?b.queue(this[0],e):n===t?this:this.each(function(){var t=b.queue(this,e,n);b._queueHooks(this,e),"fx"===e&&"inprogress"!==t[0]&&b.dequeue(this,e)})},dequeue:function(e){return this.each(function(){b.dequeue(this,e)})},delay:function(e,t){return e=b.fx?b.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,o=b.Deferred(),a=this,s=this.length,u=function(){--i||o.resolveWith(a,[a])};"string"!=typeof e&&(n=e,e=t),e=e||"fx";while(s--)r=b._data(a[s],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(u));return u(),o.promise(n)}});var I,z,X=/[\t\r\n]/g,U=/\r/g,V=/^(?:input|select|textarea|button|object)$/i,Y=/^(?:a|area)$/i,J=/^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,G=/^(?:checked|selected)$/i,Q=b.support.getSetAttribute,K=b.support.input;b.fn.extend({attr:function(e,t){return b.access(this,b.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){b.removeAttr(this,e)})},prop:function(e,t){return b.access(this,b.prop,e,t,arguments.length>1)},removeProp:function(e){return e=b.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,o,a=0,s=this.length,u="string"==typeof e&&e;if(b.isFunction(e))return this.each(function(t){b(this).addClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(w)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(X," "):" ")){o=0;while(i=t[o++])0>r.indexOf(" "+i+" ")&&(r+=i+" ");n.className=b.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,a=0,s=this.length,u=0===arguments.length||"string"==typeof e&&e;if(b.isFunction(e))return this.each(function(t){b(this).removeClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(w)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(X," "):"")){o=0;while(i=t[o++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?b.trim(r):""}return this},toggleClass:function(e,t){var n=typeof e,r="boolean"==typeof t;return b.isFunction(e)?this.each(function(n){b(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n){var o,a=0,s=b(this),u=t,l=e.match(w)||[];while(o=l[a++])u=r?u:!s.hasClass(o),s[u?"addClass":"removeClass"](o)}else(n===i||"boolean"===n)&&(this.className&&b._data(this,"__className__",this.className),this.className=this.className||e===!1?"":b._data(this,"__className__")||"")})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(X," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,o=this[0];{if(arguments.length)return i=b.isFunction(e),this.each(function(n){var o,a=b(this);1===this.nodeType&&(o=i?e.call(this,n,a.val()):e,null==o?o="":"number"==typeof o?o+="":b.isArray(o)&&(o=b.map(o,function(e){return null==e?"":e+""})),r=b.valHooks[this.type]||b.valHooks[this.nodeName.toLowerCase()],r&&"set"in r&&r.set(this,o,"value")!==t||(this.value=o))});if(o)return r=b.valHooks[o.type]||b.valHooks[o.nodeName.toLowerCase()],r&&"get"in r&&(n=r.get(o,"value"))!==t?n:(n=o.value,"string"==typeof n?n.replace(U,""):null==n?"":n)}}}),b.extend({valHooks:{option:{get:function(e){var t=e.attributes.value;return!t||t.specified?e.value:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,a=o?null:[],s=o?i+1:r.length,u=0>i?s:o?i:0;for(;s>u;u++)if(n=r[u],!(!n.selected&&u!==i||(b.support.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&b.nodeName(n.parentNode,"optgroup"))){if(t=b(n).val(),o)return t;a.push(t)}return a},set:function(e,t){var n=b.makeArray(t);return b(e).find("option").each(function(){this.selected=b.inArray(b(this).val(),n)>=0}),n.length||(e.selectedIndex=-1),n}}},attr:function(e,n,r){var o,a,s,u=e.nodeType;if(e&&3!==u&&8!==u&&2!==u)return typeof e.getAttribute===i?b.prop(e,n,r):(a=1!==u||!b.isXMLDoc(e),a&&(n=n.toLowerCase(),o=b.attrHooks[n]||(J.test(n)?z:I)),r===t?o&&a&&"get"in o&&null!==(s=o.get(e,n))?s:(typeof e.getAttribute!==i&&(s=e.getAttribute(n)),null==s?t:s):null!==r?o&&a&&"set"in o&&(s=o.set(e,r,n))!==t?s:(e.setAttribute(n,r+""),r):(b.removeAttr(e,n),t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(w);if(o&&1===e.nodeType)while(n=o[i++])r=b.propFix[n]||n,J.test(n)?!Q&&G.test(n)?e[b.camelCase("default-"+n)]=e[r]=!1:e[r]=!1:b.attr(e,n,""),e.removeAttribute(Q?n:r)},attrHooks:{type:{set:function(e,t){if(!b.support.radioValue&&"radio"===t&&b.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(e,n,r){var i,o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return a=1!==s||!b.isXMLDoc(e),a&&(n=b.propFix[n]||n,o=b.propHooks[n]),r!==t?o&&"set"in o&&(i=o.set(e,r,n))!==t?i:e[n]=r:o&&"get"in o&&null!==(i=o.get(e,n))?i:e[n]},propHooks:{tabIndex:{get:function(e){var n=e.getAttributeNode("tabindex");return n&&n.specified?parseInt(n.value,10):V.test(e.nodeName)||Y.test(e.nodeName)&&e.href?0:t}}}}),z={get:function(e,n){var r=b.prop(e,n),i="boolean"==typeof r&&e.getAttribute(n),o="boolean"==typeof r?K&&Q?null!=i:G.test(n)?e[b.camelCase("default-"+n)]:!!i:e.getAttributeNode(n);return o&&o.value!==!1?n.toLowerCase():t},set:function(e,t,n){return t===!1?b.removeAttr(e,n):K&&Q||!G.test(n)?e.setAttribute(!Q&&b.propFix[n]||n,n):e[b.camelCase("default-"+n)]=e[n]=!0,n}},K&&Q||(b.attrHooks.value={get:function(e,n){var r=e.getAttributeNode(n);return b.nodeName(e,"input")?e.defaultValue:r&&r.specified?r.value:t},set:function(e,n,r){return b.nodeName(e,"input")?(e.defaultValue=n,t):I&&I.set(e,n,r)}}),Q||(I=b.valHooks.button={get:function(e,n){var r=e.getAttributeNode(n);return r&&("id"===n||"name"===n||"coords"===n?""!==r.value:r.specified)?r.value:t},set:function(e,n,r){var i=e.getAttributeNode(r);return i||e.setAttributeNode(i=e.ownerDocument.createAttribute(r)),i.value=n+="","value"===r||n===e.getAttribute(r)?n:t}},b.attrHooks.contenteditable={get:I.get,set:function(e,t,n){I.set(e,""===t?!1:t,n)}},b.each(["width","height"],function(e,n){b.attrHooks[n]=b.extend(b.attrHooks[n],{set:function(e,r){return""===r?(e.setAttribute(n,"auto"),r):t}})})),b.support.hrefNormalized||(b.each(["href","src","width","height"],function(e,n){b.attrHooks[n]=b.extend(b.attrHooks[n],{get:function(e){var r=e.getAttribute(n,2);return null==r?t:r}})}),b.each(["href","src"],function(e,t){b.propHooks[t]={get:function(e){return e.getAttribute(t,4)}}})),b.support.style||(b.attrHooks.style={get:function(e){return e.style.cssText||t},set:function(e,t){return e.style.cssText=t+""}}),b.support.optSelected||(b.propHooks.selected=b.extend(b.propHooks.selected,{get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}})),b.support.enctype||(b.propFix.enctype="encoding"),b.support.checkOn||b.each(["radio","checkbox"],function(){b.valHooks[this]={get:function(e){return null===e.getAttribute("value")?"on":e.value}}}),b.each(["radio","checkbox"],function(){b.valHooks[this]=b.extend(b.valHooks[this],{set:function(e,n){return b.isArray(n)?e.checked=b.inArray(b(e).val(),n)>=0:t}})});var Z=/^(?:input|select|textarea)$/i,et=/^key/,tt=/^(?:mouse|contextmenu)|click/,nt=/^(?:focusinfocus|focusoutblur)$/,rt=/^([^.]*)(?:\.(.+)|)$/;function it(){return!0}function ot(){return!1}b.event={global:{},add:function(e,n,r,o,a){var s,u,l,c,p,f,d,h,g,m,y,v=b._data(e);if(v){r.handler&&(c=r,r=c.handler,a=c.selector),r.guid||(r.guid=b.guid++),(u=v.events)||(u=v.events={}),(f=v.handle)||(f=v.handle=function(e){return typeof b===i||e&&b.event.triggered===e.type?t:b.event.dispatch.apply(f.elem,arguments)},f.elem=e),n=(n||"").match(w)||[""],l=n.length;while(l--)s=rt.exec(n[l])||[],g=y=s[1],m=(s[2]||"").split(".").sort(),p=b.event.special[g]||{},g=(a?p.delegateType:p.bindType)||g,p=b.event.special[g]||{},d=b.extend({type:g,origType:y,data:o,handler:r,guid:r.guid,selector:a,needsContext:a&&b.expr.match.needsContext.test(a),namespace:m.join(".")},c),(h=u[g])||(h=u[g]=[],h.delegateCount=0,p.setup&&p.setup.call(e,o,m,f)!==!1||(e.addEventListener?e.addEventListener(g,f,!1):e.attachEvent&&e.attachEvent("on"+g,f))),p.add&&(p.add.call(e,d),d.handler.guid||(d.handler.guid=r.guid)),a?h.splice(h.delegateCount++,0,d):h.push(d),b.event.global[g]=!0;e=null}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,p,f,d,h,g,m=b.hasData(e)&&b._data(e);if(m&&(c=m.events)){t=(t||"").match(w)||[""],l=t.length;while(l--)if(s=rt.exec(t[l])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){p=b.event.special[d]||{},d=(r?p.delegateType:p.bindType)||d,f=c[d]||[],s=s[2]&&RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),u=o=f.length;while(o--)a=f[o],!i&&g!==a.origType||n&&n.guid!==a.guid||s&&!s.test(a.namespace)||r&&r!==a.selector&&("**"!==r||!a.selector)||(f.splice(o,1),a.selector&&f.delegateCount--,p.remove&&p.remove.call(e,a));u&&!f.length&&(p.teardown&&p.teardown.call(e,h,m.handle)!==!1||b.removeEvent(e,d,m.handle),delete c[d])}else for(d in c)b.event.remove(e,d+t[l],n,r,!0);b.isEmptyObject(c)&&(delete m.handle,b._removeData(e,"events"))}},trigger:function(n,r,i,a){var s,u,l,c,p,f,d,h=[i||o],g=y.call(n,"type")?n.type:n,m=y.call(n,"namespace")?n.namespace.split("."):[];if(l=f=i=i||o,3!==i.nodeType&&8!==i.nodeType&&!nt.test(g+b.event.triggered)&&(g.indexOf(".")>=0&&(m=g.split("."),g=m.shift(),m.sort()),u=0>g.indexOf(":")&&"on"+g,n=n[b.expando]?n:new b.Event(g,"object"==typeof n&&n),n.isTrigger=!0,n.namespace=m.join("."),n.namespace_re=n.namespace?RegExp("(^|\\.)"+m.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,n.result=t,n.target||(n.target=i),r=null==r?[n]:b.makeArray(r,[n]),p=b.event.special[g]||{},a||!p.trigger||p.trigger.apply(i,r)!==!1)){if(!a&&!p.noBubble&&!b.isWindow(i)){for(c=p.delegateType||g,nt.test(c+g)||(l=l.parentNode);l;l=l.parentNode)h.push(l),f=l;f===(i.ownerDocument||o)&&h.push(f.defaultView||f.parentWindow||e)}d=0;while((l=h[d++])&&!n.isPropagationStopped())n.type=d>1?c:p.bindType||g,s=(b._data(l,"events")||{})[n.type]&&b._data(l,"handle"),s&&s.apply(l,r),s=u&&l[u],s&&b.acceptData(l)&&s.apply&&s.apply(l,r)===!1&&n.preventDefault();if(n.type=g,!(a||n.isDefaultPrevented()||p._default&&p._default.apply(i.ownerDocument,r)!==!1||"click"===g&&b.nodeName(i,"a")||!b.acceptData(i)||!u||!i[g]||b.isWindow(i))){f=i[u],f&&(i[u]=null),b.event.triggered=g;try{i[g]()}catch(v){}b.event.triggered=t,f&&(i[u]=f)}return n.result}},dispatch:function(e){e=b.event.fix(e);var n,r,i,o,a,s=[],u=h.call(arguments),l=(b._data(this,"events")||{})[e.type]||[],c=b.event.special[e.type]||{};if(u[0]=e,e.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,e)!==!1){s=b.event.handlers.call(this,e,l),n=0;while((o=s[n++])&&!e.isPropagationStopped()){e.currentTarget=o.elem,a=0;while((i=o.handlers[a++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(i.namespace))&&(e.handleObj=i,e.data=i.data,r=((b.event.special[i.origType]||{}).handle||i.handler).apply(o.elem,u),r!==t&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,e),e.result}},handlers:function(e,n){var r,i,o,a,s=[],u=n.delegateCount,l=e.target;if(u&&l.nodeType&&(!e.button||"click"!==e.type))for(;l!=this;l=l.parentNode||this)if(1===l.nodeType&&(l.disabled!==!0||"click"!==e.type)){for(o=[],a=0;u>a;a++)i=n[a],r=i.selector+" ",o[r]===t&&(o[r]=i.needsContext?b(r,this).index(l)>=0:b.find(r,this,null,[l]).length),o[r]&&o.push(i);o.length&&s.push({elem:l,handlers:o})}return n.length>u&&s.push({elem:this,handlers:n.slice(u)}),s},fix:function(e){if(e[b.expando])return e;var t,n,r,i=e.type,a=e,s=this.fixHooks[i];s||(this.fixHooks[i]=s=tt.test(i)?this.mouseHooks:et.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new b.Event(a),t=r.length;while(t--)n=r[t],e[n]=a[n];return e.target||(e.target=a.srcElement||o),3===e.target.nodeType&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,a):e},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,i,a,s=n.button,u=n.fromElement;return null==e.pageX&&null!=n.clientX&&(i=e.target.ownerDocument||o,a=i.documentElement,r=i.body,e.pageX=n.clientX+(a&&a.scrollLeft||r&&r.scrollLeft||0)-(a&&a.clientLeft||r&&r.clientLeft||0),e.pageY=n.clientY+(a&&a.scrollTop||r&&r.scrollTop||0)-(a&&a.clientTop||r&&r.clientTop||0)),!e.relatedTarget&&u&&(e.relatedTarget=u===e.target?n.toElement:u),e.which||s===t||(e.which=1&s?1:2&s?3:4&s?2:0),e}},special:{load:{noBubble:!0},click:{trigger:function(){return b.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):t}},focus:{trigger:function(){if(this!==o.activeElement&&this.focus)try{return this.focus(),!1}catch(e){}},delegateType:"focusin"},blur:{trigger:function(){return this===o.activeElement&&this.blur?(this.blur(),!1):t},delegateType:"focusout"},beforeunload:{postDispatch:function(e){e.result!==t&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=b.extend(new b.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?b.event.trigger(i,null,t):b.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},b.removeEvent=o.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]===i&&(e[r]=null),e.detachEvent(r,n))},b.Event=function(e,n){return this instanceof b.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?it:ot):this.type=e,n&&b.extend(this,n),this.timeStamp=e&&e.timeStamp||b.now(),this[b.expando]=!0,t):new b.Event(e,n)},b.Event.prototype={isDefaultPrevented:ot,isPropagationStopped:ot,isImmediatePropagationStopped:ot,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=it,e&&(e.preventDefault?e.preventDefault():e.returnValue=!1)},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=it,e&&(e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=it,this.stopPropagation()}},b.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){b.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;
return(!i||i!==r&&!b.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),b.support.submitBubbles||(b.event.special.submit={setup:function(){return b.nodeName(this,"form")?!1:(b.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=b.nodeName(n,"input")||b.nodeName(n,"button")?n.form:t;r&&!b._data(r,"submitBubbles")&&(b.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),b._data(r,"submitBubbles",!0))}),t)},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&b.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){return b.nodeName(this,"form")?!1:(b.event.remove(this,"._submit"),t)}}),b.support.changeBubbles||(b.event.special.change={setup:function(){return Z.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(b.event.add(this,"propertychange._change",function(e){"checked"===e.originalEvent.propertyName&&(this._just_changed=!0)}),b.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),b.event.simulate("change",this,e,!0)})),!1):(b.event.add(this,"beforeactivate._change",function(e){var t=e.target;Z.test(t.nodeName)&&!b._data(t,"changeBubbles")&&(b.event.add(t,"change._change",function(e){!this.parentNode||e.isSimulated||e.isTrigger||b.event.simulate("change",this.parentNode,e,!0)}),b._data(t,"changeBubbles",!0))}),t)},handle:function(e){var n=e.target;return this!==n||e.isSimulated||e.isTrigger||"radio"!==n.type&&"checkbox"!==n.type?e.handleObj.handler.apply(this,arguments):t},teardown:function(){return b.event.remove(this,"._change"),!Z.test(this.nodeName)}}),b.support.focusinBubbles||b.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){b.event.simulate(t,e.target,b.event.fix(e),!0)};b.event.special[t]={setup:function(){0===n++&&o.addEventListener(e,r,!0)},teardown:function(){0===--n&&o.removeEventListener(e,r,!0)}}}),b.fn.extend({on:function(e,n,r,i,o){var a,s;if("object"==typeof e){"string"!=typeof n&&(r=r||n,n=t);for(a in e)this.on(a,n,r,e[a],o);return this}if(null==r&&null==i?(i=n,r=n=t):null==i&&("string"==typeof n?(i=r,r=t):(i=r,r=n,n=t)),i===!1)i=ot;else if(!i)return this;return 1===o&&(s=i,i=function(e){return b().off(e),s.apply(this,arguments)},i.guid=s.guid||(s.guid=b.guid++)),this.each(function(){b.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,o;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,b(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if("object"==typeof e){for(o in e)this.off(o,n,e[o]);return this}return(n===!1||"function"==typeof n)&&(r=n,n=t),r===!1&&(r=ot),this.each(function(){b.event.remove(this,e,r,n)})},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},trigger:function(e,t){return this.each(function(){b.event.trigger(e,t,this)})},triggerHandler:function(e,n){var r=this[0];return r?b.event.trigger(e,n,r,!0):t}}),function(e,t){var n,r,i,o,a,s,u,l,c,p,f,d,h,g,m,y,v,x="sizzle"+-new Date,w=e.document,T={},N=0,C=0,k=it(),E=it(),S=it(),A=typeof t,j=1<<31,D=[],L=D.pop,H=D.push,q=D.slice,M=D.indexOf||function(e){var t=0,n=this.length;for(;n>t;t++)if(this[t]===e)return t;return-1},_="[\\x20\\t\\r\\n\\f]",F="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",O=F.replace("w","w#"),B="([*^$|!~]?=)",P="\\["+_+"*("+F+")"+_+"*(?:"+B+_+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+O+")|)|)"+_+"*\\]",R=":("+F+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+P.replace(3,8)+")*)|.*)\\)|)",W=RegExp("^"+_+"+|((?:^|[^\\\\])(?:\\\\.)*)"+_+"+$","g"),$=RegExp("^"+_+"*,"+_+"*"),I=RegExp("^"+_+"*([\\x20\\t\\r\\n\\f>+~])"+_+"*"),z=RegExp(R),X=RegExp("^"+O+"$"),U={ID:RegExp("^#("+F+")"),CLASS:RegExp("^\\.("+F+")"),NAME:RegExp("^\\[name=['\"]?("+F+")['\"]?\\]"),TAG:RegExp("^("+F.replace("w","w*")+")"),ATTR:RegExp("^"+P),PSEUDO:RegExp("^"+R),CHILD:RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+_+"*(even|odd|(([+-]|)(\\d*)n|)"+_+"*(?:([+-]|)"+_+"*(\\d+)|))"+_+"*\\)|)","i"),needsContext:RegExp("^"+_+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+_+"*((?:-\\d)?\\d*)"+_+"*\\)|)(?=[^-]|$)","i")},V=/[\x20\t\r\n\f]*[+~]/,Y=/^[^{]+\{\s*\[native code/,J=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,G=/^(?:input|select|textarea|button)$/i,Q=/^h\d$/i,K=/'|\\/g,Z=/\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,et=/\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)/g,tt=function(e,t){var n="0x"+t-65536;return n!==n?t:0>n?String.fromCharCode(n+65536):String.fromCharCode(55296|n>>10,56320|1023&n)};try{q.call(w.documentElement.childNodes,0)[0].nodeType}catch(nt){q=function(e){var t,n=[];while(t=this[e++])n.push(t);return n}}function rt(e){return Y.test(e+"")}function it(){var e,t=[];return e=function(n,r){return t.push(n+=" ")>i.cacheLength&&delete e[t.shift()],e[n]=r}}function ot(e){return e[x]=!0,e}function at(e){var t=p.createElement("div");try{return e(t)}catch(n){return!1}finally{t=null}}function st(e,t,n,r){var i,o,a,s,u,l,f,g,m,v;if((t?t.ownerDocument||t:w)!==p&&c(t),t=t||p,n=n||[],!e||"string"!=typeof e)return n;if(1!==(s=t.nodeType)&&9!==s)return[];if(!d&&!r){if(i=J.exec(e))if(a=i[1]){if(9===s){if(o=t.getElementById(a),!o||!o.parentNode)return n;if(o.id===a)return n.push(o),n}else if(t.ownerDocument&&(o=t.ownerDocument.getElementById(a))&&y(t,o)&&o.id===a)return n.push(o),n}else{if(i[2])return H.apply(n,q.call(t.getElementsByTagName(e),0)),n;if((a=i[3])&&T.getByClassName&&t.getElementsByClassName)return H.apply(n,q.call(t.getElementsByClassName(a),0)),n}if(T.qsa&&!h.test(e)){if(f=!0,g=x,m=t,v=9===s&&e,1===s&&"object"!==t.nodeName.toLowerCase()){l=ft(e),(f=t.getAttribute("id"))?g=f.replace(K,"\\$&"):t.setAttribute("id",g),g="[id='"+g+"'] ",u=l.length;while(u--)l[u]=g+dt(l[u]);m=V.test(e)&&t.parentNode||t,v=l.join(",")}if(v)try{return H.apply(n,q.call(m.querySelectorAll(v),0)),n}catch(b){}finally{f||t.removeAttribute("id")}}}return wt(e.replace(W,"$1"),t,n,r)}a=st.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},c=st.setDocument=function(e){var n=e?e.ownerDocument||e:w;return n!==p&&9===n.nodeType&&n.documentElement?(p=n,f=n.documentElement,d=a(n),T.tagNameNoComments=at(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),T.attributes=at(function(e){e.innerHTML="<select></select>";var t=typeof e.lastChild.getAttribute("multiple");return"boolean"!==t&&"string"!==t}),T.getByClassName=at(function(e){return e.innerHTML="<div class='hidden e'></div><div class='hidden'></div>",e.getElementsByClassName&&e.getElementsByClassName("e").length?(e.lastChild.className="e",2===e.getElementsByClassName("e").length):!1}),T.getByName=at(function(e){e.id=x+0,e.innerHTML="<a name='"+x+"'></a><div name='"+x+"'></div>",f.insertBefore(e,f.firstChild);var t=n.getElementsByName&&n.getElementsByName(x).length===2+n.getElementsByName(x+0).length;return T.getIdNotName=!n.getElementById(x),f.removeChild(e),t}),i.attrHandle=at(function(e){return e.innerHTML="<a href='#'></a>",e.firstChild&&typeof e.firstChild.getAttribute!==A&&"#"===e.firstChild.getAttribute("href")})?{}:{href:function(e){return e.getAttribute("href",2)},type:function(e){return e.getAttribute("type")}},T.getIdNotName?(i.find.ID=function(e,t){if(typeof t.getElementById!==A&&!d){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},i.filter.ID=function(e){var t=e.replace(et,tt);return function(e){return e.getAttribute("id")===t}}):(i.find.ID=function(e,n){if(typeof n.getElementById!==A&&!d){var r=n.getElementById(e);return r?r.id===e||typeof r.getAttributeNode!==A&&r.getAttributeNode("id").value===e?[r]:t:[]}},i.filter.ID=function(e){var t=e.replace(et,tt);return function(e){var n=typeof e.getAttributeNode!==A&&e.getAttributeNode("id");return n&&n.value===t}}),i.find.TAG=T.tagNameNoComments?function(e,n){return typeof n.getElementsByTagName!==A?n.getElementsByTagName(e):t}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},i.find.NAME=T.getByName&&function(e,n){return typeof n.getElementsByName!==A?n.getElementsByName(name):t},i.find.CLASS=T.getByClassName&&function(e,n){return typeof n.getElementsByClassName===A||d?t:n.getElementsByClassName(e)},g=[],h=[":focus"],(T.qsa=rt(n.querySelectorAll))&&(at(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||h.push("\\["+_+"*(?:checked|disabled|ismap|multiple|readonly|selected|value)"),e.querySelectorAll(":checked").length||h.push(":checked")}),at(function(e){e.innerHTML="<input type='hidden' i=''/>",e.querySelectorAll("[i^='']").length&&h.push("[*^$]="+_+"*(?:\"\"|'')"),e.querySelectorAll(":enabled").length||h.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),h.push(",.*:")})),(T.matchesSelector=rt(m=f.matchesSelector||f.mozMatchesSelector||f.webkitMatchesSelector||f.oMatchesSelector||f.msMatchesSelector))&&at(function(e){T.disconnectedMatch=m.call(e,"div"),m.call(e,"[s!='']:x"),g.push("!=",R)}),h=RegExp(h.join("|")),g=RegExp(g.join("|")),y=rt(f.contains)||f.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},v=f.compareDocumentPosition?function(e,t){var r;return e===t?(u=!0,0):(r=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t))?1&r||e.parentNode&&11===e.parentNode.nodeType?e===n||y(w,e)?-1:t===n||y(w,t)?1:0:4&r?-1:1:e.compareDocumentPosition?-1:1}:function(e,t){var r,i=0,o=e.parentNode,a=t.parentNode,s=[e],l=[t];if(e===t)return u=!0,0;if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:0;if(o===a)return ut(e,t);r=e;while(r=r.parentNode)s.unshift(r);r=t;while(r=r.parentNode)l.unshift(r);while(s[i]===l[i])i++;return i?ut(s[i],l[i]):s[i]===w?-1:l[i]===w?1:0},u=!1,[0,0].sort(v),T.detectDuplicates=u,p):p},st.matches=function(e,t){return st(e,null,null,t)},st.matchesSelector=function(e,t){if((e.ownerDocument||e)!==p&&c(e),t=t.replace(Z,"='$1']"),!(!T.matchesSelector||d||g&&g.test(t)||h.test(t)))try{var n=m.call(e,t);if(n||T.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(r){}return st(t,p,null,[e]).length>0},st.contains=function(e,t){return(e.ownerDocument||e)!==p&&c(e),y(e,t)},st.attr=function(e,t){var n;return(e.ownerDocument||e)!==p&&c(e),d||(t=t.toLowerCase()),(n=i.attrHandle[t])?n(e):d||T.attributes?e.getAttribute(t):((n=e.getAttributeNode(t))||e.getAttribute(t))&&e[t]===!0?t:n&&n.specified?n.value:null},st.error=function(e){throw Error("Syntax error, unrecognized expression: "+e)},st.uniqueSort=function(e){var t,n=[],r=1,i=0;if(u=!T.detectDuplicates,e.sort(v),u){for(;t=e[r];r++)t===e[r-1]&&(i=n.push(r));while(i--)e.splice(n[i],1)}return e};function ut(e,t){var n=t&&e,r=n&&(~t.sourceIndex||j)-(~e.sourceIndex||j);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function lt(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function ct(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function pt(e){return ot(function(t){return t=+t,ot(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}o=st.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=o(t);return n},i=st.selectors={cacheLength:50,createPseudo:ot,match:U,find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(et,tt),e[3]=(e[4]||e[5]||"").replace(et,tt),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||st.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&st.error(e[0]),e},PSEUDO:function(e){var t,n=!e[5]&&e[2];return U.CHILD.test(e[0])?null:(e[4]?e[2]=e[4]:n&&z.test(n)&&(t=ft(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){return"*"===e?function(){return!0}:(e=e.replace(et,tt).toLowerCase(),function(t){return t.nodeName&&t.nodeName.toLowerCase()===e})},CLASS:function(e){var t=k[e+" "];return t||(t=RegExp("(^|"+_+")"+e+"("+_+"|$)"))&&k(e,function(e){return t.test(e.className||typeof e.getAttribute!==A&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=st.attr(r,e);return null==i?"!="===t:t?(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i+" ").indexOf(n)>-1:"|="===t?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,p,f,d,h,g=o!==a?"nextSibling":"previousSibling",m=t.parentNode,y=s&&t.nodeName.toLowerCase(),v=!u&&!s;if(m){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&v){c=m[x]||(m[x]={}),l=c[e]||[],d=l[0]===N&&l[1],f=l[0]===N&&l[2],p=d&&m.childNodes[d];while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if(1===p.nodeType&&++f&&p===t){c[e]=[N,d,f];break}}else if(v&&(l=(t[x]||(t[x]={}))[e])&&l[0]===N)f=l[1];else while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===y:1===p.nodeType)&&++f&&(v&&((p[x]||(p[x]={}))[e]=[N,f]),p===t))break;return f-=i,f===r||0===f%r&&f/r>=0}}},PSEUDO:function(e,t){var n,r=i.pseudos[e]||i.setFilters[e.toLowerCase()]||st.error("unsupported pseudo: "+e);return r[x]?r(t):r.length>1?(n=[e,e,"",t],i.setFilters.hasOwnProperty(e.toLowerCase())?ot(function(e,n){var i,o=r(e,t),a=o.length;while(a--)i=M.call(e,o[a]),e[i]=!(n[i]=o[a])}):function(e){return r(e,0,n)}):r}},pseudos:{not:ot(function(e){var t=[],n=[],r=s(e.replace(W,"$1"));return r[x]?ot(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:ot(function(e){return function(t){return st(e,t).length>0}}),contains:ot(function(e){return function(t){return(t.textContent||t.innerText||o(t)).indexOf(e)>-1}}),lang:ot(function(e){return X.test(e||"")||st.error("unsupported lang: "+e),e=e.replace(et,tt).toLowerCase(),function(t){var n;do if(n=d?t.getAttribute("xml:lang")||t.getAttribute("lang"):t.lang)return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===f},focus:function(e){return e===p.activeElement&&(!p.hasFocus||p.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!i.pseudos.empty(e)},header:function(e){return Q.test(e.nodeName)},input:function(e){return G.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||t.toLowerCase()===e.type)},first:pt(function(){return[0]}),last:pt(function(e,t){return[t-1]}),eq:pt(function(e,t,n){return[0>n?n+t:n]}),even:pt(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:pt(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:pt(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:pt(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}};for(n in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})i.pseudos[n]=lt(n);for(n in{submit:!0,reset:!0})i.pseudos[n]=ct(n);function ft(e,t){var n,r,o,a,s,u,l,c=E[e+" "];if(c)return t?0:c.slice(0);s=e,u=[],l=i.preFilter;while(s){(!n||(r=$.exec(s)))&&(r&&(s=s.slice(r[0].length)||s),u.push(o=[])),n=!1,(r=I.exec(s))&&(n=r.shift(),o.push({value:n,type:r[0].replace(W," ")}),s=s.slice(n.length));for(a in i.filter)!(r=U[a].exec(s))||l[a]&&!(r=l[a](r))||(n=r.shift(),o.push({value:n,type:a,matches:r}),s=s.slice(n.length));if(!n)break}return t?s.length:s?st.error(e):E(e,u).slice(0)}function dt(e){var t=0,n=e.length,r="";for(;n>t;t++)r+=e[t].value;return r}function ht(e,t,n){var i=t.dir,o=n&&"parentNode"===i,a=C++;return t.first?function(t,n,r){while(t=t[i])if(1===t.nodeType||o)return e(t,n,r)}:function(t,n,s){var u,l,c,p=N+" "+a;if(s){while(t=t[i])if((1===t.nodeType||o)&&e(t,n,s))return!0}else while(t=t[i])if(1===t.nodeType||o)if(c=t[x]||(t[x]={}),(l=c[i])&&l[0]===p){if((u=l[1])===!0||u===r)return u===!0}else if(l=c[i]=[p],l[1]=e(t,n,s)||r,l[1]===!0)return!0}}function gt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function mt(e,t,n,r,i){var o,a=[],s=0,u=e.length,l=null!=t;for(;u>s;s++)(o=e[s])&&(!n||n(o,r,i))&&(a.push(o),l&&t.push(s));return a}function yt(e,t,n,r,i,o){return r&&!r[x]&&(r=yt(r)),i&&!i[x]&&(i=yt(i,o)),ot(function(o,a,s,u){var l,c,p,f=[],d=[],h=a.length,g=o||xt(t||"*",s.nodeType?[s]:s,[]),m=!e||!o&&t?g:mt(g,f,e,s,u),y=n?i||(o?e:h||r)?[]:a:m;if(n&&n(m,y,s,u),r){l=mt(y,d),r(l,[],s,u),c=l.length;while(c--)(p=l[c])&&(y[d[c]]=!(m[d[c]]=p))}if(o){if(i||e){if(i){l=[],c=y.length;while(c--)(p=y[c])&&l.push(m[c]=p);i(null,y=[],l,u)}c=y.length;while(c--)(p=y[c])&&(l=i?M.call(o,p):f[c])>-1&&(o[l]=!(a[l]=p))}}else y=mt(y===a?y.splice(h,y.length):y),i?i(null,a,y,u):H.apply(a,y)})}function vt(e){var t,n,r,o=e.length,a=i.relative[e[0].type],s=a||i.relative[" "],u=a?1:0,c=ht(function(e){return e===t},s,!0),p=ht(function(e){return M.call(t,e)>-1},s,!0),f=[function(e,n,r){return!a&&(r||n!==l)||((t=n).nodeType?c(e,n,r):p(e,n,r))}];for(;o>u;u++)if(n=i.relative[e[u].type])f=[ht(gt(f),n)];else{if(n=i.filter[e[u].type].apply(null,e[u].matches),n[x]){for(r=++u;o>r;r++)if(i.relative[e[r].type])break;return yt(u>1&&gt(f),u>1&&dt(e.slice(0,u-1)).replace(W,"$1"),n,r>u&&vt(e.slice(u,r)),o>r&&vt(e=e.slice(r)),o>r&&dt(e))}f.push(n)}return gt(f)}function bt(e,t){var n=0,o=t.length>0,a=e.length>0,s=function(s,u,c,f,d){var h,g,m,y=[],v=0,b="0",x=s&&[],w=null!=d,T=l,C=s||a&&i.find.TAG("*",d&&u.parentNode||u),k=N+=null==T?1:Math.random()||.1;for(w&&(l=u!==p&&u,r=n);null!=(h=C[b]);b++){if(a&&h){g=0;while(m=e[g++])if(m(h,u,c)){f.push(h);break}w&&(N=k,r=++n)}o&&((h=!m&&h)&&v--,s&&x.push(h))}if(v+=b,o&&b!==v){g=0;while(m=t[g++])m(x,y,u,c);if(s){if(v>0)while(b--)x[b]||y[b]||(y[b]=L.call(f));y=mt(y)}H.apply(f,y),w&&!s&&y.length>0&&v+t.length>1&&st.uniqueSort(f)}return w&&(N=k,l=T),x};return o?ot(s):s}s=st.compile=function(e,t){var n,r=[],i=[],o=S[e+" "];if(!o){t||(t=ft(e)),n=t.length;while(n--)o=vt(t[n]),o[x]?r.push(o):i.push(o);o=S(e,bt(i,r))}return o};function xt(e,t,n){var r=0,i=t.length;for(;i>r;r++)st(e,t[r],n);return n}function wt(e,t,n,r){var o,a,u,l,c,p=ft(e);if(!r&&1===p.length){if(a=p[0]=p[0].slice(0),a.length>2&&"ID"===(u=a[0]).type&&9===t.nodeType&&!d&&i.relative[a[1].type]){if(t=i.find.ID(u.matches[0].replace(et,tt),t)[0],!t)return n;e=e.slice(a.shift().value.length)}o=U.needsContext.test(e)?0:a.length;while(o--){if(u=a[o],i.relative[l=u.type])break;if((c=i.find[l])&&(r=c(u.matches[0].replace(et,tt),V.test(a[0].type)&&t.parentNode||t))){if(a.splice(o,1),e=r.length&&dt(a),!e)return H.apply(n,q.call(r,0)),n;break}}}return s(e,p)(r,t,d,n,V.test(e)),n}i.pseudos.nth=i.pseudos.eq;function Tt(){}i.filters=Tt.prototype=i.pseudos,i.setFilters=new Tt,c(),st.attr=b.attr,b.find=st,b.expr=st.selectors,b.expr[":"]=b.expr.pseudos,b.unique=st.uniqueSort,b.text=st.getText,b.isXMLDoc=st.isXML,b.contains=st.contains}(e);var at=/Until$/,st=/^(?:parents|prev(?:Until|All))/,ut=/^.[^:#\[\.,]*$/,lt=b.expr.match.needsContext,ct={children:!0,contents:!0,next:!0,prev:!0};b.fn.extend({find:function(e){var t,n,r,i=this.length;if("string"!=typeof e)return r=this,this.pushStack(b(e).filter(function(){for(t=0;i>t;t++)if(b.contains(r[t],this))return!0}));for(n=[],t=0;i>t;t++)b.find(e,this[t],n);return n=this.pushStack(i>1?b.unique(n):n),n.selector=(this.selector?this.selector+" ":"")+e,n},has:function(e){var t,n=b(e,this),r=n.length;return this.filter(function(){for(t=0;r>t;t++)if(b.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e,!1))},filter:function(e){return this.pushStack(ft(this,e,!0))},is:function(e){return!!e&&("string"==typeof e?lt.test(e)?b(e,this.context).index(this[0])>=0:b.filter(e,this).length>0:this.filter(e).length>0)},closest:function(e,t){var n,r=0,i=this.length,o=[],a=lt.test(e)||"string"!=typeof e?b(e,t||this.context):0;for(;i>r;r++){n=this[r];while(n&&n.ownerDocument&&n!==t&&11!==n.nodeType){if(a?a.index(n)>-1:b.find.matchesSelector(n,e)){o.push(n);break}n=n.parentNode}}return this.pushStack(o.length>1?b.unique(o):o)},index:function(e){return e?"string"==typeof e?b.inArray(this[0],b(e)):b.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n="string"==typeof e?b(e,t):b.makeArray(e&&e.nodeType?[e]:e),r=b.merge(this.get(),n);return this.pushStack(b.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),b.fn.andSelf=b.fn.addBack;function pt(e,t){do e=e[t];while(e&&1!==e.nodeType);return e}b.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return b.dir(e,"parentNode")},parentsUntil:function(e,t,n){return b.dir(e,"parentNode",n)},next:function(e){return pt(e,"nextSibling")},prev:function(e){return pt(e,"previousSibling")},nextAll:function(e){return b.dir(e,"nextSibling")},prevAll:function(e){return b.dir(e,"previousSibling")},nextUntil:function(e,t,n){return b.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return b.dir(e,"previousSibling",n)},siblings:function(e){return b.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return b.sibling(e.firstChild)},contents:function(e){return b.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:b.merge([],e.childNodes)}},function(e,t){b.fn[e]=function(n,r){var i=b.map(this,t,n);return at.test(e)||(r=n),r&&"string"==typeof r&&(i=b.filter(r,i)),i=this.length>1&&!ct[e]?b.unique(i):i,this.length>1&&st.test(e)&&(i=i.reverse()),this.pushStack(i)}}),b.extend({filter:function(e,t,n){return n&&(e=":not("+e+")"),1===t.length?b.find.matchesSelector(t[0],e)?[t[0]]:[]:b.find.matches(e,t)},dir:function(e,n,r){var i=[],o=e[n];while(o&&9!==o.nodeType&&(r===t||1!==o.nodeType||!b(o).is(r)))1===o.nodeType&&i.push(o),o=o[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function ft(e,t,n){if(t=t||0,b.isFunction(t))return b.grep(e,function(e,r){var i=!!t.call(e,r,e);return i===n});if(t.nodeType)return b.grep(e,function(e){return e===t===n});if("string"==typeof t){var r=b.grep(e,function(e){return 1===e.nodeType});if(ut.test(t))return b.filter(t,r,!n);t=b.filter(t,r)}return b.grep(e,function(e){return b.inArray(e,t)>=0===n})}function dt(e){var t=ht.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}var ht="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",gt=/ jQuery\d+="(?:null|\d+)"/g,mt=RegExp("<(?:"+ht+")[\\s/>]","i"),yt=/^\s+/,vt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bt=/<([\w:]+)/,xt=/<tbody/i,wt=/<|&#?\w+;/,Tt=/<(?:script|style|link)/i,Nt=/^(?:checkbox|radio)$/i,Ct=/checked\s*(?:[^=]|=\s*.checked.)/i,kt=/^$|\/(?:java|ecma)script/i,Et=/^true\/(.*)/,St=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,At={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:b.support.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},jt=dt(o),Dt=jt.appendChild(o.createElement("div"));At.optgroup=At.option,At.tbody=At.tfoot=At.colgroup=At.caption=At.thead,At.th=At.td,b.fn.extend({text:function(e){return b.access(this,function(e){return e===t?b.text(this):this.empty().append((this[0]&&this[0].ownerDocument||o).createTextNode(e))},null,e,arguments.length)},wrapAll:function(e){if(b.isFunction(e))return this.each(function(t){b(this).wrapAll(e.call(this,t))});if(this[0]){var t=b(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&1===e.firstChild.nodeType)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return b.isFunction(e)?this.each(function(t){b(this).wrapInner(e.call(this,t))}):this.each(function(){var t=b(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=b.isFunction(e);return this.each(function(n){b(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){b.nodeName(this,"body")||b(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(e){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&this.appendChild(e)})},prepend:function(){return this.domManip(arguments,!0,function(e){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&this.insertBefore(e,this.firstChild)})},before:function(){return this.domManip(arguments,!1,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,!1,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=0;for(;null!=(n=this[r]);r++)(!e||b.filter(e,[n]).length>0)&&(t||1!==n.nodeType||b.cleanData(Ot(n)),n.parentNode&&(t&&b.contains(n.ownerDocument,n)&&Mt(Ot(n,"script")),n.parentNode.removeChild(n)));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++){1===e.nodeType&&b.cleanData(Ot(e,!1));while(e.firstChild)e.removeChild(e.firstChild);e.options&&b.nodeName(e,"select")&&(e.options.length=0)}return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return b.clone(this,e,t)})},html:function(e){return b.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return 1===n.nodeType?n.innerHTML.replace(gt,""):t;if(!("string"!=typeof e||Tt.test(e)||!b.support.htmlSerialize&&mt.test(e)||!b.support.leadingWhitespace&&yt.test(e)||At[(bt.exec(e)||["",""])[1].toLowerCase()])){e=e.replace(vt,"<$1></$2>");try{for(;i>r;r++)n=this[r]||{},1===n.nodeType&&(b.cleanData(Ot(n,!1)),n.innerHTML=e);n=0}catch(o){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(e){var t=b.isFunction(e);return t||"string"==typeof e||(e=b(e).not(this).detach()),this.domManip([e],!0,function(e){var t=this.nextSibling,n=this.parentNode;n&&(b(this).remove(),n.insertBefore(e,t))})},detach:function(e){return this.remove(e,!0)},domManip:function(e,n,r){e=f.apply([],e);var i,o,a,s,u,l,c=0,p=this.length,d=this,h=p-1,g=e[0],m=b.isFunction(g);if(m||!(1>=p||"string"!=typeof g||b.support.checkClone)&&Ct.test(g))return this.each(function(i){var o=d.eq(i);m&&(e[0]=g.call(this,i,n?o.html():t)),o.domManip(e,n,r)});if(p&&(l=b.buildFragment(e,this[0].ownerDocument,!1,this),i=l.firstChild,1===l.childNodes.length&&(l=i),i)){for(n=n&&b.nodeName(i,"tr"),s=b.map(Ot(l,"script"),Ht),a=s.length;p>c;c++)o=l,c!==h&&(o=b.clone(o,!0,!0),a&&b.merge(s,Ot(o,"script"))),r.call(n&&b.nodeName(this[c],"table")?Lt(this[c],"tbody"):this[c],o,c);if(a)for(u=s[s.length-1].ownerDocument,b.map(s,qt),c=0;a>c;c++)o=s[c],kt.test(o.type||"")&&!b._data(o,"globalEval")&&b.contains(u,o)&&(o.src?b.ajax({url:o.src,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0}):b.globalEval((o.text||o.textContent||o.innerHTML||"").replace(St,"")));l=i=null}return this}});function Lt(e,t){return e.getElementsByTagName(t)[0]||e.appendChild(e.ownerDocument.createElement(t))}function Ht(e){var t=e.getAttributeNode("type");return e.type=(t&&t.specified)+"/"+e.type,e}function qt(e){var t=Et.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function Mt(e,t){var n,r=0;for(;null!=(n=e[r]);r++)b._data(n,"globalEval",!t||b._data(t[r],"globalEval"))}function _t(e,t){if(1===t.nodeType&&b.hasData(e)){var n,r,i,o=b._data(e),a=b._data(t,o),s=o.events;if(s){delete a.handle,a.events={};for(n in s)for(r=0,i=s[n].length;i>r;r++)b.event.add(t,n,s[n][r])}a.data&&(a.data=b.extend({},a.data))}}function Ft(e,t){var n,r,i;if(1===t.nodeType){if(n=t.nodeName.toLowerCase(),!b.support.noCloneEvent&&t[b.expando]){i=b._data(t);for(r in i.events)b.removeEvent(t,r,i.handle);t.removeAttribute(b.expando)}"script"===n&&t.text!==e.text?(Ht(t).text=e.text,qt(t)):"object"===n?(t.parentNode&&(t.outerHTML=e.outerHTML),b.support.html5Clone&&e.innerHTML&&!b.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):"input"===n&&Nt.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):"option"===n?t.defaultSelected=t.selected=e.defaultSelected:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}}b.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){b.fn[e]=function(e){var n,r=0,i=[],o=b(e),a=o.length-1;for(;a>=r;r++)n=r===a?this:this.clone(!0),b(o[r])[t](n),d.apply(i,n.get());return this.pushStack(i)}});function Ot(e,n){var r,o,a=0,s=typeof e.getElementsByTagName!==i?e.getElementsByTagName(n||"*"):typeof e.querySelectorAll!==i?e.querySelectorAll(n||"*"):t;if(!s)for(s=[],r=e.childNodes||e;null!=(o=r[a]);a++)!n||b.nodeName(o,n)?s.push(o):b.merge(s,Ot(o,n));return n===t||n&&b.nodeName(e,n)?b.merge([e],s):s}function Bt(e){Nt.test(e.type)&&(e.defaultChecked=e.checked)}b.extend({clone:function(e,t,n){var r,i,o,a,s,u=b.contains(e.ownerDocument,e);if(b.support.html5Clone||b.isXMLDoc(e)||!mt.test("<"+e.nodeName+">")?o=e.cloneNode(!0):(Dt.innerHTML=e.outerHTML,Dt.removeChild(o=Dt.firstChild)),!(b.support.noCloneEvent&&b.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||b.isXMLDoc(e)))for(r=Ot(o),s=Ot(e),a=0;null!=(i=s[a]);++a)r[a]&&Ft(i,r[a]);if(t)if(n)for(s=s||Ot(e),r=r||Ot(o),a=0;null!=(i=s[a]);a++)_t(i,r[a]);else _t(e,o);return r=Ot(o,"script"),r.length>0&&Mt(r,!u&&Ot(e,"script")),r=s=i=null,o},buildFragment:function(e,t,n,r){var i,o,a,s,u,l,c,p=e.length,f=dt(t),d=[],h=0;for(;p>h;h++)if(o=e[h],o||0===o)if("object"===b.type(o))b.merge(d,o.nodeType?[o]:o);else if(wt.test(o)){s=s||f.appendChild(t.createElement("div")),u=(bt.exec(o)||["",""])[1].toLowerCase(),c=At[u]||At._default,s.innerHTML=c[1]+o.replace(vt,"<$1></$2>")+c[2],i=c[0];while(i--)s=s.lastChild;if(!b.support.leadingWhitespace&&yt.test(o)&&d.push(t.createTextNode(yt.exec(o)[0])),!b.support.tbody){o="table"!==u||xt.test(o)?"<table>"!==c[1]||xt.test(o)?0:s:s.firstChild,i=o&&o.childNodes.length;while(i--)b.nodeName(l=o.childNodes[i],"tbody")&&!l.childNodes.length&&o.removeChild(l)
} b.merge(d, s.childNodes), s.textContent = ""; while (s.firstChild) s.removeChild(s.firstChild); s = f.lastChild
} else d.push(t.createTextNode(o)); s && f.removeChild(s), b.support.appendChecked || b.grep(Ot(d, "input"), Bt), h = 0; while (o = d[h++]) if ((!r || -1 === b.inArray(o, r)) && (a = b.contains(o.ownerDocument, o), s = Ot(f.appendChild(o), "script"), a && Mt(s), n)) { i = 0; while (o = s[i++]) kt.test(o.type || "") && n.push(o) } return s = null, f
}, cleanData: function (e, t) { var n, r, o, a, s = 0, u = b.expando, l = b.cache, p = b.support.deleteExpando, f = b.event.special; for (; null != (n = e[s]) ; s++) if ((t || b.acceptData(n)) && (o = n[u], a = o && l[o])) { if (a.events) for (r in a.events) f[r] ? b.event.remove(n, r) : b.removeEvent(n, r, a.handle); l[o] && (delete l[o], p ? delete n[u] : typeof n.removeAttribute !== i ? n.removeAttribute(u) : n[u] = null, c.push(o)) } }
}); var Pt, Rt, Wt, $t = /alpha\([^)]*\)/i, It = /opacity\s*=\s*([^)]*)/, zt = /^(top|right|bottom|left)$/, Xt = /^(none|table(?!-c[ea]).+)/, Ut = /^margin/, Vt = RegExp("^(" + x + ")(.*)$", "i"), Yt = RegExp("^(" + x + ")(?!px)[a-z%]+$", "i"), Jt = RegExp("^([+-])=(" + x + ")", "i"), Gt = { BODY: "block" }, Qt = { position: "absolute", visibility: "hidden", display: "block" }, Kt = { letterSpacing: 0, fontWeight: 400 }, Zt = ["Top", "Right", "Bottom", "Left"], en = ["Webkit", "O", "Moz", "ms"]; function tn(e, t) { if (t in e) return t; var n = t.charAt(0).toUpperCase() + t.slice(1), r = t, i = en.length; while (i--) if (t = en[i] + n, t in e) return t; return r } function nn(e, t) { return e = t || e, "none" === b.css(e, "display") || !b.contains(e.ownerDocument, e) } function rn(e, t) { var n, r, i, o = [], a = 0, s = e.length; for (; s > a; a++) r = e[a], r.style && (o[a] = b._data(r, "olddisplay"), n = r.style.display, t ? (o[a] || "none" !== n || (r.style.display = ""), "" === r.style.display && nn(r) && (o[a] = b._data(r, "olddisplay", un(r.nodeName)))) : o[a] || (i = nn(r), (n && "none" !== n || !i) && b._data(r, "olddisplay", i ? n : b.css(r, "display")))); for (a = 0; s > a; a++) r = e[a], r.style && (t && "none" !== r.style.display && "" !== r.style.display || (r.style.display = t ? o[a] || "" : "none")); return e } b.fn.extend({ css: function (e, n) { return b.access(this, function (e, n, r) { var i, o, a = {}, s = 0; if (b.isArray(n)) { for (o = Rt(e), i = n.length; i > s; s++) a[n[s]] = b.css(e, n[s], !1, o); return a } return r !== t ? b.style(e, n, r) : b.css(e, n) }, e, n, arguments.length > 1) }, show: function () { return rn(this, !0) }, hide: function () { return rn(this) }, toggle: function (e) { var t = "boolean" == typeof e; return this.each(function () { (t ? e : nn(this)) ? b(this).show() : b(this).hide() }) } }), b.extend({ cssHooks: { opacity: { get: function (e, t) { if (t) { var n = Wt(e, "opacity"); return "" === n ? "1" : n } } } }, cssNumber: { columnCount: !0, fillOpacity: !0, fontWeight: !0, lineHeight: !0, opacity: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: { "float": b.support.cssFloat ? "cssFloat" : "styleFloat" }, style: function (e, n, r, i) { if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) { var o, a, s, u = b.camelCase(n), l = e.style; if (n = b.cssProps[u] || (b.cssProps[u] = tn(l, u)), s = b.cssHooks[n] || b.cssHooks[u], r === t) return s && "get" in s && (o = s.get(e, !1, i)) !== t ? o : l[n]; if (a = typeof r, "string" === a && (o = Jt.exec(r)) && (r = (o[1] + 1) * o[2] + parseFloat(b.css(e, n)), a = "number"), !(null == r || "number" === a && isNaN(r) || ("number" !== a || b.cssNumber[u] || (r += "px"), b.support.clearCloneStyle || "" !== r || 0 !== n.indexOf("background") || (l[n] = "inherit"), s && "set" in s && (r = s.set(e, r, i)) === t))) try { l[n] = r } catch (c) { } } }, css: function (e, n, r, i) { var o, a, s, u = b.camelCase(n); return n = b.cssProps[u] || (b.cssProps[u] = tn(e.style, u)), s = b.cssHooks[n] || b.cssHooks[u], s && "get" in s && (a = s.get(e, !0, r)), a === t && (a = Wt(e, n, i)), "normal" === a && n in Kt && (a = Kt[n]), "" === r || r ? (o = parseFloat(a), r === !0 || b.isNumeric(o) ? o || 0 : a) : a }, swap: function (e, t, n, r) { var i, o, a = {}; for (o in t) a[o] = e.style[o], e.style[o] = t[o]; i = n.apply(e, r || []); for (o in t) e.style[o] = a[o]; return i } }), e.getComputedStyle ? (Rt = function (t) { return e.getComputedStyle(t, null) }, Wt = function (e, n, r) { var i, o, a, s = r || Rt(e), u = s ? s.getPropertyValue(n) || s[n] : t, l = e.style; return s && ("" !== u || b.contains(e.ownerDocument, e) || (u = b.style(e, n)), Yt.test(u) && Ut.test(n) && (i = l.width, o = l.minWidth, a = l.maxWidth, l.minWidth = l.maxWidth = l.width = u, u = s.width, l.width = i, l.minWidth = o, l.maxWidth = a)), u }) : o.documentElement.currentStyle && (Rt = function (e) { return e.currentStyle }, Wt = function (e, n, r) { var i, o, a, s = r || Rt(e), u = s ? s[n] : t, l = e.style; return null == u && l && l[n] && (u = l[n]), Yt.test(u) && !zt.test(n) && (i = l.left, o = e.runtimeStyle, a = o && o.left, a && (o.left = e.currentStyle.left), l.left = "fontSize" === n ? "1em" : u, u = l.pixelLeft + "px", l.left = i, a && (o.left = a)), "" === u ? "auto" : u }); function on(e, t, n) { var r = Vt.exec(t); return r ? Math.max(0, r[1] - (n || 0)) + (r[2] || "px") : t } function an(e, t, n, r, i) { var o = n === (r ? "border" : "content") ? 4 : "width" === t ? 1 : 0, a = 0; for (; 4 > o; o += 2) "margin" === n && (a += b.css(e, n + Zt[o], !0, i)), r ? ("content" === n && (a -= b.css(e, "padding" + Zt[o], !0, i)), "margin" !== n && (a -= b.css(e, "border" + Zt[o] + "Width", !0, i))) : (a += b.css(e, "padding" + Zt[o], !0, i), "padding" !== n && (a += b.css(e, "border" + Zt[o] + "Width", !0, i))); return a } function sn(e, t, n) { var r = !0, i = "width" === t ? e.offsetWidth : e.offsetHeight, o = Rt(e), a = b.support.boxSizing && "border-box" === b.css(e, "boxSizing", !1, o); if (0 >= i || null == i) { if (i = Wt(e, t, o), (0 > i || null == i) && (i = e.style[t]), Yt.test(i)) return i; r = a && (b.support.boxSizingReliable || i === e.style[t]), i = parseFloat(i) || 0 } return i + an(e, t, n || (a ? "border" : "content"), r, o) + "px" } function un(e) { var t = o, n = Gt[e]; return n || (n = ln(e, t), "none" !== n && n || (Pt = (Pt || b("<iframe frameborder='0' width='0' height='0'/>").css("cssText", "display:block !important")).appendTo(t.documentElement), t = (Pt[0].contentWindow || Pt[0].contentDocument).document, t.write("<!doctype html><html><body>"), t.close(), n = ln(e, t), Pt.detach()), Gt[e] = n), n } function ln(e, t) { var n = b(t.createElement(e)).appendTo(t.body), r = b.css(n[0], "display"); return n.remove(), r } b.each(["height", "width"], function (e, n) { b.cssHooks[n] = { get: function (e, r, i) { return r ? 0 === e.offsetWidth && Xt.test(b.css(e, "display")) ? b.swap(e, Qt, function () { return sn(e, n, i) }) : sn(e, n, i) : t }, set: function (e, t, r) { var i = r && Rt(e); return on(e, t, r ? an(e, n, r, b.support.boxSizing && "border-box" === b.css(e, "boxSizing", !1, i), i) : 0) } } }), b.support.opacity || (b.cssHooks.opacity = { get: function (e, t) { return It.test((t && e.currentStyle ? e.currentStyle.filter : e.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : t ? "1" : "" }, set: function (e, t) { var n = e.style, r = e.currentStyle, i = b.isNumeric(t) ? "alpha(opacity=" + 100 * t + ")" : "", o = r && r.filter || n.filter || ""; n.zoom = 1, (t >= 1 || "" === t) && "" === b.trim(o.replace($t, "")) && n.removeAttribute && (n.removeAttribute("filter"), "" === t || r && !r.filter) || (n.filter = $t.test(o) ? o.replace($t, i) : o + " " + i) } }), b(function () { b.support.reliableMarginRight || (b.cssHooks.marginRight = { get: function (e, n) { return n ? b.swap(e, { display: "inline-block" }, Wt, [e, "marginRight"]) : t } }), !b.support.pixelPosition && b.fn.position && b.each(["top", "left"], function (e, n) { b.cssHooks[n] = { get: function (e, r) { return r ? (r = Wt(e, n), Yt.test(r) ? b(e).position()[n] + "px" : r) : t } } }) }), b.expr && b.expr.filters && (b.expr.filters.hidden = function (e) { return 0 >= e.offsetWidth && 0 >= e.offsetHeight || !b.support.reliableHiddenOffsets && "none" === (e.style && e.style.display || b.css(e, "display")) }, b.expr.filters.visible = function (e) { return !b.expr.filters.hidden(e) }), b.each({ margin: "", padding: "", border: "Width" }, function (e, t) { b.cssHooks[e + t] = { expand: function (n) { var r = 0, i = {}, o = "string" == typeof n ? n.split(" ") : [n]; for (; 4 > r; r++) i[e + Zt[r] + t] = o[r] || o[r - 2] || o[0]; return i } }, Ut.test(e) || (b.cssHooks[e + t].set = on) }); var cn = /%20/g, pn = /\[\]$/, fn = /\r?\n/g, dn = /^(?:submit|button|image|reset|file)$/i, hn = /^(?:input|select|textarea|keygen)/i; b.fn.extend({ serialize: function () { return b.param(this.serializeArray()) }, serializeArray: function () { return this.map(function () { var e = b.prop(this, "elements"); return e ? b.makeArray(e) : this }).filter(function () { var e = this.type; return this.name && !b(this).is(":disabled") && hn.test(this.nodeName) && !dn.test(e) && (this.checked || !Nt.test(e)) }).map(function (e, t) { var n = b(this).val(); return null == n ? null : b.isArray(n) ? b.map(n, function (e) { return { name: t.name, value: e.replace(fn, "\r\n") } }) : { name: t.name, value: n.replace(fn, "\r\n") } }).get() } }), b.param = function (e, n) { var r, i = [], o = function (e, t) { t = b.isFunction(t) ? t() : null == t ? "" : t, i[i.length] = encodeURIComponent(e) + "=" + encodeURIComponent(t) }; if (n === t && (n = b.ajaxSettings && b.ajaxSettings.traditional), b.isArray(e) || e.jquery && !b.isPlainObject(e)) b.each(e, function () { o(this.name, this.value) }); else for (r in e) gn(r, e[r], n, o); return i.join("&").replace(cn, "+") }; function gn(e, t, n, r) { var i; if (b.isArray(t)) b.each(t, function (t, i) { n || pn.test(e) ? r(e, i) : gn(e + "[" + ("object" == typeof i ? t : "") + "]", i, n, r) }); else if (n || "object" !== b.type(t)) r(e, t); else for (i in t) gn(e + "[" + i + "]", t[i], n, r) } b.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (e, t) { b.fn[t] = function (e, n) { return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t) } }), b.fn.hover = function (e, t) { return this.mouseenter(e).mouseleave(t || e) }; var mn, yn, vn = b.now(), bn = /\?/, xn = /#.*$/, wn = /([?&])_=[^&]*/, Tn = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, Nn = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Cn = /^(?:GET|HEAD)$/, kn = /^\/\//, En = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/, Sn = b.fn.load, An = {}, jn = {}, Dn = "*/".concat("*"); try { yn = a.href } catch (Ln) { yn = o.createElement("a"), yn.href = "", yn = yn.href } mn = En.exec(yn.toLowerCase()) || []; function Hn(e) { return function (t, n) { "string" != typeof t && (n = t, t = "*"); var r, i = 0, o = t.toLowerCase().match(w) || []; if (b.isFunction(n)) while (r = o[i++]) "+" === r[0] ? (r = r.slice(1) || "*", (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n) } } function qn(e, n, r, i) { var o = {}, a = e === jn; function s(u) { var l; return o[u] = !0, b.each(e[u] || [], function (e, u) { var c = u(n, r, i); return "string" != typeof c || a || o[c] ? a ? !(l = c) : t : (n.dataTypes.unshift(c), s(c), !1) }), l } return s(n.dataTypes[0]) || !o["*"] && s("*") } function Mn(e, n) { var r, i, o = b.ajaxSettings.flatOptions || {}; for (i in n) n[i] !== t && ((o[i] ? e : r || (r = {}))[i] = n[i]); return r && b.extend(!0, e, r), e } b.fn.load = function (e, n, r) { if ("string" != typeof e && Sn) return Sn.apply(this, arguments); var i, o, a, s = this, u = e.indexOf(" "); return u >= 0 && (i = e.slice(u, e.length), e = e.slice(0, u)), b.isFunction(n) ? (r = n, n = t) : n && "object" == typeof n && (a = "POST"), s.length > 0 && b.ajax({ url: e, type: a, dataType: "html", data: n }).done(function (e) { o = arguments, s.html(i ? b("<div>").append(b.parseHTML(e)).find(i) : e) }).complete(r && function (e, t) { s.each(r, o || [e.responseText, t, e]) }), this }, b.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) { b.fn[t] = function (e) { return this.on(t, e) } }), b.each(["get", "post"], function (e, n) { b[n] = function (e, r, i, o) { return b.isFunction(r) && (o = o || i, i = r, r = t), b.ajax({ url: e, type: n, dataType: o, data: r, success: i }) } }), b.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: yn, type: "GET", isLocal: Nn.test(mn[1]), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": Dn, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /xml/, html: /html/, json: /json/ }, responseFields: { xml: "responseXML", text: "responseText" }, converters: { "* text": e.String, "text html": !0, "text json": b.parseJSON, "text xml": b.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (e, t) { return t ? Mn(Mn(e, b.ajaxSettings), t) : Mn(b.ajaxSettings, e) }, ajaxPrefilter: Hn(An), ajaxTransport: Hn(jn), ajax: function (e, n) { "object" == typeof e && (n = e, e = t), n = n || {}; var r, i, o, a, s, u, l, c, p = b.ajaxSetup({}, n), f = p.context || p, d = p.context && (f.nodeType || f.jquery) ? b(f) : b.event, h = b.Deferred(), g = b.Callbacks("once memory"), m = p.statusCode || {}, y = {}, v = {}, x = 0, T = "canceled", N = { readyState: 0, getResponseHeader: function (e) { var t; if (2 === x) { if (!c) { c = {}; while (t = Tn.exec(a)) c[t[1].toLowerCase()] = t[2] } t = c[e.toLowerCase()] } return null == t ? null : t }, getAllResponseHeaders: function () { return 2 === x ? a : null }, setRequestHeader: function (e, t) { var n = e.toLowerCase(); return x || (e = v[n] = v[n] || e, y[e] = t), this }, overrideMimeType: function (e) { return x || (p.mimeType = e), this }, statusCode: function (e) { var t; if (e) if (2 > x) for (t in e) m[t] = [m[t], e[t]]; else N.always(e[N.status]); return this }, abort: function (e) { var t = e || T; return l && l.abort(t), k(0, t), this } }; if (h.promise(N).complete = g.add, N.success = N.done, N.error = N.fail, p.url = ((e || p.url || yn) + "").replace(xn, "").replace(kn, mn[1] + "//"), p.type = n.method || n.type || p.method || p.type, p.dataTypes = b.trim(p.dataType || "*").toLowerCase().match(w) || [""], null == p.crossDomain && (r = En.exec(p.url.toLowerCase()), p.crossDomain = !(!r || r[1] === mn[1] && r[2] === mn[2] && (r[3] || ("http:" === r[1] ? 80 : 443)) == (mn[3] || ("http:" === mn[1] ? 80 : 443)))), p.data && p.processData && "string" != typeof p.data && (p.data = b.param(p.data, p.traditional)), qn(An, p, n, N), 2 === x) return N; u = p.global, u && 0 === b.active++ && b.event.trigger("ajaxStart"), p.type = p.type.toUpperCase(), p.hasContent = !Cn.test(p.type), o = p.url, p.hasContent || (p.data && (o = p.url += (bn.test(o) ? "&" : "?") + p.data, delete p.data), p.cache === !1 && (p.url = wn.test(o) ? o.replace(wn, "$1_=" + vn++) : o + (bn.test(o) ? "&" : "?") + "_=" + vn++)), p.ifModified && (b.lastModified[o] && N.setRequestHeader("If-Modified-Since", b.lastModified[o]), b.etag[o] && N.setRequestHeader("If-None-Match", b.etag[o])), (p.data && p.hasContent && p.contentType !== !1 || n.contentType) && N.setRequestHeader("Content-Type", p.contentType), N.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + Dn + "; q=0.01" : "") : p.accepts["*"]); for (i in p.headers) N.setRequestHeader(i, p.headers[i]); if (p.beforeSend && (p.beforeSend.call(f, N, p) === !1 || 2 === x)) return N.abort(); T = "abort"; for (i in { success: 1, error: 1, complete: 1 }) N[i](p[i]); if (l = qn(jn, p, n, N)) { N.readyState = 1, u && d.trigger("ajaxSend", [N, p]), p.async && p.timeout > 0 && (s = setTimeout(function () { N.abort("timeout") }, p.timeout)); try { x = 1, l.send(y, k) } catch (C) { if (!(2 > x)) throw C; k(-1, C) } } else k(-1, "No Transport"); function k(e, n, r, i) { var c, y, v, w, T, C = n; 2 !== x && (x = 2, s && clearTimeout(s), l = t, a = i || "", N.readyState = e > 0 ? 4 : 0, r && (w = _n(p, N, r)), e >= 200 && 300 > e || 304 === e ? (p.ifModified && (T = N.getResponseHeader("Last-Modified"), T && (b.lastModified[o] = T), T = N.getResponseHeader("etag"), T && (b.etag[o] = T)), 204 === e ? (c = !0, C = "nocontent") : 304 === e ? (c = !0, C = "notmodified") : (c = Fn(p, w), C = c.state, y = c.data, v = c.error, c = !v)) : (v = C, (e || !C) && (C = "error", 0 > e && (e = 0))), N.status = e, N.statusText = (n || C) + "", c ? h.resolveWith(f, [y, C, N]) : h.rejectWith(f, [N, C, v]), N.statusCode(m), m = t, u && d.trigger(c ? "ajaxSuccess" : "ajaxError", [N, p, c ? y : v]), g.fireWith(f, [N, C]), u && (d.trigger("ajaxComplete", [N, p]), --b.active || b.event.trigger("ajaxStop"))) } return N }, getScript: function (e, n) { return b.get(e, t, n, "script") }, getJSON: function (e, t, n) { return b.get(e, t, n, "json") } }); function _n(e, n, r) { var i, o, a, s, u = e.contents, l = e.dataTypes, c = e.responseFields; for (s in c) s in r && (n[c[s]] = r[s]); while ("*" === l[0]) l.shift(), o === t && (o = e.mimeType || n.getResponseHeader("Content-Type")); if (o) for (s in u) if (u[s] && u[s].test(o)) { l.unshift(s); break } if (l[0] in r) a = l[0]; else { for (s in r) { if (!l[0] || e.converters[s + " " + l[0]]) { a = s; break } i || (i = s) } a = a || i } return a ? (a !== l[0] && l.unshift(a), r[a]) : t } function Fn(e, t) { var n, r, i, o, a = {}, s = 0, u = e.dataTypes.slice(), l = u[0]; if (e.dataFilter && (t = e.dataFilter(t, e.dataType)), u[1]) for (i in e.converters) a[i.toLowerCase()] = e.converters[i]; for (; r = u[++s];) if ("*" !== r) { if ("*" !== l && l !== r) { if (i = a[l + " " + r] || a["* " + r], !i) for (n in a) if (o = n.split(" "), o[1] === r && (i = a[l + " " + o[0]] || a["* " + o[0]])) { i === !0 ? i = a[n] : a[n] !== !0 && (r = o[0], u.splice(s--, 0, r)); break } if (i !== !0) if (i && e["throws"]) t = i(t); else try { t = i(t) } catch (c) { return { state: "parsererror", error: i ? c : "No conversion from " + l + " to " + r } } } l = r } return { state: "success", data: t } } b.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /(?:java|ecma)script/ }, converters: { "text script": function (e) { return b.globalEval(e), e } } }), b.ajaxPrefilter("script", function (e) { e.cache === t && (e.cache = !1), e.crossDomain && (e.type = "GET", e.global = !1) }), b.ajaxTransport("script", function (e) { if (e.crossDomain) { var n, r = o.head || b("head")[0] || o.documentElement; return { send: function (t, i) { n = o.createElement("script"), n.async = !0, e.scriptCharset && (n.charset = e.scriptCharset), n.src = e.url, n.onload = n.onreadystatechange = function (e, t) { (t || !n.readyState || /loaded|complete/.test(n.readyState)) && (n.onload = n.onreadystatechange = null, n.parentNode && n.parentNode.removeChild(n), n = null, t || i(200, "success")) }, r.insertBefore(n, r.firstChild) }, abort: function () { n && n.onload(t, !0) } } } }); var On = [], Bn = /(=)\?(?=&|$)|\?\?/; b.ajaxSetup({ jsonp: "callback", jsonpCallback: function () { var e = On.pop() || b.expando + "_" + vn++; return this[e] = !0, e } }), b.ajaxPrefilter("json jsonp", function (n, r, i) { var o, a, s, u = n.jsonp !== !1 && (Bn.test(n.url) ? "url" : "string" == typeof n.data && !(n.contentType || "").indexOf("application/x-www-form-urlencoded") && Bn.test(n.data) && "data"); return u || "jsonp" === n.dataTypes[0] ? (o = n.jsonpCallback = b.isFunction(n.jsonpCallback) ? n.jsonpCallback() : n.jsonpCallback, u ? n[u] = n[u].replace(Bn, "$1" + o) : n.jsonp !== !1 && (n.url += (bn.test(n.url) ? "&" : "?") + n.jsonp + "=" + o), n.converters["script json"] = function () { return s || b.error(o + " was not called"), s[0] }, n.dataTypes[0] = "json", a = e[o], e[o] = function () { s = arguments }, i.always(function () { e[o] = a, n[o] && (n.jsonpCallback = r.jsonpCallback, On.push(o)), s && b.isFunction(a) && a(s[0]), s = a = t }), "script") : t }); var Pn, Rn, Wn = 0, $n = e.ActiveXObject && function () { var e; for (e in Pn) Pn[e](t, !0) }; function In() { try { return new e.XMLHttpRequest } catch (t) { } } function zn() { try { return new e.ActiveXObject("Microsoft.XMLHTTP") } catch (t) { } } b.ajaxSettings.xhr = e.ActiveXObject ? function () { return !this.isLocal && In() || zn() } : In, Rn = b.ajaxSettings.xhr(), b.support.cors = !!Rn && "withCredentials" in Rn, Rn = b.support.ajax = !!Rn, Rn && b.ajaxTransport(function (n) { if (!n.crossDomain || b.support.cors) { var r; return { send: function (i, o) { var a, s, u = n.xhr(); if (n.username ? u.open(n.type, n.url, n.async, n.username, n.password) : u.open(n.type, n.url, n.async), n.xhrFields) for (s in n.xhrFields) u[s] = n.xhrFields[s]; n.mimeType && u.overrideMimeType && u.overrideMimeType(n.mimeType), n.crossDomain || i["X-Requested-With"] || (i["X-Requested-With"] = "XMLHttpRequest"); try { for (s in i) u.setRequestHeader(s, i[s]) } catch (l) { } u.send(n.hasContent && n.data || null), r = function (e, i) { var s, l, c, p; try { if (r && (i || 4 === u.readyState)) if (r = t, a && (u.onreadystatechange = b.noop, $n && delete Pn[a]), i) 4 !== u.readyState && u.abort(); else { p = {}, s = u.status, l = u.getAllResponseHeaders(), "string" == typeof u.responseText && (p.text = u.responseText); try { c = u.statusText } catch (f) { c = "" } s || !n.isLocal || n.crossDomain ? 1223 === s && (s = 204) : s = p.text ? 200 : 404 } } catch (d) { i || o(-1, d) } p && o(s, c, p, l) }, n.async ? 4 === u.readyState ? setTimeout(r) : (a = ++Wn, $n && (Pn || (Pn = {}, b(e).unload($n)), Pn[a] = r), u.onreadystatechange = r) : r() }, abort: function () { r && r(t, !0) } } } }); var Xn, Un, Vn = /^(?:toggle|show|hide)$/, Yn = RegExp("^(?:([+-])=|)(" + x + ")([a-z%]*)$", "i"), Jn = /queueHooks$/, Gn = [nr], Qn = { "*": [function (e, t) { var n, r, i = this.createTween(e, t), o = Yn.exec(t), a = i.cur(), s = +a || 0, u = 1, l = 20; if (o) { if (n = +o[2], r = o[3] || (b.cssNumber[e] ? "" : "px"), "px" !== r && s) { s = b.css(i.elem, e, !0) || n || 1; do u = u || ".5", s /= u, b.style(i.elem, e, s + r); while (u !== (u = i.cur() / a) && 1 !== u && --l) } i.unit = r, i.start = s, i.end = o[1] ? s + (o[1] + 1) * n : n } return i }] }; function Kn() { return setTimeout(function () { Xn = t }), Xn = b.now() } function Zn(e, t) { b.each(t, function (t, n) { var r = (Qn[t] || []).concat(Qn["*"]), i = 0, o = r.length; for (; o > i; i++) if (r[i].call(e, t, n)) return }) } function er(e, t, n) { var r, i, o = 0, a = Gn.length, s = b.Deferred().always(function () { delete u.elem }), u = function () { if (i) return !1; var t = Xn || Kn(), n = Math.max(0, l.startTime + l.duration - t), r = n / l.duration || 0, o = 1 - r, a = 0, u = l.tweens.length; for (; u > a; a++) l.tweens[a].run(o); return s.notifyWith(e, [l, o, n]), 1 > o && u ? n : (s.resolveWith(e, [l]), !1) }, l = s.promise({ elem: e, props: b.extend({}, t), opts: b.extend(!0, { specialEasing: {} }, n), originalProperties: t, originalOptions: n, startTime: Xn || Kn(), duration: n.duration, tweens: [], createTween: function (t, n) { var r = b.Tween(e, l.opts, t, n, l.opts.specialEasing[t] || l.opts.easing); return l.tweens.push(r), r }, stop: function (t) { var n = 0, r = t ? l.tweens.length : 0; if (i) return this; for (i = !0; r > n; n++) l.tweens[n].run(1); return t ? s.resolveWith(e, [l, t]) : s.rejectWith(e, [l, t]), this } }), c = l.props; for (tr(c, l.opts.specialEasing) ; a > o; o++) if (r = Gn[o].call(l, e, c, l.opts)) return r; return Zn(l, c), b.isFunction(l.opts.start) && l.opts.start.call(e, l), b.fx.timer(b.extend(u, { elem: e, anim: l, queue: l.opts.queue })), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always) } function tr(e, t) { var n, r, i, o, a; for (i in e) if (r = b.camelCase(i), o = t[r], n = e[i], b.isArray(n) && (o = n[1], n = e[i] = n[0]), i !== r && (e[r] = n, delete e[i]), a = b.cssHooks[r], a && "expand" in a) { n = a.expand(n), delete e[r]; for (i in n) i in e || (e[i] = n[i], t[i] = o) } else t[r] = o } b.Animation = b.extend(er, { tweener: function (e, t) { b.isFunction(e) ? (t = e, e = ["*"]) : e = e.split(" "); var n, r = 0, i = e.length; for (; i > r; r++) n = e[r], Qn[n] = Qn[n] || [], Qn[n].unshift(t) }, prefilter: function (e, t) { t ? Gn.unshift(e) : Gn.push(e) } }); function nr(e, t, n) { var r, i, o, a, s, u, l, c, p, f = this, d = e.style, h = {}, g = [], m = e.nodeType && nn(e); n.queue || (c = b._queueHooks(e, "fx"), null == c.unqueued && (c.unqueued = 0, p = c.empty.fire, c.empty.fire = function () { c.unqueued || p() }), c.unqueued++, f.always(function () { f.always(function () { c.unqueued--, b.queue(e, "fx").length || c.empty.fire() }) })), 1 === e.nodeType && ("height" in t || "width" in t) && (n.overflow = [d.overflow, d.overflowX, d.overflowY], "inline" === b.css(e, "display") && "none" === b.css(e, "float") && (b.support.inlineBlockNeedsLayout && "inline" !== un(e.nodeName) ? d.zoom = 1 : d.display = "inline-block")), n.overflow && (d.overflow = "hidden", b.support.shrinkWrapBlocks || f.always(function () { d.overflow = n.overflow[0], d.overflowX = n.overflow[1], d.overflowY = n.overflow[2] })); for (i in t) if (a = t[i], Vn.exec(a)) { if (delete t[i], u = u || "toggle" === a, a === (m ? "hide" : "show")) continue; g.push(i) } if (o = g.length) { s = b._data(e, "fxshow") || b._data(e, "fxshow", {}), "hidden" in s && (m = s.hidden), u && (s.hidden = !m), m ? b(e).show() : f.done(function () { b(e).hide() }), f.done(function () { var t; b._removeData(e, "fxshow"); for (t in h) b.style(e, t, h[t]) }); for (i = 0; o > i; i++) r = g[i], l = f.createTween(r, m ? s[r] : 0), h[r] = s[r] || b.style(e, r), r in s || (s[r] = l.start, m && (l.end = l.start, l.start = "width" === r || "height" === r ? 1 : 0)) } } function rr(e, t, n, r, i) { return new rr.prototype.init(e, t, n, r, i) } b.Tween = rr, rr.prototype = { constructor: rr, init: function (e, t, n, r, i, o) { this.elem = e, this.prop = n, this.easing = i || "swing", this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (b.cssNumber[n] ? "" : "px") }, cur: function () { var e = rr.propHooks[this.prop]; return e && e.get ? e.get(this) : rr.propHooks._default.get(this) }, run: function (e) { var t, n = rr.propHooks[this.prop]; return this.pos = t = this.options.duration ? b.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : rr.propHooks._default.set(this), this } }, rr.prototype.init.prototype = rr.prototype, rr.propHooks = { _default: { get: function (e) { var t; return null == e.elem[e.prop] || e.elem.style && null != e.elem.style[e.prop] ? (t = b.css(e.elem, e.prop, ""), t && "auto" !== t ? t : 0) : e.elem[e.prop] }, set: function (e) { b.fx.step[e.prop] ? b.fx.step[e.prop](e) : e.elem.style && (null != e.elem.style[b.cssProps[e.prop]] || b.cssHooks[e.prop]) ? b.style(e.elem, e.prop, e.now + e.unit) : e.elem[e.prop] = e.now } } }, rr.propHooks.scrollTop = rr.propHooks.scrollLeft = { set: function (e) { e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now) } }, b.each(["toggle", "show", "hide"], function (e, t) { var n = b.fn[t]; b.fn[t] = function (e, r, i) { return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(ir(t, !0), e, r, i) } }), b.fn.extend({ fadeTo: function (e, t, n, r) { return this.filter(nn).css("opacity", 0).show().end().animate({ opacity: t }, e, n, r) }, animate: function (e, t, n, r) { var i = b.isEmptyObject(e), o = b.speed(t, n, r), a = function () { var t = er(this, b.extend({}, e), o); a.finish = function () { t.stop(!0) }, (i || b._data(this, "finish")) && t.stop(!0) }; return a.finish = a, i || o.queue === !1 ? this.each(a) : this.queue(o.queue, a) }, stop: function (e, n, r) { var i = function (e) { var t = e.stop; delete e.stop, t(r) }; return "string" != typeof e && (r = n, n = e, e = t), n && e !== !1 && this.queue(e || "fx", []), this.each(function () { var t = !0, n = null != e && e + "queueHooks", o = b.timers, a = b._data(this); if (n) a[n] && a[n].stop && i(a[n]); else for (n in a) a[n] && a[n].stop && Jn.test(n) && i(a[n]); for (n = o.length; n--;) o[n].elem !== this || null != e && o[n].queue !== e || (o[n].anim.stop(r), t = !1, o.splice(n, 1)); (t || !r) && b.dequeue(this, e) }) }, finish: function (e) { return e !== !1 && (e = e || "fx"), this.each(function () { var t, n = b._data(this), r = n[e + "queue"], i = n[e + "queueHooks"], o = b.timers, a = r ? r.length : 0; for (n.finish = !0, b.queue(this, e, []), i && i.cur && i.cur.finish && i.cur.finish.call(this), t = o.length; t--;) o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1)); for (t = 0; a > t; t++) r[t] && r[t].finish && r[t].finish.call(this); delete n.finish }) } }); function ir(e, t) { var n, r = { height: e }, i = 0; for (t = t ? 1 : 0; 4 > i; i += 2 - t) n = Zt[i], r["margin" + n] = r["padding" + n] = e; return t && (r.opacity = r.width = e), r } b.each({ slideDown: ir("show"), slideUp: ir("hide"), slideToggle: ir("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function (e, t) { b.fn[e] = function (e, n, r) { return this.animate(t, e, n, r) } }), b.speed = function (e, t, n) { var r = e && "object" == typeof e ? b.extend({}, e) : { complete: n || !n && t || b.isFunction(e) && e, duration: e, easing: n && t || t && !b.isFunction(t) && t }; return r.duration = b.fx.off ? 0 : "number" == typeof r.duration ? r.duration : r.duration in b.fx.speeds ? b.fx.speeds[r.duration] : b.fx.speeds._default, (null == r.queue || r.queue === !0) && (r.queue = "fx"), r.old = r.complete, r.complete = function () { b.isFunction(r.old) && r.old.call(this), r.queue && b.dequeue(this, r.queue) }, r }, b.easing = { linear: function (e) { return e }, swing: function (e) { return .5 - Math.cos(e * Math.PI) / 2 } }, b.timers = [], b.fx = rr.prototype.init, b.fx.tick = function () { var e, n = b.timers, r = 0; for (Xn = b.now() ; n.length > r; r++) e = n[r], e() || n[r] !== e || n.splice(r--, 1); n.length || b.fx.stop(), Xn = t }, b.fx.timer = function (e) { e() && b.timers.push(e) && b.fx.start() }, b.fx.interval = 13, b.fx.start = function () { Un || (Un = setInterval(b.fx.tick, b.fx.interval)) }, b.fx.stop = function () { clearInterval(Un), Un = null }, b.fx.speeds = { slow: 600, fast: 200, _default: 400 }, b.fx.step = {}, b.expr && b.expr.filters && (b.expr.filters.animated = function (e) { return b.grep(b.timers, function (t) { return e === t.elem }).length }), b.fn.offset = function (e) { if (arguments.length) return e === t ? this : this.each(function (t) { b.offset.setOffset(this, e, t) }); var n, r, o = { top: 0, left: 0 }, a = this[0], s = a && a.ownerDocument; if (s) return n = s.documentElement, b.contains(n, a) ? (typeof a.getBoundingClientRect !== i && (o = a.getBoundingClientRect()), r = or(s), { top: o.top + (r.pageYOffset || n.scrollTop) - (n.clientTop || 0), left: o.left + (r.pageXOffset || n.scrollLeft) - (n.clientLeft || 0) }) : o }, b.offset = { setOffset: function (e, t, n) { var r = b.css(e, "position"); "static" === r && (e.style.position = "relative"); var i = b(e), o = i.offset(), a = b.css(e, "top"), s = b.css(e, "left"), u = ("absolute" === r || "fixed" === r) && b.inArray("auto", [a, s]) > -1, l = {}, c = {}, p, f; u ? (c = i.position(), p = c.top, f = c.left) : (p = parseFloat(a) || 0, f = parseFloat(s) || 0), b.isFunction(t) && (t = t.call(e, n, o)), null != t.top && (l.top = t.top - o.top + p), null != t.left && (l.left = t.left - o.left + f), "using" in t ? t.using.call(e, l) : i.css(l) } }, b.fn.extend({ position: function () { if (this[0]) { var e, t, n = { top: 0, left: 0 }, r = this[0]; return "fixed" === b.css(r, "position") ? t = r.getBoundingClientRect() : (e = this.offsetParent(), t = this.offset(), b.nodeName(e[0], "html") || (n = e.offset()), n.top += b.css(e[0], "borderTopWidth", !0), n.left += b.css(e[0], "borderLeftWidth", !0)), { top: t.top - n.top - b.css(r, "marginTop", !0), left: t.left - n.left - b.css(r, "marginLeft", !0) } } }, offsetParent: function () { return this.map(function () { var e = this.offsetParent || o.documentElement; while (e && !b.nodeName(e, "html") && "static" === b.css(e, "position")) e = e.offsetParent; return e || o.documentElement }) } }), b.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (e, n) { var r = /Y/.test(n); b.fn[e] = function (i) { return b.access(this, function (e, i, o) { var a = or(e); return o === t ? a ? n in a ? a[n] : a.document.documentElement[i] : e[i] : (a ? a.scrollTo(r ? b(a).scrollLeft() : o, r ? o : b(a).scrollTop()) : e[i] = o, t) }, e, i, arguments.length, null) } }); function or(e) { return b.isWindow(e) ? e : 9 === e.nodeType ? e.defaultView || e.parentWindow : !1 } b.each({ Height: "height", Width: "width" }, function (e, n) { b.each({ padding: "inner" + e, content: n, "": "outer" + e }, function (r, i) { b.fn[i] = function (i, o) { var a = arguments.length && (r || "boolean" != typeof i), s = r || (i === !0 || o === !0 ? "margin" : "border"); return b.access(this, function (n, r, i) { var o; return b.isWindow(n) ? n.document.documentElement["client" + e] : 9 === n.nodeType ? (o = n.documentElement, Math.max(n.body["scroll" + e], o["scroll" + e], n.body["offset" + e], o["offset" + e], o["client" + e])) : i === t ? b.css(n, r, s) : b.style(n, r, i, s) }, n, a ? i : t, a, null) } }) }), e.jQuery = e.$ = b, "function" == typeof define && define.amd && define.amd.jQuery && define("jquery", [], function () { return b })
})(window);


(function($){$.browserTest=function(a,z){var u='unknown',x='X',m=function(r,h){for(var i=0;i<h.length;i=i+1){r=r.replace(h[i][0],h[i][1]);}return r;},c=function(i,a,b,c){var r={name:m((a.exec(i)||[u,u])[1],b)};r[r.name]=true;r.version=(c.exec(i)||[x,x,x,x])[3];if(r.name.match(/safari/)&&r.version>400){r.version='2.0';}if(r.name==='presto'){r.version=($.browser.version>9.27)?'futhark':'linear_b';}r.versionNumber=parseFloat(r.version,10)||0;r.versionX=(r.version!==x)?(r.version+'').substr(0,1):x;r.className=r.name+r.versionX;return r;};a=(a.match(/Opera|Navigator|Minefield|KHTML|Chrome/)?m(a,[[/(Firefox|MSIE|KHTML,\slike\sGecko|Konqueror)/,''],['Chrome Safari','Chrome'],['KHTML','Konqueror'],['Minefield','Firefox'],['Navigator','Netscape']]):a).toLowerCase();$.browser=$.extend((!z)?$.browser:{},c(a,/(camino|chrome|firefox|netscape|konqueror|lynx|msie|opera|safari)/,[],/(camino|chrome|firefox|netscape|netscape6|opera|version|konqueror|lynx|msie|safari)(\/|\s)([a-z0-9\.\+]*?)(\;|dev|rel|\s|$)/));$.layout=c(a,/(gecko|konqueror|msie|opera|webkit)/,[['konqueror','khtml'],['msie','trident'],['opera','presto']],/(applewebkit|rv|konqueror|msie)(\:|\/|\s)([a-z0-9\.]*?)(\;|\)|\s)/);$.os={name:(/(win|mac|linux|sunos|solaris|iphone)/.exec(navigator.platform.toLowerCase())||[u])[0].replace('sunos','solaris')};if(!z){$('html').addClass([$.os.name,$.browser.name,$.browser.className,$.layout.name,$.layout.className].join(' '));}};$.browserTest(navigator.userAgent);})(jQuery);
/*! Copyright (c) 2011 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.0.6
 * 
 * Requires: 1.2.2+
 */
(function(a){function d(b){var c=b||window.event,d=[].slice.call(arguments,1),e=0,f=!0,g=0,h=0;return b=a.event.fix(c),b.type="mousewheel",c.wheelDelta&&(e=c.wheelDelta/120),c.detail&&(e=-c.detail/3),h=e,c.axis!==undefined&&c.axis===c.HORIZONTAL_AXIS&&(h=0,g=-1*e),c.wheelDeltaY!==undefined&&(h=c.wheelDeltaY/120),c.wheelDeltaX!==undefined&&(g=-1*c.wheelDeltaX/120),d.unshift(b,e,g,h),(a.event.dispatch||a.event.handle).apply(this,d)}var b=["DOMMouseScroll","mousewheel"];if(a.event.fixHooks)for(var c=b.length;c;)a.event.fixHooks[b[--c]]=a.event.mouseHooks;a.event.special.mousewheel={setup:function(){if(this.addEventListener)for(var a=b.length;a;)this.addEventListener(b[--a],d,!1);else this.onmousewheel=d},teardown:function(){if(this.removeEventListener)for(var a=b.length;a;)this.removeEventListener(b[--a],d,!1);else this.onmousewheel=null}},a.fn.extend({mousewheel:function(a){return a?this.bind("mousewheel",a):this.trigger("mousewheel")},unmousewheel:function(a){return this.unbind("mousewheel",a)}})})(jQuery)

/* Modernizr 2.8.3 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-fontface-canvas-canvastext-inlinesvg-teststyles
 */
;window.Modernizr=function(a,b,c){function v(a){i.cssText=a}function w(a,b){return v(prefixes.join(a+";")+(b||""))}function x(a,b){return typeof a===b}function y(a,b){return!!~(""+a).indexOf(b)}function z(a,b,d){for(var e in a){var f=b[a[e]];if(f!==c)return d===!1?a[e]:x(f,"function")?f.bind(d||b):f}return!1}var d="2.8.3",e={},f=b.documentElement,g="modernizr",h=b.createElement(g),i=h.style,j,k={}.toString,l={svg:"http://www.w3.org/2000/svg"},m={},n={},o={},p=[],q=p.slice,r,s=function(a,c,d,e){var h,i,j,k,l=b.createElement("div"),m=b.body,n=m||b.createElement("body");if(parseInt(d,10))while(d--)j=b.createElement("div"),j.id=e?e[d]:g+(d+1),l.appendChild(j);return h=["&#173;",'<style id="s',g,'">',a,"</style>"].join(""),l.id=g,(m?l:n).innerHTML+=h,n.appendChild(l),m||(n.style.background="",n.style.overflow="hidden",k=f.style.overflow,f.style.overflow="hidden",f.appendChild(n)),i=c(l,a),m?l.parentNode.removeChild(l):(n.parentNode.removeChild(n),f.style.overflow=k),!!i},t={}.hasOwnProperty,u;!x(t,"undefined")&&!x(t.call,"undefined")?u=function(a,b){return t.call(a,b)}:u=function(a,b){return b in a&&x(a.constructor.prototype[b],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(b){var c=this;if(typeof c!="function")throw new TypeError;var d=q.call(arguments,1),e=function(){if(this instanceof e){var a=function(){};a.prototype=c.prototype;var f=new a,g=c.apply(f,d.concat(q.call(arguments)));return Object(g)===g?g:f}return c.apply(b,d.concat(q.call(arguments)))};return e}),m.canvas=function(){var a=b.createElement("canvas");return!!a.getContext&&!!a.getContext("2d")},m.canvastext=function(){return!!e.canvas&&!!x(b.createElement("canvas").getContext("2d").fillText,"function")},m.fontface=function(){var a;return s('@font-face {font-family:"font";src:url("https://")}',function(c,d){var e=b.getElementById("smodernizr"),f=e.sheet||e.styleSheet,g=f?f.cssRules&&f.cssRules[0]?f.cssRules[0].cssText:f.cssText||"":"";a=/src/i.test(g)&&g.indexOf(d.split(" ")[0])===0}),a},m.inlinesvg=function(){var a=b.createElement("div");return a.innerHTML="<svg/>",(a.firstChild&&a.firstChild.namespaceURI)==l.svg};for(var A in m)u(m,A)&&(r=A.toLowerCase(),e[r]=m[A](),p.push((e[r]?"":"no-")+r));return e.addTest=function(a,b){if(typeof a=="object")for(var d in a)u(a,d)&&e.addTest(d,a[d]);else{a=a.toLowerCase();if(e[a]!==c)return e;b=typeof b=="function"?b():b,typeof enableClasses!="undefined"&&enableClasses&&(f.className+=" "+(b?"":"no-")+a),e[a]=b}return e},v(""),h=j=null,e._version=d,e.testStyles=s,e}(this,this.document);
(function(__globals__)
{
  "use strict";

var vitrium = {actions:{},analytics:{},aria:{},async:{},bin:{},codec:{},crypto:{},easy:{},events:{},features:{},fonts:{},fs:{},g4s:{},geometry:{},geometry2:{},i18n:{},io:{cache:{},documents:{},package:{}},json:{},log:{},service:{},ui:{},utils:{asyncStorage:{},pools:{}},viewer:{events:{},version:{}},xps:{},zip:{}};
// script:viewer/lib/underscore-min.js
//     Underscore.js 1.4.2
//     http://underscorejs.org
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.
(function(){var e=this,t=e._,n={},r=Array.prototype,i=Object.prototype,s=Function.prototype,o=r.push,u=r.slice,a=r.concat,f=r.unshift,l=i.toString,c=i.hasOwnProperty,h=r.forEach,p=r.map,d=r.reduce,v=r.reduceRight,m=r.filter,g=r.every,y=r.some,b=r.indexOf,w=r.lastIndexOf,E=Array.isArray,S=Object.keys,x=s.bind,T=function(e){if(e instanceof T)return e;if(!(this instanceof T))return new T(e);this._wrapped=e};typeof exports!="undefined"?(typeof module!="undefined"&&module.exports&&(exports=module.exports=T),exports._=T):e._=T,T.VERSION="1.4.2";var N=T.each=T.forEach=function(e,t,r){if(e==null)return;if(h&&e.forEach===h)e.forEach(t,r);else if(e.length===+e.length){for(var i=0,s=e.length;i<s;i++)if(t.call(r,e[i],i,e)===n)return}else for(var o in e)if(T.has(e,o)&&t.call(r,e[o],o,e)===n)return};T.map=T.collect=function(e,t,n){var r=[];return e==null?r:p&&e.map===p?e.map(t,n):(N(e,function(e,i,s){r[r.length]=t.call(n,e,i,s)}),r)},T.reduce=T.foldl=T.inject=function(e,t,n,r){var i=arguments.length>2;e==null&&(e=[]);if(d&&e.reduce===d)return r&&(t=T.bind(t,r)),i?e.reduce(t,n):e.reduce(t);N(e,function(e,s,o){i?n=t.call(r,n,e,s,o):(n=e,i=!0)});if(!i)throw new TypeError("Reduce of empty array with no initial value");return n},T.reduceRight=T.foldr=function(e,t,n,r){var i=arguments.length>2;e==null&&(e=[]);if(v&&e.reduceRight===v)return r&&(t=T.bind(t,r)),arguments.length>2?e.reduceRight(t,n):e.reduceRight(t);var s=e.length;if(s!==+s){var o=T.keys(e);s=o.length}N(e,function(u,a,f){a=o?o[--s]:--s,i?n=t.call(r,n,e[a],a,f):(n=e[a],i=!0)});if(!i)throw new TypeError("Reduce of empty array with no initial value");return n},T.find=T.detect=function(e,t,n){var r;return C(e,function(e,i,s){if(t.call(n,e,i,s))return r=e,!0}),r},T.filter=T.select=function(e,t,n){var r=[];return e==null?r:m&&e.filter===m?e.filter(t,n):(N(e,function(e,i,s){t.call(n,e,i,s)&&(r[r.length]=e)}),r)},T.reject=function(e,t,n){var r=[];return e==null?r:(N(e,function(e,i,s){t.call(n,e,i,s)||(r[r.length]=e)}),r)},T.every=T.all=function(e,t,r){t||(t=T.identity);var i=!0;return e==null?i:g&&e.every===g?e.every(t,r):(N(e,function(e,s,o){if(!(i=i&&t.call(r,e,s,o)))return n}),!!i)};var C=T.some=T.any=function(e,t,r){t||(t=T.identity);var i=!1;return e==null?i:y&&e.some===y?e.some(t,r):(N(e,function(e,s,o){if(i||(i=t.call(r,e,s,o)))return n}),!!i)};T.contains=T.include=function(e,t){var n=!1;return e==null?n:b&&e.indexOf===b?e.indexOf(t)!=-1:(n=C(e,function(e){return e===t}),n)},T.invoke=function(e,t){var n=u.call(arguments,2);return T.map(e,function(e){return(T.isFunction(t)?t:e[t]).apply(e,n)})},T.pluck=function(e,t){return T.map(e,function(e){return e[t]})},T.where=function(e,t){return T.isEmpty(t)?[]:T.filter(e,function(e){for(var n in t)if(t[n]!==e[n])return!1;return!0})},T.max=function(e,t,n){if(!t&&T.isArray(e)&&e[0]===+e[0]&&e.length<65535)return Math.max.apply(Math,e);if(!t&&T.isEmpty(e))return-Infinity;var r={computed:-Infinity};return N(e,function(e,i,s){var o=t?t.call(n,e,i,s):e;o>=r.computed&&(r={value:e,computed:o})}),r.value},T.min=function(e,t,n){if(!t&&T.isArray(e)&&e[0]===+e[0]&&e.length<65535)return Math.min.apply(Math,e);if(!t&&T.isEmpty(e))return Infinity;var r={computed:Infinity};return N(e,function(e,i,s){var o=t?t.call(n,e,i,s):e;o<r.computed&&(r={value:e,computed:o})}),r.value},T.shuffle=function(e){var t,n=0,r=[];return N(e,function(e){t=T.random(n++),r[n-1]=r[t],r[t]=e}),r};var k=function(e){return T.isFunction(e)?e:function(t){return t[e]}};T.sortBy=function(e,t,n){var r=k(t);return T.pluck(T.map(e,function(e,t,i){return{value:e,index:t,criteria:r.call(n,e,t,i)}}).sort(function(e,t){var n=e.criteria,r=t.criteria;if(n!==r){if(n>r||n===void 0)return 1;if(n<r||r===void 0)return-1}return e.index<t.index?-1:1}),"value")};var L=function(e,t,n,r){var i={},s=k(t);return N(e,function(t,o){var u=s.call(n,t,o,e);r(i,u,t)}),i};T.groupBy=function(e,t,n){return L(e,t,n,function(e,t,n){(T.has(e,t)?e[t]:e[t]=[]).push(n)})},T.countBy=function(e,t,n){return L(e,t,n,function(e,t,n){T.has(e,t)||(e[t]=0),e[t]++})},T.sortedIndex=function(e,t,n,r){n=n==null?T.identity:k(n);var i=n.call(r,t),s=0,o=e.length;while(s<o){var u=s+o>>>1;n.call(r,e[u])<i?s=u+1:o=u}return s},T.toArray=function(e){return e?e.length===+e.length?u.call(e):T.values(e):[]},T.size=function(e){return e.length===+e.length?e.length:T.keys(e).length},T.first=T.head=T.take=function(e,t,n){return t!=null&&!n?u.call(e,0,t):e[0]},T.initial=function(e,t,n){return u.call(e,0,e.length-(t==null||n?1:t))},T.last=function(e,t,n){return t!=null&&!n?u.call(e,Math.max(e.length-t,0)):e[e.length-1]},T.rest=T.tail=T.drop=function(e,t,n){return u.call(e,t==null||n?1:t)},T.compact=function(e){return T.filter(e,function(e){return!!e})};var A=function(e,t,n){return N(e,function(e){T.isArray(e)?t?o.apply(n,e):A(e,t,n):n.push(e)}),n};T.flatten=function(e,t){return A(e,t,[])},T.without=function(e){return T.difference(e,u.call(arguments,1))},T.uniq=T.unique=function(e,t,n,r){var i=n?T.map(e,n,r):e,s=[],o=[];return N(i,function(n,r){if(t?!r||o[o.length-1]!==n:!T.contains(o,n))o.push(n),s.push(e[r])}),s},T.union=function(){return T.uniq(a.apply(r,arguments))},T.intersection=function(e){var t=u.call(arguments,1);return T.filter(T.uniq(e),function(e){return T.every(t,function(t){return T.indexOf(t,e)>=0})})},T.difference=function(e){var t=a.apply(r,u.call(arguments,1));return T.filter(e,function(e){return!T.contains(t,e)})},T.zip=function(){var e=u.call(arguments),t=T.max(T.pluck(e,"length")),n=new Array(t);for(var r=0;r<t;r++)n[r]=T.pluck(e,""+r);return n},T.object=function(e,t){var n={};for(var r=0,i=e.length;r<i;r++)t?n[e[r]]=t[r]:n[e[r][0]]=e[r][1];return n},T.indexOf=function(e,t,n){if(e==null)return-1;var r=0,i=e.length;if(n){if(typeof n!="number")return r=T.sortedIndex(e,t),e[r]===t?r:-1;r=n<0?Math.max(0,i+n):n}if(b&&e.indexOf===b)return e.indexOf(t,n);for(;r<i;r++)if(e[r]===t)return r;return-1},T.lastIndexOf=function(e,t,n){if(e==null)return-1;var r=n!=null;if(w&&e.lastIndexOf===w)return r?e.lastIndexOf(t,n):e.lastIndexOf(t);var i=r?n:e.length;while(i--)if(e[i]===t)return i;return-1},T.range=function(e,t,n){arguments.length<=1&&(t=e||0,e=0),n=arguments[2]||1;var r=Math.max(Math.ceil((t-e)/n),0),i=0,s=new Array(r);while(i<r)s[i++]=e,e+=n;return s};var O=function(){};T.bind=function(t,n){var r,i;if(t.bind===x&&x)return x.apply(t,u.call(arguments,1));if(!T.isFunction(t))throw new TypeError;return i=u.call(arguments,2),r=function(){if(this instanceof r){O.prototype=t.prototype;var e=new O,s=t.apply(e,i.concat(u.call(arguments)));return Object(s)===s?s:e}return t.apply(n,i.concat(u.call(arguments)))}},T.bindAll=function(e){var t=u.call(arguments,1);return t.length==0&&(t=T.functions(e)),N(t,function(t){e[t]=T.bind(e[t],e)}),e},T.memoize=function(e,t){var n={};return t||(t=T.identity),function(){var r=t.apply(this,arguments);return T.has(n,r)?n[r]:n[r]=e.apply(this,arguments)}},T.delay=function(e,t){var n=u.call(arguments,2);return setTimeout(function(){return e.apply(null,n)},t)},T.defer=function(e){return T.delay.apply(T,[e,1].concat(u.call(arguments,1)))},T.throttle=function(e,t){var n,r,i,s,o,u,a=T.debounce(function(){o=s=!1},t);return function(){n=this,r=arguments;var f=function(){i=null,o&&(u=e.apply(n,r)),a()};return i||(i=setTimeout(f,t)),s?o=!0:(s=!0,u=e.apply(n,r)),a(),u}},T.debounce=function(e,t,n){var r,i;return function(){var s=this,o=arguments,u=function(){r=null,n||(i=e.apply(s,o))},a=n&&!r;return clearTimeout(r),r=setTimeout(u,t),a&&(i=e.apply(s,o)),i}},T.once=function(e){var t=!1,n;return function(){return t?n:(t=!0,n=e.apply(this,arguments),e=null,n)}},T.wrap=function(e,t){return function(){var n=[e];return o.apply(n,arguments),t.apply(this,n)}},T.compose=function(){var e=arguments;return function(){var t=arguments;for(var n=e.length-1;n>=0;n--)t=[e[n].apply(this,t)];return t[0]}},T.after=function(e,t){return e<=0?t():function(){if(--e<1)return t.apply(this,arguments)}},T.keys=S||function(e){if(e!==Object(e))throw new TypeError("Invalid object");var t=[];for(var n in e)T.has(e,n)&&(t[t.length]=n);return t},T.values=function(e){var t=[];for(var n in e)T.has(e,n)&&t.push(e[n]);return t},T.pairs=function(e){var t=[];for(var n in e)T.has(e,n)&&t.push([n,e[n]]);return t},T.invert=function(e){var t={};for(var n in e)T.has(e,n)&&(t[e[n]]=n);return t},T.functions=T.methods=function(e){var t=[];for(var n in e)T.isFunction(e[n])&&t.push(n);return t.sort()},T.extend=function(e){return N(u.call(arguments,1),function(t){for(var n in t)e[n]=t[n]}),e},T.pick=function(e){var t={},n=a.apply(r,u.call(arguments,1));return N(n,function(n){n in e&&(t[n]=e[n])}),t},T.omit=function(e){var t={},n=a.apply(r,u.call(arguments,1));for(var i in e)T.contains(n,i)||(t[i]=e[i]);return t},T.defaults=function(e){return N(u.call(arguments,1),function(t){for(var n in t)e[n]==null&&(e[n]=t[n])}),e},T.clone=function(e){return T.isObject(e)?T.isArray(e)?e.slice():T.extend({},e):e},T.tap=function(e,t){return t(e),e};var M=function(e,t,n,r){if(e===t)return e!==0||1/e==1/t;if(e==null||t==null)return e===t;e instanceof T&&(e=e._wrapped),t instanceof T&&(t=t._wrapped);var i=l.call(e);if(i!=l.call(t))return!1;switch(i){case"[object String]":return e==String(t);case"[object Number]":return e!=+e?t!=+t:e==0?1/e==1/t:e==+t;case"[object Date]":case"[object Boolean]":return+e==+t;case"[object RegExp]":return e.source==t.source&&e.global==t.global&&e.multiline==t.multiline&&e.ignoreCase==t.ignoreCase}if(typeof e!="object"||typeof t!="object")return!1;var s=n.length;while(s--)if(n[s]==e)return r[s]==t;n.push(e),r.push(t);var o=0,u=!0;if(i=="[object Array]"){o=e.length,u=o==t.length;if(u)while(o--)if(!(u=M(e[o],t[o],n,r)))break}else{var a=e.constructor,f=t.constructor;if(a!==f&&!(T.isFunction(a)&&a instanceof a&&T.isFunction(f)&&f instanceof f))return!1;for(var c in e)if(T.has(e,c)){o++;if(!(u=T.has(t,c)&&M(e[c],t[c],n,r)))break}if(u){for(c in t)if(T.has(t,c)&&!(o--))break;u=!o}}return n.pop(),r.pop(),u};T.isEqual=function(e,t){return M(e,t,[],[])},T.isEmpty=function(e){if(e==null)return!0;if(T.isArray(e)||T.isString(e))return e.length===0;for(var t in e)if(T.has(e,t))return!1;return!0},T.isElement=function(e){return!!e&&e.nodeType===1},T.isArray=E||function(e){return l.call(e)=="[object Array]"},T.isObject=function(e){return e===Object(e)},N(["Arguments","Function","String","Number","Date","RegExp"],function(e){T["is"+e]=function(t){return l.call(t)=="[object "+e+"]"}}),T.isArguments(arguments)||(T.isArguments=function(e){return!!e&&!!T.has(e,"callee")}),typeof /./!="function"&&(T.isFunction=function(e){return typeof e=="function"}),T.isFinite=function(e){return T.isNumber(e)&&isFinite(e)},T.isNaN=function(e){return T.isNumber(e)&&e!=+e},T.isBoolean=function(e){return e===!0||e===!1||l.call(e)=="[object Boolean]"},T.isNull=function(e){return e===null},T.isUndefined=function(e){return e===void 0},T.has=function(e,t){return c.call(e,t)},T.noConflict=function(){return e._=t,this},T.identity=function(e){return e},T.times=function(e,t,n){for(var r=0;r<e;r++)t.call(n,r)},T.random=function(e,t){return t==null&&(t=e,e=0),e+(0|Math.random()*(t-e+1))};var _={escape:{"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","/":"&#x2F;"}};_.unescape=T.invert(_.escape);var D={escape:new RegExp("["+T.keys(_.escape).join("")+"]","g"),unescape:new RegExp("("+T.keys(_.unescape).join("|")+")","g")};T.each(["escape","unescape"],function(e){T[e]=function(t){return t==null?"":(""+t).replace(D[e],function(t){return _[e][t]})}}),T.result=function(e,t){if(e==null)return null;var n=e[t];return T.isFunction(n)?n.call(e):n},T.mixin=function(e){N(T.functions(e),function(t){var n=T[t]=e[t];T.prototype[t]=function(){var e=[this._wrapped];return o.apply(e,arguments),F.call(this,n.apply(T,e))}})};var P=0;T.uniqueId=function(e){var t=P++;return e?e+t:t},T.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var H=/(.)^/,B={"'":"'","\\":"\\","\r":"r","\n":"n","	":"t","\u2028":"u2028","\u2029":"u2029"},j=/\\|'|\r|\n|\t|\u2028|\u2029/g;T.template=function(e,t,n){n=T.defaults({},n,T.templateSettings);var r=new RegExp([(n.escape||H).source,(n.interpolate||H).source,(n.evaluate||H).source].join("|")+"|$","g"),i=0,s="__p+='";e.replace(r,function(t,n,r,o,u){s+=e.slice(i,u).replace(j,function(e){return"\\"+B[e]}),s+=n?"'+\n((__t=("+n+"))==null?'':_.escape(__t))+\n'":r?"'+\n((__t=("+r+"))==null?'':__t)+\n'":o?"';\n"+o+"\n__p+='":"",i=u+t.length}),s+="';\n",n.variable||(s="with(obj||{}){\n"+s+"}\n"),s="var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n"+s+"return __p;\n";try{var o=new Function(n.variable||"obj","_",s)}catch(u){throw u.source=s,u}if(t)return o(t,T);var a=function(e){return o.call(this,e,T)};return a.source="function("+(n.variable||"obj")+"){\n"+s+"}",a},T.chain=function(e){return T(e).chain()};var F=function(e){return this._chain?T(e).chain():e};T.mixin(T),N(["pop","push","reverse","shift","sort","splice","unshift"],function(e){var t=r[e];T.prototype[e]=function(){var n=this._wrapped;return t.apply(n,arguments),(e=="shift"||e=="splice")&&n.length===0&&delete n[0],F.call(this,n)}}),N(["concat","join","slice"],function(e){var t=r[e];T.prototype[e]=function(){return F.call(this,t.apply(this._wrapped,arguments))}}),T.extend(T.prototype,{chain:function(){return this._chain=!0,this},value:function(){return this._wrapped}})}).call(this);
// script:viewer/lib/backbone.js
//     Backbone.js 0.9.2

//     (c) 2010-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(){

  // Initial Setup
  // -------------

  // Save a reference to the global object (`window` in the browser, `global`
  // on the server).
  var root = this;

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create a local reference to slice/splice.
  var slice = Array.prototype.slice;
  var splice = Array.prototype.splice;

  // The top-level namespace. All public Backbone classes and modules will
  // be attached to this. Exported for both CommonJS and the browser.
  var Backbone;
  if (typeof exports !== 'undefined') {
    Backbone = exports;
  } else {
    Backbone = root.Backbone = {};
  }

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '0.9.2';

  // Require Underscore, if we're on the server, and it's not already present.
  var _ = root._;
  if (!_ && (typeof require !== 'undefined')) _ = require('underscore');

  // For Backbone's purposes, jQuery, Zepto, or Ender owns the `$` variable.
  var $ = root.jQuery || root.Zepto || root.ender;

  // Set the JavaScript library that will be used for DOM manipulation and
  // Ajax calls (a.k.a. the `$` variable). By default Backbone will use: jQuery,
  // Zepto, or Ender; but the `setDomLibrary()` method lets you inject an
  // alternate JavaScript library (or a mock library for testing your views
  // outside of a browser).
  Backbone.setDomLibrary = function(lib) {
    $ = lib;
  };

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // -----------------

  // Regular expression used to split event strings
  var eventSplitter = /\s+/;

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback functions
  // to an event; trigger`-ing an event fires all callbacks in succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind one or more space separated events, `events`, to a `callback`
    // function. Passing `"all"` will bind the callback to all events fired.
    on: function(events, callback, context) {

      var calls, event, node, tail, list;
      if (!callback) return this;
      events = events.split(eventSplitter);
      calls = this._callbacks || (this._callbacks = {});

      // Create an immutable callback list, allowing traversal during
      // modification.  The tail is an empty object that will always be used
      // as the next node.
      while (event = events.shift()) {
        list = calls[event];
        node = list ? list.tail : {};
        node.next = tail = {};
        node.context = context;
        node.callback = callback;
        calls[event] = {tail: tail, next: list ? list.next : node};
      }

      return this;
    },

    // Remove one or many callbacks. If `context` is null, removes all callbacks
    // with that function. If `callback` is null, removes all callbacks for the
    // event. If `events` is null, removes all bound callbacks for all events.
    off: function(events, callback, context) {
      var event, calls, node, tail, cb, ctx;

      // No events, or removing *all* events.
      if (!(calls = this._callbacks)) return;
      if (!(events || callback || context)) {
        delete this._callbacks;
        return this;
      }

      // Loop through the listed events and contexts, splicing them out of the
      // linked list of callbacks if appropriate.
      events = events ? events.split(eventSplitter) : _.keys(calls);
      while (event = events.shift()) {
        node = calls[event];
        delete calls[event];
        if (!node || !(callback || context)) continue;
        // Create a new list, omitting the indicated callbacks.
        tail = node.tail;
        while ((node = node.next) !== tail) {
          cb = node.callback;
          ctx = node.context;
          if ((callback && cb !== callback) || (context && ctx !== context)) {
            this.on(event, cb, ctx);
          }
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(events) {
      var event, node, calls, tail, args, all, rest;
      if (!(calls = this._callbacks)) return this;
      all = calls.all;
      events = events.split(eventSplitter);
      rest = slice.call(arguments, 1);

      // For each event, walk through the linked list of callbacks twice,
      // first to trigger the event, then to trigger any `"all"` callbacks.
      while (event = events.shift()) {
        if (node = calls[event]) {
          tail = node.tail;
          while ((node = node.next) !== tail) {
            node.callback.apply(node.context || this, rest);
          }
        }
        if (node = all) {
          tail = node.tail;
          args = [event].concat(rest);
          while ((node = node.next) !== tail) {
            node.callback.apply(node.context || this, args);
          }
        }
      }

      return this;
    }

  };

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Backbone.Model
  // --------------

  // Create a new model, with defined attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var defaults;
    attributes || (attributes = {});
    if (options && options.parse) attributes = this.parse(attributes);
    if (defaults = getValue(this, 'defaults')) {
      attributes = _.extend({}, defaults, attributes);
    }
    if (options && options.collection) this.collection = options.collection;
    this.attributes = {};
    this._escapedAttributes = {};
    this.cid = _.uniqueId('c');
    this.changed = {};
    this._silent = {};
    this._pending = {};
    this.set(attributes, {silent: true});
    // Reset change tracking.
    this.changed = {};
    this._silent = {};
    this._pending = {};
    this._previousAttributes = _.clone(this.attributes);
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // A hash of attributes that have silently changed since the last time
    // `change` was called.  Will become pending attributes on the next call.
    _silent: null,

    // A hash of attributes that have changed since the last `'change'` event
    // began.
    _pending: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      var html;
      if (html = this._escapedAttributes[attr]) return html;
      var val = this.get(attr);
      return this._escapedAttributes[attr] = _.escape(val == null ? '' : '' + val);
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"` unless
    // you choose to silence it.
    set: function(key, value, options) {
      var attrs, attr, val;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (_.isObject(key) || key == null) {
        attrs = key;
        options = value;
      } else {
        attrs = {};
        attrs[key] = value;
      }

      // Extract attributes and options.
      options || (options = {});
      if (!attrs) return this;
      if (attrs instanceof Model) attrs = attrs.attributes;
      if (options.unset) for (attr in attrs) attrs[attr] = void 0;

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      var changes = options.changes = {};
      var now = this.attributes;
      var escaped = this._escapedAttributes;
      var prev = this._previousAttributes || {};

      // For each `set` attribute...
      for (attr in attrs) {
        val = attrs[attr];

        // If the new and current value differ, record the change.
        if (!_.isEqual(now[attr], val) || (options.unset && _.has(now, attr))) {
          delete escaped[attr];
          (options.silent ? this._silent : changes)[attr] = true;
        }

        // Update or delete the current value.
        options.unset ? delete now[attr] : now[attr] = val;

        // If the new and previous value differ, record the change.  If not,
        // then remove changes for this attribute.
        if (!_.isEqual(prev[attr], val) || (_.has(now, attr) != _.has(prev, attr))) {
          this.changed[attr] = val;
          if (!options.silent) this._pending[attr] = true;
        } else {
          delete this.changed[attr];
          delete this._pending[attr];
        }
      }

      // Fire the `"change"` events.
      if (!options.silent) this.change(options);
      return this;
    },

    // Remove an attribute from the model, firing `"change"` unless you choose
    // to silence it. `unset` is a noop if the attribute doesn't exist.
    unset: function(attr, options) {
      (options || (options = {})).unset = true;
      return this.set(attr, null, options);
    },

    // Clear all attributes on the model, firing `"change"` unless you choose
    // to silence it.
    clear: function(options) {
      (options || (options = {})).unset = true;
      return this.set(_.clone(this.attributes), options);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overriden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;
      options.success = function(resp, status, xhr) {
        if (!model.set(model.parse(resp, xhr), options)) return false;
        if (success) success(model, resp);
      };
      options.error = Backbone.wrapError(options.error, model, options);
      return (this.sync || Backbone.sync).call(this, 'read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, value, options) {
      var attrs, current;

      // Handle both `("key", value)` and `({key: value})` -style calls.
      if (_.isObject(key) || key == null) {
        attrs = key;
        options = value;
      } else {
        attrs = {};
        attrs[key] = value;
      }
      options = options ? _.clone(options) : {};

      // If we're "wait"-ing to set changed attributes, validate early.
      if (options.wait) {
        if (!this._validate(attrs, options)) return false;
        current = _.clone(this.attributes);
      }

      // Regular saves `set` attributes before persisting to the server.
      var silentOptions = _.extend({}, options, {silent: true});
      if (attrs && !this.set(attrs, options.wait ? silentOptions : options)) {
        return false;
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      var model = this;
      var success = options.success;
      options.success = function(resp, status, xhr) {
        var serverAttrs = model.parse(resp, xhr);
        if (options.wait) {
          delete options.wait;
          serverAttrs = _.extend(attrs || {}, serverAttrs);
        }
        if (!model.set(serverAttrs, options)) return false;
        if (success) {
          success(model, resp);
        } else {
          model.trigger('sync', model, resp, options);
        }
      };

      // Finish configuring and sending the Ajax request.
      options.error = Backbone.wrapError(options.error, model, options);
      var method = this.isNew() ? 'create' : 'update';
      var xhr = (this.sync || Backbone.sync).call(this, method, this, options);
      if (options.wait) this.set(current, silentOptions);
      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var triggerDestroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      if (this.isNew()) {
        triggerDestroy();
        return false;
      }

      options.success = function(resp) {
        if (options.wait) triggerDestroy();
        if (success) {
          success(model, resp);
        } else {
          model.trigger('sync', model, resp, options);
        }
      };

      options.error = Backbone.wrapError(options.error, model, options);
      var xhr = (this.sync || Backbone.sync).call(this, 'delete', this, options);
      if (!options.wait) triggerDestroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base = getValue(this, 'urlRoot') || getValue(this.collection, 'url') || urlError();
      if (this.isNew()) return base;
      return base + (base.charAt(base.length - 1) == '/' ? '' : '/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, xhr) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return this.id == null;
    },

    // Call this method to manually fire a `"change"` event for this model and
    // a `"change:attribute"` event for each changed attribute.
    // Calling this will cause all objects observing the model to update.
    change: function(options) {
      options || (options = {});
      var changing = this._changing;
      this._changing = true;

      // Silent changes become pending changes.
      for (var attr in this._silent) this._pending[attr] = true;

      // Silent changes are triggered.
      var changes = _.extend({}, options.changes, this._silent);
      this._silent = {};
      for (var attr in changes) {
        this.trigger('change:' + attr, this, this.get(attr), options);
      }
      if (changing) return this;

      // Continue firing `"change"` events while there are pending changes.
      while (!_.isEmpty(this._pending)) {
        this._pending = {};
        this.trigger('change', this, options);
        // Pending and silent changes still remain.
        for (var attr in this.changed) {
          if (this._pending[attr] || this._silent[attr]) continue;
          delete this.changed[attr];
        }
        this._previousAttributes = _.clone(this.attributes);
      }

      this._changing = false;
      return this;
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (!arguments.length) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false, old = this._previousAttributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (!arguments.length || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Check if the model is currently in a valid state. It's only possible to
    // get into an *invalid* state if you're using silent changes.
    isValid: function() {
      return !this.validate(this.attributes);
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. If a specific `error` callback has
    // been passed, call that instead of firing the general `"error"` event.
    _validate: function(attrs, options) {
      if (options.silent || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validate(attrs, options);
      if (!error) return true;
      if (options && options.error) {
        options.error(this, error, options);
      } else {
        this.trigger('error', this, error, options);
      }
      return false;
    }

  });

  // Backbone.Collection
  // -------------------

  // Provides a standard collection class for our sets of models, ordered
  // or unordered. If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, {silent: true, parse: options.parse});
  };

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Add a model, or list of models to the set. Pass **silent** to avoid
    // firing the `add` event for every new model.
    add: function(models, options) {
      var i, index, length, model, cid, id, cids = {}, ids = {}, dups = [];
      options || (options = {});
      models = _.isArray(models) ? models.slice() : [models];

      // Begin by turning bare objects into model references, and preventing
      // invalid models or duplicate models from being added.
      for (i = 0, length = models.length; i < length; i++) {
        if (!(model = models[i] = this._prepareModel(models[i], options))) {
          throw new Error("Can't add an invalid model to a collection");
        }
        cid = model.cid;
        id = model.id;
        if (cids[cid] || this._byCid[cid] || ((id != null) && (ids[id] || this._byId[id]))) {
          dups.push(i);
          continue;
        }
        cids[cid] = ids[id] = model;
      }

      // Remove duplicates.
      i = dups.length;
      while (i--) {
        models.splice(dups[i], 1);
      }

      // Listen to added models' events, and index models for lookup by
      // `id` and by `cid`.
      for (i = 0, length = models.length; i < length; i++) {
        (model = models[i]).on('all', this._onModelEvent, this);
        this._byCid[model.cid] = model;
        if (model.id != null) this._byId[model.id] = model;
      }

      // Insert models into the collection, re-sorting if needed, and triggering
      // `add` events unless silenced.
      this.length += length;
      index = options.at != null ? options.at : this.models.length;
      splice.apply(this.models, [index, 0].concat(models));
      if (this.comparator) this.sort({silent: true});
      if (options.silent) return this;
      for (i = 0, length = this.models.length; i < length; i++) {
        if (!cids[(model = this.models[i]).cid]) continue;
        options.index = i;
        model.trigger('add', model, this, options);
      }
      return this;
    },

    // Remove a model, or a list of models from the set. Pass silent to avoid
    // firing the `remove` event for every model removed.
    remove: function(models, options) {
      var i, l, index, model;
      options || (options = {});
      models = _.isArray(models) ? models.slice() : [models];
      for (i = 0, l = models.length; i < l; i++) {
        model = this.getByCid(models[i]) || this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byCid[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model);
      }
      return this;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, options);
      return model;
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, _.extend({at: 0}, options));
      return model;
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Get a model from the set by id.
    get: function(id) {
      if (id == null) return void 0;
      return this._byId[id.id != null ? id.id : id];
    },

    // Get a model from the set by client id.
    getByCid: function(cid) {
      return cid && this._byCid[cid.cid || cid];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of `filter`.
    where: function(attrs) {
      if (_.isEmpty(attrs)) return [];
      return this.filter(function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      options || (options = {});
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      var boundComparator = _.bind(this.comparator, this);
      if (this.comparator.length == 1) {
        this.models = this.sortBy(boundComparator);
      } else {
        this.models.sort(boundComparator);
      }
      if (!options.silent) this.trigger('reset', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.map(this.models, function(model){ return model.get(attr); });
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any `add` or `remove` events. Fires `reset` when finished.
    reset: function(models, options) {
      models  || (models = []);
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i]);
      }
      this._reset();
      this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return this;
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `add: true` is passed, appends the
    // models to the collection instead of resetting.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === undefined) options.parse = true;
      var collection = this;
      var success = options.success;
      options.success = function(resp, status, xhr) {
        collection[options.add ? 'add' : 'reset'](collection.parse(resp, xhr), options);
        if (success) success(collection, resp);
      };
      options.error = Backbone.wrapError(options.error, collection, options);
      return (this.sync || Backbone.sync).call(this, 'read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      var coll = this;
      options = options ? _.clone(options) : {};
      model = this._prepareModel(model, options);
      if (!model) return false;
      if (!options.wait) coll.add(model, options);
      var success = options.success;
      options.success = function(nextModel, resp, xhr) {
        if (options.wait) coll.add(nextModel, options);
        if (success) {
          success(nextModel, resp);
        } else {
          nextModel.trigger('sync', model, resp, options);
        }
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, xhr) {
      return resp;
    },

    // Proxy to _'s chain. Can't be proxied the same way the rest of the
    // underscore methods are proxied because it relies on the underscore
    // constructor.
    chain: function () {
      return _(this.models).chain();
    },

    // Reset all internal state. Called when the collection is reset.
    _reset: function(options) {
      this.length = 0;
      this.models = [];
      this._byId  = {};
      this._byCid = {};
    },

    // Prepare a model or hash of attributes to be added to this collection.
    _prepareModel: function(model, options) {
      options || (options = {});
      if (!(model instanceof Model)) {
        var attrs = model;
        options.collection = this;
        model = new this.model(attrs, options);
        if (!model._validate(model.attributes, options)) model = false;
      } else if (!model.collection) {
        model.collection = this;
      }
      return model;
    },

    // Internal method to remove a model's ties to a collection.
    _removeReference: function(model) {
      if (this == model.collection) {
        delete model.collection;
      }
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event == 'add' || event == 'remove') && collection != this) return;
      if (event == 'destroy') {
        this.remove(model, options);
      }
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  var methods = ['forEach', 'each', 'map', 'reduce', 'reduceRight', 'find',
    'detect', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any',
    'include', 'contains', 'invoke', 'max', 'min', 'sortBy', 'sortedIndex',
    'toArray', 'size', 'first', 'initial', 'rest', 'last', 'without', 'indexOf',
    'shuffle', 'lastIndexOf', 'isEmpty', 'groupBy'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      return _[method].apply(_, [this.models].concat(_.toArray(arguments)));
    };
  });

  // Backbone.Router
  // -------------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var namedParam    = /:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[-[\]{}()+?.,\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      Backbone.history || (Backbone.history = new History);
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (!callback) callback = this[name];
      Backbone.history.route(route, _.bind(function(fragment) {
        var args = this._extractParameters(route, fragment);
        callback && callback.apply(this, args);
        this.trigger.apply(this, ['route:' + name].concat(args));
        Backbone.history.trigger('route', this, name, args);
      }, this));
      return this;
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      var routes = [];
      for (var route in this.routes) {
        routes.unshift([route, this.routes[route]]);
      }
      for (var i = 0, l = routes.length; i < l; i++) {
        this.route(routes[i][0], routes[i][1], this[routes[i][1]]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(namedParam, '([^\/]+)')
                   .replace(splatParam, '(.*?)');
      return new RegExp('^' + route + '$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted parameters.
    _extractParameters: function(route, fragment) {
      return route.exec(fragment).slice(1);
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on URL fragments. If the
  // browser does not support `onhashchange`, falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');
  };

  // Cached regex for cleaning leading hashes and slashes .
  var routeStripper = /^[#\/]/;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(windowOverride) {
      var loc = windowOverride ? windowOverride.location : window.location;
      var match = loc.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || forcePushState) {
          fragment = window.location.pathname;
          var search = window.location.search;
          if (search) fragment += search;
        } else {
          fragment = this.getHash();
        }
      }
      if (!fragment.indexOf(this.options.root)) fragment = fragment.substr(this.options.root.length);
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({}, {root: '/'}, this.options, options);
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && window.history && window.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      if (oldIE) {
        this.iframe = $('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        $(window).bind('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        $(window).bind('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = window.location;
      var atRoot  = loc.pathname == this.options.root;

      // If we've started off with a route from a `pushState`-enabled browser,
      // but we're currently in a browser that doesn't support it...
      if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {
        this.fragment = this.getFragment(null, true);
        window.location.replace(this.options.root + '#' + this.fragment);
        // Return immediately as browser will do redirect to new url
        return true;

      // Or if we've started out with a hash-based route, but we're currently
      // in a browser where it could be `pushState`-based instead...
      } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {
        this.fragment = this.getHash().replace(routeStripper, '');
        window.history.replaceState({}, document.title, loc.protocol + '//' + loc.host + this.options.root + this.fragment);
      }

      if (!this.options.silent) {
        return this.loadUrl();
      }
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      $(window).unbind('popstate', this.checkUrl).unbind('hashchange', this.checkUrl);
      clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current == this.fragment && this.iframe) current = this.getFragment(this.getHash(this.iframe));
      if (current == this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl() || this.loadUrl(this.getHash());
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragmentOverride) {
      var fragment = this.fragment = this.getFragment(fragmentOverride);
      var matched = _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
      return matched;
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: options};
      var frag = (fragment || '').replace(routeStripper, '');
      if (this.fragment == frag) return;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        if (frag.indexOf(this.options.root) != 0) frag = this.options.root + frag;
        this.fragment = frag;
        window.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, frag);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this.fragment = frag;
        this._updateHash(window.location, frag, options.replace);
        if (this.iframe && (frag != this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a history entry on hash-tag change.
          // When replace is true, we don't want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, frag, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        window.location.assign(this.options.root + fragment);
      }
      if (options.trigger) this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        location.replace(location.toString().replace(/(javascript:|#).*$/, '') + '#' + fragment);
      } else {
        location.hash = fragment;
      }
    }
  });

  // Backbone.View
  // -------------

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    this._configure(options || {});
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be prefered to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view from the DOM. Note that the view isn't present in the
    // DOM by default, so calling this method may be a no-op.
    remove: function() {
      this.$el.remove();
      return this;
    },

    // For small amounts of DOM Elements, where a full-blown template isn't
    // needed, use **make** to manufacture elements, one at a time.
    //
    //     var el = this.make('li', {'class': 'row'}, this.model.escape('title'));
    //
    make: function(tagName, attributes, content) {
      var el = document.createElement(tagName);
      if (attributes) $(el).attr(attributes);
      if (content) $(el).html(content);
      return el;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = (element instanceof $) ? element : $(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save'
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = getValue(this, 'events')))) return;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) throw new Error('Method "' + events[key] + '" does not exist');
        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.bind(eventName, method);
        } else {
          this.$el.delegate(selector, eventName, method);
        }
      }
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.unbind('.delegateEvents' + this.cid);
    },

    // Performs the initial configuration of a View with a set of options.
    // Keys with special meaning *(model, collection, id, className)*, are
    // attached directly to the view.
    _configure: function(options) {
      if (this.options) options = _.extend({}, this.options, options);
      for (var i = 0, l = viewOptions.length; i < l; i++) {
        var attr = viewOptions[i];
        if (options[attr]) this[attr] = options[attr];
      }
      this.options = options;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = getValue(this, 'attributes') || {};
        if (this.id) attrs.id = this.id;
        if (this.className) attrs['class'] = this.className;
        this.setElement(this.make(this.tagName, attrs), false);
      } else {
        this.setElement(this.el, false);
      }
    }

  });

  // The self-propagating extend function that Backbone classes use.
  var extend = function (protoProps, classProps) {
    var child = inherits(this, protoProps, classProps);
    child.extend = this.extend;
    return child;
  };

  // Set up inheritance for the model, collection, and view.
  Model.extend = Collection.extend = Router.extend = View.extend = extend;

  // Backbone.sync
  // -------------

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    options || (options = {});

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = getValue(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (!options.data && model && (method == 'create' || method == 'update')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(model.toJSON());
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (Backbone.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (Backbone.emulateHTTP) {
      if (type === 'PUT' || type === 'DELETE') {
        if (Backbone.emulateJSON) params.data._method = type;
        params.type = 'POST';
        params.beforeSend = function(xhr) {
          xhr.setRequestHeader('X-HTTP-Method-Override', type);
        };
      }
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !Backbone.emulateJSON) {
      params.processData = false;
    }

    // Make the request, allowing the user to override any Ajax options.
    return $.ajax(_.extend(params, options));
  };

  // Wrap an optional error callback with a fallback error event.
  Backbone.wrapError = function(onError, originalModel, options) {
    return function(model, resp) {
      resp = model === originalModel ? resp : model;
      if (onError) {
        onError(originalModel, resp, options);
      } else {
        originalModel.trigger('error', originalModel, resp, options);
      }
    };
  };

  // Helpers
  // -------

  // Shared empty constructor function to aid in prototype-chain creation.
  var ctor = function(){};

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var inherits = function(parent, protoProps, staticProps) {
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && protoProps.hasOwnProperty('constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ parent.apply(this, arguments); };
    }

    // Inherit class (static) properties from parent.
    _.extend(child, parent);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Add static properties to the constructor function, if supplied.
    if (staticProps) _.extend(child, staticProps);

    // Correctly set child's `prototype.constructor`.
    child.prototype.constructor = child;

    // Set a convenience property in case the parent's prototype is needed later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Helper function to get a value from a Backbone object as a property
  // or as a function.
  var getValue = function(object, prop) {
    if (!(object && object[prop])) return null;
    return _.isFunction(object[prop]) ? object[prop]() : object[prop];
  };

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

}).call(this);
// script:viewer/lib/hammer.min.js
/*! Hammer.JS - v1.0.5 - 2013-04-07
 * http://eightmedia.github.com/hammer.js
 *
 * Copyright (c) 2013 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */

(function(window, undefined) {
  'use strict';

  /**
   * Hammer
   * use this to create instances
   * @param   {HTMLElement}   element
   * @param   {Object}        options
   * @returns {Hammer.Instance}
   * @constructor
   */
  var Hammer = function(element, options) {
    return new Hammer.Instance(element, options || {});
  };

  // default settings
  Hammer.defaults = {
    // add styles and attributes to the element to prevent the browser from doing
    // its native behavior. this doesnt prevent the scrolling, but cancels
    // the contextmenu, tap highlighting etc
    // set to false to disable this
    stop_browser_behavior: {
      // this also triggers onselectstart=false for IE
      userSelect: 'none',
      // this makes the element blocking in IE10 >, you could experiment with the value
      // see for more options this issue; https://github.com/EightMedia/hammer.js/issues/241
      touchAction: 'none',
      touchCallout: 'none',
      contentZooming: 'none',
      userDrag: 'none',
      tapHighlightColor: 'rgba(0,0,0,0)'
    }

    // more settings are defined per gesture at gestures.js
  };

  // detect touchevents
  Hammer.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;
  Hammer.HAS_TOUCHEVENTS = ('ontouchstart' in window);

  // dont use mouseevents on mobile devices
  Hammer.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
  Hammer.NO_MOUSEEVENTS = true;//Hammer.HAS_TOUCHEVENTS && navigator.userAgent.match(Hammer.MOBILE_REGEX);

  // eventtypes per touchevent (start, move, end)
  // are filled by Hammer.event.determineEventTypes on setup
  Hammer.EVENT_TYPES = {};

  // direction defines
  Hammer.DIRECTION_DOWN = 'down';
  Hammer.DIRECTION_LEFT = 'left';
  Hammer.DIRECTION_UP = 'up';
  Hammer.DIRECTION_RIGHT = 'right';

  // pointer type
  Hammer.POINTER_MOUSE = 'mouse';
  Hammer.POINTER_TOUCH = 'touch';
  Hammer.POINTER_PEN = 'pen';

  // touch event defines
  Hammer.EVENT_START = 'start';
  Hammer.EVENT_MOVE = 'move';
  Hammer.EVENT_END = 'end';

  // hammer document where the base events are added at
  Hammer.DOCUMENT = document;

  // plugins namespace
  Hammer.plugins = {};

  // if the window events are set...
  Hammer.READY = false;

  /**
   * setup events to detect gestures on the document
   */
  function setup() {
    if(Hammer.READY) {
      return;
    }

    // find what eventtypes we add listeners to
    Hammer.event.determineEventTypes();

    // Register all gestures inside Hammer.gestures
    for(var name in Hammer.gestures) {
      if(Hammer.gestures.hasOwnProperty(name)) {
        Hammer.detection.register(Hammer.gestures[name]);
      }
    }

    // Add touch events on the document
    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_MOVE, Hammer.detection.detect);
    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_END, Hammer.detection.detect);

    // Hammer is ready...!
    Hammer.READY = true;
  }

  /**
   * create new hammer instance
   * all methods should return the instance itself, so it is chainable.
   * @param   {HTMLElement}       element
   * @param   {Object}            [options={}]
   * @returns {Hammer.Instance}
   * @constructor
   */
  Hammer.Instance = function(element, options) {
    var self = this;

    // setup HammerJS window events and register all gestures
    // this also sets up the default options
    setup();

    this.element = element;

    // start/stop detection option
    this.enabled = true;

    // merge options
    this.options = Hammer.utils.extend(
        Hammer.utils.extend({}, Hammer.defaults),
        options || {});

    // add some css to the element to prevent the browser from doing its native behavoir
    if(this.options.stop_browser_behavior) {
      Hammer.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);
    }

    // start detection on touchstart
    Hammer.event.onTouch(element, Hammer.EVENT_START, function (ev)
    {
      if(self.enabled) {
        Hammer.detection.startDetect(self, ev);
      }
    });

    // return instance
    return this;
  };


  Hammer.Instance.prototype = {
    /**
     * bind events to the instance
     * @param   {String}      gesture
     * @param   {Function}    handler
     * @returns {Hammer.Instance}
     */
    on: function onEvent(gesture, handler){
      var gestures = gesture.split(' ');
      for(var t=0; t<gestures.length; t++) {
        this.element.addEventListener(gestures[t], handler, false);
      }
      return this;
    },


    /**
     * unbind events to the instance
     * @param   {String}      gesture
     * @param   {Function}    handler
     * @returns {Hammer.Instance}
     */
    off: function offEvent(gesture, handler){
      var gestures = gesture.split(' ');
      for(var t=0; t<gestures.length; t++) {
        this.element.removeEventListener(gestures[t], handler, false);
      }
      return this;
    },


    /**
     * trigger gesture event
     * @param   {String}      gesture
     * @param   {Object}      eventData
     * @returns {Hammer.Instance}
     */
    trigger: function triggerEvent(gesture, eventData){
      // create DOM event
      var event = Hammer.DOCUMENT.createEvent('Event');
      event.initEvent(gesture, true, true);
      event.gesture = eventData;

      // trigger on the target if it is in the instance element,
      // this is for event delegation tricks
      var element = this.element;
      if(Hammer.utils.hasParent(eventData.target, element)) {
        element = eventData.target;
        element.dispatchEvent(event);
      }

      if (this.element === eventData.target)
      {
        element.dispatchEvent(event);
      }

        
      return this;
    },


    /**
     * enable of disable hammer.js detection
     * @param   {Boolean}   state
     * @returns {Hammer.Instance}
     */
    enable: function enable(state) {
      this.enabled = state;
      return this;
    }
  };

  /**
   * this holds the last move event,
   * used to fix empty touchend issue
   * see the onTouch event for an explanation
   * @type {Object}
   */
  var last_move_event = null;


  /**
   * when the mouse is hold down, this is true
   * @type {Boolean}
   */
  var enable_detect = false;


  /**
   * when touch events have been fired, this is true
   * @type {Boolean}
   */
  var touch_triggered = false;
 

  Hammer.event = {
    /**
     * simple addEventListener
     * @param   {HTMLElement}   element
     * @param   {String}        type
     * @param   {Function}      handler
     */
    bindDom: function(element, type, handler) {
      var types = type.split(' ');
      for(var t=0; t<types.length; t++) {
        element.addEventListener(types[t], handler, false);
      }
    },


    /**
     * touch events with mouse fallback
     * @param   {HTMLElement}   element
     * @param   {String}        eventType        like Hammer.EVENT_MOVE
     * @param   {Function}      handler
     */
    onTouch: function onTouch(element, eventType, handler) {
      var self = this;

      this.bindDom(element, Hammer.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {
			
        var sourceEventType = ev.type.toLowerCase();

        // onmouseup, but when touchend has been fired we do nothing.
        // this is for touchdevices which also fire a mouseup on touchend
        if(sourceEventType.match(/mouse/) && touch_triggered) {
          return;
        }

          // mousebutton must be down or a touch event
        else if( sourceEventType.match(/touch/) ||   // touch events are always on screen
            sourceEventType.match(/pointerdown/) || // pointerevents touch
            (sourceEventType.match(/mouse/) && ev.which === 1)   // mouse is pressed
        ){
          enable_detect = true;
        }

        // we are in a touch event, set the touch triggered bool to true,
        // this for the conflicts that may occur on ios and android
        if(sourceEventType.match(/touch|pointer/)) {
          touch_triggered = true;
        }

        // count the total touches on the screen
        var count_touches = 0;

        // when touch has been triggered in this detection session
        // and we are now handling a mouse event, we stop that to prevent conflicts
        if(enable_detect) {
          // update pointerevent
          if(Hammer.HAS_POINTEREVENTS && eventType != Hammer.EVENT_END) {
            count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);
          }
            // touch
          else if(sourceEventType.match(/touch/)) {
            count_touches = ev.touches.length;
          }
            // mouse
          else if(!touch_triggered) {
            count_touches = sourceEventType.match(/up/) ? 0 : 1;
          }

          // if we are in a end event, but when we remove one touch and
          // we still have enough, set eventType to move
          if(count_touches > 0 && eventType == Hammer.EVENT_END) {
            eventType = Hammer.EVENT_MOVE;
          }
            // no touches, force the end event
          else if(!count_touches) {
            eventType = Hammer.EVENT_END;
          }

          // because touchend has no touches, and we often want to use these in our gestures,
          // we send the last move event as our eventData in touchend
          if(!count_touches && last_move_event !== null) {
            ev = last_move_event;
          }
            // store the last move event
          else {
            last_move_event = ev;
          }

          // trigger the handler
          handler.call(Hammer.detection, self.collectEventData(element, eventType, ev));

          // remove pointerevent from list
          if(Hammer.HAS_POINTEREVENTS && eventType == Hammer.EVENT_END) {
            count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);
          }
        }

        //debug(sourceEventType +" "+ eventType);

        // on the end we reset everything
        if(!count_touches) {
          last_move_event = null;
          enable_detect = false;
          touch_triggered = false;
          Hammer.PointerEvent.reset();
        }
      });
    },


    /**
     * we have different events for each device/browser
     * determine what we need and set them in the Hammer.EVENT_TYPES constant
     */
    determineEventTypes: function determineEventTypes() {
      // determine the eventtype we want to set
      var types;

      // pointerEvents magic
      if(Hammer.HAS_POINTEREVENTS) {
        types = Hammer.PointerEvent.getEvents();
      }
        // on Android, iOS, blackberry, windows mobile we dont want any mouseevents
      else if(Hammer.NO_MOUSEEVENTS) {
        types = [
            'touchstart',
            'touchmove',
            'touchend touchcancel'];
      }
        // for non pointer events browsers and mixed browsers,
        // like chrome on windows8 touch laptop
      else {
        types = [
            'touchstart mousedown',
            'touchmove mousemove',
            'touchend touchcancel mouseup'];
      }

      Hammer.EVENT_TYPES[Hammer.EVENT_START]  = types[0];
      Hammer.EVENT_TYPES[Hammer.EVENT_MOVE]   = types[1];
      Hammer.EVENT_TYPES[Hammer.EVENT_END]    = types[2];
    },


    /**
     * create touchlist depending on the event
     * @param   {Object}    ev
     * @param   {String}    eventType   used by the fakemultitouch plugin
     */
    getTouchList: function getTouchList(ev/*, eventType*/) {
      // get the fake pointerEvent touchlist
      if(Hammer.HAS_POINTEREVENTS) {
        return Hammer.PointerEvent.getTouchList();
      }
        // get the touchlist
      else if(ev.touches) {
        return ev.touches;
      }
        // make fake touchlist from mouse position
      else {
        return [{
          identifier: 1,
          pageX: ev.pageX,
          pageY: ev.pageY,
          target: ev.target
        }];
      }
    },


    /**
     * collect event data for Hammer js
     * @param   {HTMLElement}   element
     * @param   {String}        eventType        like Hammer.EVENT_MOVE
     * @param   {Object}        eventData
     */
    collectEventData: function collectEventData(element, eventType, ev) {
      var touches = this.getTouchList(ev, eventType);

      // find out pointerType
      var pointerType = Hammer.POINTER_TOUCH;
      if(ev.type.match(/mouse/) || Hammer.PointerEvent.matchType(Hammer.POINTER_MOUSE, ev)) {
        pointerType = Hammer.POINTER_MOUSE;
      }

      return {
        center      : Hammer.utils.getCenter(touches),
        timeStamp   : new Date().getTime(),
        target      : ev.target,
        touches     : touches,
        eventType   : eventType,
        pointerType : pointerType,
        srcEvent    : ev,

        /**
         * prevent the browser default actions
         * mostly used to disable scrolling of the browser
         */
        preventDefault: function() {
          if(this.srcEvent.preventManipulation) {
            this.srcEvent.preventManipulation();
          }

          if(this.srcEvent.preventDefault) {
            this.srcEvent.preventDefault();
          }
        },

        /**
         * stop bubbling the event up to its parents
         */
        stopPropagation: function() {
          this.srcEvent.stopPropagation();
        },

        /**
         * immediately stop gesture detection
         * might be useful after a swipe was detected
         * @return {*}
         */
        stopDetect: function() {
          return Hammer.detection.stopDetect();
        }
      };
    }
  };

  Hammer.PointerEvent = {
    /**
     * holds all pointers
     * @type {Object}
     */
    pointers: {},

    /**
     * get a list of pointers
     * @returns {Array}     touchlist
     */
    getTouchList: function() {
      var self = this;
      var touchlist = [];

      // we can use forEach since pointerEvents only is in IE10
      Object.keys(self.pointers).sort().forEach(function(id) {
        touchlist.push(self.pointers[id]);
      });
      return touchlist;
    },

    /**
     * update the position of a pointer
     * @param   {String}   type             Hammer.EVENT_END
     * @param   {Object}   pointerEvent
     */
    updatePointer: function(type, pointerEvent) {
      if(type == Hammer.EVENT_END) {
        this.pointers = {};
      }
      else {
        pointerEvent.identifier = pointerEvent.pointerId;
        this.pointers[pointerEvent.pointerId] = pointerEvent;
      }

      return Object.keys(this.pointers).length;
    },

    /**
     * check if ev matches pointertype
     * @param   {String}        pointerType     Hammer.POINTER_MOUSE
     * @param   {PointerEvent}  ev
     */
    matchType: function(pointerType, ev) {
      if(!ev.pointerType) {
        return false;
      }

      var types = {};
      types[Hammer.POINTER_MOUSE] = (ev.pointerType == ev.MSPOINTER_TYPE_MOUSE || ev.pointerType == Hammer.POINTER_MOUSE);
      types[Hammer.POINTER_TOUCH] = (ev.pointerType == ev.MSPOINTER_TYPE_TOUCH || ev.pointerType == Hammer.POINTER_TOUCH);
      types[Hammer.POINTER_PEN] = (ev.pointerType == ev.MSPOINTER_TYPE_PEN || ev.pointerType == Hammer.POINTER_PEN);
      return types[pointerType];
    },


    /**
     * get events
     */
    getEvents: function() {
      return [
          'pointerdown MSPointerDown',
          'pointermove MSPointerMove',
          'pointerup pointercancel MSPointerUp MSPointerCancel'
      ];
    },

    /**
     * reset the list
     */
    reset: function() {
      this.pointers = {};
    }
  };


  Hammer.utils = {
    /**
     * extend method,
     * also used for cloning when dest is an empty object
     * @param   {Object}    dest
     * @param   {Object}    src
	 * @parm	{Boolean}	merge		do a merge
     * @returns {Object}    dest
     */
    extend: function extend(dest, src, merge) {
      for (var key in src) {
        if(dest[key] !== undefined && merge) {
          continue;
        }
        dest[key] = src[key];
      }
      return dest;
    },


    /**
     * find if a node is in the given parent
     * used for event delegation tricks
     * @param   {HTMLElement}   node
     * @param   {HTMLElement}   parent
     * @returns {boolean}       has_parent
     */
    hasParent: function(node, parent) {
      while(node){
        if(node == parent) {
          return true;
        }
        node = node.parentNode;
      }
      return false;
    },


    /**
     * get the center of all the touches
     * @param   {Array}     touches
     * @returns {Object}    center
     */
    getCenter: function getCenter(touches) {
      var valuesX = [], valuesY = [];

      for(var t= 0,len=touches.length; t<len; t++) {
        valuesX.push(touches[t].pageX);
        valuesY.push(touches[t].pageY);
      }

      return {
        pageX: ((Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2),
        pageY: ((Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2)
      };
    },


    /**
     * calculate the velocity between two points
     * @param   {Number}    delta_time
     * @param   {Number}    delta_x
     * @param   {Number}    delta_y
     * @returns {Object}    velocity
     */
    getVelocity: function getVelocity(delta_time, delta_x, delta_y) {
      return {
        x: Math.abs(delta_x / delta_time) || 0,
        y: Math.abs(delta_y / delta_time) || 0
      };
    },


    /**
     * calculate the angle between two coordinates
     * @param   {Touch}     touch1
     * @param   {Touch}     touch2
     * @returns {Number}    angle
     */
    getAngle: function getAngle(touch1, touch2) {
      var y = touch2.pageY - touch1.pageY,
          x = touch2.pageX - touch1.pageX;
      return Math.atan2(y, x) * 180 / Math.PI;
    },


    /**
     * angle to direction define
     * @param   {Touch}     touch1
     * @param   {Touch}     touch2
     * @returns {String}    direction constant, like Hammer.DIRECTION_LEFT
     */
    getDirection: function getDirection(touch1, touch2) {
      var x = Math.abs(touch1.pageX - touch2.pageX),
          y = Math.abs(touch1.pageY - touch2.pageY);

      if(x >= y) {
        return touch1.pageX - touch2.pageX > 0 ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;
      }
      else {
        return touch1.pageY - touch2.pageY > 0 ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;
      }
    },


    /**
     * calculate the distance between two touches
     * @param   {Touch}     touch1
     * @param   {Touch}     touch2
     * @returns {Number}    distance
     */
    getDistance: function getDistance(touch1, touch2) {
      var x = touch2.pageX - touch1.pageX,
          y = touch2.pageY - touch1.pageY;
      return Math.sqrt((x*x) + (y*y));
    },


    /**
     * calculate the scale factor between two touchLists (fingers)
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param   {Array}     start
     * @param   {Array}     end
     * @returns {Number}    scale
     */
    getScale: function getScale(start, end) {
      // need two fingers...
      if(start.length >= 2 && end.length >= 2) {
        return this.getDistance(end[0], end[1]) /
            this.getDistance(start[0], start[1]);
      }
      return 1;
    },


    /**
     * calculate the rotation degrees between two touchLists (fingers)
     * @param   {Array}     start
     * @param   {Array}     end
     * @returns {Number}    rotation
     */
    getRotation: function getRotation(start, end) {
      // need two fingers
      if(start.length >= 2 && end.length >= 2) {
        return this.getAngle(end[1], end[0]) -
            this.getAngle(start[1], start[0]);
      }
      return 0;
    },


    /**
     * boolean if the direction is vertical
     * @param    {String}    direction
     * @returns  {Boolean}   is_vertical
     */
    isVertical: function isVertical(direction) {
      return (direction == Hammer.DIRECTION_UP || direction == Hammer.DIRECTION_DOWN);
    },


    /**
     * stop browser default behavior with css props
     * @param   {HtmlElement}   element
     * @param   {Object}        css_props
     */
    stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_props) {
      var prop,
          vendors = ['webkit','khtml','moz','ms','o',''];

      if(!css_props || !element.style) {
        return;
      }

      // with css properties for modern browsers
      for(var i = 0; i < vendors.length; i++) {
        for(var p in css_props) {
          if(css_props.hasOwnProperty(p)) {
            prop = p;

            // vender prefix at the property
            if(vendors[i]) {
              prop = vendors[i] + prop.substring(0, 1).toUpperCase() + prop.substring(1);
            }

            // set the style
            element.style[prop] = css_props[p];
          }
        }
      }

      // also the disable onselectstart
      if(css_props.userSelect == 'none') {
        element.onselectstart = function() {
          return false;
        };
      }
    }
  };

  Hammer.detection = {
    // contains all registred Hammer.gestures in the correct order
    gestures: [],

    // data of the current Hammer.gesture detection session
    current: null,

    // the previous Hammer.gesture session data
    // is a full clone of the previous gesture.current object
    previous: null,

    // when this becomes true, no gestures are fired
    stopped: false,


    /**
     * start Hammer.gesture detection
     * @param   {Hammer.Instance}   inst
     * @param   {Object}            eventData
     */
    startDetect: function startDetect(inst, eventData) {
      // already busy with a Hammer.gesture detection on an element
      if (this.current && this.current.inst !== inst)
      {
        if (this.current !== null)
        {
          this.stopDetect();
        }
      }
      if(this.current) {
        return;
      }

      this.stopped = false;

      this.current = {
        inst        : inst, // reference to HammerInstance we're working for
        startEvent  : Hammer.utils.extend({}, eventData), // start eventData for distances, timing etc
        lastEvent   : false, // last eventData
        name        : '' // current gesture we're in/detected, can be 'tap', 'hold' etc
      };
     /* eventData._preventDefault = eventData.preventDefault;
      eventData.preventDefault = function ()
      {
        try
        {
          throw new Error();
        } catch (e)
        {
          console.log(e.stack);
        }
        this._preventDefault();
      };*/

      this.detect(eventData);
    },


    /**
     * Hammer.gesture detection
     * @param   {Object}    eventData
     * @param   {Object}    eventData
     */
    detect: function detect(eventData) {
      if(!this.current || this.stopped) {
        return;
      }
        
      // extend event data with calculations about scale, distance etc
      eventData = this.extendEventData(eventData);

      // instance options
      var inst_options = this.current.inst.options;
      //console.log(inst_options);
      // call Hammer.gesture handlers
      for(var g=0,len=this.gestures.length; g<len; g++) {
        var gesture = this.gestures[g];

        // only when the instance options have enabled this gesture
        if(!this.stopped && inst_options[gesture.name] !== false) {
          // if a handler returns false, we stop with the detection
          if(gesture.handler.call(gesture, eventData, this.current.inst) === false) {
            this.stopDetect();
            break;
          }
        }
      }

      // store as previous event event
      if(this.current) {
        this.current.lastEvent = eventData;
      }

      // endevent, but not the last touch, so dont stop
      if(eventData.eventType == Hammer.EVENT_END && !eventData.touches.length-1) {
        this.stopDetect();
      }

      return eventData;
    },


    /**
     * clear the Hammer.gesture vars
     * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected
     * to stop other Hammer.gestures from being fired
     */
    stopDetect: function stopDetect() {
      // clone current data to the store as the previous gesture
      // used for the double tap gesture, since this is an other gesture detect session
      this.previous = Hammer.utils.extend({}, this.current);

      // reset the current
      this.current = null;
      
      // stopped!
      this.stopped = true;
    },


    /**
     * extend eventData for Hammer.gestures
     * @param   {Object}   ev
     * @returns {Object}   ev
     */
    extendEventData: function extendEventData(ev) {
      var startEv = this.current.startEvent;

      // if the touches change, set the new touches over the startEvent touches
      // this because touchevents don't have all the touches on touchstart, or the
      // user must place his fingers at the EXACT same time on the screen, which is not realistic
      // but, sometimes it happens that both fingers are touching at the EXACT same time
      if(startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {
        // extend 1 level deep to get the touchlist with the touch objects
        startEv.touches = [];
        for(var i=0,len=ev.touches.length; i<len; i++) {
          startEv.touches.push(Hammer.utils.extend({}, ev.touches[i]));
        }
      }

      var delta_time = ev.timeStamp - startEv.timeStamp,
          delta_x = ev.center.pageX - startEv.center.pageX,
          delta_y = ev.center.pageY - startEv.center.pageY,
          velocity = Hammer.utils.getVelocity(delta_time, delta_x, delta_y);

      Hammer.utils.extend(ev, {
        deltaTime   : delta_time,

        deltaX      : delta_x,
        deltaY      : delta_y,

        velocityX   : velocity.x,
        velocityY   : velocity.y,

        distance    : Hammer.utils.getDistance(startEv.center, ev.center),
        angle       : Hammer.utils.getAngle(startEv.center, ev.center),
        direction   : Hammer.utils.getDirection(startEv.center, ev.center),

        scale       : Hammer.utils.getScale(startEv.touches, ev.touches),
        rotation    : Hammer.utils.getRotation(startEv.touches, ev.touches),

        startEvent  : startEv
      });

      return ev;
    },


    /**
     * register new gesture
     * @param   {Object}    gesture object, see gestures.js for documentation
     * @returns {Array}     gestures
     */
    register: function register(gesture) {
      // add an enable gesture options if there is no given
      var options = gesture.defaults || {};
      if(options[gesture.name] === undefined) {
        options[gesture.name] = true;
      }

      // extend Hammer default options with the Hammer.gesture options
      Hammer.utils.extend(Hammer.defaults, options, true);

      // set its index
      gesture.index = gesture.index || 1000;

      // add Hammer.gesture to the list
      this.gestures.push(gesture);

      // sort the list by index
      this.gestures.sort(function(a, b) {
        if (a.index < b.index) {
          return -1;
        }
        if (a.index > b.index) {
          return 1;
        }
        return 0;
      });

      return this.gestures;
    }
  };


  Hammer.gestures = Hammer.gestures || {};

  /**
   * Custom gestures
   * ==============================
   *
   * Gesture object
   * --------------------
   * The object structure of a gesture:
   *
   * { name: 'mygesture',
   *   index: 1337,
   *   defaults: {
   *     mygesture_option: true
   *   }
   *   handler: function(type, ev, inst) {
   *     // trigger gesture event
   *     inst.trigger(this.name, ev);
   *   }
   * }
  
   * @param   {String}    name
   * this should be the name of the gesture, lowercase
   * it is also being used to disable/enable the gesture per instance config.
   *
   * @param   {Number}    [index=1000]
   * the index of the gesture, where it is going to be in the stack of gestures detection
   * like when you build an gesture that depends on the drag gesture, it is a good
   * idea to place it after the index of the drag gesture.
   *
   * @param   {Object}    [defaults={}]
   * the default settings of the gesture. these are added to the instance settings,
   * and can be overruled per instance. you can also add the name of the gesture,
   * but this is also added by default (and set to true).
   *
   * @param   {Function}  handler
   * this handles the gesture detection of your custom gesture and receives the
   * following arguments:
   *
   *      @param  {Object}    eventData
   *      event data containing the following properties:
   *          timeStamp   {Number}        time the event occurred
   *          target      {HTMLElement}   target element
   *          touches     {Array}         touches (fingers, pointers, mouse) on the screen
   *          pointerType {String}        kind of pointer that was used. matches Hammer.POINTER_MOUSE|TOUCH
   *          center      {Object}        center position of the touches. contains pageX and pageY
   *          deltaTime   {Number}        the total time of the touches in the screen
   *          deltaX      {Number}        the delta on x axis we haved moved
   *          deltaY      {Number}        the delta on y axis we haved moved
   *          velocityX   {Number}        the velocity on the x
   *          velocityY   {Number}        the velocity on y
   *          angle       {Number}        the angle we are moving
   *          direction   {String}        the direction we are moving. matches Hammer.DIRECTION_UP|DOWN|LEFT|RIGHT
   *          distance    {Number}        the distance we haved moved
   *          scale       {Number}        scaling of the touches, needs 2 touches
   *          rotation    {Number}        rotation of the touches, needs 2 touches *
   *          eventType   {String}        matches Hammer.EVENT_START|MOVE|END
   *          srcEvent    {Object}        the source event, like TouchStart or MouseDown *
   *          startEvent  {Object}        contains the same properties as above,
   *                                      but from the first touch. this is used to calculate
   *                                      distances, deltaTime, scaling etc
   *
   *      @param  {Hammer.Instance}    inst
   *      the instance we are doing the detection for. you can get the options from
   *      the inst.options object and trigger the gesture event by calling inst.trigger
   *
   *
   * Handle gestures
   * --------------------
   * inside the handler you can get/set Hammer.detection.current. This is the current
   * detection session. It has the following properties
   *      @param  {String}    name
   *      contains the name of the gesture we have detected. it has not a real function,
   *      only to check in other gestures if something is detected.
   *      like in the drag gesture we set it to 'drag' and in the swipe gesture we can
   *      check if the current gesture is 'drag' by accessing Hammer.detection.current.name
   *
   *      @readonly
   *      @param  {Hammer.Instance}    inst
   *      the instance we do the detection for
   *
   *      @readonly
   *      @param  {Object}    startEvent
   *      contains the properties of the first gesture detection in this session.
   *      Used for calculations about timing, distance, etc.
   *
   *      @readonly
   *      @param  {Object}    lastEvent
   *      contains all the properties of the last gesture detect in this session.
   *
   * after the gesture detection session has been completed (user has released the screen)
   * the Hammer.detection.current object is copied into Hammer.detection.previous,
   * this is usefull for gestures like doubletap, where you need to know if the
   * previous gesture was a tap
   *
   * options that have been set by the instance can be received by calling inst.options
   *
   * You can trigger a gesture event by calling inst.trigger("mygesture", event).
   * The first param is the name of your gesture, the second the event argument
   *
   *
   * Register gestures
   * --------------------
   * When an gesture is added to the Hammer.gestures object, it is auto registered
   * at the setup of the first Hammer instance. You can also call Hammer.detection.register
   * manually and pass your gesture object as a param
   *
   */

  /**
   * Hold
   * Touch stays at the same place for x time
   * @events  hold
   */
  Hammer.gestures.Hold = {
    name: 'hold',
    index: 10,
    defaults: {
      hold_timeout	: 500,
      hold_threshold	: 1
    },
    timer: null,
    handler: function holdGesture(ev, inst) {
      switch(ev.eventType) {
        case Hammer.EVENT_START:
          // clear any running timers
          clearTimeout(this.timer);

          // set the gesture so we can check in the timeout if it still is
          Hammer.detection.current.name = this.name;

          // set timer and if after the timeout it still is hold,
          // we trigger the hold event
          this.timer = setTimeout(function() {
            if(Hammer.detection.current.name == 'hold') {
              inst.trigger('hold', ev);
            }
          }, inst.options.hold_timeout);
          break;

          // when you move or end we clear the timer
        case Hammer.EVENT_MOVE:
          if(ev.distance > inst.options.hold_threshold) {
            clearTimeout(this.timer);
          }
          break;

        case Hammer.EVENT_END:
          clearTimeout(this.timer);
          break;
      }
    }
  };


  /**
   * Tap/DoubleTap
   * Quick touch at a place or double at the same place
   * @events  tap, doubletap
   */
  Hammer.gestures.Tap = {
    name: 'tap',
    index: 100,
    defaults: {
      tap_max_touchtime	: 250,
      tap_max_distance	: 10,
      tap_always			: true,
      doubletap_distance	: 20,
      doubletap_interval	: 300
    },
    handler: function tapGesture(ev, inst)
    {
      if(ev.eventType == Hammer.EVENT_END) {
        // previous gesture, for the double tap since these are two different gesture detections
        var prev = Hammer.detection.previous,
    did_doubletap = false;
      
            
        // when the touchtime is higher then the max touch time
        // or when the moving distance is too much
        if(ev.deltaTime > inst.options.tap_max_touchtime ||
            ev.distance > inst.options.tap_max_distance) {
          return;
        }

        // check if double tap
        if(prev && prev.name == 'tap' &&
            (ev.timeStamp - prev.lastEvent.timeStamp) < inst.options.doubletap_interval &&
            ev.distance < inst.options.doubletap_distance) {
          inst.trigger('doubletap', ev);
          did_doubletap = true;
        }

        // do a single tap
        if(!did_doubletap || inst.options.tap_always) {
          Hammer.detection.current.name = 'tap';
			  
          inst.trigger(Hammer.detection.current.name, ev);
        }
      }
    }
  };


  /**
   * Swipe
   * triggers swipe events when the end velocity is above the threshold
   * @events  swipe, swipeleft, swiperight, swipeup, swipedown
   */
  Hammer.gestures.Swipe = {
    name: 'swipe',
    index: 40,
    defaults: {
      // set 0 for unlimited, but this can conflict with transform
      swipe_max_touches  : 1,
      swipe_velocity     : 0.7
    },
    handler: function swipeGesture(ev, inst) {
      if(ev.eventType == Hammer.EVENT_END) {
        // max touches
        if(inst.options.swipe_max_touches > 0 &&
            ev.touches.length > inst.options.swipe_max_touches) {
          return;
        }

        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if(ev.velocityX > inst.options.swipe_velocity ||
            ev.velocityY > inst.options.swipe_velocity) {
          // trigger swipe events
          inst.trigger(this.name, ev);
          inst.trigger(this.name + ev.direction, ev);
        }
      }
    }
  };


  /**
   * Drag
   * Move with x fingers (default 1) around on the page. Blocking the scrolling when
   * moving left and right is a good practice. When all the drag events are blocking
   * you disable scrolling on that area.
   * @events  drag, drapleft, dragright, dragup, dragdown
   */
  Hammer.gestures.Drag = {
    name: 'drag',
    index: 50,
    defaults: {
      drag_min_distance : 10,
      // set 0 for unlimited, but this can conflict with transform
      drag_max_touches  : 1,
      // prevent default browser behavior when dragging occurs
      // be careful with it, it makes the element a blocking element
      // when you are using the drag gesture, it is a good practice to set this true
      drag_block_horizontal   : false,
      drag_block_vertical     : false,
      // drag_lock_to_axis keeps the drag gesture on the axis that it started on,
      // It disallows vertical directions if the initial direction was horizontal, and vice versa.
      drag_lock_to_axis       : false,
      // drag lock only kicks in when distance > drag_lock_min_distance
      // This way, locking occurs only when the distance has become large enough to reliably determine the direction
      drag_lock_min_distance : 25
    },
    triggered: false,
    handler: function dragGesture(ev, inst) {
      // current gesture isnt drag, but dragged is true
      // this means an other gesture is busy. now call dragend
      if(Hammer.detection.current.name != this.name && this.triggered) {
        inst.trigger(this.name +'end', ev);
        this.triggered = false;
        return;
      }

      // max touches
      if(inst.options.drag_max_touches > 0 &&
          ev.touches.length > inst.options.drag_max_touches) {
        return;
      }

      switch(ev.eventType) {
        case Hammer.EVENT_START:
          this.triggered = false;
          break;

        case Hammer.EVENT_MOVE:
          // when the distance we moved is too small we skip this gesture
          // or we can be already in dragging
          if(ev.distance < inst.options.drag_min_distance &&
              Hammer.detection.current.name != this.name) {
            return;
          }

          // we are dragging!
          Hammer.detection.current.name = this.name;

          // lock drag to axis?
          if(Hammer.detection.current.lastEvent.drag_locked_to_axis || (inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance<=ev.distance)) {
            ev.drag_locked_to_axis = true;
          }
          var last_direction = Hammer.detection.current.lastEvent.direction;
          if(ev.drag_locked_to_axis && last_direction !== ev.direction) {
            // keep direction on the axis that the drag gesture started on
            if(Hammer.utils.isVertical(last_direction)) {
              ev.direction = (ev.deltaY < 0) ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;
            }
            else {
              ev.direction = (ev.deltaX < 0) ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;
            }
          }

          // first time, trigger dragstart event
          if(!this.triggered) {
            inst.trigger(this.name +'start', ev);
            this.triggered = true;
          }

          // trigger normal event
          inst.trigger(this.name, ev);

          // direction event, like dragdown
          inst.trigger(this.name + ev.direction, ev);

          // block the browser events
          if( (inst.options.drag_block_vertical && Hammer.utils.isVertical(ev.direction)) ||
              (inst.options.drag_block_horizontal && !Hammer.utils.isVertical(ev.direction))) {
            ev.preventDefault();
          }
          break;

        case Hammer.EVENT_END:
          // trigger dragend
          if(this.triggered) {
            inst.trigger(this.name +'end', ev);
          }

          this.triggered = false;
          break;
      }
    }
  };


  /**
   * Transform
   * User want to scale or rotate with 2 fingers
   * @events  transform, pinch, pinchin, pinchout, rotate
   */
  Hammer.gestures.Transform = {
    name: 'transform',
    index: 45,
    defaults: {
      // factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
      transform_min_scale     : 0.01,
      // rotation in degrees
      transform_min_rotation  : 1,
      // prevent default browser behavior when two touches are on the screen
      // but it makes the element a blocking element
      // when you are using the transform gesture, it is a good practice to set this true
      transform_always_block  : false
    },
    triggered: false,
    handler: function transformGesture(ev, inst) {
      // current gesture isnt drag, but dragged is true
      // this means an other gesture is busy. now call dragend
      if(Hammer.detection.current.name != this.name && this.triggered) {
        inst.trigger(this.name +'end', ev);
        this.triggered = false;
        return;
      }

      // atleast multitouch
      if(ev.touches.length < 2) {
        return;
      }

      // prevent default when two fingers are on the screen
      if(inst.options.transform_always_block) {
        ev.preventDefault();
      }

      switch(ev.eventType) {
        case Hammer.EVENT_START:
          this.triggered = false;
          break;

        case Hammer.EVENT_MOVE:
          var scale_threshold = Math.abs(1-ev.scale);
          var rotation_threshold = Math.abs(ev.rotation);

          // when the distance we moved is too small we skip this gesture
          // or we can be already in dragging
          if(scale_threshold < inst.options.transform_min_scale &&
              rotation_threshold < inst.options.transform_min_rotation) {
            return;
          }

          // we are transforming!
          Hammer.detection.current.name = this.name;

          // first time, trigger dragstart event
          if(!this.triggered) {
            inst.trigger(this.name +'start', ev);
            this.triggered = true;
          }

          inst.trigger(this.name, ev); // basic transform event

          // trigger rotate event
          if(rotation_threshold > inst.options.transform_min_rotation) {
            inst.trigger('rotate', ev);
          }

          // trigger pinch event
          if(scale_threshold > inst.options.transform_min_scale) {
            inst.trigger('pinch', ev);
            inst.trigger('pinch'+ ((ev.scale < 1) ? 'in' : 'out'), ev);
          }
          break;

        case Hammer.EVENT_END:
          // trigger dragend
          if(this.triggered) {
            inst.trigger(this.name +'end', ev);
          }

          this.triggered = false;
          break;
      }
    }
  };


  /**
   * Touch
   * Called as first, tells the user has touched the screen
   * @events  touch
   */
  Hammer.gestures.Touch = {
    name: 'touch',
    index: -Infinity,
    defaults: {
      // call preventDefault at touchstart, and makes the element blocking by
      // disabling the scrolling of the page, but it improves gestures like
      // transforming and dragging.
      // be careful with using this, it can be very annoying for users to be stuck
      // on the page
      prevent_default: false,

      // disable mouse events, so only touch (or pen!) input triggers events
      prevent_mouseevents: false
    },
    handler: function touchGesture(ev, inst) {
      if(inst.options.prevent_mouseevents && ev.pointerType == Hammer.POINTER_MOUSE) {
        ev.stopDetect();
        return;
      }

      if(inst.options.prevent_default) {
        ev.preventDefault();
      }

      if(ev.eventType ==  Hammer.EVENT_START) {
        inst.trigger(this.name, ev);
      }
    }
  };

  Hammer.gestures.FTouch = {
    name: 'ftouch',
    index: 0,
    defaults: {},
    handler: function (ev, inst)
    {
      var eType = ev.eventType;
      if (eType === Hammer.EVENT_MOVE)
      {
        inst.trigger(this.name + "move", ev);
      }
      else if (eType === Hammer.EVENT_START)
      {
        inst.trigger(this.name + "start", ev);
      }
      else if (eType === Hammer.EVENT_END)
      {
        inst.trigger(this.name + "end", ev);
      }
    }
  };


/**
 * Release
 * Called as last, tells the user has released the screen
 * @events  release
 */
Hammer.gestures.Release = {
    name: 'release',
    index: Infinity,
    handler: function releaseGesture(ev, inst) {
        if(ev.eventType ==  Hammer.EVENT_END) {
            inst.trigger(this.name, ev);
        }
    }
};

// node export
if(typeof module === 'object' && typeof module.exports === 'object'){
    module.exports = Hammer;
}
// just window export
else {
    window.Hammer = Hammer;

    // requireJS module definition
    if(typeof window.define === 'function' && window.define.amd) {
        window.define('hammer', [], function() {
            return Hammer;
        });
    }
}
})(this);
// script:viewer/lib/jquery.hammer.js
/*
 * special event API with Hammer.JS
 * version 0.9
 * author: Damien Antipa
 * https://github.com/dantipa/hammer.js
 */
(function ($)
{
  var hammerEvents = ['hold', 'tap', 'doubletap', 'transformstart', 'transform', 'transformend', 'dragstart', 'drag', 'dragend', 'swipe', 'release'];

  $.each(hammerEvents, function (i, event)
  {

    $.event.special[event] = {

      setup: function (data, namespaces, eventHandle)
      {
        var $target = $(this),
            hammer;

        if (!$target.hammer)
        {
          hammer = new Hammer(this, data);
          hammer.options.prevent_mouseevents = true;
          hammer.on("touchstart", function (e)
          {
            var tagName = e.target.tagName;
            if (tagName !== "INPUT" && tagName !== "TEXTAREA" && tagName !== "SELECT") e.preventDefault();
          });
          $target.data('hammerjs', hammer);
        }

        hammer = $target.data('hammerjs');

       var h =  hammer['_h' + event] = function (ev)
        {
          $target.trigger($.Event(event, ev));
        };
        hammer.on(event, h);
      },

      teardown: function (namespaces)
      {
        var $target = $(this),
            hammer = $target.data('hammerjs');
        var h = hammer['_h' + event];
        if (hammer && h)
        {
          hammer.off(event, h);
          hammer['_h' + event] = null;
        }
      }
    };
  });
}(jQuery));
// script:viewer/namespace.js
//
// script:viewer/vitrium.js
(function (vitrium)
{
	vitrium.is_mobile = detectmob();
	function detectmob() 
	{ 
		 if( navigator.userAgent.match(/Android/i)
		 || navigator.userAgent.match(/webOS/i)
		 || navigator.userAgent.match(/iPhone/i)
		 || navigator.userAgent.match(/iPad/i)
		 || navigator.userAgent.match(/iPod/i)
		 || navigator.userAgent.match(/BlackBerry/i)
		 || navigator.userAgent.match(/Windows Phone/i)
		 || navigator.userAgent.match(/Tablet PC/i)
		 ){
			return true;
		}
		else 
		{
			return false;
		}
	}
   
	
}(vitrium));

// script:viewer/finite-state-machine.js
(function (exports,_, Backbone)
{
	"use strict";
	exports.FiniteStateMachineDeclaration = FiniteStateMachineDeclaration;
	exports.State = State;
	
	
	function FiniteStateMachineDeclaration()
	{	
		this._counter = 0;
		this._posibleStates = {};
		this._declarations = [];
	}
	
	FiniteStateMachineDeclaration.prototype = {
		declare : function(state, options)
		{
			var id = this.get(state);			
			if (!this._declarations[id])
			{
				options = options || { name : state};
				options.name =	state;
				this._declarations[id] = options;
			
				return id;
			}
			else
			{
				throw new Error("State ["+state+"] is already declared!");
			}
			
		}, 
		name : function(id)
		{      
        return this._declarations[id].name;
		},
		get : function(state)
		{
			var id;
			if (state in this._posibleStates)
			{
				id =  this._posibleStates[state];
			}
			else
			{
				this._posibleStates[state] = id = this._counter++;
			}
			
			return id;
		},
		exists : function(state)
		{
			return state in this._posibleStates;
		},
		assertState : function(newStateId, oldStateId, stateStack, pushed)
		{
			if (!pushed && stateStack.length === 0)
			{
				throw new Error("Initial state must be pushed! [newState:"+ this._declarations[newStateId].name + "]");
			}
			
			if (this._declarations.length <= newStateId)
			{
				throw new Error("State is not declared!");
			}
						
			var decl = this._declarations[newStateId];
			
			if (!_.isUndefined(decl.pushable) )
			{
				if (decl.pushable !== pushed)
				{
					throw new Error("Unallowed operation! [name: "+decl.name+"decl: "+decl.pushable+" pushed: "+pushed+"]");
				}
			}
			
			if (_.isArray(decl.prevIn))
			{
				var  prevIn = decl.prevIn;
				if (prevIn.indexOf(oldStateId) === -1)
				{
					throw new Error("Previous state is not satisfied. [from: "+ this._declarations[oldStateId].name + " to: "+decl.name+"]");
				}
			}
			
			if (_.isArray(decl.notParents))
			{
				var notParents = decl.notParents;
				for (var i = 0, len=notParents.length; i < len; ++i)
				{
					var parent = notParents[i];
					if (stateStack.indexOf(parent) !== -1)
					{
						throw new Error("Parent state is not allowed! [parent: "+this._declarations[parent].name+" to: "+decl.name+"]");
					}
				}
			}
			
			if (_.isArray(decl.directParent))
			{
				var parent = decl.directParent;
				if (stateStack.indexOf(parent) === -1)
				{
					throw new Error("Direct parent not found. [directParent: "+this._declarations[parent].name+" to: "+decl.name+" realParent: "+(stateStack.length > 0 ? this._declarations[stateStack[0]].name : "none")+"]");
				}	
			}
		}
	};
	
	function State(declaration)
	{
		this._declaration = declaration;
		this._stateStack = [];
	}
		
	State.prototype = {
		push : function(stateId)
		{
			var c = this.current();
//
			this._stateStack.push(stateId);
			this.trigger("change", stateId, this);
		},
		has : function(id)
		{
			return this._stateStack.indexOf(id) !== -1;
		},
		pop: function()
		{
			var oldId = this._stateStack.pop();
			this.trigger("change", this.current(), this);
			
			return oldId;
		},
		current : function()
		{
			var st = this._stateStack;
			var l = st.length ;
			return l === 0 ? null : st[l-1];
		},
		change : function (stateId)
		{
			//
			
			var st = this._stateStack;
			var l = st.length ;
			
			st[l-1] = stateId;
			this.trigger("change", stateId, this);
		},
		popTo : function(stateId)
		{
			var st = this._stateStack;
			var i = st.indexOf(stateId);
			
			//
			
			// rewind stack to requested point
			st.length = i+1;
			
			this.trigger("change", stateId, this);
		},
		reset : function(stateId)
		{
			this._stateStack.length = 0;
			this.push(stateId);
		},
		changeState: function(oldId, newId)
		{
			//
			
			var st = this._stateStack;
			var i = st.indexOf(oldId); 
			
			//
			st[i] = newId;
			this.trigger("change", this.current(), this);
		}
	};
	
	_.extend(State.prototype, Backbone.Events);

}(
vitrium,
_,
Backbone
));
// script:viewer/viewer-states.js
(function (exports)
{
"use strict";
	var STATES = exports.STATES = new vitrium.FiniteStateMachineDeclaration();
	
}(
vitrium.viewer
));
// script:viewer/url-path.js
(function (exports, global)
{
  "use strict";
  
	var path = "";
	var scripts = global.document.scripts;
	for (var i = 0, len = scripts.length; i < len;++i)
	{
		var srcAttr = scripts[i].attributes.getNamedItem("src");
		if (srcAttr)
		{
			
			var src = srcAttr.value;
			if (src)
			{
				var srcI = src.indexOf("vitrium-viewer.js");
				if (srcI !== -1)
				{
					path = src.substring(0, srcI);
					break;
				}
				else 
				{
					path = "";
				}
			}
		}
	}
	
	exports.base_path = path;

}(vitrium, __globals__));
// script:viewer/i18n.js
(function (exports, Backbone, _)
{
	var language = null;
	var languageObject = {};
	
	var selectedLanguage = {};
	
	_.extend(exports, Backbone.Events);
	
	var FORMAT_PATTERN = /[{](\d+)[}]/g;
	
	exports.format = function(string, args)
	{
		var len = args.length;
		
		function formatFunction(match, index)
		{
			var idx = parseInt(index, 10);
			if (idx >= len)
			{
				return "?";
			}
			
			return args[idx];
		};
		
		return string.replace(FORMAT_PATTERN, formatFunction);
	};
	
	exports._T = function(key, args)
	{
		var str = selectedLanguage[key];
		if (_.isUndefined(str))
		{
			 str = "?"+key+"?";
			 if (args)
			 {
				 for (var i = 0, len=args.length; i < len;++i)
				 {
					str += (i !== 0 ? ", " : " ") +"{"+i+"}";
				 }
			 }
		}
		
		if (args && args.length > 0 || str.match(FORMAT_PATTERN))
		{
			return exports.format(str, args);
		}
		else
		{
			return str;
		}
	};
	
	exports._TG = function(key, gen,  args)
	{
		if (!_.isArray(gen))
		{
			gen = [gen];
		}
		
		var str;
		var newKey;
		do
		{
			newKey = gen.length === 0 ? key : key + "-"+gen.join("-");
			gen.pop();
			str = selectedLanguage[newKey];
		}
		while(_.isUndefined(str) && newKey !== key); 
		
		return exports._T(newKey, args);
	};
	
	exports.setLanguage = function (id)
	{
		var lang = languageObject[id];
		
		if (lang && selectedLanguage !== lang)
		{
			selectedLanguage = lang;
			exports.trigger("language:changed", exports);
		}
		else if (!lang)
		{
			throw new Error("There is no such language ID ("+id+")");
		}
	}
	exports.addToLocalization = function (id, newLanguageObject)
	{
		
		var empty =_.isEmpty(languageObject);
				
		if (!empty && languageObject[id])
		{
			_.extend(languageObject[id], newLanguageObject);
		}
		else
		{
			languageObject[id] = newLanguageObject;
		}
		
		if (empty)
		{
			exports.setLanguage(id);		
		}
	};
	

	
}(
vitrium.i18n, 
Backbone,
 _));
// script:localization-en.js
vitrium.i18n.addToLocalization("en", {
  "ui-zoom-in": "Zoom in",
  "ui-zoom-out": "Zoom out",
  "ui-zoom-fit-to-window": "Fit to window",
  "ui-next-page": "Next page",
  "ui-previous-page": "Previous page",
  "ui-page-count": "<span class='page-count-info-of'>of&nbsp;</span>{0}",
  "ui-search": "Search",
  "ui-search-tooltip": "Search [Ctrl + F]",
  "ui-search-next": "Search forward [Enter]",
  "ui-search-prev": "Search backward [Ctrl + Enter]",
  "btn-close" : "Close",
  "btn-cancel" : "Cancel",
  
  "ui-search-document-end-reached-title": "The end of document",
  "ui-search-document-end-reached": "The end of document has been reached. Do you want to continue from beginning?",
  "ui-search-document-end-start-btn-title" : "Continue from beginning [Enter] " ,
  "ui-search-document-end-start-btn-label": "Continue" ,
  "ui-search-document-end-cancel-btn-title": "Cancel [Esc]",
  "ui-search-document-end-cancel-btn-label": "Cancel",
   
  "ui-search-document-beg-reached-title": "The beginning of document",
  "ui-search-document-beg-reached": "The beginning of document has been reached. Do you want to continue from end?",
  "ui-search-document-beg-start-btn-title" : "Continue from end [Enter] " ,
  "ui-search-document-beg-start-btn-label": "Continue" ,
  "ui-search-document-beg-cancel-btn-title": "Cancel [Esc]",
  "ui-search-document-beg-cancel-btn-label": "Cancel",
  "ui-search-close": "Close search [Esc]",
  "ui-search-in-progress-title" : "Searching...",
  "ui-search-in-progress" : "Searching is in progress, please wait.",
  "ui-search-completed-title" : "Search completed",
  "ui-search-completed" : "Search has been finished.",
  "message-font-substitution-unspecified": "The following embedded fonts will be substituted because they cannot be extracted and some characters or text position may not display correctly: {0}",
  "message-font-substitution-license": "Due to font licensing restrictions, the following fonts will be substituted and some characters or text position may not display correctly: {0}",
   
  "server-error-message" : "An error occurred while loading the document. Please try again. If the problem persists, contact your System Administrator.",
  "server-error-message-title" : "Error loading document",
  "server-error-button-title" : "Try again",
  
  "server-error-message-404": "Document failed to load. Please try again in a few minutes. If the problem persists, please contact your System Administrator.",
  
  "server-error-message-401": "Access to view this document is denied and any local copies have been removed. If the problem persists, please contact your System Administrator.",
  "server-error-message-title-401": "Access denied",
  "server-error-button-title-401": "Try again",

  "server-error-message-403": "Proceed to Single Sign On authentication ...",
  "server-error-message-title-403": "Single Sign On Authentication",
  "server-error-button-title-403": "Continue",
  
  "server-error-message-410": "Document has been deleted.",
  "server-error-message-title-410": "Document deleted",
  "server-error-button-title-410": "Try again",
  
  "web-viewer-updated-title" : "Application updated",
   "web-viewer-updated" : "A new version of this application has been loaded.",
   "web-viewer-updated-button" : "Proceed",
   
  "message-cannot-load-pages": "The following pages could not be loaded: {0}",
  "message-cannot-load-page": "This page cannot be displayed. Scroll up or down to view other pages in this document.",
  "message-document-updated": "A newer version of this document has been loaded.",
  "message-document-updated-previous-copy-deleted" : "A new version of this document has been loaded and the out-of-date saved version was removed. Would you like to save the new version?",  
  "document-updated-dont-save-button" : "Cancel",
  "document-updated-save-button" : "Save",
  
  "message-document-updated-title": "Document reloaded",
  "unknown" : "An error has occured. Please try again.",
  
  "ui-tools-menu-title" : "Tools",
  "ui-tools-save-document-offline" : "Save document to cache for offline use ({0})",
  "ui-tools-document-is-offline" : "Delete saved copy of this document",
  "ui-tools-manage-saved-documents" : "Manage saved documents",
  "ui-tools-saved-documents-title" : "Saved documents",
  "ui-tools-clear-cache" : "Clear cache {0}",
  "ui-tools-about" : "About",
  "ui-tools-downloading"  : "Downloading",
  "ui-tools-downloading-cancel"  : "Cancel",
  "ui-tools-download-completed"  : "Download completed",
  "ui-tools-download-failed"  : "Download failed",
  "ui-tools-download-failed-message"  : "The document could not be saved for offline use. Most likely the amount of data your web browser can store on this computer has been exceeded. Please delete unused documents, refresh this webpage and try again.",
  "ui-tools-download-close"  : "Close",
  "ui-tools-open": "Open document",
  
  "about-title" : "About",
  "about-send-feedback-button": "Send feedback",
  "send-feedback-title": "Send feedback",
  "send-feedback-subject" : "Feedback",
  "send-feedback-problem-description" : "Problem description:",  
  "send-feedback-system-information" : "System information:",
  
  "send-feedback-feedback-label" : "Tell us what is happening. (required)",
  "send-feedback-email-label" : "Email",
  "send-feedback-email-placeholder" : "Email (optional)",
  "send-feedback-problem-text" : "If your Email client application did not popped up. Please send the message bellow to the address: <a href='mailto:{0}'><strong>{0}</strong></a>.",
  "send-feedback-connection-error" : "There is a problem while sending your feedback. Check your Internet connection first. ",
  
  "delete-current-document-title" : "Delete saved copy of this document", 
  "delete-current-document-question" : "Do you really want to delete the saved copy of this document from your computer? The online version of this document will be used instead.",
  
  "box-unauthorized-title": "Login required",
  "box-unauthorized-message": "You've lost your privileges to view this document. If you have downloaded this document to your device than it has been deleted. ",
  "box-unauthorized-button": "Proceed to login",
  "menu-close" : "Close",
  "fs-close" : "Close",
  "fs-mode-edit" : "More options",
  "fs-mode-view" : "Hide options",
  "fs-action-create-folder-title" : "Create folder",
  "fs-action-create-folder-label" : "Folder name",
  "fs-action-create-folder-help" : "Type a name of the new folder. Folder name must be unique.",
  "fs-action-err-empty" : "Data for this field is required.",
  "fs-action-err-invalid" : "This field contains an invalid entry.",
  "fs-cancel" : "Cancel",
  "fs-action-item-delete-title" : "Delete",
  "fs-action-item-rename-title" : "Rename",
  "fs-action-item-move-title" : "Move",
  "fs-action-item-move-dialog-title" : "Move: {0}",
  "fs-action-item-rename-label" : "New document title",
  "fs-action-item-rename-help" : "Type a new item name.",
  "fs-action-item-delete-question" : "Are you sure you want to delete \"{0}\"?",
  "fs-action-item-move-to" : "Move",
  "fs-action-doItemRename-success": "The document has been renamed.",
  "fs-action-doItemDelete-success": "The document has been deleted.",
  "fs-action-doCreateFolder-success" : "The folder has been created.",
  "fs-action-doItemMove-success" : "The document has been moved.",
  "fs-empty-folder": "This folder is empty",
  "ui-tools-qr-share" : "Display document QR code ",
  "qr-share-title" : "Document QR code",
  "fs-action-failed" : "Action failed.",
  "message-cache-is-disabled" : "Saving documents offline is not available. Your browser may not support this feature, there may be a network connection problem or you may be browsing with privacy settings enabled.",
  "message-download-successful":"The document has been successfully downloaded and is available for viewing offline by visiting this page again. You may bookmark this page for your convenience.",
  "document-author-label" : "Author",
  "document-pages-label" : "Pages",
  "document-size-label" : "Storage space",
  "document-saved-label" : "Saved on",
  "err-folder-already-exists" : "A folder with the same name already exists.",
  "web-viewer-deleted-expired-document-title" : "Offline use expired",
  "web-viewer-deleted-expired-document" : "Offline use of this document has expired. Locally saved copy of this document has been deleted.",
  "web-viewer-deleted-expired-document-button" : "Proceed",
  "message-documents-erased-title": "Off-line data deleted",
  "message-documents-erased": "Your off-line accessible documents has been deleted from your computer.",
  "web-viewer-service-unable-to-connect-title" : "Service connection error",
  "web-viewer-service-unable-to-connect": "Communication with server failed. Some features will be disabled.",
  "highlight-panel-title": "Highlighting",
  "notes-panel-title": "Notes",
  "thumbnails-panel-title": "Thumbnails",
  "bookmarks-panel-title": "Bookmarks",
  "text-selection-done": "Done",
  "text-selection-highlight": "Highlight",
  "note-page": "Page:",
  "note-form-title-new": "New note",
  "note-text-label": "Note:",
  "note-form-validation-empty-note": "Please enter your note.",
  "note-cancel-label" : "Cancel",
  "note-save-label": "Save",
  "note-form-title-edit": "Edit note",
  "tool-null": "Read mode",
  "tool-note": "Create note",
  "tool-eraser": "Delete annotation",
  "tool-freehighlight": "Draw free shape",
  "tool-texthighlight": "Highlight selected text",
  "tool-undo": "Undo",
  "tool-repeat": "Redo",
  "selected-tool-note": "Click the page to create a note",
  "selected-tool-eraser": "Click the annotation to delete it",
  "selected-tool-freehighlight": "Press mouse button on the page to start drawing",
  "selected-tool-texthighlight": "Select text on the page to highlight it",
  "side-panel-close": "Close",
  "sync-display-error-desktop": "Annotations are not synchronized. Click the bubble to try it again.",
  "sync-display-error-mobile": "Annotations are not synchronized. Tap the bubble to try it again."
  

});
// script:viewer/browser-compatibility-detection.js
(function(exports, fonts, Modernizr, globals, $)
{
	"use strict"
	var tests = {};
	var document = globals.document;
		
	declare("canvas-woff-support", function(callback)
	{
		if (Modernizr.fontface && Modernizr.canvas)
		{
			var uaString = globals.navigator.appVersion;
			var skipTestAsSuccessful =  false;
			
			uaString.replace(/.*Trident\/(\d+)\..+/g, function(string, version){ 
				skipTestAsSuccessful = parseInt(version) >= 7;
			});
			
			if (!skipTestAsSuccessful&& $.browser.chrome)
			{
				uaString.replace(/.*Chrome\/(\d+)\..+/g, function(string, version){ 
					skipTestAsSuccessful = parseInt(version) >= 19;
				});
			}
			
			if (!skipTestAsSuccessful && $.browser.safari)
			{
				uaString.replace(/.*Version\/(\d+)\..+/g, function(string, version){ 
					skipTestAsSuccessful = parseInt(version) >= 5;
				});
			}
			
			if (!skipTestAsSuccessful && $.browser.firefox)
			{
				uaString.replace(/.*Firefox\/(\d+)\..+/g, function(string, version){ 
					skipTestAsSuccessful = parseInt(version) >= 18;
				});
			}
		
			if (!skipTestAsSuccessful)
			{
				fonts.load({
					fonts : [{ 
						key : "vitriumtestfont",
						data : "data:application/x-font-woff;base64,d09GRk9UVE8AAARUAAsAAAAABnwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABDRkYgAAABCAAAAOQAAADuK8RPXEZGVE0AAAHsAAAAHAAAABxo/hdsR0RFRgAAAggAAAAYAAAAHgAPAB5PUy8yAAACIAAAAEkAAABgO7tMumNtYXAAAAJsAAAANAAAAUIADeimaGVhZAAAAqAAAAAwAAAANv/r7JhoaGVhAAAC0AAAAB4AAAAkBxsEDGhtdHgAAALwAAAACAAAAAgH0AAnbWF4cAAAAvgAAAAGAAAABgACUABuYW1lAAADAAAAATwAAAJhF6X02nBvc3QAAAQ8AAAAFgAAACD/hgAzeJxjZGBhYWBkZOQKzSvJLMlJTTFkYGRiYGTQ/cHP8EOG8Ycs0w855h/iLD08jJvW/Ar9OYVVhmEhvwwDg4AMwxJBGQYg874QAwtICweDDYMrg19pXqarmYGBc1FqYklqikJ5ZkmGglt+XolbflF6qoKRnoGCRkZJSYGVvn4aUDQNJKpXnKaXl1qiCXcDwjEMDIztDEyMjEpm3Xt/uO5l3Lv355a9zHvFfkn8WPlPgm3vn3LRH64/t/xxZedb87OY8T+DegPDzymif4t/6f4sZuf7VSPSLdrNw/WzGIh4eACGsE9jAAAAAQAAAADMF3JjAAAAAM5zUUoAAAAAznNTvnicY2BkgAA+BjEgyQLETEDMCMEAA18ALnicY2BhfsH4hYGVgYGpi2k3AwNDD4RmvM9gyMgEFGVg42RAASxQOiDNNYXhwDOGZwzMCv8tGKKYGf7fBwozwhUqACEjAM0BDfMAAAB4nGNgYGBmgGAZBkYGELAB8hjBfBYGBSDNAoRA/jOG//8hpBQjVCUDIxsDjDliAQAoVwaZeJxjYGRgYADiHP5Ww3h+m68M3MwvgCIM54pDPOG0OoMi8wFmEJeDgQlEAQAEOgideJxjYGRgYGZgUGSIYn7BAATMBxgYGVABEwAzZwIxAAAD6AAAA+gAJwAAUAAAAgAAeJyFkLFOwzAURa/bNFIlhFA/AHlBKkNdJ2HKWpQBiZGKtShOY1SSKnXVH+AXmJlZWJj5Aja+iJvUqoSQaKy8d9718/OVAZziHQL77wqPngWG+PDcQ4gvz31ciHPPAYbi3vMAZ+LZc0j9jZ0iGLIqu1MtC4zw6rmHE3x67uMG354DjMS15wGkePAcUn/BDA0MFnCMOSR2sOSSlKFGRW5zgyX3JWIoaOYxOxzXGimmXIXvLQ69ChtWiqqhfgnMGrNwJpc760qZ1ZXL6mZpZKy0HJfOrdPptKBatKraFKoyjqfuurGtpVVnMKJUOetWJifedprFFk8sTG63zP/5Tvn/HbnXE0zImjFmjFjjt81UHq4mJ5NIT2IdJcdMzqk1fA3b+ZKc3U5XXW49YW6aja0rqXWktNbyyMAf9fhlOHicY2BmAIP/zQxGQIqRAQ0AAChVAbkAAA=="
						}],
					timeout : 1000,
					checkInterval  : 16,
					additionalCharacters : "\uE600",
					noASCII : true,
					//FIXME would be better to have an actual error callback :-/
					success: fontLoadCallback,
					error : fontLoadCallback
				});
			}
			else
			{
				setTimeout(function(){callback(true);}, 0);
			}
		}
		else
		{
			setTimeout(function(){callback(false);}, 0);
		}	
		
		function fontLoadCallback()
		{
			var testCanvas = document.createElement("canvas");
		
			var w = testCanvas.width = 100;
			var h = testCanvas.height = 100;
					
			var ctx = testCanvas.getContext("2d");
					
			ctx.fillStyle = "white";
			ctx.fillRect(0,0, w, h);
			
			ctx.fillStyle = "black";
			ctx.font = h+"px vitriumtestfont";
			ctx.fillText("\uE600",0,h);
			fonts.free();
			//console.log(testCanvas.toDataURL());
			
			var imgData = ctx.getImageData(0, 0, w, h);
					
			var c = w/2;
			var r = h/2;
			var pixelIndex = ((r*w)+c)*4;
			
			var data = imgData.data;
			//rgba
			callback(data[pixelIndex] === 0 && data[pixelIndex+1] === 0 && data[pixelIndex+2] === 0 && data[pixelIndex+3] === 255); 
		}
	});
		
	exports.require = function(features, success, error)
	{
		
		var i = 0,len=features.length;
		for ( ; i < len; ++i)
		{
			var feature = features[i];
			tests[feature](callback);
		}
		
		var isOk = true;
		function callback(testOk)
		{
			isOk = isOk && testOk;
			--i;
			
			if (i === 0 && isOk)
			{
				success();
			}
			else if (i === 0)
			{
				error();
			}
		}
	};
	
	function declare(feature, testfunction, async)
	{
		testfunction["async"] = true;
		exports[feature.toUpperCase()] = feature;
		tests[feature] = testfunction;
	}

}(vitrium, vitrium.fonts, Modernizr, __globals__, $));
// script:viewer/task-scheduler.js
(function (exports, _)
{
"use strict";

var MAX_STEPS = 1000000;
var SCHEDULE_NEXT_STEP_DELAY = 0;
var CHECK_DURATION_EACH_STEP = 50;
var MS_PER_FRAME = 1000/60;
var MAX_STEP_DURATION = 100;

 function TaskScheduler(master)
 {
  this.tasks = []; 
  this.active = false;
  this.master = master;
  
  this.lastTime = null;
  
  this.delayed = false;
  this.currentTask = null;
  
  this.lastFrame = Date.now();
  this.paused = false;
 }
 
 TaskScheduler.prototype = {
  filter : function(predicate)
  {
    this.tasks = _.filter(this.tasks, predicate);
  },
  pause : function()
  {
    this.paused = true;
  },
  resume : function()
  {
    this.paused = false;
    this.delayed = true;
  },	
  execute : function()
  {
    if (!this.active && !this.paused)
    {
      exports.globalTaskScheduler = this;
      this.lastTime = Date.now();
      this.delayed = false;
      //console.log("execute");
      this.active = true;
      var s = 0;
      var current = null;
      var tasks = this.tasks;
      var delayed = false;
      do
      {
        ++s;
        this.currentTask = current = tasks.shift();
        if (current)
        {
          while (!delayed && current.semaphore === 0 && !current.done)
          {
            ++s;
            current.step();
            
            delayed = this.hasDelayedExecution(s);
          }
          
         
        }
              
      } 
      while (!delayed && current);
      
      if (delayed)
      {
        tasks.push(current);
        this.delayed = true;
      }
      this.currentTask  = null;
      this.active = false;		
    }
  },
  hasDelayedExecution : function(step)
  {
     if (step > MAX_STEPS)
     {
     
        return true;
     }
     else
     {
        var durationCheck = step % CHECK_DURATION_EACH_STEP;
        if (durationCheck === 0)
        {
           var lastTime = this.lastTime;
           var currentTime = Date.now();
           var diff = currentTime - lastTime;
           if ( diff >= MAX_STEP_DURATION)
           {
             this.lastTime = currentTime;
             var sinceLastFrame = currentTime - this.lastFrame;
             var lostFrames = ((sinceLastFrame) / MS_PER_FRAME)|0;
            
              var p = (this.lastFrame + (MS_PER_FRAME*lostFrames)+MS_PER_FRAME) - currentTime;
              var delay = Math.max(p,SCHEDULE_NEXT_STEP_DELAY);
          
             return true;
           }
        }
     }

      return false;
  },
  addTask: function(task)
  {
    this.tasks.push(task);
    this.master.refresh();
  }, 
  markFrame : function()
  {
    this.lastFrame = Date.now();
    //this.execute();
  }
 };
 
 function Task()
 {
 //it does not mean successfully 
  this.done = false;
  this.semaphore = 0;
  this.parentTask = null;
  
  // this is for task filtering
  this.page = null;
  // concrete task must step to done in next step
  this.interrupted = false;
 }
 
 Task.prototype = {
  wait : function()
    {
    ++this.semaphore;
    // console.log("["+this._id()+"] wait: "+this.semaphore);
    },
   post : function()
   {
     if(this.semaphore === 0)
     {
      throw new Error("Unbalanced use of semaphore!!!");
     }
     --this.semaphore;

     if (this.semaphore === 0)
     {
       exports.globalTaskScheduler.addTask(this);
     }
     //console.log("["+this._id()+"] post: "+this.semaphore);
  },
  interrupt : function()
  {
    this.interrupted = true;
  }
 };
 
 exports.Task = Task;
 exports.TaskScheduler = TaskScheduler;
 
 exports.globalTaskScheduler = null;
 
 
}
(
vitrium,
_
));
// script:viewer/geometry.js
/// <reference path="~/build.html" />

(function (exports)
{
  "use strict"
  exports.Point = Point;
  exports.Matrix = Matrix;
  /**
    @class Point 
  */
  function Point(x, y)
  {
    this.x = x;
    this.y = y;
  }
    
  Point.prototype = {
    relativeTo : function(p)
    {
      this.x += p.x;
      this.y += p.y;
      return this;
    },	
    subs : function(p)
    {
      this.x -= p.x;
      this.y -= p.y;
      return this;
    },
    rotateClockwise : function(ang)
    {
      var cosa = Math.cos(ang), sina = Math.sin(ang);
      var t = this.x; 
      this.x = t*cosa + this.y*sina; this.y = -t*sina + this.y*cosa;
      return this;
    },
    rotateClockwiseF : function(ang, cos, sin)
    {
      var cosa = cos(ang), sina = sin(ang);
      var t = this.x; 
      this.x = t*cosa + this.y*sina; this.y = -t*sina + this.y*cosa;
      return this;
    },	
    clone : function()
    {
      return new Point(this.x, this.y);
    },
    assign : function(p)
    {
      this.x = p.x;
      this.y = p.y;
      return this;
    },
    distance : function(p)
    {
      var dx = this.x - p.x;
      var dy = this.y - p.y;
      
      return Math.pow(dx*dx + dy*dy, 1/2);
    },
    equals : function(p)
    {
      return this.x === p.x && this.y === p.y;
    }
  };
  
  Point.prototype.add = Point.prototype.relativeTo; 
  
  /**
     @class Matrix
  */
  
  /**
    a c e
    b d f
    0 0 1
  */
  function Matrix(a, b, c, d, e, f)
  {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f  = f;
   
  }
  
  Matrix.identity = function()
  {
    return new Matrix(1,0,0,1,0,0);
  };
  
  Matrix.fromXPS = function(transform)
  {
    var t = transform.split(",");
    //return new Matrix(parseFloat(t[0]), parseFloat(t[2]), parseFloat(t[1]), parseFloat(t[3]), parseFloat(t[4]), parseFloat(t[5]));
    return new Matrix(parseFloat(t[0]), parseFloat(t[1]), parseFloat(t[2]), parseFloat(t[3]), parseFloat(t[4]), parseFloat(t[5]));
  };

  /**
    a c e     ma 	mc  	me     a*ma + c *mb + e*0		a*mc + c * md + e *0		a * me + c *mf + e*1
    b d f  *  mb	md 	mf  =  b *ma + d*mb + f*0		b*mc + d * md + f * 0		b * me + d *mf + f *1
    0 0 1     0    	0    	0        0*ma + 0*mb + 0*0		0*mc + 0*md + 0*0		0* me + 0 *mf + 1 *1
  */
  
  Matrix.prototype.multiply = function(m)
  {
    return new Matrix(
      this.a*m.a+this.c*m.b,
      this.b*m.a+this.d*m.b,  
      this.a*m.c+this.c*m.d,
      this.b*m.c +this.d *m.d,
      this.a*m.e + this.c*m.f + this.e,
      this.b*m.e + this.d*m.f + this.f);
  };
  
  Matrix.prototype.multiplyPoint = function(m)
  {
    /**
      a	c	e		x 		a*x + c *y	+ e*1
      b	d	f	*	y  =  b*x +  d*y	+ f *1
      0	0	1		1		0*x +  0*y + 1*1
      */
    return new Point(this.a * m.x + this.c * m.y + this.e, this.b * m.x + this.d*m.y + this.f);
  };
  
  Matrix.prototype.inPlaceMultiplyPoint = function(m)
  {
    /**
      a	c	e		x 		a*x + c *y	+ e*1
      b	d	f	*	y  =  b*x +  d*y	+ f *1
      0	0	1		1		0*x +  0*y + 1*1
      */
    var x = this.a * m.x + this.c * m.y + this.e;
    var y = this.b * m.x + this.d*m.y + this.f;
    m.x = x;
    m.y = y;
    return m;
  };
  
  
  Matrix.prototype.transform = function(ctx)
  {
    ctx.transform(this.a, this.b, this.c, this.d, this.e, this.f);
  };
  
  Matrix.prototype.getScale = function()
  {
    var sqrt = Math.sqrt;
    var pow = Math.pow;
    
    return new Point(sqrt(pow(this.a, 2) + pow(this.b, 2)), sqrt(pow(this.c, 2) + pow(this.d, 2)));
  };
  
  Matrix.prototype.getRotation = function()
  {		
    return Math.atan2(this.c/this.d);
  };
  
  
  Matrix.prototype.inverse = function()
  {
    var a11 = this.a;
    var a21 = this.b;
    var a31 = 0;
    
    var a12 = this.c;
    var a22 = this.d;
    var a32 = 0;
    
    var a13 = this.e;
    var a23 = this.f;
    var a33 = 1;
    
    var det11 =  det2x2(a22, a23, a32, a33);
        
    var inverseDetA = 1/((a11 * det11)- (a12*det2x2(a21,a23,a31,a33)) + (a13*det2x2(a21,a22,a31,a31)));
    
    var b11 = det11;
    var b12 = det2x2(a13,a12,
                  a33, a32);
  
    var b13 = det2x2(a12,a13,
                  a22, a23);
    
    var b21 = det2x2(a23,a21,
                   a33,a31);
                   
    var b22 = det2x2(a11,a13,
                   a31,a33);
                   
    var b23 = det2x2(a13,a11,
                    a23,a21);
    
    var b31 = det2x2(a21, a22,
                   a31, a32);
                   
    var b32 = det2x2(a12, a11,
                  a32, a31);
                  
    var b33 = det2x2(a11, a12,
                  a21, a22);
                  
    return new Matrix(inverseDetA * b11, inverseDetA*b21, inverseDetA*b12,  inverseDetA*b22, inverseDetA*b13, inverseDetA*b23);	
  };
  
  function det2x2(a11, a12, a21, a22)
  {
    return a11*a22 - a21*a12;
  }

  Matrix.prototype.toString = function()
  {
    return this.a + "\t" + this.c +"\t"+this.e+"\n"+this.b+"\t"+this.d+"\t"+this.f+"\n0\t0\t1";
  };
  
}(vitrium.geometry));
// script:viewer/geometry-rectangle.js
/// <reference path="~/build.html" />

(function (exports, geometry)
{
  "use strict";

  exports.Rectangle = Rectangle;
  exports.DataRectangle = DataRectangle;
  /**
    Rectangle supports unified way how to manipulate with rectangles in viewer
  */
  function Rectangle(x, y, width, height, angle)
  {
    this.x = x;
    this.y = y;
    this.w = width;
    this.h = height;
    this.a = angle;
  }

  Rectangle.createFromCoordinates = function (x1, y1, x2, y2)
  {
    /// <returns type="Rectangle">Normalized rectanble</returns>

    var rx1, rx2, ry1, ry2;
    
    // normalize
    if (x1 > x2) { rx1 = x2; rx2 = x1; }
    else { rx1 = x1; rx2 = x2; };

    if (y1 > y2) { ry1 = y2; ry2 = y1; }
    else { ry1 = y1; ry2 = y2; }
    
    return new Rectangle(rx1, ry1, rx2 - rx1, ry2 - ry1, 0);
  };
  
  /*
  Registry values isIntersectedFast
  */
  var tmp0 = new geometry.Point(0, 0);
  var tmp1 = new geometry.Point(0, 0);
  var tmp2 = new geometry.Point(0, 0);
  var tmp3 = new geometry.Point(0, 0);
  var tmp4 = new geometry.Point(0, 0);
  var tmp5 = new geometry.Point(0, 0);
  var tmp6 = new geometry.Point(0, 0);
  var tmp7 = new geometry.Point(0, 0);
  var tmp8 = new geometry.Point(0, 0);

  Rectangle.prototype = {
    init : Rectangle,
    clone: function ()
    {
      return new Rectangle(this.x, this.y, this.w, this.h, this.a);
    },
    assign : function(other)
    {
      this.x = other.x;
      this.y = other.y;
      this.w = other.w;
      this.h = other.h;
      this.a = other.a;
    },
    intersectWithZeroAngle : function(other)
    {
      /// <param name="other" type="Rectangle"></param>
      /// <returns type="Rectangle" mayBeNull="true">The intersection area</returns>

      if (this.isIntersected(other) && this.a === 0 && other.a === 0)
      {
        var tx2 = this.x + this.w;
        var ty2 = this.y + this.h;

        var otx2 = other.x + other.w;
        var oty2 = other.y + other.h;

        var min = Math.min;
        var max = Math.max;

        var x = max(this.x, other.x);
        var y = max(this.y, other.y);
        var x2 = min(tx2, otx2);
        var y2 = min(ty2, oty2);

        return new Rectangle(x, y, x2 - x, y2 - y, 0);
      }
      else
      {
        return null;
      }
    },
    isWrapping : function(other)
    {
      return this.x <= other.x && this.y <= other.y && (this.x + this.w) >= (other.x + other.w) && (this.y + this.h) >= (other.y + other.h);
    },
    getCenterPoint : function()
    {
      /// <returns type="geometry.Point">Center of a rectangle</returns>
      return new geometry.Point(this.x + this.w / 2, this.y + this.h / 2);
    },
    getEndPoint : function()
    {
      /// <returns type="geometry.Point"></returns>
      return new geometry.Point(this.x + this.w, this.y + this.h);
    },
    getStartPoint : function()
    {
      /// <returns type="geometry.Point"></returns>
      return new geometry.Point(this.x, this.y);
    },
    move : function(x, y)
    {
      this.x += x;
      this.y += y;
    },
    isPointIn : function(point)
    {
      var x = point.x;
      var y = point.y;

      return x >= this.x && x <= (this.x + this.w) && y >= this.y && y <= (this.y+this.h);
    },
    isIntersected: function (other)
    {
      return this.isIntersectedFast(other, Math.cos, Math.sin);
    },
    isIntersectedFast: function (other, cos, sin)
    {
      var rr1C = tmp0, rr1S = tmp1,
          rr2C = tmp2, rr2S = tmp3;

      this.fillCenterVectors(rr1C, rr1S);
      other.fillCenterVectors(rr2C, rr2S);

      var A = tmp4, B = tmp5,   // vertices of the rotated rr2
      C = tmp6,      // center of rr2
      BL = tmp7, TR = tmp8; // vertices of rr2 (bottom-left, top-right)

      var ang = this.a - other.a, // orientation of rotated rr1
           cosa = cos(ang),           // precalculated trigonometic -
           sina = sin(ang);           // - values for repeated use

      var t, x, a;      // temporary variables for various uses
      var dx;           // deltaX for linear equations
      var ext1, ext2;   // min/max vertical values

      // move rr2 to make rr1 cannonic
      C.assign(rr2C);
      C.subs(rr1C);

      // rotate rr2 clockwise by rr2->ang to make rr2 axis-aligned
      C.rotateClockwiseF(ang, cos, sin);

      // calculate vertices of (moved and axis-aligned := 'ma') rr2
      BL.assign(C);
      TR.assign(C);

      BL.subs(rr2S);
      TR.add(rr2S);

      // calculate vertices of (rotated := 'r') rr1
      A.x = -rr1S.y * sina; B.x = A.x; t = rr1S.x * cosa; A.x += t; B.x -= t;
      A.y = rr1S.y * cosa; B.y = A.y; t = rr1S.x * sina; A.y += t; B.y -= t;

      t = sina * cosa;

      // verify that A is vertical min/max, B is horizontal min/max
      if (t < 0)
      {
        t = A.x; A.x = B.x; B.x = t;
        t = A.y; A.y = B.y; B.y = t;
      }

      // verify that B is horizontal minimum (leftest-vertex)
      if (sina < 0) { B.x = -B.x; B.y = -B.y; }

      // if rr2(ma) isn't in the horizontal range of
      // colliding with rr1(r), collision is impossible
      if (B.x > TR.x || B.x > -BL.x) return 0;

      // if rr1(r) is axis-aligned, vertical min/max are easy to get
      if (t == 0) { ext1 = A.y; ext2 = -ext1; }
        // else, find vertical min/max in the range [BL.x, TR.x]
      else
      {
        x = BL.x - A.x; a = TR.x - A.x;
        ext1 = A.y;
        // if the first vertical min/max isn't in (BL.x, TR.x), then
        // find the vertical min/max on BL.x or on TR.x
        if (a * x > 0)
        {
          dx = A.x;
          if (x < 0) { dx -= B.x; ext1 -= B.y; x = a; }
          else { dx += B.x; ext1 += B.y; }
          ext1 *= x; ext1 /= dx; ext1 += A.y;
        }

        x = BL.x + A.x; a = TR.x + A.x;
        ext2 = -A.y;
        // if the second vertical min/max isn't in (BL.x, TR.x), then
        // find the local vertical min/max on BL.x or on TR.x
        if (a * x > 0)
        {
          dx = -A.x;
          if (x < 0) { dx -= B.x; ext2 -= B.y; x = a; }
          else { dx += B.x; ext2 += B.y; }
          ext2 *= x; ext2 /= dx; ext2 -= A.y;
        }
      }

      // check whether rr2(ma) is in the vertical range of colliding with rr1(r)
      // (for the horizontal range of rr2)
      return !((ext1 < BL.y && ext2 < BL.y) ||
         (ext1 > TR.y && ext2 > TR.y));

    },
    fillCenterVectors: function (C, S)
    {
      var sX = this.w / 2;
      var sY = this.h / 2;
      //center vector, orientated within the world. basically this will be the x,y value plus half the width and half the height
      C.x = this.x + sX;
      C.y = this.y + sY;
      //side vector, orientated locally, this will be half the width and half the height
      S.x = sX;
      S.y = sY;
    },
    toString : function()
    {
      return "x=" + this.x + " y=" + this.y + " w=" + this.w + " h=" + this.h;
    },
    equals : function(other)
    {
      if (!other) return false;
      return this.x === other.x && this.y === other.y && this.w === other.w && this.h === other.h && this.a === other.a;
    }
  };

  function DataRectangle(x, y, width, height, angle, data)
  {
    Rectangle.call(this, x, y, width, height, angle);
    this.d = data;
  }
  DataRectangle.prototype = Object.create(Rectangle.prototype);
  DataRectangle.prototype.init = DataRectangle;
  DataRectangle.prototype.assign = function (other)
  {
    Rectangle.prototype.assign.call(this, other);
    this.d = other.d;
  };

  DataRectangle.prototype.clone = function ()
  {
    return new DataRectangle(this.x, this.y, this.w, this.h, this.a, this.d);
  };

  
}
(vitrium.geometry2, vitrium.geometry));

// script:viewer/geometry-simplify-path.js
/// <reference path="~/build.html" />

(function (exports)
{
  "use strict";
  exports.simplifyPath = simplifyPath;

  function Line(p1, p2)
  {
    this.p1 = p1;
    this.p2 = p2;
  };
  Line.prototype._helper = [0, 0, 0];
  Line.prototype.distanceToPoint = function (point)
  {
    // slope
    var m = (this.p2.y - this.p1.y) / (this.p2.x - this.p1.x),
      // y offset
      b = this.p1.y - (m * this.p1.x),
      d = this._helper;
    // distance to the linear equation
    d[0] = Math.abs(point.y - (m * point.x) - b) / Math.sqrt(Math.pow(m, 2) + 1);
    // distance to p1
    d[1] = Math.sqrt(Math.pow((point.x - this.p1.x), 2) + Math.pow((point.y - this.p1.y), 2));
    // distance to p2
    d[2] = Math.sqrt(Math.pow((point.x - this.p2.x), 2) + Math.pow((point.y - this.p2.y), 2));
    // return the smallest distance
    return d.sort(function (a, b)
    {
      return (a - b); //causes an array to be sorted numerically and ascending
    })[0];
  };


  function simplifyPath(points, tolerance)
  {
    if (points.length > 2)
    {
      var arr = douglasPeucker(points, tolerance);
      // always have to push the very last point on so it doesn't get left off
      arr.push(points[points.length - 1]);
      return arr;
    }
    else
    {
      return points;
    }
  };

  function douglasPeucker(points, tolerance)
  {
    if (points.length <= 2)
    {
      return [points[0]];
    }
    var returnPoints = [],
      // make line from start to end 
      line = new Line(points[0], points[points.length - 1]),
      // find the largest distance from intermediate poitns to this line
      maxDistance = 0,
      maxDistanceIndex = 0,
      p;
    for (var i = 1; i <= points.length - 2; i++)
    {
      var distance = line.distanceToPoint(points[i]);
      if (distance > maxDistance)
      {
        maxDistance = distance;
        maxDistanceIndex = i;
      }
    }
    // check if the max distance is greater than our tollerance allows 
    if (maxDistance >= tolerance)
    {
      p = points[maxDistanceIndex];
      line.distanceToPoint(p, true);
      // include this point in the output 
      returnPoints = returnPoints.concat(douglasPeucker(points.slice(0, maxDistanceIndex + 1), tolerance));
      // returnPoints.push( points[maxDistanceIndex] );
      returnPoints = returnPoints.concat(douglasPeucker(points.slice(maxDistanceIndex, points.length), tolerance));
    } else
    {
      // ditching this point
      p = points[maxDistanceIndex];
      line.distanceToPoint(p, true);
      returnPoints = [points[0]];
    }
    return returnPoints;
  }
}
(vitrium.geometry));

// script:viewer/xps-format-parser.js
(function(exports, geometry)
{
  "use strict";
  var Point = geometry.Point;
  
  var PATH_COMMANDS = ['F', 'M', 'L', 'H', 'V', 'C', 'Q', 'S', 'T', 'A', 'Z', 'f', 'm', 'l', 'h', 'v', 'c', 'q', 's', 't', 'a', 'z'];
  var PATH_PARSE_RE = /[-+]?[0-9]*\.?[0-9]+|[a-z]|[A-Z]/g;
  var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
  
  exports.parsePathData = parsePathData;
  exports.parsePoint = parsePoint;
  exports.parseRectangle = parseRectangle;
  exports.convertColor = convertColor;
  //FIXME this should not be here
  exports.setFillRule = setFillRule;
  
  function parsePathData(ctx, data) 
  {		
    var cmd = null;
    var arg = [];
    var lastControlPoint = {};
    var endPoint = new Point(0,0);
    
    ctx.vCurrentPath = data;
    
    data.replace(PATH_PARSE_RE, 
    function(token)
    {
      if (PATH_COMMANDS.indexOf(token) === -1 && cmd)
      {
        arg.push(token);
      }
      else
      {
        cmd = token;
      }

      cmd = execute(cmd, arg);
      
      return '';
    });

    
    
    function execute(cmd, arg)
    {
      var len = arg.length;
      switch (cmd) {
        case 'F':
        case 'f':
          if (len === 1)
          {
          //vitrium.log.warn("unsupported drawing cmd: "+cmd);
          
          // it might be supported in a future
          if (arg[0] === '1')
          {
            setFillRule(ctx, "nonzero");
            
          }
          else
          {
            setFillRule(ctx, "evenodd");
          }
          
          arg.splice(0);
          
          }
          break;
        case 'M':
        case 'm':
          if (len === 2)
          {	
            var cp = new Point(parseFloat(arg[0]), parseFloat(arg[1]));
            if (cmd === 'm')
            {
              cp.relativeTo(endPoint);
              cmd = "l";
            }
            else
            {
              cmd = "L";
            }

            ctx.moveTo(cp.x, cp.y);
            
            endPoint = cp;		
            arg.splice(0);
          
          }
          break;
        case 'L':
        case 'l':
          if (len === 2)
          {
            var cp = new Point(parseFloat(arg[0]), parseFloat(arg[1]));
            if (cmd === 'l')
            {
              cp.relativeTo(endPoint);
            }
            
            ctx.lineTo(cp.x, cp.y);	
            
            endPoint = cp;
            arg.splice(0);
            
          }
        break;
        case 'H':
        case 'h':
          if (len == 1)
          {
            var cp = new Point(parseFloat(arg[0]), endPoint.y);
            if (cmd === 'h')
            {
              cp.x += endPoint.x;
            }
            
            ctx.lineTo(cp.x, cp.y);	
            
            endPoint = cp;
            arg.splice(0);
            
          }
        break;
        case 'V':
        case 'v':
          if (len == 1)
          {
            var cp = new Point(endPoint.x, parseFloat(arg[0]));
            if (cmd === 'v')
            {
              cp.y += endPoint.y;
            }
            
            ctx.lineTo(cp.x, cp.y);	
            
            endPoint = cp;
            arg.splice(0);
          }
        break;				
        case 'C':
        case 'c':
          if (len === 6)
          {
            var cp1 = new Point (parseFloat(arg[0]), parseFloat(arg[1]));
            var cp2 = new Point(parseFloat(arg[2]), parseFloat(arg[3]));
            var dp = new Point(parseFloat(arg[4]), parseFloat(arg[5]));
            
            if (cmd === 'c')
            {
              cp1.relativeTo(endPoint);
              cp2.relativeTo(endPoint);
              dp.relativeTo(endPoint);
            }
            
            ctx.bezierCurveTo(
              cp1.x, cp1.y ,
              cp2.x, cp2.y,
              dp.x, dp.y
              );
              
            lastControlPoint = cp2;
            endPoint = dp;
            arg.splice(0);
          }
          break;
        case 'Q':
        case 'q':
          if (len === 4)
          {
            var cp = new Point(parseFloat(arg[0]), parseFloat(arg[1]));
            var dp = new Point(parseFloat(arg[2]), parseFloat(arg[3]));
            
            if (cmd === 'q')
            {
              cp.relativeTo(endPoint);
              dp.relativeTo(endPoint);
            }
            
            ctx.quadraticCurveTo(
              cp.x,cp.y, 
              dp.x,dp.y
              );
              
            endPoint = dp;
            arg.splice(0);
          }
        break;
        case 'S':
        case 's':
          if (len === 4)
          {
            var cp1;
            if (lastControlPoint == null)
            {
              cp1 = endPoint;
            }
            else
            {
              //http://stackoverflow.com/questions/5287559/calculating-control-points-for-a-shorthand-smooth-svg-path-bezier-curve
              cp1 = new Point(2*endPoint.x - lastControlPoint.x, 2*endPoint.y - lastControlPoint.y);
            }
            
            var cp2 = new Point(parseFloat(arg[0]), parseFloat(arg[1]));				
            var dp =  new Point(parseFloat(arg[2]), parseFloat(arg[3]));
            
            if (cmd === 's')
            {
              cp2.relativeTo(endPoint);
              dp.relativeTo(endPoint);
            }
            
            ctx.bezierCurveTo(
                cp1.x, cp1.y, 
                cp2.x, cp2.y,	
                dp.x, dp.y
                );
                
            lastControlPoint = cp2;
            endPoint = dp;
                
            arg.splice(0);
          }
        break;
        case 'A':
        case 'a':
          if (len === 7)
          {
            // this code is from canvg.js licensed as MIT, http://code.google.com/p/canvg/
            var rx = parseFloat(arg[0]);
            var ry = parseFloat(arg[1]);
            var xAxisRotation = parseFloat(arg[2]) *  (Math.PI / 180.0);
            var largeArcFlag = parseInt(arg[3], 10); // values 0,1
            var sweepFlag = parseInt(arg[4], 10); //values 0, 1
            var cp  = new Point(parseFloat(arg[5]),  parseFloat(arg[6]));
            
            if (cmd === 'a')
            {
              cp.relativeTo(endPoint);
            }
            
            // Conversion from endpoint to center parameterization
            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
            // x1', y1'
            var currp = new Point(
                Math.cos(xAxisRotation) * (endPoint.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (endPoint.y - cp.y) / 2.0,
                -Math.sin(xAxisRotation) * (endPoint.x  - cp.x) / 2.0 + Math.cos(xAxisRotation) * (endPoint.y - cp.y) / 2.0
              );
              
            // adjust radii
            var l = Math.pow(currp.x,2)/Math.pow(rx,2)+Math.pow(currp.y,2)/Math.pow(ry,2);
            if (l > 1) {
              rx *= Math.sqrt(l);
              ry *= Math.sqrt(l);
            }
            
            // cx', cy'
            var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(
                ((Math.pow(rx,2)*Math.pow(ry,2))-(Math.pow(rx,2)*Math.pow(currp.y,2))-(Math.pow(ry,2)*Math.pow(currp.x,2))) /
                (Math.pow(rx,2)*Math.pow(currp.y,2)+Math.pow(ry,2)*Math.pow(currp.x,2))
            );
            
            if (isNaN(s)) s = 0;
            var cpp = new Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
            // cx, cy
            var centp = new Point(
              (endPoint.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
              (endPoint.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
            );
            
            var a1 = angle([1,0], [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry]);
            // angle delta
            var u = [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry];
            var v = [(-currp.x-cpp.x)/rx,(-currp.y-cpp.y)/ry];
            var ad = angle(u, v);
            if (ratio(u,v) <= -1) ad = Math.PI;
            if (ratio(u,v) >= 1) ad = 0;
            
            if (sweepFlag == 0 && ad > 0) ad = ad - 2 * Math.PI;
            if (sweepFlag == 1 && ad < 0) ad = ad + 2 * Math.PI;
            
            var r = rx > ry ? rx : ry;
            var sx = rx > ry ? 1 : rx / ry;
            var sy = rx > ry ? ry / rx : 1;
            
            ctx.translate(centp.x, centp.y);
            ctx.rotate(xAxisRotation);
            ctx.scale(sx, sy);
            ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
            ctx.scale(1/sx, 1/sy);
            ctx.rotate(-xAxisRotation);
            ctx.translate(-centp.x, -centp.y);
            
            endPoint = cp;
            arg.splice(0);
          }					
        case 'Z':
        case 'z':
          ctx.closePath();
          break;
        default:
          arg.splice(0);
        break;
      }
      
      // Smooth Cubic Bzier Curve command needs to reset control point if command is different from 'S' and 'C'
      switch (cmd)
      {
        case 'S':
        case 's':
        case 'C':
        case 'c':
        break;
        default:
          lastControlPoint = null;
        break;
      }

      return cmd;

    }
  }
  
  function setFillRule(ctx, rule)
  {
    if ("fillRule" in ctx)
    {
      ctx.fillRule = rule;
    }
    else if ("mozFillRule" in ctx)
    {
      ctx.mozFillRule = rule;
    }
    else if ("webkitFillRule" in  ctx)
    {
      ctx.webkitFillRule = rule;
    }
    else if ("msFillRule" in  ctx)
    {
      ctx.msFillRule = rule;
    }
    else
    {
      ctx.argFillRule = rule;
    }
  }

  function parsePoint(arg) 
  {
    var parts = arg.split(',')
    var point = new Point(parseFloat(parts[0]), parseFloat(parts[1]) );
    return point;
  }
  
  function parseRectangle(arg)
  {
    var parts = arg.split(',');
    
    return { 
      x : parseFloat(parts[0]), 
      y : parseFloat(parts[1]), 
      width : parseFloat(parts[2]),
      height : parseFloat(parts[3])
    };
  }
    
  function convertColor(color)
  {
    var len = color.length;
    if (color.length > 0 && color.charAt(0) == "#")
    {
      if (color.length == 9)
      {
        var a = parseInt(color.substring(1,3),16) / 0xff;
        var r = parseInt(color.substring(3,5),16);
        var g = parseInt(color.substring(5,7),16);
        var b = parseInt(color.substring(7,9),16);
        return "rgba("+r+","+g+","+b+","+a+")";
      }
      else
      {
        return color;
      }
    }
    else
    {
      return "#000";
    }
  }
  // vector magnitude
  function magnitude(v) { return Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2)); }
  // ratio between two vectors
  function ratio(u, v) { return (u[0]*v[0]+u[1]*v[1]) / (magnitude(u)*magnitude(v)); }
  // angle between two vectors
  function angle(u, v) { return (u[0]*v[1] < u[1]*v[0] ? -1 : 1) * Math.acos(ratio(u,v)); }
  
  
  

}
(vitrium.xps, vitrium.geometry));
// script:viewer/rectangle-path-detector.js
(function(exports, geometry)
{
  exports.RectanglePathDetector = RectanglePathDetector;
 
  
  function RectanglePathDetector()
  {
    this.fillRule = "evenodd";
    this.notARectangle = false;
    
    this.vertices = [];
    this.lastPoint = 0;
    this.dimensions = null;
  }
  
  RectanglePathDetector.prototype = 
  {
    addVertex : function(x,y)
    {
      var point = new geometry.Point(x,y)
      this.vertices.push(point);
        
      this.lastPoint = point;
    },
    moveTo : function(x,y)
    {
      if (this.notARectangle) return;
      
      if (this.vertices.length !== 0)
      {
        this.notARectangle = true;
      }
      else
      {
        this.addVertex(x,y);
      }
    },
    lineTo : function(x,y)
    {
      if (this.notARectangle) return;
      if (this.vertices.length == 0 || this.vertices.length > 3) 
      {
        this.notARectangle = true;
      }
      
      var lp = this.lastPoint;
      if (lp.x === x || lp.y === y)
      {
        this.addVertex(x,y);
      }
      else
      {
        this.notARectangle = true;
      }
      
    },
    closePath : function()
    {
      if (this.notARectangle) return;
      if (this.vertices.length !== 4)
      {      
        this.notARectangle = false;
        return;
      }
      
      var v = this.vertices;
      var distanceA0 = v[0].distance(v[1]);
      var distanceA1 = v[2].distance(v[3]);
      var distanceB0 = v[0].distance(v[3]);
      var distanceB1 = v[1].distance(v[2]);
      
      if (distanceA0 !== distanceA1 ||
          distanceB0 !== distanceB1 ||
          !this.checkRightAngle(v[1], v[2], v[0]) || 
          !this.checkRightAngle(v[3], v[2], v[0]))
      {
        this.notARectangle = true;
        this.dimensions = null;
      }
      else
      {
        var current = v[0];
        var biggest = v[3];
        var cI = 0;
        for (var i = 1, len = v.length; i < len ; ++i)
        {
          var n = v[i];
          if (n.x < current.x || n.y < current.y)
          {
            current = n;
            cI = i;
          }
          
          if (n.x > biggest.x || n.y > biggest.y)
          {
            biggest = n;
          }
        }
        
        var next = v[(cI + 1) % 4];
        var prev = v[cI === 0 ? 3 : cI -1];
        
        var width, height;
        if (next.x > current.x)
        {
          width = next.distance(current);
          height = prev.distance(current);
        }
        else
        {
          width = prev.distance(current);
          height = next.distance(current);
        }
        
        this.dimensions = {
          x : current.x,
          y : current.y,
          eX : biggest.x,
          eY : biggest.y,
          width : width,
          height : height
        };
      }
          
        
    },
    checkRightAngle : function(A, B, C)
    {
      var a = C.distance(B);
      var b = C.distance(A);
      var c = A.distance(B);
      
      var cosAlpha = (b*b + c*c - a*a) / 2*b*c;
      var radAngle = Math.acos(cosAlpha);
      var degAngle = 180 * radAngle / Math.PI;
      
      return Math.abs(degAngle - 90) < 0.01;
    },    
    bezierCurveTo : setNotARectangle,
    quadraticCurveTo : setNotARectangle,
    arc : setNotARectangle
  };

  function setNotARectangle()
  {
    this.notARectangle = true;
  }
  
}(
vitrium.geometry,
vitrium.geometry));
// script:viewer/error-icon-di.js
(function(exports)
{
  "use strict";
  
  exports.renderErrorIcon = renderErrorIcon;
  function renderErrorIcon(ctx, scale) 
  {
    ctx.save();
    ctx.scale(scale, scale);
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(48,0);
    ctx.lineTo(48,48);
    ctx.lineTo(0,48);
    ctx.closePath();
    ctx.clip();
    ctx.strokeStyle = 'rgba(0,0,0,0)';
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
    ctx.miterLimit = 4;
    ctx.save();
    ctx.restore();
    ctx.save();
    ctx.restore();
    ctx.save();
    ctx.save();
    ctx.transform(1.566667,0,0,1.566667,-8.925566,-23.94764);
    ctx.save();
    ctx.transform(0.01444074,0,0,0.01331973,33.38871,40.40337);
    ctx.save();
    var g=ctx.createLinearGradient(-1051.93545446865,-150.69685117966003,-1051.93545446865,327.66039340941995);
    g.addColorStop(0,"rgba(0, 0, 0, 0)");
    g.addColorStop(0.5,"rgba(0, 0, 0, 1)");
    g.addColorStop(1,"rgba(0, 0, 0, 0)");
    ctx.fillStyle = g;
    ctx.strokeStyle = "rgba(0, 0, 0, 0)";
    ctx.lineWidth = 1;
    ctx.lineCap = "round";
    ctx.lineJoin = "miter";
    ctx.miterLimit = 4;
    ctx.globalAlpha = 0.4020618498325348;
    ctx.beginPath();
    ctx.moveTo(-1559.2523,-150.69685);
    ctx.lineTo(-219.6188000000002,-150.69685);
    ctx.quadraticCurveTo(-219.6188000000002,-150.69685,-219.6188000000002,-150.69685);
    ctx.lineTo(-219.6188000000002,327.66033000000004);
    ctx.quadraticCurveTo(-219.6188000000002,327.66033000000004,-219.6188000000002,327.66033000000004);
    ctx.lineTo(-1559.2523,327.66033000000004);
    ctx.quadraticCurveTo(-1559.2523,327.66033000000004,-1559.2523,327.66033000000004);
    ctx.lineTo(-1559.2523,-150.69685);
    ctx.quadraticCurveTo(-1559.2523,-150.69685,-1559.2523,-150.69685);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();
    ctx.save();
    g=ctx.createRadialGradient(-211.14593668118982,85.66786882034,0,-211.14593668118982,85.66786882034,117.14286);
    g.addColorStop(0,"rgba(0, 0, 0, 1)");
    g.addColorStop(1,"rgba(0, 0, 0, 0)");
    ctx.fillStyle = g;
    ctx.strokeStyle = "rgba(0, 0, 0, 0)";
    ctx.lineWidth = 1;
    ctx.lineCap = "round";
    ctx.lineJoin = "miter";
    ctx.miterLimit = 4;
    ctx.globalAlpha = 0.4020618498325348;
    ctx.beginPath();
    ctx.moveTo(-219.61876,-150.68038);
    ctx.bezierCurveTo(-219.61876,-150.68038,-219.61876,327.65041,-219.61876,327.65041);
    ctx.bezierCurveTo(-76.744594,328.55086,125.78146,220.48075,125.78138,88.454235);
    ctx.bezierCurveTo(125.78138,-43.572302,-33.655436,-150.68036,-219.61876,-150.68038);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();
    ctx.save();
    g=ctx.createRadialGradient(-1567.7247633188101,85.66786882034,0,-1567.7247633188101,85.66786882034,117.14286);
    g.addColorStop(0,"rgba(0, 0, 0, 1)");
    g.addColorStop(1,"rgba(0, 0, 0, 0)");
    ctx.fillStyle = g;
    ctx.strokeStyle = "rgba(0, 0, 0, 0)";
    ctx.lineWidth = 1;
    ctx.lineCap = "round";
    ctx.lineJoin = "miter";
    ctx.miterLimit = 4;
    ctx.globalAlpha = 0.4020618498325348;
    ctx.beginPath();
    ctx.moveTo(-1559.2523,-150.68038);
    ctx.bezierCurveTo(-1559.2523,-150.68038,-1559.2523,327.65041,-1559.2523,327.65041);
    ctx.bezierCurveTo(-1702.1265,328.55086,-1904.6525,220.48075,-1904.6525,88.454235);
    ctx.bezierCurveTo(-1904.6525,-43.572302,-1745.2157,-150.68036,-1559.2523,-150.68038);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();
    ctx.restore();
    ctx.save();
    ctx.transform(1,0,0.004537846,1,-0.138907,-1.394718e-15);
    ctx.save();
    ctx.fillStyle = "#cc0000";
    ctx.strokeStyle = "#9f0000";
    ctx.lineWidth = 0.6382977962493896;
    ctx.miterLimit = 4;
    ctx.transform(1,0,-0.008726683,1,0.328074,1.276596);
    ctx.beginPath();
    ctx.moveTo(33.282781,38.644744);
    ctx.lineTo(22.407791,18.394765);
    ctx.bezierCurveTo(22.095292,17.832266,21.532792,17.519767,20.907793,17.519767);
    ctx.bezierCurveTo(20.282793,17.519767,19.720294,17.894765,19.407795,18.457265);
    ctx.lineTo(8.7828048,38.707245);
    ctx.bezierCurveTo(8.5328048,39.207244,8.5328048,39.894744,8.8453048,40.394743);
    ctx.bezierCurveTo(9.1578038,40.894743,9.6578038,41.144742,10.282804,41.144742);
    ctx.lineTo(31.782782,41.144742);
    ctx.bezierCurveTo(32.407781,41.144742,32.97028,40.832243,33.220281,40.332243);
    ctx.bezierCurveTo(33.53278,39.832243,33.53278,39.207244,33.282781,38.644744);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();
    ctx.save();
    ctx.strokeStyle = "#000000";
    ctx.miterLimit = 4;
    ctx.transform(0.625,0,-0.005534934,0.634254,6.164053,15.76055);
    ctx.save();
    ctx.save();
    ctx.restore();
    ctx.save();
    ctx.restore();
    ctx.restore();
    ctx.save();
    g=ctx.createLinearGradient(4.1914,11.1133,47.3197,56.0523);
    g.addColorStop(0,"#D4D4D4");
    g.addColorStop(0.3982,"#E2E2E2");
    g.addColorStop(1,"#FFFFFF");
    ctx.fillStyle = g;
    ctx.strokeStyle = "rgba(0, 0, 0, 0)";
    ctx.beginPath();
    ctx.moveTo(9.5,37.6);
    ctx.bezierCurveTo(9.2,38.1,9.5,38.5,10,38.5);
    ctx.lineTo(38.2,38.5);
    ctx.bezierCurveTo(38.7,38.5,39,38.1,38.7,37.6);
    ctx.lineTo(24.4,11);
    ctx.bezierCurveTo(24.1,10.5,23.7,10.5,23.5,11);
    ctx.lineTo(9.5,37.6);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();
    ctx.restore();
    ctx.save();
    ctx.fillStyle = "rgba(0, 0, 0, 0)";
    g=ctx.createLinearGradient(9.5588786783069,29.483851249035002,29.61032677792,46.318955598740004);
    g.addColorStop(0,"rgba(255, 255, 255, 1)");
    g.addColorStop(1,"rgba(255, 255, 255, 0.34020618)");
    ctx.strokeStyle = "[object CanvasGradient]";
    ctx.lineWidth = 0.6382979154586792;
    ctx.miterLimit = 4;
    ctx.transform(1,0,-0.008726683,1,0.318277,1.276596);
    ctx.globalAlpha = 0.5;
    ctx.beginPath();
    ctx.moveTo(32.323106,38.183905);
    ctx.lineTo(22.150271,19.265666);
    ctx.bezierCurveTo(21.71698,18.45069,21.561698,18.189213,20.908406,18.189213);
    ctx.bezierCurveTo(20.346525,18.189213,20.054127,18.57002,19.651305,19.339291);
    ctx.lineTo(9.7489285,38.242296);
    ctx.bezierCurveTo(9.1737649,39.303588,9.1128238,39.580228,9.3937644,40.047345);
    ctx.bezierCurveTo(9.6747034,40.514462,10.032797,40.48902,11.356441,40.519491);
    ctx.lineTo(30.974593,40.519491);
    ctx.bezierCurveTo(32.206825,40.534726,32.483988,40.440837,32.70874,39.97372);
    ctx.bezierCurveTo(32.989681,39.506602,32.867799,39.136,32.323106,38.183905);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();
    ctx.restore();
    ctx.save();
    ctx.strokeStyle = "#000000";
    ctx.miterLimit = 4;
    ctx.transform(0.555088,0,0,0.555052,7.749711,17.80196);
    ctx.save();
    ctx.strokeStyle = "rgba(0, 0, 0, 0)";
    ctx.beginPath();
    ctx.moveTo(23.9,36.5);
    ctx.bezierCurveTo(22.6,36.5,21.6,35.5,21.6,34.2);
    ctx.bezierCurveTo(21.6,32.8,22.5,31.9,23.9,31.9);
    ctx.bezierCurveTo(25.3,31.9,26.1,32.8,26.2,34.2);
    ctx.bezierCurveTo(26.2,35.5,25.3,36.5,23.9,36.5);
    ctx.lineTo(23.9,36.5);
    ctx.closePath();
    ctx.moveTo(22.5,30.6);
    ctx.lineTo(21.9,19.1);
    ctx.lineTo(25.9,19.1);
    ctx.lineTo(25.3,30.6);
    ctx.lineTo(22.4,30.6);
    ctx.lineTo(22.5,30.6);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();
    ctx.restore();
    ctx.restore();
    ctx.restore();
    ctx.restore();
  }
}
(vitrium.viewer));
// script:viewer/memory-pools.js
/// <reference path="~/build.html" />

(function (exports, vitrium, geometry,geometry2,_)
{
	"use strict";
	exports.ArrayPool = ArrayPool;
	exports.PointPool = PointPool;
	exports.RectanglePool = RectanglePool;
	exports.RectangleArrayPool = RectangleArrayPool;
	var Point = geometry.Point;
	var DataRectangle = geometry2.DataRectangle;
	
	
	function ArrayPool()
	{
		this.pool =[];
	}
	
	ArrayPool.prototype = {
		create : function(len)
		{
			var obj  = this.pool.pop();
			if (!obj)
			{
				var arr = new Array(len);
				arr._pool = this;
				arr.free = this.arrFree;
				return arr;
			}
			else
			{
				obj.length = len;
				return obj;
			}
		}, 
		free : function(obj)
		{
			this.pool.push(obj);
			obj.length = 0;
		},
		arrFree : function()
		{
			this._pool.free(this);
		}
	};
	
	function PointPool()
	{
		this.pool = [];
	}

	PointPool.prototype = {
		clone : function(p)
		{	
			return this.create(p.x, p.y);
		},
		create : function(x, y)
		{
			var obj  = this.pool.pop();
			if (!obj)
			{
				return new Point(x,y);
			}
			else
			{
				obj.x = x;
				obj.y = y;
				
				return obj;
			}
		}, 
		free : function(obj)
		{
			this.pool.push(obj);
		}
	};
	
	function RectangleArrayPool(rectanglePool)
	{
		this.pool = [];
		this.rectanglePool = rectanglePool;
	}
	
	RectangleArrayPool.prototype = {
		create : function(len)
		{
			var obj  = this.pool.pop();
			if (!obj)
			{
				var arr = new Array(len);
				arr._pool = this;
				arr._ref = 0;
				arr.callback = null;
				arr.incRef = this.arrIncRef;
				arr.decRef = this.arrDecRef;
				return arr;
			}
			else
			{
				obj.length = len;
				return obj;
			}
		}, 
		free : function(obj)
		{
			this.pool.push(obj);
			var pool = this.rectanglePool.pool;
			for (var i = 0, len=obj.length; i< len;++i)
			{
				pool.push(obj[i]);
			}
			obj.length = 0;
		},
		arrIncRef : function()
		{
			++this._ref;
		},
		arrDecRef : function()
		{
			var ref = --this._ref;
			if (ref === 0)
			{
				this._pool.free(this);
				if (this.callback) this.callback(this);
			}
			else if (ref < 0)
			{
				this._ref = 0;
				vitrium.log.error("[RectangleArrayPool] Unbalanced decRef call!");
			}
		}
	};
	
	function RectanglePool()
	{
		this.pool = [];
	}

	RectanglePool.prototype = {
		clone : function(r)
		{	
			var obj  = this.pool.pop();
			if (!obj)
			{
				obj = new DataRectangle(0, 0, 0, 0, 0, null);
			}
		
			obj.assign(r);
			return obj;
		},
		create : function(text, pX, pY, dX, dY, angle)
		{
			var obj  = this.pool.pop();
			if (!obj)
			{
			  return new DataRectangle(pX, pY, dX, dY, angle, text);
			}
			else
			{
			  obj.init(pX, pY, dX, dY, angle, text);
				
				return obj;
			}
		}, 
		free : function(obj)
		{
			var p = this.pool;
			if (p.length < 10000)
			{
				p.push(obj);
			}
		}
	};
	
	exports.GLOBAL_POINT_POOL = new PointPool();
	exports.GLOBAL_ARRAY_POOL = new ArrayPool();
	exports.GLOBAL_RECTANGLE_POOL = new RectanglePool();
}(
vitrium.utils.pools,
vitrium,
vitrium.geometry,
vitrium.geometry2,
_
));
// script:viewer/date-time-parser.js
(function(exports, _)
{
  "use strict";
  
  /*
    accepts following format 2008-06-15T21:15:07 
  */
  exports.parseDateTimeUTC = function(dateStr)
  {
    var parts = dateStr.split("T");
    var datePart = toNumbers(parts[0].split("-"));
    var timePartStr = parts[1];

    var minusUTCOffset = timePartStr.indexOf("-");
    var plusUTCOffset = timePartStr.indexOf("+");
    var offset = null;

    if (minusUTCOffset !== -1 )
    {
      offset = toNumbers(timePartStr.substring(minusUTCOffset + 1).split(":"));
      timePartStr = timePartStr.substring(0, minusUTCOffset);
    }
    else if (plusUTCOffset !== -1)
    {
      offset = toNumbers(timePartStr.substring(plusUTCOffset + 1).split(":"));
      timePartStr = timePartStr.substring(0, plusUTCOffset);
    }
    
    var timePart = toNumbers(timePartStr.split(":"));
      
    if (datePart.length === 3 && timePart.length === 3)
    { 
      var result = new Date();
      result.setUTCFullYear(datePart[0]);
      result.setUTCMonth(datePart[1]-1);
      result.setUTCDate(datePart[2]);
      
      result.setUTCHours(timePart[0]);
      result.setUTCMinutes(timePart[1]);
      result.setUTCSeconds(timePart[2]);
      
      if (offset !== null)
      {
        var hours = offset[0];
        var minutes = offset[1];
        var ms = hours * 60 * 60 * 1000 + minutes * 60 * 1000;
        if (plusUTCOffset !== -1) ms *= -1;
                
        result.setUTCMilliseconds(ms);
      }
      return result;    
    }
    else
    {
      throw new Error("Unable to parse a date time string [\""+dateStr+"\" has an incorrect format]");
    }
  };
  
  function toNumbers(parts)
  {
    for (var i = 0, len = parts.length; i < len; ++i)
    {
      var num = parseInt(parts[i], 10);
      if (_.isNaN(num))
      {
        throw new Error("Unable to parse a date time string [\""+parts[i]+"\" is not a number]");
      }
      
      parts[i] = num;    
    }
    
    return parts;
  }
  
}
(vitrium.utils, _));
// script:viewer/offline-storage-guard.js
(function(exports, utils, io, log, Backbone, _)
{
  "use strict";
  
  exports.OfflineStorageGuard = OfflineStorageGuard;
  
  function OfflineStorageGuard(safeArgumentsModel, viewer)
  {
    this.viewer = viewer;
    this.model = safeArgumentsModel;  
    this.document = null;
    
    viewer.on("document:attached", this.onDocumentAttached, this);
    viewer.on("document:detached", this.onDocumentDetached, this);
    safeArgumentsModel.on("change:offlineExpiryDate", this.onOfflineStorageExpiryDateChanged, this);
    //safeArgumentsModel.on("change:saveOfflineEnabled", this.onOfflineStorageExpiryDateChanged, this);
    safeArgumentsModel.on("change:cacheEnabled", this.onCacheEnabled, this);
    
    this.checkTimer = null;
    this.infoLoaded = false;
  }
  
  OfflineStorageGuard.prototype = {
    destroy : function()
    {
      viewer.off("document:attached", this.onDocumentAttached, this);
      viewer.off("document:detached", this.onDocumentDetached, this);
    },
    onDocumentAttached : function(document)
    {
       this.document  = document;
       document.on("info:loaded", this.onInfoLoaded, this);
    },
    onInfoLoaded : function()
    {
      this.infoLoaded = true;
      this.onOfflineStorageExpiryDateChanged();
    }, 
    onDocumentDetached : function(document)
    {
      document.off("info:loaded", this.onInfoLoaded, this);
  
      this.document  = null; 
      this.infoLoaded = false;
      
      this.scheduleInvalidation(null);
    },
    onOfflineStorageExpiryDateChanged : function()
    {
        if (this.model.has("offlineExpiryDate"))
        {
            this.scheduleInvalidation(utils.parseDateTimeUTC(this.model.get("offlineExpiryDate")).getTime());
        }
        else
        {
          this.scheduleInvalidation(null);
          
        }
    },
    onCacheEnabled : function()
    {
      if (this.document)
      {
        this.document.getContext().cacheEnabled = this.model.get("cacheEnabled");
      }
    },
    scheduleInvalidation : function(time)
    {
      if (!this.infoLoaded)  return;
      clearTimeout(this.checkTimer);
      
      if (time === null) 
      {
          this.document.getContext().offlineStorage = true;
          return;
      }
      
      var at = time - Date.now();
      if (at < 0) {
        at = 0;
        this.document.getContext().offlineStorage = false;
      }
      else
      {
        this.document.getContext().offlineStorage = true;
      }
      
      this.checkTimer = setTimeout(_.bind(function()
      {
        if (time > Date.now())
        {
           this.scheduleInvalidation(time);
        }                    

        this.viewer.cancelCurrentStorageAction();
        var ctx = this.document.getContext();
        ctx.offlineStorage = false;
        
        var cache = ctx.cacheManager.openCache(ctx.url, _.bind(function ()
        {
          cache.erase();
          this.document.trigger("offline-invalidated", cache.downloadState === io.CACHE_STATE.DOWNLOADED);
        }, this), 
        function ()
        {
          log.warn("there is a problem during document removal");
        });
      }, this), Math.min(at, 2147483647));
    }
  };
 
}
(
vitrium.viewer,
vitrium.utils,
vitrium.io,
vitrium.log,
Backbone,
_
));
// script:viewer/cursor-view.js
/// <reference path="~/build.html" />

(function (exports, ui, Backbone, _)
{
  "use strict";
  exports.CursorView = CursorView;
  exports.CursorModel = CursorModel;
  exports.Cursor = Cursor;


  function CursorView(viewer, model)
  {
    this.viewer = viewer;
    model.on("change:cursor", this.requestChange, this);
    this._onRender = new ui.UISync(this.onRender, this, 0);

    this._renderedCursor = null;
    this._requestedCursor = null;
  }

  CursorView.prototype = {
    requestChange : function(model, cursor)
    {
        if (cursor === null) cursor = "default";
     //   try { throw new Error(); } catch (e) { console.log(cursor, e.stack); };

      if (this._requestedCursor !== cursor)
      {
        if (this._renderedCursor === cursor)
        {
          this._requestedCursor = null;
        }
        else
        {
          this._requestedCursor = cursor;
          this.viewer.uiLoop.runAsync(this._onRender);
        }
      }
      
    },
    onRender : function()
    {
      var rc = this._requestedCursor;
      if (rc !== null)
      {
        var el = this.viewer.el;
        el.style.cursor = rc;
        
        this._renderedCursor = rc;
        this._requestedCursor = null;
      }
    }
  };

 
  function Cursor(cursor, priority)
  {
    this.cursor = cursor;
    this.priority = priority;
    this.idx = null;
  }
  
  /**
  Flyweight pattern implementation for cursors
  priority - 0 for implicit actions
           - 1 for user selected actions or object manipulations
  */
  Cursor.create = function (cursor, priority)
  {
    if (!("_cursors" in this)) this._cursors = [];

    var found =  _.find(this._cursors, function (c) { return c.cursor === cursor && c.priority === priority; });
    if (found)
    {
      return found;
    }
    else
    {
      var c = new Cursor(cursor, priority);
      this._cursors.push(c);
      return c;
    }
  };

  Cursor.comparator = function (c0, c1)
  {
    var deltaP = c0.priority - c1.priority;
    if (deltaP === 0)
    {
      // stable sort
      deltaP = c0.idx - c1.idx;
    }
    return deltaP;
  };

  function CursorModel()
  {
    this._defaultCursor = new Cursor(null, 0);
    this._cursors = [this._defaultCursor];
  }

  CursorModel.prototype = {
    push: function (cursor)
    {
      if (cursor === null) return false;
      if (this._cursors.indexOf(cursor) === -1)
      {
        cursor.idx = this._cursors.length;
        this._cursors.push(cursor);
        this._cursors.sort(Cursor.comparator);

        this.triggerUpdate();
        return true;
      }
      return false;
    },
    pop: function (cursor)
    {
      if (cursor === null) return;

      this._cursors = _.without(this._cursors, cursor);
      cursor.idx = null;

      this.triggerUpdate();
    },
    triggerUpdate: function()
    {
      this.trigger("change:cursor", this, this.currentCursor().cursor);
    },
    currentCursor : function()
    {
      var s = this._cursors;
      return s[s.length-1];
    }
  };
  _.extend(CursorModel.prototype, Backbone.Events);


}
(vitrium.viewer,
 vitrium.ui,
 Backbone,
 _
));

// script:viewer/line-data-to-rectangle.js
(function(exports, geometry, geometry2)
{
  "use strict";
  
  exports.RectangleContext = RectangleContext;
  
  var DataRectangle = geometry2.DataRectangle;
  var Point = geometry.Point;
  
  
  /**
    @class RectangleContext
  */
  function RectangleContext(matrix)
  {	
    if (!matrix) matrix = null;
    
    this.matrix = matrix;
  
  /**
                                                x (max)
            _____________________
            |
            |   p1-------------------p2
            |    |                          |
            |    |                          |
            |   p4-------------------p3
            |
 y (max)|
  */
  
    this.p1 = new Point(Number.MAX_VALUE, Number.MAX_VALUE);
    this.p2 = new Point(Number.MIN_VALUE, Number.MAX_VALUE);
    this.p3 = new Point(Number.MIN_VALUE, Number.MIN_VALUE);
    this.p4 = new Point(Number.MAX_VALUE, Number.MIN_VALUE);
  }
  
  var RectangleContextP = RectangleContext.prototype;
  RectangleContextP.moveTo = function(x, y)
  {	
    var p = new Point(x,y);
    if (this.matrix)
    {
      p = this.matrix.multiplyPoint(p);
    }
    
    var p1 = this.p1;
    p1.x = Math.min(p1.x, p.x);
    p1.y = Math.min(p1.y, p.y);
    
    var p2 = this.p2;
    p2.x = Math.max(p2.x, p.x);
    p2.y = Math.min(p2.y, p.y);
    
    var p3 = this.p3;
    p3.x = Math.max(p3.x, p.x);
    p3.y = Math.max(p3.y, p.y);
    
    var p4 = this.p4;
    p4.x = Math.min(p4.x, p.x);
    p4.y = Math.max(p4.y, p.y);
  };
  

  RectangleContextP.getRectangle = function()
  {
    return new DataRectangle(this.p1.x, this.p1.y, this.p2.x - this.p1.x, this.p4.y - this.p1.y, 0, null);
  };
  
  RectangleContextP.lineTo = function(x, y)
  {
    this.moveTo(x, y);
  };
  
  RectangleContextP.bezierCurveTo = function(ax,ay,bx,by, dx,dy)
  {
    this.moveTo(dx, dy);
  };
  
  RectangleContextP.quadraticCurveTo = function(cpx, cpy, dx, dy)
  {
    this.moveTo(dx, dy);
  };
  
  RectangleContextP.closePath = function(){};
   
  RectangleContextP.arc = RectangleContextP.translate = RectangleContextP.rotate = RectangleContextP.scale = function()
  {
    vitrium.log.warn("cannot aproximate ractangle correctly");
  };
  

}(vitrium.utils, vitrium.geometry, vitrium.geometry2));
// script:viewer/link-rectangle-processor.js
(function (exports, vitrium, _, $, document, pools) {	
	"use strict";
	
	var T_PATH = "P";  //Path
	var T_GLYPHS = "G";  //Glyphs
	var P_DATA = "E";  //Data
	
	
	_.extend(exports,
	{
		LinkRectangleProcessorFactory : LinkRectangleProcessorFactory,
		LinkToRectangleProcessor :  LinkToRectangleProcessor
	});
	
	var Point = vitrium.geometry.Point;
	
	var GLOBAL_RECTANGLE_POOL = pools.GLOBAL_RECTANGLE_POOL;
	
	function LinkRectangleProcessorFactory(rectangleStorage, nameRectangleStorage)
	{
		this.getInstance = function()
		{
			return new LinkToRectangleProcessor(rectangleStorage, nameRectangleStorage);
		};
	}
	
	var P0 = new Point(0,0);
	var P1 = new Point(0,0);
	
	function LinkToRectangleProcessor(rectangleStorage, nameRectangleStorage)
	{
		this.rectangleStorage = rectangleStorage;
		this.nameRectangleStorage = nameRectangleStorage;
		
		this.add = false;
		this.pageNumber = 0;
	}
	
	LinkToRectangleProcessor.prototype = {
		begin : function(pageNumber)
		{
		    this.pageNumber = pageNumber;
		    this.add = this.rectangleStorage.begin(pageNumber);
			this.nameRectangleStorage.begin(pageNumber);
		}, 
		addLink : function (matrix, link, type, object)
		{
			if (this.add)
			{
				var rectangle = this.getRectangle(matrix, link, type, object);			
				if (rectangle)
				{
					this.rectangleStorage.add(this.pageNumber, rectangle);
				}
			}
		},	
		getRectangle : function(matrix, objData, type, object)
		{
			var p = P0;
			var p2 = P1;
			
			var rectangle = null;
			if (type === T_GLYPHS)
			{
				p.x = object.x;
				p.y = object.y;
				matrix.inPlaceMultiplyPoint(p);
				
				p2.x = object.x + object.width;
				p2.y =  object.y + object.height;
				matrix.inPlaceMultiplyPoint(p2);
				
				/*var p = matrix.multiplyPoint(new Point(object.x, object.y));
				var p2 = matrix.multiplyPoint(new Point(object.x + object.width, object.y + object.height));*/
				
				p2.x = p2.x - p.x;
				p2.y = p2.y - p.y;
				
				//TODO support rotation				
				rectangle = GLOBAL_RECTANGLE_POOL.create(objData, p.x, p.y, p2.x, p2.y, 0);
			}
			else  if (type === T_PATH)
			{
				var data = object.properties[P_DATA];
				var ctx = new vitrium.utils.RectangleContext(matrix);
				
				vitrium.viewer.processPathData(ctx, data);
				rectangle = ctx.getRectangle();
				rectangle.d = objData;
				rectangle = GLOBAL_RECTANGLE_POOL.clone(rectangle);
			}
			
			return rectangle;
		},	
		addName : function(matrix, name, type, object)
		{
			if (this.add)
			{
				var rectangle = this.getRectangle(matrix, name, type, object);
				if (rectangle)
				{
					this.nameRectangleStorage.add(this.pageNumber, rectangle);
				}
			}
		},
		end : function()
		{
			if (this.add)
			{
				this.rectangleStorage.commit(this.pageNumber);
				this.nameRectangleStorage.trigger("finished", this.pageNumber);	
			}
		},	
		freeMemory : function()
		{
			this.rectangleStorage.free(this.pageNumber);
			this.nameRectangleStorage.free(this.pageNumber);
		}
	};
		
}(
vitrium.viewer, 
vitrium, 
_, 
jQuery, document, vitrium.utils.pools));
// script:viewer/link-controller.js
/// <reference path="~/build.html" />

(function (exports, viewer, geometry, geometry2, ui, window, _, $)
{
  "use strict";

  exports.LinkController = LinkController;
  exports.openLink = openLink;
  var viewer = exports;

  var STATES = viewer.STATES;
  var ST_READY = STATES.get("READY");

  var S_NONE = null;
  var S_PAGE = viewer.Cursor.create("text", 0);
  var S_LINK = viewer.Cursor.create("pointer", 0);

  function LinkController(linkRectangleStorage, nameRectangleStorage, viewer, cursorModel)
  {
    this.linkRectangleStorage = linkRectangleStorage;
    this.nameRectangleStorage = nameRectangleStorage;
    this.cursorModel = cursorModel;

    this.viewer = viewer;
    this.waitForName = null;
    this.pageNumber = null;

    this.lastMousePosition = new geometry.Point(0, 0);
    this.queryPoint = new geometry.Point(0, 0);
    this.queryRectangle = new geometry2.DataRectangle(0, 0, 0, 0, 0, null);
    this.queryResult = [];

    viewer.on("change:viewport", this.onRenderCursorStatus, this)
          .on("mousemove", this.onMouseMove, this)
          .on("mouseleave", this.onMouseLeave, this)
          .on("mouseup", this.onClick, this)
          .on("tap", this.onTap, this);


    nameRectangleStorage.on("finished", this.onNameRectanglesFinished, this);

    this.renderCursorStatus = new ui.UISync(this.onRenderCursorStatus, this, 0);
    this.status = S_NONE;
  }

  LinkController.prototype = {
    onRenderCursorStatus: function ()
    {
      var status = this.status;
      var newstatus = S_NONE;
      var link = null;
      if (this.viewer.state.current() === ST_READY)
      {
        link = this.getLink(this.lastMousePosition);
      }
     

      if (this.pageNumber !== null)
      {
        newstatus = S_PAGE;

        if (status !== newstatus)
        {
          //FIXME it breaks encapsulation, but is more efficient
          this.viewer.setProperty("pageUnderMouse", this.pageNumber);
        }
      }
      else if (status === S_PAGE)
      {
        //FIXME it breaks encapsulation
        this.viewer.setProperty("pageUnderMouse", null);
      }
           

      if (link)
      {
        newstatus = S_LINK;
      }

      if (status !== newstatus)
      {
        if (status !== S_NONE) this.cursorModel.pop(status);
        if (newstatus !== S_NONE) this.cursorModel.push(newstatus);
      }
      this.status = newstatus;
    },
    onNameRectanglesFinished: function (pageIdx)
    {
      if (this.waitForName && this.waitForName.pageNumber === pageIdx)
      {
        this.tryFindRefNamePosition(this.waitForName.pageNumber, this.waitForName.name);
        this.waitForName = null;
      }
    },
    onMouseMove: function (e, state)
    {
      var mousePoint = this.lastMousePosition;
      mousePoint.x = e.pageX;
      mousePoint.y = e.pageY;


      this.onDocumentMousePositionChanged();

    },
    onMouseLeave: function(e)
    {
       if (e.which === 0)
       {
          var mousePoint = this.lastMousePosition;
          mousePoint.x = -1;
          mousePoint.y = -1;
          this.onDocumentMousePositionChanged();
       }          
    },
    onClick: function (evt, state)
    {
      var mousePoint = this.lastMousePosition;
      mousePoint.x = evt.pageX;
      mousePoint.y = evt.pageY;
      if (state.current() === ST_READY)
      {
        var link = this.getLink(mousePoint);
        if (link)
        {
          this.open(link.d);
        }
      }
    },
    onTap: function (evt, state)
    {
      this.onClick(evt.gesture.center, state);
    },
    onDocumentMousePositionChanged: function ()
    {
      if (this.viewer.state.current() === ST_READY)
      {
        this.viewer.uiLoop.runAsync(this.renderCursorStatus);
      }
    },
    open: function (link)
    {
      if (link.indexOf("name:") === 0)
      {
        var name = link.substring(5, link.length);
        if (name.length > 0)
        {
          var pageNumber = this.document.getTargetPage(name);
          if (pageNumber !== null)
          {
            this.viewer.scrollTo(pageNumber);
            if (!this.tryFindRefNamePosition(link, name))
            {
              this.waitForName = {
                name: name,
                pageNumber: pageNumber
              };
            }
          }
          else
          {
            vitrium.log.warn("link=" + link + " not found");
          }
        }
      }
      else if (link.indexOf("page:") === 0)
      {
        var pageNumber = parseInt(link.substring(5, link.length), 10);
        if (!_.isNaN(pageNumber))
        {
          this.viewer.scrollTo(pageNumber - 1);
        }
      }
      else
      {
        openLink(link);
      }
    },
    getLink: function (point)
    {
      var v = this.viewer;
      var pageNumber = this.pageNumber = v.getPageNumberByCoordinates(point.x, point.y, 1);
      var result = this.queryResult;
      result.length = 0;

      if (pageNumber !== null)
      {
        var pageCoords = this.queryPoint;
        pageCoords.x = point.x;
        pageCoords.y = point.y;

        v.translateCoordinatesToPage(pageCoords, pageNumber);

        var queryRect = this.queryRectangle;
        queryRect.init(pageCoords.x, pageCoords.y, 1, 1, 0, null);

        this.linkRectangleStorage.intersect(pageNumber, result, queryRect);
      }
      var link = (result.length > 0 ? result[0] : null);
      result.length = 0;
      //		console.log(pageNumber, link, point.x, point.y);
      return link;
    },
    tryFindRefNamePosition: function (pageIdx, name)
    {
      var rectangles = this.nameRectangleStorage.getRectangles(pageIdx, 0, true);
      if (rectangles !== null)
      {
        for (var i = 0, len = rectangles.length; i < len; ++i)
        {
          var r = rectangles[i];
          if (r.d === name)
          {
            this.viewer.scrollToPoint(pageIdx, r.position, "top");
            return true;
          }
        }
      }
      return false;
    }

  };

  function openLink(link)
  {
    if (vitrium.is_mobile)
    {
      var document = window.document;
      var a = document.createElement('a');
      a.setAttribute("href", link);
      a.setAttribute("target", "_blank");

      var dispatch = document.createEvent("HTMLEvents")
      dispatch.initEvent("click", true, true);
      a.dispatchEvent(dispatch);
    }
    else
    {
      window.open(link);
    }
  }

}(
vitrium.viewer,
vitrium.viewer,
vitrium.geometry,
vitrium.geometry2,
vitrium.ui,
__globals__,
_,
jQuery));
// script:viewer/logging.js
(function (exports, _, $, globals) {
	"use strict";
	var logger = null;
	var levels = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3 };
	var strLevels = ["debug", "info", "warn", "error"];

	_.extend(exports,{
	   levels: levels,
		setLevel : setLevel,
		setCaptureLevel: setCaptureLevel,
		getLevel : getLevel,
		getCapture: getCapture,
		setLogger: function(_logger)
		{
		   logger = _logger;
		},
		log : log,
		debug : debug,
		info : info,
		warn : warn,
		error : error
	});
	
	
	var level = levels.WARN;
	var captureLevel = levels.WARN;
	
	var capture = [];
	
	function setLevel(_level) {
		if (_level >= levels.DEBUG && _level <= levels.ERROR)
		{
			level = _level;
		}
		else
		{
			throw new Error("ERROR: level["+_level+"] cannot be set!");
		}
	}
	
	function setCaptureLevel(_level)
	{
		if (_level >= levels.DEBUG && _level <= levels.ERROR)
		{
			captureLevel = _level;
		}
		else
		{
			throw new Error("ERROR: captureLevel["+_level+"] cannot be set!");
		}
	}
	
	function getCapture(filter)
	{
		return !filter ? capture : _.filter(capture, filter);
	}
	
	function getLevel()
	{
		return level;
	}
	
	function logIntoConsole(_level, message)
	{
		if (globals.console)
		{
			var logged = false;
			_.each(levels,function(val,key)
			{
				if (_level == val)
				{
					var logFunct = globals.console[key.toLowerCase()];
					if (_.isFunction(logFunct))
					{
						logFunct.apply(globals.console, message);
						logged = true;
					}
				}
			});
			
			if (!logged && _.isFunction(globals.console.log))
			{
			   globals.console.log.apply(globals.console, message);
			}
		}
	}
	
	function log(_level, message)
	{		
		if (_level >= level)
		{
		   if (logger) logger(_level, message, strLevels[_level]);
			logIntoConsole(_level, message);
			
		}
		
		if (_level >= captureLevel)
		{			
			if (capture.length > 100)
			{
				capture.shift();
			}		
			message.toString = _messageToString;
			capture.push({ level : _level, message : message});
		}
	}

	function _messageToString() {
	   var buffer = [];
	   for (var i = 0, len = this.length; i !== len; ++i)
	   {
	      var part = this[i];
	      if (part === null)
	      {
	         buffer.push("null");
	      }
	      else if (_.isUndefined(part))
	      {
	         buffer.push("undefined");
	      }
	      else if (_.isString(part) || _.isNumber(part) || _.isBoolean(part))
	      {
	         buffer.push(part);
	      }
	      else if (part.toString)
	      {
	         buffer.push(part.toString());
	      }
	      else
	      {
	         buffer.push(JSON.stringify(part));
	      }
	   }

	   return buffer.join(" ");
	};
	
	function debug()
	{
	   log(levels.DEBUG, _capture.apply(null, arguments));
	}
	
	function info()
	{
	   log(levels.INFO, _capture.apply(null, arguments));
	}
	
	function warn()
	{
	   log(levels.WARN, _capture.apply(null, arguments));
	}
	
	function error()
	{
	   log(levels.ERROR, _capture.apply(null, arguments));
	}

	function _capture()
	{
	   var args = [];
	   for (var i = 0, len = arguments.length; i !== len; ++i)
	      args[i] = arguments[i];

	   return args;
   }
}(
 vitrium.log,
 _, 
 jQuery, 
 __globals__));
// script:viewer/events.js
(function(exports)
{
	"use strict";
	exports.setProperty = setProperty;
	
	/**
		@function setProperty
		If property value has been changed then sets the new value and emits an event throught the trigger method.
		The function must be called with this pointer.
		@arguments
			@req string propertyName
			@req value
			
			string eventName @default('"change:"+propertyName')
			function eqFunct @default('== operator comparator')
	*/
	function setProperty(propertyName, value, eventName, eqFunct)
	{
		if (typeof eqFunct  != "function")
		{
			eqFunct = eq;
		}
		
		if (!eq(this[propertyName],value))
		{
			this[propertyName] = value;
			
			if (!eventName)
			{
				eventName = "change:"+propertyName;
			}
			
			this.trigger(eventName, value, this);
		}
	}
	
	function eq(a, b)
	{
		return a == b;
	}
	
}(vitrium.events));

// script:viewer/font-loader.js
(function (exports,vitrium, $, document) {
	"use strict";
	exports.load = load;
	exports.free = free;
	
	var ASCII_PRINTABLE_CHARACTERS = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
	var canvas, ctx;
	function load(options)
	{
		var fonts = options.fonts;
		var okCallback = options.success || function(){};
		var errorCallback = options.error || function(){};
		var timeout = options.timeout || 1000 ;
		var checkInterval = options.checkInterval || 50 ;
		var additionalCharacters = options.additionalCharacters || "?";

		var noASCII = !!options.noASCII;
		var testString = noASCII ? additionalCharacters :( ASCII_PRINTABLE_CHARACTERS+additionalCharacters);
		
		if (!_.isArray(fonts))
		{
			throw new Error("Error: fonts must be specified!");
		}
		
		var div = $("<div class='vitrium-font-reference'>");
		var styleRules = new Array(fonts.length+2);
		//var style = document.styleSheets[0];
		styleRules[0]  = "<style type='text/css' data-document-font='true'>";
		for (var i = 0,len=fonts.length; i <len; ++i)
		{
			var font = fonts[i];			
			
			$("<div style='top:0px; left:0px; overflow:hidden; width: 1px; height: 1px; visibility: hidden; position:absolute; font-family:\""+font.key+"\"'>"+testString+"</div>").appendTo(div);	
			
			if ($.browser.chrome)
			{
				//it removes ugly warning from the developer console
				font.data = font.data.replace("application/x-font-woff", "application/font-woff");
			}
			
			//style.insertRule("@font-face { font-family: '"+ font.key +"'; src: url('"+ font.data+"');}", 0);
			styleRules[i+1] = "@font-face { font-family: '"+ font.key +"'; src: url('"+ font.data+"');}";
			
			//console.log(font.key);
		}
		styleRules[styleRules.length-1] = "</style>";
		if (fonts.length !== 0)
		{
		   $(document.head).append(styleRules.join("\n"));
		   div.appendTo("body");
		}
		
		

		/*
			HACK bellow checks if font is loaded
		*/
	
		if (!canvas)
		{
			canvas = document.createElement("canvas");
			ctx = canvas.getContext("2d");
		}
		 
		var baseFonts = ['monospace', 'sans-serif', 'serif'];
		var baseSize = 72;
	
		
		var fontWidths = new Array(baseFonts.length); 
		for (var i = 0; i < baseFonts.length; ++i)
		{
			ctx.font = baseSize+"px "+baseFonts[i];
			fontWidths[i] = ctx.measureText(testString).width ;
		}
		
		var fontsToCheck = new Array(fonts.length);
		
		var timeoutTimer;
		var checkFunct = checker;
		var checkTimer = setTimeout(checkFunct, checkInterval);
		
		timeoutTimer = setTimeout(function(){
			clearTimeout(checkTimer);			
			// this means that font has exactly same size as sans-serif font
			$(".vitrium-font-reference").remove();
			errorCallback(fontsToCheck);
		}, timeout);
		
		
		function checker()
		{	
			var allFontsReady = true;
			for (var i = 0; i < fonts.length; ++i)
			{
				var check = fontsToCheck[i];
				if (!check)
				{
					for (var fIdx = 0; fIdx < baseFonts.length; ++fIdx)
					{
						ctx.font = baseSize+"px '"+fonts[i].key+"',"+baseFonts[fIdx];
						var width = ctx.measureText(testString).width ;
						if (width > 0 && fontWidths[fIdx] != width)
						{
							check = true;
							fontsToCheck[i] = true;
						}
					}
				}
				
				if (!check)
				{
					allFontsReady = false;
				}
			}
			
			if (allFontsReady)
			{
				clearTimeout(timeoutTimer);
				$(".vitrium-font-reference").remove();
				okCallback();
			}
			else
			{
				checkTimer = setTimeout(checkFunct, checkInterval);
			}			
		}
	}
	
	function free()
	{
	   $("[data-document-font]").remove();
	}
}(
vitrium.fonts, 
vitrium, 
jQuery, 
document));
// script:viewer/intersect.js
(function (exports)
{
	"use strict";
	
	exports.intersect1D = intersect;
	exports.intSubstract1D = intSubstract;
	exports.IntInterval = IntInterval;
	exports.IntIntervalGroup = IntIntervalGroup;
	
	var max = Math.max;
	var min = Math.min;
	
	function intersect(x1, x2, y1, y2)
	{
		if (x2 >= y1 && y2 >= x1)
		{
			return { 
				start : max(x1, y1),
				end : min(x2, y2)
			};
		}
			
		return  null;
	};
	
	/**
		closed IntInterval <x1, x2> - (y1, y2) 
		numbers are suposed to be integers 
	*/
	function intSubstract(x1, x2, y1, y2)
	{
		if (y1 < x1 && y2 > x2)
		{
			//y |-----------------------|
			//x         |----------------|
			//the IntInterval is erased
			//continue;
			return null;
		}
		else if (y1 >= x1 && y2 <= x2)
		{
			//y 		          |--------|
			//x   |--------------------------------|
			
			// the IntInterval is splitted to <x1,y1> and <y2, x2>
			if (y1 !== y2 && y1+1 !== y2)
			{
				return [
					new IntInterval(x1,y1),
					new IntInterval(y2, x2)
				];
			}
			else
			{
				return [
					new IntInterval(x1,x2)					
				];
			}
		}
		else if (x1 <= y1 && x2 > y1)
		{
			//y                |-------------|
			//x	    |---------|
			return [
				new IntInterval(x1,y1)
			];
		}
		else if (y1 < x1 && y2 > x1)
		{
			//y          |------------------|
			//x                        |------------------|
			return [
				new IntInterval(y2,x2)
			];
		}
		else
		{
			return [
				new IntInterval(x1,x2)
			];
		}
	}
	
	exports.intersect1DFill = intersectFill;
	function intersectFill(x1, x2, y1, y2)
	{
	//	console.log(arguments);
		if (x2 >= y1 && y2 >= x1)
		{
			result.start = max(x1, y1);
			result.end = min(x2, y2);
			
			return result;
		}
			
		return  null;
	};
	
	function IntInterval(start, end)
	{
		this.start = start;
		this.end =  end;
	}
	
	IntInterval.prototype = {
		set : function(start, end)
		{
			this.start = start;
			this.end = end;
		},
		intersect : function(start, end)
		{
			return intersectFill(this, this.start, this.end, start, end) === null;
		},
		toString : function()
		{
			return "<"+this.start+";"+this.end+">";
		}
	};
	
	function IntIntervalGroup()
	{
		this.intervals = [];
	}
	
	IntIntervalGroup.prototype  = {
		add : function(start, end)
		{	
			this.intervals.push(new IntInterval(start, end));
		},
		addInterval : function(interval)
		{	
		  this.intervals.push(interval);
		},
		substract : function(y1, y2)
		{
			var intervals = this.intervals;
			var len = intervals.length;
			var newIntervals = new Array(len);
			var added = 0;
			
			for (var i = 0; i < len; ++i)
			{
				var interval =  intervals[i];
				var x1 = interval.start;
				var x2 = interval.end;
				
				if (y1 < x1 && y2 > x2)
				{
					//y |-----------------------|
					//x         |----------------|
					//the IntInterval is erased
					continue;
				}
				else if (y1 >= x1 && y2 <= x2)
				{
					//y 		          |--------|
					//x   |--------------------------------|
										
					if (y1 !== y2 && y1+1 !== y2)
					{
						// the IntInterval is splitted to <x1,y1> and <y2, x2>
						newIntervals[added++] = new IntInterval(x1,y1); 				
						interval.start = y2;
					}
				}
				else if (x1 <= y1 && x2 > y1)
				{
					//y                |-------------|
					//x	    |---------|
				  interval.end = y1;
				}
				else if (y1 < x1 && y2 > x1)
				{
					//y          |------------------|
					//x                        |------------------|
				  interval.start = y2;
				}
				
				newIntervals[added++] = interval;
			}
			
			newIntervals.length = added;
			this.intervals = newIntervals;
		},
		compact : function()
		{
			var intervals = this.intervals;
			intervals.sort(function(a, b)
			{
				return a.start - b.start;
			});
			
			var len = intervals.length;
			var newIntervals = new Array(len);
			var added = 0;
			
			var lastInterval = null;
			for (var i = 0; i < len; ++i)
			{
			  var interval = intervals[i];
				if (i !== 0 )
				{
				  if (interval.start <= lastInterval.end)
					{
				    lastInterval.end = interval.end;
					}
					else
					{
				    lastInterval = interval;
						newIntervals[added++] = lastInterval;
					}
				}
				else
				{
				  lastInterval = interval;
					newIntervals[added++] = lastInterval;
				}
			}
			
			newIntervals.length = added;
			this.intervals = newIntervals;
		}
//
	};
	
	
//
	
}(
vitrium.utils
));
// script:viewer/vitrium-document-model.js
/// <reference path="~/build.html" />

(function (exports, viewer, async, io, vitrium, _, $, Backbone, utils, window) {
  "use strict";
  
  var R_PAGE = 0;
  var R_TEXTINDEX =  1;
  var R_INFO = 2;
  var R_FONTS = 3;
  var R_DOCUMENT_OUTLINE = 4;
  
  exports.VitriumDocumentModel = VitriumDocumentModel;
  
  function VitriumDocumentModel(fileSystem, context)
  {    
    this.info = null;
    this.requests = [
      {},	//R_PAGE 
      {},	//R_TEXTINDEX 
      {},	//R_INFO 
      {}, 	//R_FONTS
      {} // R_DOCUMENT_OUTLINE 
    ] ;
      
    
    this.onPageLoaded = _.bind(onPageLoaded, this);
    this.onInfoLoaded = _.bind(onInfoLoaded, this);
    this.onTextIndexLoaded = _.bind(onTextIndexLoaded , this);
    
    this.intersectionResult = { start : 0, end  : 0};
    
    this.documentInfoOverride = {};
    this.documentInfoProperties = ["title", "author", "publisher"];
 
    this.fontsManager = new viewer.FontsManager(_.bind(function(pages){
      this.trigger("page-fonts:initialized", pages);
    }, this));
    this.packageFormatHandler = new viewer.VitriumDocumentPackageFormatManager(fileSystem, this.fontsManager);
    this.context = context;
    this.fileSystem = fileSystem;

    this.loadInfoFuture = null;
  }
  
  VitriumDocumentModel.prototype = {
      setDocumentInfo : function(override)
      {
        var properties = _.pick(override, this.documentInfoProperties)
        _.each(properties, function(val, key)
        {
          if (val === null) delete properties[key];
        });
        
        this.documentInfoOverride = properties;
        
        if (this.info !== null)        
        {
          var info = this.getDocumentInfo();
          this.trigger("change:documentInfo", info, this);
          var cache = this.context.cacheManager.openCache(this.context.url, function ()
          {
            cache.storeGlobalDocumentInfo(info);
          }, function () { /*ignore error*/ });
        }
        
      },
      getDocumentInfo : function()
      {
        if (this.info === null)
        {
          return null;
        }
         return _.extend(_.pick(this.info, this.documentInfoProperties), this.documentInfoOverride);
      },
      load : function()
      {		
        if (!this.requests.loadInfo)
        {
          loadingBegin.call(this, R_INFO, 1, 1);

          var future = this.loadInfoFuture = this.packageFormatHandler.loadInfo();
          future.then(this.onInfoLoaded)
            .catchError(createLoadingErrorCallback.call(this, R_INFO, 1))
            .whenComplete(_.bind(function ()
            {
              this.loadInfoFuture = null;
            }, this));
        }
      },
      requestPage : function(page)
      {
        loadingBegin.call(this, R_PAGE, page, 1);
    
        this.packageFormatHandler.loadPage({
          idx: page,
          success :  this.onPageLoaded,
          error : createLoadingErrorCallback.call(this, R_PAGE, page)
        });
      },
      requestTextIndexFileForPage: 	function(page)
      {
        loadingBegin.call(this, R_TEXTINDEX, page, 1);
        
        var cancel = this.packageFormatHandler.loadTextIndex({
          idx: page,
          success :  this.onTextIndexLoaded,
          error : createLoadingErrorCallback.call(this, R_TEXTINDEX, page)
        });
        var self = this;
        return function()
        {
          cancel();
          loadingEnd.call(self,  R_TEXTINDEX);
        };
      },
      freePage : function(page)
      {
        this.packageFormatHandler.freePage(page);
        loadingEnd.call(this, R_PAGE, page);
      },
      freePageRange : function(start, end)
      {
        var dp = this.packageFormatHandler;
        var ir = this.intersectionResult;
      
        for (var i = start; i <= end;++i)
        {
          dp.freePage(i);
          loadingEnd.call(this, R_PAGE, i);
        }
      },
      destroy : function()
      {
        //$(window).off("online", this.onConnectionStatusChanged).off("offline", this.onConnectionStatusChanged);	
        this.packageFormatHandler.destroy();
        if (this.loadInfoFuture !== null) this.loadInfoFuture.cancel();
      },
      fileProvider: function()
      {
        // TODO: rename to packageFormatHandler
        return this.packageFormatHandler;
      },
      getTargetPage : 	function(link)
      {
        var page = this.info.linkTargets[link];
        return _.isUndefined(page) ? null : page;
      },
      isAnyRequest : 	function()
      {
        var req = this.requests;
        var empty = true;
        var isEmpty = _.isEmpty;
        
        for (var i = 0, len=req.length; i < len && empty;++i)
        {
          empty = isEmpty(req[i]);
        }
        
        return !empty;
     },
     getContext : function()
     {  
        return this.context;
     },
     downloadToOfflineStorage: function()
     {
       var finished = false;
       var requests = [];

       function cleanUpCallback()
       {
         if (!finished)
         {
           _.each(requests, function (r) { r.cancel(); });
           finished = true;

           cache.erase();
         }
       }

       var completer = new async.ProgressCompleter(cleanUpCallback);
       completer.future.then(function () { finished = true; }).catchError(cleanUpCallback);
       var errorCallback = _.bind(completer.fail, completer);

       var self = this;
       var ctx = this.context;
       var fileSystem = this.fileSystem;
       var remoteFileSystem = this.fileSystem.remoteFileSystem;
       var formatHandler = this.packageFormatHandler;

       var cache = ctx.cacheManager.openCache(ctx.url, function ()
       {
         if (finished) return;

         cache.setDownloadState(io.CACHE_STATE.DOWNLOADING, function ()
         {
           if (finished) return;

           cache.listStoredItems(function (items)
           {
             if (finished) return;

             var downloadFiles = formatHandler.listFilesForDownload();
             var entries = fileSystem.entries;

             var notCached = [];
             var totalSize = 0;
             var downloadedSize = 0;
             _.each(downloadFiles, function (file)
             {
               if (items.indexOf(file) === -1)
               {
                 notCached.push(file);
                 var entry = _.find(entries, function (e) { return e.filename === file; });
                 totalSize += entry.compressedSize;
               }
             });

             if (items.indexOf("||info||") === -1)
             {
               //I don't have cancel this
               remoteFileSystem.loadFileSystemInfo().then(function (info)
               {
                 cache.storeFileSystemInfo(info, function ()
                 {
                 }, errorCallback);
               })
               .catchError(errorCallback);
             }

             var retrys = 4;
             
             _.each(notCached, function (file)
             {
               var r = remoteFileSystem.read(file);
               r.then(function onData(data)
               {
                  if (finished) return;

                   cache.storeFile(file, data, function ()
                   {
                     if (finished) return;

                     retrys = 4;
                     --numberOfRequests;
                     if (numberOfRequests === 0)
                     {
                       var realSize = 0;
                       _.each(entries, function (e)
                       {
                         if (downloadFiles.indexOf(e.filename) !== -1)
                         {
                           realSize += e.uncompressedSize;
                         }
                       });

                       var r = formatHandler.loadFirstPageThumbnail().then(function (thumbnail)
                       {
                         var documentInfo = self.getDocumentInfo();
                         documentInfo.thumb = thumbnail;
                         documentInfo.pages = formatHandler.getNumberOfPages();
                         documentInfo.location = window.location.toString();

                         cache.setDownloadState(io.CACHE_STATE.DOWNLOADED, function ()
                         {
                           if (finished) return;

                           completer.progress(100);
                           completer.complete();

                         },
                          errorCallback,
                          {
                            documentInfo: documentInfo,
                            size: realSize
                          });
                       })
                       .catchError(errorCallback);
                       requests.push(r);
                     }
                     else
                     {
                       var entry = _.find(entries, function (e) { return e.filename === file; });
                       downloadedSize += entry.compressedSize;

                       if (numberOfRequests > 1)
                       {
                         var progress = Math.floor(downloadedSize / totalSize * 100);
                         completer.progress(progress);
                       }
                     }
                   },
                   function (e)
                   {
                     --retrys;
                     if (retrys === 0)
                     {
                       errorCallback(e);
                     }
                     else
                     {
                       onData(data);
                     }
                   });
               })
               .catchError(errorCallback);
               requests.push(r);
             });

             var numberOfRequests = requests.length;

           }, errorCallback);
         }, errorCallback, null);
       }, errorCallback);

       return completer.future;
     }
  };
  _.extend(VitriumDocumentModel.prototype, Backbone.Events);
  _.extend(VitriumDocumentModel.prototype, vitrium.events);
    
  function onTextIndexLoaded(textIndex, request)
  {
    var idx = request.userdata.idx;
    this.trigger("textindex:loaded",  idx,  textIndex, this);
    loadingEnd.call(this,  R_TEXTINDEX, idx);
  }
  
  function onInfoLoaded(info)
  {
    this.info = info;
    this.trigger("info:loaded", info, this);
    this.trigger("change:documentInfo", this.getDocumentInfo(), this);
    loadingEnd.call(this, R_INFO, 1);
    loadingBegin.call(this, R_DOCUMENT_OUTLINE, 1, 1);

    this.packageFormatHandler.loadDocumentOutline({
      complete: _.bind(onDocumentOutlineCompleted, this),
      error: createLoadingErrorCallback.call(this, R_DOCUMENT_OUTLINE, 1)
    });
  }

  function onDocumentOutlineCompleted(files)
  {
    loadingEnd.call(this, R_DOCUMENT_OUTLINE, 1);

    if (files.length > 1)
    {
      vitrium.log.error("Document contains more that one DocumentOutline.");
    }
    else if (files.length == 1)
    {
      this.trigger("document-outline:loaded", files[0].data);
    }
    else
    {
      vitrium.log.debug("There is no DocumentOutline.");
    }
  }
  
 
 
      
  function onPageLoaded(idx, state, pageData)
  {
    this.trigger("page:loaded",  idx, pageData, state, this);
    
    if (state === 3)
    {
      loadingEnd.call(this, R_PAGE, idx);
    }
  }
    
  
  function loadingBegin(className, name, request)
  {
    var isRequest = this.isAnyRequest();
    this.requests[className][name] = request;
        
    if (!isRequest)
    {
      this.trigger("loading:begin", this);
    }
  }
  
  function loadingEnd(className, name)
  {
    delete this.requests[className][name] ;
    
    if (!this.isAnyRequest())
    {
      this.trigger("loading:end", this);
    }
  }
  
  function createLoadingErrorCallback(className, name)
  {
    return _.bind(function(error, state)
    {
      loadingEnd.call(this, className, name);
      
      if (error && error.stack)
      {
        vitrium.log.error(error.stack);
      }
      
      if (state !== -2)
      {
        this.trigger("loading:error", className, name, error, state, this);
      }
      
    }, this);
  }
  
}(
vitrium.viewer,
vitrium.viewer,
vitrium.async,
vitrium.io,
vitrium, 
_, 
jQuery, 
Backbone, 
vitrium.utils, 
__globals__));
// script:viewer/string-priority-property.js
(function(exports, _)
{
  "use strict";
  
  exports.StringPriorityProperty = StringPriorityProperty;
  
  function StringPriorityProperty()
  {
    this.accessors = [];
  }
  
  StringPriorityProperty.prototype = {
    val : function()
    {
      var a = this.accessors;
      var val = null;
      for (var i = 0, len=a.length; i < len; ++i)
      {
        var _val = this.accessors[i].callback();
        if (_.isString(_val))
        {
          val = _val;
          break;
        }
      }
      return val;      
    },
    createAccessor : function(priority, callback)
    {
      this.accessors.push(new  Accessor(priority, callback));
      this.accessors.sort(priorityAccessorComparator);
    }
  };
  
  function Accessor(priority, callback)
  {
    this.priority = priority;
    this.callback = callback;    
  }
  
  /**
    It sorts in descending order
  */
  function priorityAccessorComparator(aa, ab)
  {
    var a  = aa.priority;
    var b = ab.priority;
    if (a > b)
    {
      return -1;
    }
    else if (a < b)
    {
      return 1;
    }
    else
    {
      return 0;
    }
  }
  
}
(vitrium.utils, _));
// script:viewer/io/codecs/utf8-decoder.js
/// <reference path="~/build.html" />

(function (exports, log, _, global) {
	"use strict";
	
	var blobAPISupported = global.Blob && global.FileReader;
	var Utf8JSONDecoder;
	var Utf8Decoder;
	

	Utf8JSONDecoder = function(len)
	{
		Utf8Decoder.call(this, len);
	}
		
	Utf8Decoder = function(len) {
		if (!len)
		{
			len = 1000;
		}
			
			this.tmp_arr = null; 
			this.len = len;
			this.i = 0;
			this.ac = 0;
			this.c1 = 0;
			this.c2 = 0;
			this.c3 = 0;
	}

	if (!!global.ArrayBuffer)
	{
		
				var UDP = Utf8Decoder.prototype;
				UDP.init = 	function (callback) {
					this.tmp_arr = new Array(this.len);
					callback();
				};
				
				UDP.free = function()
				{
					this.tmp_arr = null;
				};
				
				UDP.writeUint8Array = function(arrays, callback)
				{
					if (this.tmp_arr === null)
					{
						return;
					}

					for (var i = 0, len = arrays.length; i < len; ++i)
					{
						this.decodeUTF8(arrays[i]);	
					}
					callback();
				};
				
				UDP.getData = function(callback, onerror)
				{
					callback( this.tmp_arr.join("") );
				};
				
				UDP.decodeUTF8 =function(array) {
					var ch = String.fromCharCode;
					var i = 0;
					var ac = this.ac;
					var c1 = this.c1;
					var c2 = this.c2;
					var c3 = this.c3;
					
					var tmp_arr = this.tmp_arr;
					var len = array.length;
					
					
					for (i = 0; i < len; ++i) 
					{
						if (c1 == 0)
						{
							c1 = array[i];
						}
						else if (c1 > 191 && c2 === 0)
						{
							c2 = array[i];
						}
						else 
						{
							c3 = array[i];
						}
						
						var writeChar = null;
						
						if (c1 < 128) 
						{
							writeChar = c1;
						} 
						else if (c1 > 191 && c1 < 224 && c2 > 0) 
						{
							writeChar = ((c1 & 31) << 6) | (c2 & 63);
						} else if (c3 > 0) {
							writeChar = ((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63);
						}
						
						
						if (writeChar)
						{
							c1 = 0;
							c2 = 0;
							c3 = 0;
							tmp_arr[ac++]  = ch(writeChar);				
						}
					}

					this.ac = ac;
					this.c1 = c1;
					this.c2 = c2;
					this.c3 = c3;
				};
					
				_.extend(Utf8JSONDecoder.prototype, UDP);
				Utf8JSONDecoder.prototype.getData = function(callback)
				{
						callback(JSON.parse(this.tmp_arr.join("")));	
				};
				
		}
		else
		{
				var UDP = Utf8Decoder.prototype;
				UDP.init = function(callback) 
				{
					this.tmp_arr = new Array(this.len);
					callback();
				};
				
				UDP.free = function()
				{
					this.tmp_arr = null;
				};
				
				UDP.writeUint8Array = function(arrays, callback) 
				{
					if (this.tmp_arr === null)
					{
						return;
					}
				
					for (var i = 0, len = arrays.length; i < len; ++i)
					{
						this.decodeUTF8(arrays[i]);	
					}
					callback();
				};
				
				UDP.getData = function(callback, onerror) 
				{	
					callback(this.tmp_arr.join(''));
				};
				
				UDP.decodeUTF8 = function(array) {
						var ch = String.fromCharCode;

				var i = 0;
				var ac = this.ac;
				var c1 = this.c1;
				var c2 = this.c2;
				var c3 = this.c3;
				
				var tmp_arr = this.tmp_arr;
				var len = array.length;
				
				
					if (array.readNumber)
					{
						for (i = 0; i < len; ++i) 
						{
							if (c1 == 0)
							{
								c1 =  array.readNumber(1,i);
							}
							else if (c1 > 191 && c2 === 0)
							{
								c2 = array.readNumber(1,i);
							}
							else 
							{
								c3 =array.readNumber(1,i);
							}
							
							var writeChar = null;
							
							if (c1 < 128) 
							{
								writeChar = c1;
							} 
							else if (c1 > 191 && c1 < 224 && c2 > 0) 
							{
								writeChar = ((c1 & 31) << 6) | (c2 & 63);
							} else if (c3 > 0) {
								writeChar = ((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63);
							}
							
							
							if (writeChar)
							{
								c1 = 0;
								c2 = 0;
								c3 = 0;
								tmp_arr[ac++]  = ch(writeChar);
								
								/*if (tmp_arr[tmp_arr.length - 1] === "{" && tmp_arr[tmp_arr.length - 2] === "}")
								{
									console.log("wrong!!!");
								}*/
					
							}
						}
					}
					else
					{	
						for (i = 0; i < len; ++i) 
						{
							if (c1 == 0)
							{
								c1 =  array[i];
							}
							else if (c1 > 191 && c2 === 0)
							{
								c2 = array[i];
							}
							else 
							{
								c3 =array[i];
							}
							
							var writeChar = null;
							
							if (c1 < 128) 
							{
								writeChar = c1;
							} 
							else if (c1 > 191 && c1 < 224 && c2 > 0) 
							{
								writeChar = ((c1 & 31) << 6) | (c2 & 63);
							} else if (c3 > 0) {
								writeChar = ((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63);
							}
							
							
							if (writeChar)
							{
								c1 = 0;
								c2 = 0;
								c3 = 0;
								tmp_arr[ac++]  = ch(writeChar);
								
								/*if (tmp_arr[tmp_arr.length - 1] === "{" && tmp_arr[tmp_arr.length - 2] === "}")
								{
									console.log("wrong!!!");
								}*/
					
							}
						}
				}

				this.ac = ac;
				this.c1 = c1;
				this.c2 = c2;
				this.c3 = c3;
			};
			
			_.extend(Utf8JSONDecoder.prototype, UDP);
			Utf8JSONDecoder.prototype.getData = function(callback)
			{
				callback(JSON.parse(this.tmp_arr.join('')));
			};	
		}
	
	
	var SimpleUTF8Decoder = Utf8Decoder;
	
	if (blobAPISupported)
	{
		Utf8JSONDecoder = function(len)
		{
			Utf8Decoder.call(this ,length);
		}
		
		Utf8Decoder = function(len) {
			this.parts = null;
		}
		
		Utf8Decoder.prototype = {
			init : function(callback)
			{
				this.parts = [];
				callback();
			},
			free : function()
			{
				this.parts = null;
			},
			writeUint8Array : function(arrays, callback) 
			{
				var parts = this.parts;
				for (var i = 0, len = arrays.length; i < len; ++i)
				{
					parts.push(arrays[i].buffer);	
				}
				callback();
			},
			decodeUTF8 : function(array)
			{
				this.parts.push(array.buffer);	
			},
			getData : function(callback)
			{
				var b = new global.Blob(this.parts, {type : "text/plain"});
				var reader =new global.FileReader();
				
				reader.onload = function()
				{
					callback(this.result);
					this.onload = null;
					this.onerror = null;
					b = null;
					reader = null;
				};
				
				reader.onerror = function()
				{
					callback(null);
					this.onload = null;
					this.onerror = null;
					b = null;
					reader = null;
				};
				
				reader.readAsText(b, "UTF-8");
			}
		}
		
		_.extend(Utf8JSONDecoder.prototype, Utf8Decoder.prototype);
		Utf8JSONDecoder.prototype.getDataSuper = Utf8JSONDecoder.prototype.getData;
		Utf8JSONDecoder.prototype.getData = function(callback)
		{
			this.getDataSuper(function(data){ callback(JSON.parse(data)); });
		};	
		
	}
	
	
	_.extend(exports, {
		Utf8Decoder :  Utf8Decoder,
		Utf8JSONDecoder : Utf8JSONDecoder,
		SimpleUTF8Decoder : SimpleUTF8Decoder
	});	
}
(
vitrium.bin,
vitrium.log,
_, 
__globals__
));
// script:viewer/io/codecs/utf8-codec.js
/// <reference path="~/build.html" />

(function (exports, bin, async, global) {
   "use strict";

   var blobAPISupported = global.Blob && global.FileReader;

   var utf8 = exports.utf8 = { encode: null, decode: null };
   utf8.decode = _decode;
   utf8.encode = blobAPISupported ? _encode_with_blob : _encode_deffered;

   function _decode(bytes)
   {
      var completer = new async.Completer();
      
      var decoder = new bin.Utf8Decoder(bytes.length);

      decoder.init(function () {
         setTimeout(function () {
            decoder.decodeUTF8(bytes);
            decoder.getData(function (str) {
               if (str === null) completer.fail();
               else completer.complete(str);
            })
         }, 0);
      });

      return completer.future;
   }

   _decode.true_async = blobAPISupported;


   function _encode_with_blob(str)
   {      
      var completer = new async.Completer();

      var blob = new Blob([str], { type: "text/plain;charset=UTF-8" });
      var reader = new FileReader();

      reader.onerror = function () {
         completer.fail(reader.error);
      };

      reader.onload = function () {
         completer.complete(new Uint8Array(reader.result))
      };

      reader.readAsArrayBuffer(blob);

      return completer.future;
   }
   _encode_with_blob.true_async = true;

   function _encode_deffered(str)
   {
      return async.callDefered(function () {
         return _encode(str);
      });
   }
   _encode_deffered.true_async = false;

   function _encode(str) {
      var capacity = _count_utf8_bytes(str);
      var result = new Uint8Array(capacity);
      var len = str.length;
      var p = 0;
      var code;
      var i;
      
      for (i = 0; i !== len; ++i) {
         code = str.charCodeAt(i);
         if (code <= 0x7f)
         {
            result[p++] = code;
         }
         else if (code <= 0x7ff)
         {                         // 2 bytes                     
            result[p++] =  0xc0 | (code >>> 6 & 0x1f);
            result[p++] =  0x80 | (code & 0x3f);
         }
         else if (code <= 0xd700 || code >= 0xe000)
         {    
            result[p++] = 0xe0 | (code >>> 12 & 0x0f);
            result[p++] = 0x80 | (code >>> 6 & 0x3f);
            result[p++] = 0x80 | (code & 0x3f);
         }
         else
         {                                            // 4 bytes, surrogate pair
            code = (((code - 0xd800) << 10) | (str.charCodeAt(++i) - 0xdc00)) + 0x10000;
            result[p++] = 0xf0 | (code >>> 18 & 0x07);
            result[p++] = 0x80 | (code >>> 12 & 0x3f);
            result[p++] = 0x80 | (code >>> 6 & 0x3f); 
            result[p++] = 0x80 | (code & 0x3f);
         }
      }
      return result;
   }

   function _count_utf8_bytes(str) {
      var len = str.length;
      var result = 0;
      var code;
      var i;
      
      for (i = 0; i !== len; ++i) {
         code = str.charCodeAt(i);
         if (code <= 0x7f) {
            ++result;
         }
         else if (code <= 0x7ff) {
            result += 2;
         } else if (code <= 0xd700 || code >= 0xe000) {
            result += 3;
         } else {                                            // 4 bytes, surrogate pair
            result += 4;
         }
      }
      return result;
   }
}
(vitrium.codec,
 vitrium.bin,
 vitrium.async,
 __globals__
));

// script:viewer/io/codecs/base64-str-to-arr.js
var global = self || window;
(function(global)
{
   var Base64Binary = {
   _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

   /* will return a  Uint8Array type */
   decodeArrayBuffer: function(input) {
      var bytes = (input.length/4) * 3;
      var ab = new ArrayBuffer(bytes);
      return Base64Binary.decode(input, ab);	
   },

   decode: function(input, arrayBuffer) {
      var _keyStr  = Base64Binary._keyStr;
      //get last chars to see if are valid
      var lkey1 = _keyStr.indexOf(input.charAt(input.length-1));		 
      var lkey2 = _keyStr.indexOf(input.charAt(input.length-2));		 

      var bytes = (input.length/4) * 3;
      if (lkey1 == 64) bytes--; //padding chars, so skip
      if (lkey2 == 64) bytes--; //padding chars, so skip

      var uarray;
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i = 0;
      var j = 0;

      if (arrayBuffer)
         uarray = new Uint8Array(arrayBuffer);
      else
         uarray = new Uint8Array(bytes);

      //input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

      for (i=0; i<bytes; i+=3) {	
         //get the 3 octects in 4 ascii chars
         enc1 = _keyStr.indexOf(input.charAt(j++));
         enc2 = _keyStr.indexOf(input.charAt(j++));
         enc3 = _keyStr.indexOf(input.charAt(j++));
         enc4 = _keyStr.indexOf(input.charAt(j++));

         chr1 = (enc1 << 2) | (enc2 >> 4);
         chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
         chr3 = ((enc3 & 3) << 6) | enc4;

         uarray[i] = chr1;			
         if (enc3 != 64) uarray[i+1] = chr2;
         if (enc4 != 64) uarray[i+2] = chr3;
      }
      return uarray;	
   }
   };

   global["Base64Binary"]  = Base64Binary;

}(global));
// script:viewer/io/codecs/base64-codec.js
   /// <reference path="~/build.html" />

(function (exports, async, global) {
   "use strict";
   var blobAPISupported = global.Blob && global.FileReader;
   var atobSupported = !!global.atob;
   var BLOB_TYPE = {type: "application/binary"};

   function _atob_decode(str) {
      return async.callDefered(function () {
         var binary_string = global.atob(str);
         var len = binary_string.length;
         var bytes = new Uint8Array(len);
         for (var i = 0; i !== len; ++i) {
            bytes[i] = binary_string.charCodeAt(i);
         }
         return bytes;
      });
   }
   _atob_decode.true_async = false;

   function _decode(str)
   {
      return async.callDefered(function () {
         return global.Base64Binary.decode(str);
      });
   }

   _decode.true_async = false;


   if (blobAPISupported) {
      
      exports.base64 = (function () {
         var BASE64_SEP = "base64,";
         function _encode(bytes)
         {
            var completer = new async.Completer();
            var blob = new Blob([bytes], BLOB_TYPE);

            var reader = new FileReader();
            reader.onerror = function () {
               completer.fail();
            };

            reader.onload = function () {
               var url = reader.result;

               var idx = url.indexOf(BASE64_SEP);
               if (idx === -1) completer.fail();
               else {
                  var base64Data = url.substring(idx + BASE64_SEP.length, url.length);
                  completer.complete(base64Data);
               }
            };

            reader.readAsDataURL(blob);
            return completer.future;
         }
         _encode.true_async = true;

         return {
            encode : _encode,
            decode : atobSupported ? _atob_decode : _decode
         };
      }());
   }
   else
   {
      exports.base64 = (function () {
         function _encode(bytes)
         {
               var e    = '';
               var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
 
               var byteLength    = bytes.length;
               var byteRemainder = byteLength % 3;
               var mainLength = byteLength - byteRemainder;
 
               var a, b, c, d;
               var chunk;
 
               // Main loop deals with bytes in chunks of 3
               for (var i = 0; i < mainLength; i = i + 3) {
                  // Combine the three bytes into a single integer
                  chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
 
                  // Use bitmasks to extract 6-bit segments from the triplet
                  a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
                  b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12
                  c = (chunk & 4032) >> 6;// 4032     = (2^6 - 1) << 6
                  d = chunk & 63;          // 63       = 2^6 - 1
 
                  // Convert the raw binary segments to the appropriate ASCII encoding
                  e += encodings[a] + encodings[b] + encodings[c] + encodings[d];
               }
 
               // Deal with the remaining bytes and padding
               if (byteRemainder == 1) {
                  chunk = bytes[mainLength];
 
                  a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2
 
                  // Set the 4 least significant bits to zero
                  b = (chunk & 3) << 4; // 3   = 2^2 - 1
 
                  e += encodings[a] + encodings[b] + '==';
               } else if (byteRemainder == 2) {
                  chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];
 
                  a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
                  b = (chunk & 1008) >> 4;// 1008  = (2^6 - 1) << 4
 
                  // Set the 2 least significant bits to zero
                  c = (chunk & 15) << 2; // 15    = 2^4 - 1
 
                  e += encodings[a] + encodings[b] + encodings[c] + '=';
               }
  
               return e;
         }

         function _encode_deffered (bytes) { return async.callDefered(function () { return _encode(bytes); }); }
         _encode_deffered.true_async = false;

         return {
            encode: _encode_deffered,
            decode: atobSupported ? _atob_decode : _decode
         }
      }());
   }  
}
(vitrium.codec,
vitrium.async,
__globals__));

// script:viewer/io/crypto/jsbn.js
// Copyright (c) 2005  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.

// Basic JavaScript BN library - subset useful for RSA encryption.

// Bits per digit

var BigInteger = (function() {
"use strict";
var dbits;

// JavaScript engine analysis
var canary = 0xdeadbeefcafe;
var j_lm = ((canary&0xffffff)==0xefcafe);

// (public) Constructor
function BigInteger(a,b,c) {
  if(a != null)
    if("number" == typeof a) this.fromNumber(a,b,c);
    else if(b == null && "string" != typeof a) this.fromString(a,256);
    else this.fromString(a,b);
}

// return new, unset BigInteger
function nbi() { return new BigInteger(null); }

// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.

// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i,x,w,j,c,n) {
  while(--n >= 0) {
    var v = x*this[i++]+w[j]+c;
    c = Math.floor(v/0x4000000);
    w[j++] = v&0x3ffffff;
  }
  return c;
}
// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i,x,w,j,c,n) {
  var xl = x&0x7fff, xh = x>>15;
  while(--n >= 0) {
    var l = this[i]&0x7fff;
    var h = this[i++]>>15;
    var m = xh*l+h*xl;
    l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
    w[j++] = l&0x3fffffff;
  }
  return c;
}
// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i,x,w,j,c,n) {
  var xl = x&0x3fff, xh = x>>14;
  while(--n >= 0) {
    var l = this[i]&0x3fff;
    var h = this[i++]>>14;
    var m = xh*l+h*xl;
    l = xl*l+((m&0x3fff)<<14)+w[j]+c;
    c = (l>>28)+(m>>14)+xh*h;
    w[j++] = l&0xfffffff;
  }
  return c;
}
if(j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
  BigInteger.prototype.am = am2;
  dbits = 30;
}
else if(j_lm && (navigator.appName != "Netscape")) {
  BigInteger.prototype.am = am1;
  dbits = 26;
}
else { // Mozilla/Netscape seems to prefer am3
  BigInteger.prototype.am = am3;
  dbits = 28;
}

BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = ((1<<dbits)-1);
BigInteger.prototype.DV = (1<<dbits);

var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2,BI_FP);
BigInteger.prototype.F1 = BI_FP-dbits;
BigInteger.prototype.F2 = 2*dbits-BI_FP;

// Digit conversions
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr,vv;
rr = "0".charCodeAt(0);
for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

function int2char(n) { return BI_RM.charAt(n); }
function intAt(s,i) {
  var c = BI_RC[s.charCodeAt(i)];
  return (c==null)?-1:c;
}

// (protected) copy this to r
function bnpCopyTo(r) {
  for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
  r.t = this.t;
  r.s = this.s;
}

// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x) {
  this.t = 1;
  this.s = (x<0)?-1:0;
  if(x > 0) this[0] = x;
  else if(x < -1) this[0] = x+this.DV;
  else this.t = 0;
}

// return bigint initialized to value
function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

// (protected) set from string and radix
function bnpFromString(s,b) {
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 256) k = 8; // byte array
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else { this.fromRadix(s,b); return; }
  this.t = 0;
  this.s = 0;
  var i = s.length, mi = false, sh = 0;
  while(--i >= 0) {
    var x = (k==8)?s[i]&0xff:intAt(s,i);
    if(x < 0) {
      if(s.charAt(i) == "-") mi = true;
      continue;
    }
    mi = false;
    if(sh == 0)
      this[this.t++] = x;
    else if(sh+k > this.DB) {
      this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
      this[this.t++] = (x>>(this.DB-sh));
    }
    else
      this[this.t-1] |= x<<sh;
    sh += k;
    if(sh >= this.DB) sh -= this.DB;
  }
  if(k == 8 && (s[0]&0x80) != 0) {
    this.s = -1;
    if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
  }
  this.clamp();
  if(mi) BigInteger.ZERO.subTo(this,this);
}

// (protected) clamp off excess high words
function bnpClamp() {
  var c = this.s&this.DM;
  while(this.t > 0 && this[this.t-1] == c) --this.t;
}

// (public) return string representation in given radix
function bnToString(b) {
  if(this.s < 0) return "-"+this.negate().toString(b);
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else return this.toRadix(b);
  var km = (1<<k)-1, d, m = false, r = "", i = this.t;
  var p = this.DB-(i*this.DB)%k;
  if(i-- > 0) {
    if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
    while(i >= 0) {
      if(p < k) {
        d = (this[i]&((1<<p)-1))<<(k-p);
        d |= this[--i]>>(p+=this.DB-k);
      }
      else {
        d = (this[i]>>(p-=k))&km;
        if(p <= 0) { p += this.DB; --i; }
      }
      if(d > 0) m = true;
      if(m) r += int2char(d);
    }
  }
  return m?r:"0";
}

// (public) -this
function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

// (public) |this|
function bnAbs() { return (this.s<0)?this.negate():this; }

// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a) {
  var r = this.s-a.s;
  if(r != 0) return r;
  var i = this.t;
  r = i-a.t;
  if(r != 0) return (this.s<0)?-r:r;
  while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
  return 0;
}

// returns bit length of the integer x
function nbits(x) {
  var r = 1, t;
  if((t=x>>>16) != 0) { x = t; r += 16; }
  if((t=x>>8) != 0) { x = t; r += 8; }
  if((t=x>>4) != 0) { x = t; r += 4; }
  if((t=x>>2) != 0) { x = t; r += 2; }
  if((t=x>>1) != 0) { x = t; r += 1; }
  return r;
}

// (public) return the number of bits in "this"
function bnBitLength() {
  if(this.t <= 0) return 0;
  return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
}

// (protected) r = this << n*DB
function bnpDLShiftTo(n,r) {
  var i;
  for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
  for(i = n-1; i >= 0; --i) r[i] = 0;
  r.t = this.t+n;
  r.s = this.s;
}

// (protected) r = this >> n*DB
function bnpDRShiftTo(n,r) {
  for(var i = n; i < this.t; ++i) r[i-n] = this[i];
  r.t = Math.max(this.t-n,0);
  r.s = this.s;
}

// (protected) r = this << n
function bnpLShiftTo(n,r) {
  var bs = n%this.DB;
  var cbs = this.DB-bs;
  var bm = (1<<cbs)-1;
  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
  for(i = this.t-1; i >= 0; --i) {
    r[i+ds+1] = (this[i]>>cbs)|c;
    c = (this[i]&bm)<<bs;
  }
  for(i = ds-1; i >= 0; --i) r[i] = 0;
  r[ds] = c;
  r.t = this.t+ds+1;
  r.s = this.s;
  r.clamp();
}

// (protected) r = this >> n
function bnpRShiftTo(n,r) {
  r.s = this.s;
  var ds = Math.floor(n/this.DB);
  if(ds >= this.t) { r.t = 0; return; }
  var bs = n%this.DB;
  var cbs = this.DB-bs;
  var bm = (1<<bs)-1;
  r[0] = this[ds]>>bs;
  for(var i = ds+1; i < this.t; ++i) {
    r[i-ds-1] |= (this[i]&bm)<<cbs;
    r[i-ds] = this[i]>>bs;
  }
  if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
  r.t = this.t-ds;
  r.clamp();
}

// (protected) r = this - a
function bnpSubTo(a,r) {
  var i = 0, c = 0, m = Math.min(a.t,this.t);
  while(i < m) {
    c += this[i]-a[i];
    r[i++] = c&this.DM;
    c >>= this.DB;
  }
  if(a.t < this.t) {
    c -= a.s;
    while(i < this.t) {
      c += this[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    c += this.s;
  }
  else {
    c += this.s;
    while(i < a.t) {
      c -= a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    c -= a.s;
  }
  r.s = (c<0)?-1:0;
  if(c < -1) r[i++] = this.DV+c;
  else if(c > 0) r[i++] = c;
  r.t = i;
  r.clamp();
}

// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a,r) {
  var x = this.abs(), y = a.abs();
  var i = x.t;
  r.t = i+y.t;
  while(--i >= 0) r[i] = 0;
  for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
  r.s = 0;
  r.clamp();
  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
}

// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r) {
  var x = this.abs();
  var i = r.t = 2*x.t;
  while(--i >= 0) r[i] = 0;
  for(i = 0; i < x.t-1; ++i) {
    var c = x.am(i,x[i],r,2*i,0,1);
    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
      r[i+x.t] -= x.DV;
      r[i+x.t+1] = 1;
    }
  }
  if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
  r.s = 0;
  r.clamp();
}

// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m,q,r) {
  var pm = m.abs();
  if(pm.t <= 0) return;
  var pt = this.abs();
  if(pt.t < pm.t) {
    if(q != null) q.fromInt(0);
    if(r != null) this.copyTo(r);
    return;
  }
  if(r == null) r = nbi();
  var y = nbi(), ts = this.s, ms = m.s;
  var nsh = this.DB-nbits(pm[pm.t-1]);	// normalize modulus
  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
  else { pm.copyTo(y); pt.copyTo(r); }
  var ys = y.t;
  var y0 = y[ys-1];
  if(y0 == 0) return;
  var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
  var i = r.t, j = i-ys, t = (q==null)?nbi():q;
  y.dlShiftTo(j,t);
  if(r.compareTo(t) >= 0) {
    r[r.t++] = 1;
    r.subTo(t,r);
  }
  BigInteger.ONE.dlShiftTo(ys,t);
  t.subTo(y,y);	// "negative" y so we can replace sub with am later
  while(y.t < ys) y[y.t++] = 0;
  while(--j >= 0) {
    // Estimate quotient digit
    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {	// Try it out
      y.dlShiftTo(j,t);
      r.subTo(t,r);
      while(r[i] < --qd) r.subTo(t,r);
    }
  }
  if(q != null) {
    r.drShiftTo(ys,q);
    if(ts != ms) BigInteger.ZERO.subTo(q,q);
  }
  r.t = ys;
  r.clamp();
  if(nsh > 0) r.rShiftTo(nsh,r);	// Denormalize remainder
  if(ts < 0) BigInteger.ZERO.subTo(r,r);
}

// (public) this mod a
function bnMod(a) {
  var r = nbi();
  this.abs().divRemTo(a,null,r);
  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
  return r;
}

// Modular reduction using "classic" algorithm
function Classic(m) { this.m = m; }
function cConvert(x) {
  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
  else return x;
}
function cRevert(x) { return x; }
function cReduce(x) { x.divRemTo(this.m,null,x); }
function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;

// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit() {
  if(this.t < 1) return 0;
  var x = this[0];
  if((x&1) == 0) return 0;
  var y = x&3;		// y == 1/x mod 2^2
  y = (y*(2-(x&0xf)*y))&0xf;	// y == 1/x mod 2^4
  y = (y*(2-(x&0xff)*y))&0xff;	// y == 1/x mod 2^8
  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;	// y == 1/x mod 2^16
  // last step - calculate inverse mod DV directly;
  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
  y = (y*(2-x*y%this.DV))%this.DV;		// y == 1/x mod 2^dbits
  // we really want the negative inverse, and -DV < y < DV
  return (y>0)?this.DV-y:-y;
}

// Montgomery reduction
function Montgomery(m) {
  this.m = m;
  this.mp = m.invDigit();
  this.mpl = this.mp&0x7fff;
  this.mph = this.mp>>15;
  this.um = (1<<(m.DB-15))-1;
  this.mt2 = 2*m.t;
}

// xR mod m
function montConvert(x) {
  var r = nbi();
  x.abs().dlShiftTo(this.m.t,r);
  r.divRemTo(this.m,null,r);
  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
  return r;
}

// x/R mod m
function montRevert(x) {
  var r = nbi();
  x.copyTo(r);
  this.reduce(r);
  return r;
}

// x = x/R mod m (HAC 14.32)
function montReduce(x) {
  while(x.t <= this.mt2)	// pad x so am has enough room later
    x[x.t++] = 0;
  for(var i = 0; i < this.m.t; ++i) {
    // faster way of calculating u0 = x[i]*mp mod DV
    var j = x[i]&0x7fff;
    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
    // use am to combine the multiply-shift-add into one call
    j = i+this.m.t;
    x[j] += this.m.am(0,u0,x,i,0,this.m.t);
    // propagate carry
    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
  }
  x.clamp();
  x.drShiftTo(this.m.t,x);
  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
}

// r = "x^2/R mod m"; x != r
function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

// r = "xy/R mod m"; x,y != r
function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;

// (protected) true iff this is even
function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e,z) {
  if(e > 0xffffffff || e < 1) return BigInteger.ONE;
  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
  g.copyTo(r);
  while(--i >= 0) {
    z.sqrTo(r,r2);
    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
    else { var t = r; r = r2; r2 = t; }
  }
  return z.revert(r);
}

// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e,m) {
  var z;
  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
  return this.exp(e,z);
}

// protected
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;

// public
BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt;

// "constants"
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);

// Copyright (c) 2005-2009  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.

// Extended JavaScript BN functions, required for RSA private ops.

// Version 1.1: new BigInteger("0", 10) returns "proper" zero
// Version 1.2: square() API, isProbablePrime fix

// (public)
function bnClone() { var r = nbi(); this.copyTo(r); return r; }

// (public) return value as integer
function bnIntValue() {
  if(this.s < 0) {
    if(this.t == 1) return this[0]-this.DV;
    else if(this.t == 0) return -1;
  }
  else if(this.t == 1) return this[0];
  else if(this.t == 0) return 0;
  // assumes 16 < DB < 32
  return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
}

// (public) return value as byte
function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }

// (public) return value as short (assumes DB>=16)
function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }

// (protected) return x s.t. r^x < DV
function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

// (public) 0 if this == 0, 1 if this > 0
function bnSigNum() {
  if(this.s < 0) return -1;
  else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
  else return 1;
}

// (protected) convert to radix string
function bnpToRadix(b) {
  if(b == null) b = 10;
  if(this.signum() == 0 || b < 2 || b > 36) return "0";
  var cs = this.chunkSize(b);
  var a = Math.pow(b,cs);
  var d = nbv(a), y = nbi(), z = nbi(), r = "";
  this.divRemTo(d,y,z);
  while(y.signum() > 0) {
    r = (a+z.intValue()).toString(b).substr(1) + r;
    y.divRemTo(d,y,z);
  }
  return z.intValue().toString(b) + r;
}

// (protected) convert from radix string
function bnpFromRadix(s,b) {
  this.fromInt(0);
  if(b == null) b = 10;
  var cs = this.chunkSize(b);
  var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
  for(var i = 0; i < s.length; ++i) {
    var x = intAt(s,i);
    if(x < 0) {
      if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
      continue;
    }
    w = b*w+x;
    if(++j >= cs) {
      this.dMultiply(d);
      this.dAddOffset(w,0);
      j = 0;
      w = 0;
    }
  }
  if(j > 0) {
    this.dMultiply(Math.pow(b,j));
    this.dAddOffset(w,0);
  }
  if(mi) BigInteger.ZERO.subTo(this,this);
}

// (protected) alternate constructor
function bnpFromNumber(a,b,c) {
  if("number" == typeof b) {
    // new BigInteger(int,int,RNG)
    if(a < 2) this.fromInt(1);
    else {
      this.fromNumber(a,c);
      if(!this.testBit(a-1))	// force MSB set
        this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
      if(this.isEven()) this.dAddOffset(1,0); // force odd
      while(!this.isProbablePrime(b)) {
        this.dAddOffset(2,0);
        if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
      }
    }
  }
  else {
    // new BigInteger(int,RNG)
    var x = new Array(), t = a&7;
    x.length = (a>>3)+1;
    b.nextBytes(x);
    if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
    this.fromString(x,256);
  }
}

// (public) convert to bigendian byte array
function bnToByteArray() {
  var i = this.t, r = new Array();
  r[0] = this.s;
  var p = this.DB-(i*this.DB)%8, d, k = 0;
  if(i-- > 0) {
    if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)
      r[k++] = d|(this.s<<(this.DB-p));
    while(i >= 0) {
      if(p < 8) {
        d = (this[i]&((1<<p)-1))<<(8-p);
        d |= this[--i]>>(p+=this.DB-8);
      }
      else {
        d = (this[i]>>(p-=8))&0xff;
        if(p <= 0) { p += this.DB; --i; }
      }
      if((d&0x80) != 0) d |= -256;
      if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
      if(k > 0 || d != this.s) r[k++] = d;
    }
  }
  return r;
}

function bnEquals(a) { return(this.compareTo(a)==0); }
function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
function bnMax(a) { return(this.compareTo(a)>0)?this:a; }

// (protected) r = this op a (bitwise)
function bnpBitwiseTo(a,op,r) {
  var i, f, m = Math.min(a.t,this.t);
  for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);
  if(a.t < this.t) {
    f = a.s&this.DM;
    for(i = m; i < this.t; ++i) r[i] = op(this[i],f);
    r.t = this.t;
  }
  else {
    f = this.s&this.DM;
    for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);
    r.t = a.t;
  }
  r.s = op(this.s,a.s);
  r.clamp();
}

// (public) this & a
function op_and(x,y) { return x&y; }
function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }

// (public) this | a
function op_or(x,y) { return x|y; }
function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }

// (public) this ^ a
function op_xor(x,y) { return x^y; }
function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }

// (public) this & ~a
function op_andnot(x,y) { return x&~y; }
function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }

// (public) ~this
function bnNot() {
  var r = nbi();
  for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];
  r.t = this.t;
  r.s = ~this.s;
  return r;
}

// (public) this << n
function bnShiftLeft(n) {
  var r = nbi();
  if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
  return r;
}

// (public) this >> n
function bnShiftRight(n) {
  var r = nbi();
  if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
  return r;
}

// return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
  if(x == 0) return -1;
  var r = 0;
  if((x&0xffff) == 0) { x >>= 16; r += 16; }
  if((x&0xff) == 0) { x >>= 8; r += 8; }
  if((x&0xf) == 0) { x >>= 4; r += 4; }
  if((x&3) == 0) { x >>= 2; r += 2; }
  if((x&1) == 0) ++r;
  return r;
}

// (public) returns index of lowest 1-bit (or -1 if none)
function bnGetLowestSetBit() {
  for(var i = 0; i < this.t; ++i)
    if(this[i] != 0) return i*this.DB+lbit(this[i]);
  if(this.s < 0) return this.t*this.DB;
  return -1;
}

// return number of 1 bits in x
function cbit(x) {
  var r = 0;
  while(x != 0) { x &= x-1; ++r; }
  return r;
}

// (public) return number of set bits
function bnBitCount() {
  var r = 0, x = this.s&this.DM;
  for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);
  return r;
}

// (public) true iff nth bit is set
function bnTestBit(n) {
  var j = Math.floor(n/this.DB);
  if(j >= this.t) return(this.s!=0);
  return((this[j]&(1<<(n%this.DB)))!=0);
}

// (protected) this op (1<<n)
function bnpChangeBit(n,op) {
  var r = BigInteger.ONE.shiftLeft(n);
  this.bitwiseTo(r,op,r);
  return r;
}

// (public) this | (1<<n)
function bnSetBit(n) { return this.changeBit(n,op_or); }

// (public) this & ~(1<<n)
function bnClearBit(n) { return this.changeBit(n,op_andnot); }

// (public) this ^ (1<<n)
function bnFlipBit(n) { return this.changeBit(n,op_xor); }

// (protected) r = this + a
function bnpAddTo(a,r) {
  var i = 0, c = 0, m = Math.min(a.t,this.t);
  while(i < m) {
    c += this[i]+a[i];
    r[i++] = c&this.DM;
    c >>= this.DB;
  }
  if(a.t < this.t) {
    c += a.s;
    while(i < this.t) {
      c += this[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    c += this.s;
  }
  else {
    c += this.s;
    while(i < a.t) {
      c += a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    c += a.s;
  }
  r.s = (c<0)?-1:0;
  if(c > 0) r[i++] = c;
  else if(c < -1) r[i++] = this.DV+c;
  r.t = i;
  r.clamp();
}

// (public) this + a
function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }

// (public) this - a
function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

// (public) this * a
function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }

// (public) this^2
function bnSquare() { var r = nbi(); this.squareTo(r); return r; }

// (public) this / a
function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }

// (public) this % a
function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }

// (public) [this/a,this%a]
function bnDivideAndRemainder(a) {
  var q = nbi(), r = nbi();
  this.divRemTo(a,q,r);
  return new Array(q,r);
}

// (protected) this *= n, this >= 0, 1 < n < DV
function bnpDMultiply(n) {
  this[this.t] = this.am(0,n-1,this,0,0,this.t);
  ++this.t;
  this.clamp();
}

// (protected) this += n << w words, this >= 0
function bnpDAddOffset(n,w) {
  if(n == 0) return;
  while(this.t <= w) this[this.t++] = 0;
  this[w] += n;
  while(this[w] >= this.DV) {
    this[w] -= this.DV;
    if(++w >= this.t) this[this.t++] = 0;
    ++this[w];
  }
}

// A "null" reducer
function NullExp() {}
function nNop(x) { return x; }
function nMulTo(x,y,r) { x.multiplyTo(y,r); }
function nSqrTo(x,r) { x.squareTo(r); }

NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;

// (public) this^e
function bnPow(e) { return this.exp(e,new NullExp()); }

// (protected) r = lower n words of "this * a", a.t <= n
// "this" should be the larger one if appropriate.
function bnpMultiplyLowerTo(a,n,r) {
  var i = Math.min(this.t+a.t,n);
  r.s = 0; // assumes a,this >= 0
  r.t = i;
  while(i > 0) r[--i] = 0;
  var j;
  for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
  for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);
  r.clamp();
}

// (protected) r = "this * a" without lower n words, n > 0
// "this" should be the larger one if appropriate.
function bnpMultiplyUpperTo(a,n,r) {
  --n;
  var i = r.t = this.t+a.t-n;
  r.s = 0; // assumes a,this >= 0
  while(--i >= 0) r[i] = 0;
  for(i = Math.max(n-this.t,0); i < a.t; ++i)
    r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
  r.clamp();
  r.drShiftTo(1,r);
}

// Barrett modular reduction
function Barrett(m) {
  // setup Barrett
  this.r2 = nbi();
  this.q3 = nbi();
  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
  this.mu = this.r2.divide(m);
  this.m = m;
}

function barrettConvert(x) {
  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
  else if(x.compareTo(this.m) < 0) return x;
  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
}

function barrettRevert(x) { return x; }

// x = x mod m (HAC 14.42)
function barrettReduce(x) {
  x.drShiftTo(this.m.t-1,this.r2);
  if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
  while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
  x.subTo(this.r2,x);
  while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
}

// r = x^2 mod m; x != r
function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

// r = x*y mod m; x,y != r
function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;

// (public) this^e % m (HAC 14.85)
function bnModPow(e,m) {
  var i = e.bitLength(), k, r = nbv(1), z;
  if(i <= 0) return r;
  else if(i < 18) k = 1;
  else if(i < 48) k = 3;
  else if(i < 144) k = 4;
  else if(i < 768) k = 5;
  else k = 6;
  if(i < 8)
    z = new Classic(m);
  else if(m.isEven())
    z = new Barrett(m);
  else
    z = new Montgomery(m);

  // precomputation
  var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
  g[1] = z.convert(this);
  if(k > 1) {
    var g2 = nbi();
    z.sqrTo(g[1],g2);
    while(n <= km) {
      g[n] = nbi();
      z.mulTo(g2,g[n-2],g[n]);
      n += 2;
    }
  }

  var j = e.t-1, w, is1 = true, r2 = nbi(), t;
  i = nbits(e[j])-1;
  while(j >= 0) {
    if(i >= k1) w = (e[j]>>(i-k1))&km;
    else {
      w = (e[j]&((1<<(i+1))-1))<<(k1-i);
      if(j > 0) w |= e[j-1]>>(this.DB+i-k1);
    }

    n = k;
    while((w&1) == 0) { w >>= 1; --n; }
    if((i -= n) < 0) { i += this.DB; --j; }
    if(is1) {	// ret == 1, don't bother squaring or multiplying it
      g[w].copyTo(r);
      is1 = false;
    }
    else {
      while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
      if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
      z.mulTo(r2,g[w],r);
    }

    while(j >= 0 && (e[j]&(1<<i)) == 0) {
      z.sqrTo(r,r2); t = r; r = r2; r2 = t;
      if(--i < 0) { i = this.DB-1; --j; }
    }
  }
  return z.revert(r);
}

// (public) gcd(this,a) (HAC 14.54)
function bnGCD(a) {
  var x = (this.s<0)?this.negate():this.clone();
  var y = (a.s<0)?a.negate():a.clone();
  if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
  var i = x.getLowestSetBit(), g = y.getLowestSetBit();
  if(g < 0) return x;
  if(i < g) g = i;
  if(g > 0) {
    x.rShiftTo(g,x);
    y.rShiftTo(g,y);
  }
  while(x.signum() > 0) {
    if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
    if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
    if(x.compareTo(y) >= 0) {
      x.subTo(y,x);
      x.rShiftTo(1,x);
    }
    else {
      y.subTo(x,y);
      y.rShiftTo(1,y);
    }
  }
  if(g > 0) y.lShiftTo(g,y);
  return y;
}

// (protected) this % n, n < 2^26
function bnpModInt(n) {
  if(n <= 0) return 0;
  var d = this.DV%n, r = (this.s<0)?n-1:0;
  if(this.t > 0)
    if(d == 0) r = this[0]%n;
    else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;
  return r;
}

// (public) 1/this % m (HAC 14.61)
function bnModInverse(m) {
  var ac = m.isEven();
  if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
  var u = m.clone(), v = this.clone();
  var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
  while(u.signum() != 0) {
    while(u.isEven()) {
      u.rShiftTo(1,u);
      if(ac) {
        if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
        a.rShiftTo(1,a);
      }
      else if(!b.isEven()) b.subTo(m,b);
      b.rShiftTo(1,b);
    }
    while(v.isEven()) {
      v.rShiftTo(1,v);
      if(ac) {
        if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
        c.rShiftTo(1,c);
      }
      else if(!d.isEven()) d.subTo(m,d);
      d.rShiftTo(1,d);
    }
    if(u.compareTo(v) >= 0) {
      u.subTo(v,u);
      if(ac) a.subTo(c,a);
      b.subTo(d,b);
    }
    else {
      v.subTo(u,v);
      if(ac) c.subTo(a,c);
      d.subTo(b,d);
    }
  }
  if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
  if(d.compareTo(m) >= 0) return d.subtract(m);
  if(d.signum() < 0) d.addTo(m,d); else return d;
  if(d.signum() < 0) return d.add(m); else return d;
}

var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];
var lplim = (1<<26)/lowprimes[lowprimes.length-1];

// (public) test primality with certainty >= 1-.5^t
function bnIsProbablePrime(t) {
  var i, x = this.abs();
  if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {
    for(i = 0; i < lowprimes.length; ++i)
      if(x[0] == lowprimes[i]) return true;
    return false;
  }
  if(x.isEven()) return false;
  i = 1;
  while(i < lowprimes.length) {
    var m = lowprimes[i], j = i+1;
    while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
    m = x.modInt(m);
    while(i < j) if(m%lowprimes[i++] == 0) return false;
  }
  return x.millerRabin(t);
}

// (protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
  var n1 = this.subtract(BigInteger.ONE);
  var k = n1.getLowestSetBit();
  if(k <= 0) return false;
  var r = n1.shiftRight(k);
  t = (t+1)>>1;
  if(t > lowprimes.length) t = lowprimes.length;
  var a = nbi();
  for(var i = 0; i < t; ++i) {
    //Pick bases at random, instead of starting at 2
    a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
    var y = a.modPow(r,this);
    if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
      var j = 1;
      while(j++ < k && y.compareTo(n1) != 0) {
        y = y.modPowInt(2,this);
        if(y.compareTo(BigInteger.ONE) == 0) return false;
      }
      if(y.compareTo(n1) != 0) return false;
    }
  }
  return true;
}

// protected
BigInteger.prototype.chunkSize = bnpChunkSize;
BigInteger.prototype.toRadix = bnpToRadix;
BigInteger.prototype.fromRadix = bnpFromRadix;
BigInteger.prototype.fromNumber = bnpFromNumber;
BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger.prototype.changeBit = bnpChangeBit;
BigInteger.prototype.addTo = bnpAddTo;
BigInteger.prototype.dMultiply = bnpDMultiply;
BigInteger.prototype.dAddOffset = bnpDAddOffset;
BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger.prototype.modInt = bnpModInt;
BigInteger.prototype.millerRabin = bnpMillerRabin;

// public
BigInteger.prototype.clone = bnClone;
BigInteger.prototype.intValue = bnIntValue;
BigInteger.prototype.byteValue = bnByteValue;
BigInteger.prototype.shortValue = bnShortValue;
BigInteger.prototype.signum = bnSigNum;
BigInteger.prototype.toByteArray = bnToByteArray;
BigInteger.prototype.equals = bnEquals;
BigInteger.prototype.min = bnMin;
BigInteger.prototype.max = bnMax;
BigInteger.prototype.and = bnAnd;
BigInteger.prototype.or = bnOr;
BigInteger.prototype.xor = bnXor;
BigInteger.prototype.andNot = bnAndNot;
BigInteger.prototype.not = bnNot;
BigInteger.prototype.shiftLeft = bnShiftLeft;
BigInteger.prototype.shiftRight = bnShiftRight;
BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger.prototype.bitCount = bnBitCount;
BigInteger.prototype.testBit = bnTestBit;
BigInteger.prototype.setBit = bnSetBit;
BigInteger.prototype.clearBit = bnClearBit;
BigInteger.prototype.flipBit = bnFlipBit;
BigInteger.prototype.add = bnAdd;
BigInteger.prototype.subtract = bnSubtract;
BigInteger.prototype.multiply = bnMultiply;
BigInteger.prototype.divide = bnDivide;
BigInteger.prototype.remainder = bnRemainder;
BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger.prototype.modPow = bnModPow;
BigInteger.prototype.modInverse = bnModInverse;
BigInteger.prototype.pow = bnPow;
BigInteger.prototype.gcd = bnGCD;
BigInteger.prototype.isProbablePrime = bnIsProbablePrime;

// JSBN-specific extension
BigInteger.prototype.square = bnSquare;

// BigInteger interfaces not implemented in jsbn:

// BigInteger(int signum, byte[] magnitude)
// double doubleValue()
// float floatValue()
// int hashCode()
// long longValue()
// static BigInteger valueOf(long val)
return BigInteger;
}());
// script:viewer/io/crypto/rsa.js
var RSAKey = (function()
{
  "use strict";
// prng4.js - uses Arcfour as a PRNG

function Arcfour() {
  this.i = 0;
  this.j = 0;
  this.S = new Array();
}

// Initialize arcfour context from key, an array of ints, each from [0..255]
function ARC4init(key) {
  var i, j, t;
  for(i = 0; i < 256; ++i)
    this.S[i] = i;
  j = 0;
  for(i = 0; i < 256; ++i) {
    j = (j + this.S[i] + key[i % key.length]) & 255;
    t = this.S[i];
    this.S[i] = this.S[j];
    this.S[j] = t;
  }
  this.i = 0;
  this.j = 0;
}

function ARC4next() {
  var t;
  this.i = (this.i + 1) & 255;
  this.j = (this.j + this.S[this.i]) & 255;
  t = this.S[this.i];
  this.S[this.i] = this.S[this.j];
  this.S[this.j] = t;
  return this.S[(t + this.S[this.i]) & 255];
}

Arcfour.prototype.init = ARC4init;
Arcfour.prototype.next = ARC4next;

// Plug in your RNG constructor here
function prng_newstate() {
  return new Arcfour();
}

// Pool size must be a multiple of 4 and greater than 32.
// An array of bytes the size of the pool will be passed to init()
var rng_psize = 256;
  
  
// Random number generator - requires a PRNG backend, e.g. prng4.js

// For best results, put code like
// <body onClick='rng_seed_time();' onKeyPress='rng_seed_time();'>
// in your main HTML document.

var rng_state;
var rng_pool;
var rng_pptr;

// Mix in a 32-bit integer into the pool
function rng_seed_int(x) {
  rng_pool[rng_pptr++] ^= x & 255;
  rng_pool[rng_pptr++] ^= (x >> 8) & 255;
  rng_pool[rng_pptr++] ^= (x >> 16) & 255;
  rng_pool[rng_pptr++] ^= (x >> 24) & 255;
  if(rng_pptr >= rng_psize) rng_pptr -= rng_psize;
}

// Mix in the current time (w/milliseconds) into the pool
function rng_seed_time() {
  rng_seed_int(new Date().getTime());
}

// Initialize the pool with junk if needed.
if(rng_pool == null) {
  rng_pool = new Array();
  rng_pptr = 0;
  var t;
  if(window.crypto && window.crypto.getRandomValues) {
    // Use webcrypto if available
    var ua = new Uint8Array(32);
    window.crypto.getRandomValues(ua);
    for(t = 0; t < 32; ++t)
      rng_pool[rng_pptr++] = ua[t];
  }
  if(navigator.appName == "Netscape" && navigator.appVersion < "5" && window.crypto) {
    // Extract entropy (256 bits) from NS4 RNG if available
    var z = window.crypto.random(32);
    for(t = 0; t < z.length; ++t)
      rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
  }  
  while(rng_pptr < rng_psize) {  // extract some randomness from Math.random()
    t = Math.floor(65536 * Math.random());
    rng_pool[rng_pptr++] = t >>> 8;
    rng_pool[rng_pptr++] = t & 255;
  }
  rng_pptr = 0;
  rng_seed_time();
  //rng_seed_int(window.screenX);
  //rng_seed_int(window.screenY);
}

function rng_get_byte() {
  if(rng_state == null) {
    rng_seed_time();
    rng_state = prng_newstate();
    rng_state.init(rng_pool);
    for(rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
      rng_pool[rng_pptr] = 0;
    rng_pptr = 0;
    //rng_pool = null;
  }
  // TODO: allow reseeding after first request
  return rng_state.next();
}

function rng_get_bytes(ba) {
  var i;
  for(i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
}

function SecureRandom() {}

SecureRandom.prototype.nextBytes = rng_get_bytes;
  
// Depends on jsbn.js and rng.js
// Version 1.1: support utf-8 encoding in pkcs1pad2

// convert a (hex) string to a bignum object
function parseBigInt(str,r) {
  return new BigInteger(str,r);
}

function linebrk(s,n) {
  var ret = "";
  var i = 0;
  while(i + n < s.length) {
    ret += s.substring(i,i+n) + "\n";
    i += n;
  }
  return ret + s.substring(i,s.length);
}

function byte2Hex(b) {
  if(b < 0x10)
    return "0" + b.toString(16);
  else
    return b.toString(16);
}

// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint
function pkcs1pad2(s,n) {
  if(n < s.length + 11) { // TODO: fix for utf-8
    throw new Error("Message too long for RSA");
  }
  var ba = new Array();
  var i = s.length - 1;
  while(i >= 0 && n > 0) {
    var c = s.charCodeAt(i--);
    if(c < 128) { // encode using utf-8
      ba[--n] = c;
    }
    else if((c > 127) && (c < 2048)) {
      ba[--n] = (c & 63) | 128;
      ba[--n] = (c >> 6) | 192;
    }
    else {
      ba[--n] = (c & 63) | 128;
      ba[--n] = ((c >> 6) & 63) | 128;
      ba[--n] = (c >> 12) | 224;
    }
  }
  ba[--n] = 0;
  var rng = new SecureRandom();
  var x = new Array();
  while(n > 2) { // random non-zero pad
    x[0] = 0;
    while(x[0] == 0) rng.nextBytes(x);
    ba[--n] = x[0];
  }
  ba[--n] = 2;
  ba[--n] = 0;
  return new BigInteger(ba);
}

/**
 @author johnh@vitrium.com
*/
function pkcs1pad2ba(data, n)
{
  if (n < data.length + 11)
  {
    throw new Error("Message too long for RSA");
  }
  
  var ba = new Array();
  var i = data.length - 1;
  while (i >= 0)
  {
    ba[--n] = data[i--];
  }
  ba[--n] = 0;
  
  var rng = new SecureRandom();
  var x = new Array();
  while(n > 2) { // random non-zero pad
    x[0] = 0;
    while(x[0] == 0) rng.nextBytes(x);
    ba[--n] = x[0];
  }
  ba[--n] = 2;
  ba[--n] = 0;
  return new BigInteger(ba);
}

// "empty" RSA key constructor
function RSAKey() {
  this.n = null;
  this.e = 0;
  this.d = null;
  this.p = null;
  this.q = null;
  this.dmp1 = null;
  this.dmq1 = null;
  this.coeff = null;
}

// Set the public key fields N and e from hex strings
function RSASetPublic(N,E) {
  if(N != null && E != null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
  }
  else
    throw new Error("Invalid RSA public key");
}

// Perform raw public operation on "x": return x^e (mod n)
function RSADoPublic(x) {
  return x.modPowInt(this.e, this.n);
}

// Return the PKCS#1 RSA encryption of "text" as an even-length hex string
function RSAEncrypt(text) {
  var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3);
  if(m == null) return null;
  var c = this.doPublic(m);
  if(c == null) return null;
  var h = c.toString(16);
  if((h.length & 1) == 0) return h; else return "0" + h;
}

function RSAEncryptByteArray(ba)
{
  var m = pkcs1pad2ba(ba,(this.n.bitLength()+7)>>3);
  if(m == null) return null;
  var c = this.doPublic(m);
  if(c == null) return null;
  var h = c.toString(16);
  if((h.length & 1) == 0) return h; else return "0" + h;
}

// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string
//function RSAEncryptB64(text) {
//  var h = this.encrypt(text);
//  if(h) return hex2b64(h); else return null;
//}

// protected
RSAKey.prototype.doPublic = RSADoPublic;

// public
RSAKey.prototype.setPublic = RSASetPublic;
RSAKey.prototype.encrypt = RSAEncrypt;
RSAKey.prototype.encryptByteArray = RSAEncryptByteArray;
//RSAKey.prototype.encrypt_b64 = RSAEncryptB64;

// Depends on rsa.js and jsbn2.js

// Version 1.1: support utf-8 decoding in pkcs1unpad2

// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext
function pkcs1unpad2(d,n) {
  var b = d.toByteArray();
  var i = 0;
  while(i < b.length && b[i] == 0) ++i;
  if(b.length-i != n-1 || b[i] != 2)
    return null;
  ++i;
  while(b[i] != 0)
    if(++i >= b.length) return null;
  var ret = "";
  while(++i < b.length) {
    var c = b[i] & 255;
    if(c < 128) { // utf-8 decode
      ret += String.fromCharCode(c);
    }
    else if((c > 191) && (c < 224)) {
      ret += String.fromCharCode(((c & 31) << 6) | (b[i+1] & 63));
      ++i;
    }
    else {
      ret += String.fromCharCode(((c & 15) << 12) | ((b[i+1] & 63) << 6) | (b[i+2] & 63));
      i += 2;
    }
  }
  return ret;
}

/**
  @author johnh@vitrium.com
*/
function pkcs1unpad2ba(d,n) {
  var b = d.toByteArray();
  var i = 0;
  while(i < b.length && b[i] == 0) ++i;
  if(b.length-i != n-1 || b[i] != 2)
    return null;
  ++i;
  while(b[i] != 0)
    if(++i >= b.length) return null;
  
  var ret = [];
  while(++i < b.length) {
    ret.push(b[i] & 255);
  }
  return ret;
}


// Set the private key fields N, e, and d from hex strings
function RSASetPrivate(N,E,D) {
  if(N != null && E != null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
    this.d = parseBigInt(D,16);
  }
  else
    throw new Error("Invalid RSA private key");
}

// Set the private key fields N, e, d and CRT params from hex strings
function RSASetPrivateEx(N,E,D,P,Q,DP,DQ,C) {
  if(N != null && E != null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
    this.d = parseBigInt(D,16);
    this.p = parseBigInt(P,16);
    this.q = parseBigInt(Q,16);
    this.dmp1 = parseBigInt(DP,16);
    this.dmq1 = parseBigInt(DQ,16);
    this.coeff = parseBigInt(C,16);
  }
  else
    throw new Error("Invalid RSA private key");
}

// Generate a new random private key B bits long, using public expt E
function RSAGenerate(B,E) {
  var rng = new SecureRandom();
  var qs = B>>1;
  this.e = parseInt(E,16);
  var ee = new BigInteger(E,16);
  for(;;) {
    for(;;) {
      this.p = new BigInteger(B-qs,1,rng);
      if(this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) break;
    }
    for(;;) {
      this.q = new BigInteger(qs,1,rng);
      if(this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) break;
    }
    if(this.p.compareTo(this.q) <= 0) {
      var t = this.p;
      this.p = this.q;
      this.q = t;
    }
    var p1 = this.p.subtract(BigInteger.ONE);
    var q1 = this.q.subtract(BigInteger.ONE);
    var phi = p1.multiply(q1);
    if(phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
      this.n = this.p.multiply(this.q);
      this.d = ee.modInverse(phi);
      this.dmp1 = this.d.mod(p1);
      this.dmq1 = this.d.mod(q1);
      this.coeff = this.q.modInverse(this.p);
      break;
    }
  }
}

// Perform raw private operation on "x": return x^d (mod n)
function RSADoPrivate(x) {
  if(this.p == null || this.q == null)
    return x.modPow(this.d, this.n);

  // TODO: re-calculate any missing CRT params
  var xp = x.mod(this.p).modPow(this.dmp1, this.p);
  var xq = x.mod(this.q).modPow(this.dmq1, this.q);

  while(xp.compareTo(xq) < 0)
    xp = xp.add(this.p);
  return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
}

// Return the PKCS#1 RSA decryption of "ctext".
// "ctext" is an even-length hex string and the output is a plain string.
function RSADecrypt(ctext) {
  var c = parseBigInt(ctext, 16);
  var m = this.doPrivate(c);
  if(m == null) return null;
  return pkcs1unpad2(m, (this.n.bitLength()+7)>>3);
}

function RSADecrypt2ByteArray(ctext)
{
  var c = parseBigInt(ctext, 16);
  var m = this.doPrivate(c);
  if(m == null) return null;
  return pkcs1unpad2ba(m, (this.n.bitLength()+7)>>3);
}

// Return the PKCS#1 RSA decryption of "ctext".
// "ctext" is a Base64-encoded string and the output is a plain string.
//function RSAB64Decrypt(ctext) {
//  var h = b64tohex(ctext);
//  if(h) return this.decrypt(h); else return null;
//}

// protected
RSAKey.prototype.doPrivate = RSADoPrivate;

// public
RSAKey.prototype.setPrivate = RSASetPrivate;
RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
RSAKey.prototype.generate = RSAGenerate;
RSAKey.prototype.decrypt = RSADecrypt;
RSAKey.prototype.decrypt2ByteArray = RSADecrypt2ByteArray;

//RSAKey.prototype.b64_decrypt = RSAB64Decrypt;

return RSAKey;

}());
// script:viewer/io/crypto/aes.js
/*
CryptoJS v3.1
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(u,p){var d={},l=d.lib={},s=function(){},t=l.Base={extend:function(a){s.prototype=this;var c=new s;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
r = l.WordArray = t.extend({
   init: function (a, c) { a = this.words = a || []; this.sigBytes = c != p ? c : 4 * a.length }, toString: function (a) { return (a || v).stringify(this) }, concat: function (a) {
      var c = this.words, e = a.words, j = this.sigBytes; a = a.sigBytes; this.clamp(); if (j % 4) for (var k = 0; k < a; k++) c[j + k >>> 2] |= (e[k >>> 2] >>> 24 - 8 * (k % 4) & 255) << 24 - 8 * ((j + k) % 4); else for (k = 0; k < a; k += 4) c[j + k >>> 2] = e[k >>> 2]; this.sigBytes += a; return this
   }, clamp: function () {
      var a = this.words, c = this.sigBytes; a[c >>> 2] &= 4294967295 <<
32-8*(c%4);a.length=u.ceil(c/4)},clone:function(){var a=t.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],e=0;e<a;e+=4)c.push(4294967296*u.random()|0);return new r.init(c,a)}}),w=d.enc={},v=w.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var e=[],j=0;j<a;j++){var k=c[j>>>2]>>>24-8*(j%4)&255;e.push((k>>>4).toString(16));e.push((k&15).toString(16))}return e.join("")},parse:function(a){for(var c=a.length,e=[],j=0;j<c;j+=2)e[j>>>3]|=parseInt(a.substr(j,
2),16)<<24-4*(j%8);return new r.init(e,c/2)}},b=w.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var e=[],j=0;j<a;j++)e.push(String.fromCharCode(c[j>>>2]>>>24-8*(j%4)&255));return e.join("")},parse:function(a){for(var c=a.length,e=[],j=0;j<c;j++)e[j>>>2]|=(a.charCodeAt(j)&255)<<24-8*(j%4);return new r.init(e,c)}},x=w.Utf8={stringify:function(a){try{return decodeURIComponent(escape(b.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return b.parse(unescape(encodeURIComponent(a)))}},
q=l.BufferedBlockAlgorithm=t.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=x.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,e=c.words,j=c.sigBytes,k=this.blockSize,b=j/(4*k),b=a?u.ceil(b):u.max((b|0)-this._minBufferSize,0);a=b*k;j=u.min(4*a,j);if(a){for(var q=0;q<a;q+=k)this._doProcessBlock(e,q);q=e.splice(0,a);c.sigBytes-=j}return new r.init(q,j)},clone:function(){var a=t.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});l.Hasher=q.extend({cfg:t.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){q.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,e){return(new a.init(e)).finalize(b)}},_createHmacHelper:function(a){return function(b,e){return(new n.HMAC.init(a,
e)).finalize(b)}}});var n=d.algo={};return d}(Math);
(function(){var u=CryptoJS,p=u.lib.WordArray;u.enc.Base64={stringify:function(d){var l=d.words,p=d.sigBytes,t=this._map;d.clamp();d=[];for(var r=0;r<p;r+=3)for(var w=(l[r>>>2]>>>24-8*(r%4)&255)<<16|(l[r+1>>>2]>>>24-8*((r+1)%4)&255)<<8|l[r+2>>>2]>>>24-8*((r+2)%4)&255,v=0;4>v&&r+0.75*v<p;v++)d.push(t.charAt(w>>>6*(3-v)&63));if(l=t.charAt(64))for(;d.length%4;)d.push(l);return d.join("")},parse:function(d){var l=d.length,s=this._map,t=s.charAt(64);t&&(t=d.indexOf(t),-1!=t&&(l=t));for(var t=[],r=0,w=0;w<
l;w++)if(w%4){var v=s.indexOf(d.charAt(w-1))<<2*(w%4),b=s.indexOf(d.charAt(w))>>>6-2*(w%4);t[r>>>2]|=(v|b)<<24-8*(r%4);r++}return p.create(t,r)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}})();
(function(u){function p(b,n,a,c,e,j,k){b=b+(n&a|~n&c)+e+k;return(b<<j|b>>>32-j)+n}function d(b,n,a,c,e,j,k){b=b+(n&c|a&~c)+e+k;return(b<<j|b>>>32-j)+n}function l(b,n,a,c,e,j,k){b=b+(n^a^c)+e+k;return(b<<j|b>>>32-j)+n}function s(b,n,a,c,e,j,k){b=b+(a^(n|~c))+e+k;return(b<<j|b>>>32-j)+n}for(var t=CryptoJS,r=t.lib,w=r.WordArray,v=r.Hasher,r=t.algo,b=[],x=0;64>x;x++)b[x]=4294967296*u.abs(u.sin(x+1))|0;r=r.MD5=v.extend({_doReset:function(){this._hash=new w.init([1732584193,4023233417,2562383102,271733878])},
_doProcessBlock:function(q,n){for(var a=0;16>a;a++){var c=n+a,e=q[c];q[c]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360}var a=this._hash.words,c=q[n+0],e=q[n+1],j=q[n+2],k=q[n+3],z=q[n+4],r=q[n+5],t=q[n+6],w=q[n+7],v=q[n+8],A=q[n+9],B=q[n+10],C=q[n+11],u=q[n+12],D=q[n+13],E=q[n+14],x=q[n+15],f=a[0],m=a[1],g=a[2],h=a[3],f=p(f,m,g,h,c,7,b[0]),h=p(h,f,m,g,e,12,b[1]),g=p(g,h,f,m,j,17,b[2]),m=p(m,g,h,f,k,22,b[3]),f=p(f,m,g,h,z,7,b[4]),h=p(h,f,m,g,r,12,b[5]),g=p(g,h,f,m,t,17,b[6]),m=p(m,g,h,f,w,22,b[7]),
f=p(f,m,g,h,v,7,b[8]),h=p(h,f,m,g,A,12,b[9]),g=p(g,h,f,m,B,17,b[10]),m=p(m,g,h,f,C,22,b[11]),f=p(f,m,g,h,u,7,b[12]),h=p(h,f,m,g,D,12,b[13]),g=p(g,h,f,m,E,17,b[14]),m=p(m,g,h,f,x,22,b[15]),f=d(f,m,g,h,e,5,b[16]),h=d(h,f,m,g,t,9,b[17]),g=d(g,h,f,m,C,14,b[18]),m=d(m,g,h,f,c,20,b[19]),f=d(f,m,g,h,r,5,b[20]),h=d(h,f,m,g,B,9,b[21]),g=d(g,h,f,m,x,14,b[22]),m=d(m,g,h,f,z,20,b[23]),f=d(f,m,g,h,A,5,b[24]),h=d(h,f,m,g,E,9,b[25]),g=d(g,h,f,m,k,14,b[26]),m=d(m,g,h,f,v,20,b[27]),f=d(f,m,g,h,D,5,b[28]),h=d(h,f,
m,g,j,9,b[29]),g=d(g,h,f,m,w,14,b[30]),m=d(m,g,h,f,u,20,b[31]),f=l(f,m,g,h,r,4,b[32]),h=l(h,f,m,g,v,11,b[33]),g=l(g,h,f,m,C,16,b[34]),m=l(m,g,h,f,E,23,b[35]),f=l(f,m,g,h,e,4,b[36]),h=l(h,f,m,g,z,11,b[37]),g=l(g,h,f,m,w,16,b[38]),m=l(m,g,h,f,B,23,b[39]),f=l(f,m,g,h,D,4,b[40]),h=l(h,f,m,g,c,11,b[41]),g=l(g,h,f,m,k,16,b[42]),m=l(m,g,h,f,t,23,b[43]),f=l(f,m,g,h,A,4,b[44]),h=l(h,f,m,g,u,11,b[45]),g=l(g,h,f,m,x,16,b[46]),m=l(m,g,h,f,j,23,b[47]),f=s(f,m,g,h,c,6,b[48]),h=s(h,f,m,g,w,10,b[49]),g=s(g,h,f,m,
E,15,b[50]),m=s(m,g,h,f,r,21,b[51]),f=s(f,m,g,h,u,6,b[52]),h=s(h,f,m,g,k,10,b[53]),g=s(g,h,f,m,B,15,b[54]),m=s(m,g,h,f,e,21,b[55]),f=s(f,m,g,h,v,6,b[56]),h=s(h,f,m,g,x,10,b[57]),g=s(g,h,f,m,t,15,b[58]),m=s(m,g,h,f,D,21,b[59]),f=s(f,m,g,h,z,6,b[60]),h=s(h,f,m,g,C,10,b[61]),g=s(g,h,f,m,j,15,b[62]),m=s(m,g,h,f,A,21,b[63]);a[0]=a[0]+f|0;a[1]=a[1]+m|0;a[2]=a[2]+g|0;a[3]=a[3]+h|0},_doFinalize:function(){var b=this._data,n=b.words,a=8*this._nDataBytes,c=8*b.sigBytes;n[c>>>5]|=128<<24-c%32;var e=u.floor(a/
4294967296);n[(c+64>>>9<<4)+15]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360;n[(c+64>>>9<<4)+14]=(a<<8|a>>>24)&16711935|(a<<24|a>>>8)&4278255360;b.sigBytes=4*(n.length+1);this._process();b=this._hash;n=b.words;for(a=0;4>a;a++)c=n[a],n[a]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return b},clone:function(){var b=v.clone.call(this);b._hash=this._hash.clone();return b}});t.MD5=v._createHelper(r);t.HmacMD5=v._createHmacHelper(r)})(Math);
(function(){var u=CryptoJS,p=u.lib,d=p.Base,l=p.WordArray,p=u.algo,s=p.EvpKDF=d.extend({cfg:d.extend({keySize:4,hasher:p.MD5,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(d,r){for(var p=this.cfg,s=p.hasher.create(),b=l.create(),u=b.words,q=p.keySize,p=p.iterations;u.length<q;){n&&s.update(n);var n=s.update(d).finalize(r);s.reset();for(var a=1;a<p;a++)n=s.finalize(n),s.reset();b.concat(n)}b.sigBytes=4*q;return b}});u.EvpKDF=function(d,l,p){return s.create(p).compute(d,
l)}})();
CryptoJS.lib.Cipher||function(u){var p=CryptoJS,d=p.lib,l=d.Base,s=d.WordArray,t=d.BufferedBlockAlgorithm,r=p.enc.Base64,w=p.algo.EvpKDF,v=d.Cipher=t.extend({cfg:l.extend(),createEncryptor:function(e,a){return this.create(this._ENC_XFORM_MODE,e,a)},createDecryptor:function(e,a){return this.create(this._DEC_XFORM_MODE,e,a)},init:function(e,a,b){this.cfg=this.cfg.extend(b);this._xformMode=e;this._key=a;this.reset()},reset:function(){t.reset.call(this);this._doReset()},process:function(e){this._append(e);return this._process()},
finalize:function(e){e&&this._append(e);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(e){return{encrypt:function(b,k,d){return("string"==typeof k?c:a).encrypt(e,b,k,d)},decrypt:function(b,k,d){return("string"==typeof k?c:a).decrypt(e,b,k,d)}}}});d.StreamCipher=v.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var b=p.mode={},x=function(e,a,b){var c=this._iv;c?this._iv=u:c=this._prevBlock;for(var d=0;d<b;d++)e[a+d]^=
c[d]},q=(d.BlockCipherMode=l.extend({createEncryptor:function(e,a){return this.Encryptor.create(e,a)},createDecryptor:function(e,a){return this.Decryptor.create(e,a)},init:function(e,a){this._cipher=e;this._iv=a}})).extend();q.Encryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize;x.call(this,e,a,c);b.encryptBlock(e,a);this._prevBlock=e.slice(a,a+c)}});q.Decryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize,d=e.slice(a,a+c);b.decryptBlock(e,a);x.call(this,
e,a,c);this._prevBlock=d}});b=b.CBC=q;q=(p.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,l=[],n=0;n<c;n+=4)l.push(d);c=s.create(l,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};d.BlockCipher=v.extend({cfg:v.cfg.extend({mode:b,padding:q}),reset:function(){v.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;this._mode=c.call(a,
this,b&&b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var n=d.CipherParams=l.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),b=(p.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;return(a?s.create([1398893684,
1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=s.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return n.create({ciphertext:a,salt:c})}},a=d.SerializableCipher=l.extend({cfg:l.extend({format:b}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var l=a.createEncryptor(c,d);b=l.finalize(b);l=l.cfg;return n.create({ciphertext:b,key:c,iv:l.iv,algorithm:a,mode:l.mode,padding:l.padding,blockSize:a.blockSize,formatter:d.format})},
decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return"string"==typeof a?b.parse(a,this):a}}),p=(p.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=s.random(8));a=w.create({keySize:b+c}).compute(a,d);c=s.create(a.words.slice(b),4*c);a.sigBytes=4*b;return n.create({key:a,iv:c,salt:d})}},c=d.PasswordBasedCipher=a.extend({cfg:a.cfg.extend({kdf:p}),encrypt:function(b,c,d,l){l=this.cfg.extend(l);d=l.kdf.execute(d,
b.keySize,b.ivSize);l.iv=d.iv;b=a.encrypt.call(this,b,c,d.key,l);b.mixIn(d);return b},decrypt:function(b,c,d,l){l=this.cfg.extend(l);c=this._parse(c,l.format);d=l.kdf.execute(d,b.keySize,b.ivSize,c.salt);l.iv=d.iv;return a.decrypt.call(this,b,c,d.key,l)}})}();
(function(){for(var u=CryptoJS,p=u.lib.BlockCipher,d=u.algo,l=[],s=[],t=[],r=[],w=[],v=[],b=[],x=[],q=[],n=[],a=[],c=0;256>c;c++)a[c]=128>c?c<<1:c<<1^283;for(var e=0,j=0,c=0;256>c;c++){var k=j^j<<1^j<<2^j<<3^j<<4,k=k>>>8^k&255^99;l[e]=k;s[k]=e;var z=a[e],F=a[z],G=a[F],y=257*a[k]^16843008*k;t[e]=y<<24|y>>>8;r[e]=y<<16|y>>>16;w[e]=y<<8|y>>>24;v[e]=y;y=16843009*G^65537*F^257*z^16843008*e;b[k]=y<<24|y>>>8;x[k]=y<<16|y>>>16;q[k]=y<<8|y>>>24;n[k]=y;e?(e=z^a[a[a[G^z]]],j^=a[a[j]]):e=j=1}var H=[0,1,2,4,8,
16,32,64,128,27,54],d=d.AES=p.extend({_doReset:function(){for(var a=this._key,c=a.words,d=a.sigBytes/4,a=4*((this._nRounds=d+6)+1),e=this._keySchedule=[],j=0;j<a;j++)if(j<d)e[j]=c[j];else{var k=e[j-1];j%d?6<d&&4==j%d&&(k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255]):(k=k<<8|k>>>24,k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255],k^=H[j/d|0]<<24);e[j]=e[j-d]^k}c=this._invKeySchedule=[];for(d=0;d<a;d++)j=a-d,k=d%4?e[j]:e[j-4],c[d]=4>d||4>=j?k:b[l[k>>>24]]^x[l[k>>>16&255]]^q[l[k>>>
8&255]]^n[l[k&255]]},encryptBlock:function(a,b){this._doCryptBlock(a,b,this._keySchedule,t,r,w,v,l)},decryptBlock:function(a,c){var d=a[c+1];a[c+1]=a[c+3];a[c+3]=d;this._doCryptBlock(a,c,this._invKeySchedule,b,x,q,n,s);d=a[c+1];a[c+1]=a[c+3];a[c+3]=d},_doCryptBlock:function(a,b,c,d,e,j,l,f){for(var m=this._nRounds,g=a[b]^c[0],h=a[b+1]^c[1],k=a[b+2]^c[2],n=a[b+3]^c[3],p=4,r=1;r<m;r++)var q=d[g>>>24]^e[h>>>16&255]^j[k>>>8&255]^l[n&255]^c[p++],s=d[h>>>24]^e[k>>>16&255]^j[n>>>8&255]^l[g&255]^c[p++],t=
d[k>>>24]^e[n>>>16&255]^j[g>>>8&255]^l[h&255]^c[p++],n=d[n>>>24]^e[g>>>16&255]^j[h>>>8&255]^l[k&255]^c[p++],g=q,h=s,k=t;q=(f[g>>>24]<<24|f[h>>>16&255]<<16|f[k>>>8&255]<<8|f[n&255])^c[p++];s=(f[h>>>24]<<24|f[k>>>16&255]<<16|f[n>>>8&255]<<8|f[g&255])^c[p++];t=(f[k>>>24]<<24|f[n>>>16&255]<<16|f[g>>>8&255]<<8|f[h&255])^c[p++];n=(f[n>>>24]<<24|f[g>>>16&255]<<16|f[h>>>8&255]<<8|f[k&255])^c[p++];a[b]=q;a[b+1]=s;a[b+2]=t;a[b+3]=n},keySize:8});u.AES=p._createHelper(d)})();

// script:viewer/io/crypto/aes-cbc-dom.js
/// <reference path="~/build.html" />

(function (exports, cr, async, globals) {
   "use strict";

   var crypto = window.crypto || window.msCrypto || window.webkitCrypto; 
   exports.AesCbc = AesCbc;
   exports.AesCbcAlgorithmSettings = AesCbcAlgorithmSettings;
 

   function AesCbcAlgorithmSettings(iv)
   {
      /// <param name="iv" type="Uint8Array" />

      this.name = "AES-CBC";
      this.iv = iv === undefined ? cr.createByteArray(16) : iv;
   }

   function AesCbc(settings)
   {
      /// <param name="settings" type="AesCbcAlgorithmSettings" />
      this._settings = settings;
      this._key = null;
   }


   AesCbc.prototype.init = function(key)
   {
      /// <param name="key" type="Uint8Array" />
      var self = this;      
      
      var completer = new async.Completer();
      if (crypto && crypto.subtle) {
         var op = crypto.subtle.importKey("raw", key, this._settings, true, ["encrypt", "decrypt"]);

         bind_promise(op, complete, error);
      }
      else {
         setTimeout(function () {
            completer.fail("crypto API is not available");
         }, 0);
      }

      function complete(key)
      {
         self._key = key;
         completer.complete();
      }

      function error(e)
      {
         completer.fail(e);
      }
      
      return completer.future;
   }

   AesCbc.prototype.encrypt = function (data)
   {
      /// <param name="data" type="Uint8Array" />

      var completer = new async.Completer();
      var op;
      if ("msCrypto" in window)
      {
         op = crypto.subtle.encrypt(this._key.algorithm, this._key);
         bind_promise(op, complete, error);
         op.onprogress = function () {
       //     console.log("progress");
         };
         op.process(data);
         op.finish();
      }
      else
      {
         op = crypto.subtle.encrypt(this._settings, this._key, data);
         bind_promise(op, complete, error);
      }      

      function complete(enc)
      {         
         completer.complete(new Uint8Array(enc, 0, enc.byteLength));
      }

      function error(e)
      {
         completer.fail(e);
      }

      return completer.future;
   };

   AesCbc.prototype.decrypt = function (data)
   {
      /// <param name="data" type="Uint8Array" />

      var completer = new async.Completer();
      var op = crypto.subtle.decrypt(this._settings, this._key, data);
      bind_promise(op, complete, error);

      function complete(dec)
      {
         completer.complete(new Uint8Array(dec, 0, dec.byteLength));
      }

      function error(e)
      {
         completer.fail(e);
      }

      return completer.future;
   };

   function bind_promise(op, success, error)
   {
      if ("then" in op && "catch" in op)
      {
         op.then(success).catch(error);
      }
      else
      {
         op.oncomplete = function(){
            success(op.result);
         };
         op.onerror = error;
      }

   }
}
(
vitrium.crypto,
vitrium.crypto,
vitrium.async, 
__globals__));

// script:viewer/io/crypto/aes-cbc-sync.js
/// <reference path="~/build.html" />

(function (exports,crypto, utils, CryptoJS, globals) {
   "use strict";

   exports.AesCbcSync = AesCbcSync;
   
   if (globals.Uint8Array) {
      exports.createByteArray = function (len) {
         return new Uint8Array(len);
      };
   }
   else
   {
      exports.createByteArray = function (len) {
         var arr = new Array(len);
         for (var i = 0; i !== len; ++i)
            arr[i] = 0;

         arr.set = function (array, offset) {
            var _len = Math.min(Math.max(this.length-offset, 0), array.length);
            for (var i = 0; i !== _len; ++i)
               this[i+offset] = array[i];
         };

         return arr;
      };
   }

   

   function AesCbcSync(settings, key)
   {
      ///<param name="settings" type="vitrium.crypto.AesCbcAlgorithmSettings" />
      ///<param name="key" type="Uint8Array" />
      this._iv = utils.u8array.parse(settings.iv);
      this._key = utils.u8array.parse(key);
   }

   AesCbcSync.prototype.encrypt = function (bytes) {
      ///<param name="bytes" type="Uint8Array" />
      var encryptor = CryptoJS.algo.AES.createEncryptor(this._key,
      {
         iv: this._iv,
         mode: CryptoJS.mode.CBC,
         padding: CryptoJS.pad.Pkcs7
      });

      return this._process(bytes, encryptor);
   };

   AesCbcSync.prototype.decrypt = function (bytes) {
      ///<param name="bytes" type="Uint8Array" />
      var decryptor = CryptoJS.algo.AES.createDecryptor(this._key,
      {
         iv: this._iv,
         mode: CryptoJS.mode.CBC,
         padding: CryptoJS.pad.Pkcs7
      });

      return this._process(bytes, decryptor);
   };

   AesCbcSync.prototype._process = function (bytes, stream) {
      var words = utils.u8array.parse(bytes);
      var encryptedChunk = utils.u8array.stringify(stream.process(words));

      var lastChunkW = stream.finalize();
      if (lastChunkW.sigBytes > 0) {
         var lastChunk = utils.u8array.stringify(lastChunkW);

         var tmp = crypto.createByteArray(encryptedChunk.length + lastChunk.length);
         tmp.set(encryptedChunk, 0);
         tmp.set(lastChunk, encryptedChunk.length);

         encryptedChunk = tmp;
      }

      return encryptedChunk;
   };
}
(vitrium.crypto,
vitrium.crypto,
vitrium.utils,
 CryptoJS,
  __globals__
));

// script:viewer/io/crypto/aes-string-worker-client.js
/// <reference path="~/build.html" />

(function (exports, utils, async) {
   "use strict";

   exports.AesStringWorkerClient = AesStringWorkerClient;
   var JOB_ENCRYPT_NAME = 0;
   var JOB_DECRYPT_NAME = 1;

   function AesStringWorkerClient(settings)
   {
      /// <field name="_pool" type="uitls.Pool" />
      this._pool = null;
      this._settings = settings;
   }

   AesStringWorkerClient.prototype.init = function (key) {
      if (this._pool !== null) throw new Error("Pool has been instantiated!");

      var completer = new async.Completer();
      var self = this;

      var pool = new utils.Pool(1, utils.Pool.workerPath("aes-string-worker.js"), function () {
         self._pool = pool;
         completer.complete();
      });

      pool.start({ settings: this._settings, key: key });

      return completer.future;
   };


   AesStringWorkerClient.prototype.encrypt = function (str) {
      return this._exec(str, JOB_ENCRYPT_NAME);
   };

   AesStringWorkerClient.prototype.decrypt = function (str) {
      return this._exec(str, JOB_DECRYPT_NAME);
   };

   AesStringWorkerClient.prototype._exec = function (str, type) {
      var completer = new async.Completer(function () {
         job.terminate();
      });

      var job = this._pool.createJob(type);
      job.addEventListener("message", function (msg) {
         var data = msg.data;
         if (data.success)
         {
            completer.complete(data.data);
         }
         else
         {
            completer.fail(data.data);
         }
      });

      job.postMessage({ operation: type, data: str });

      return completer.future;
   };
   




}
(vitrium.crypto,
vitrium.utils,
vitrium.async));

// script:viewer/io/crypto/mode-ctr-gladman.js
/*
CryptoJS v3.1
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
 * derived from CryptoJS.mode.CTR 
 * Jan Hruby jhruby.web@gmail.com
 */
CryptoJS.mode.CTRGladman = (function () {
    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

	function incWord(word)
	{	
		if (((word >> 24) & 0xff) === 0xff) { //overflow
		var b1 = (word >> 16)&0xff;
		var b2 = (word >> 8)&0xff;
		var b3 = word & 0xff;

		if (b1 === 0xff) // overflow b1
		{		 
		b1 = 0;
		if (b2 === 0xff)
		{
			b2 = 0;
			if (b3 === 0xff)
			{
				b3 = 0;
			}
			else
			{
				++b3;
			}
		}
		else
		{
			++b2;
		}
		}
		else
		{
		++b1;
		}

		word = 0;	  	  
		word += (b1 << 16);
		word += (b2 << 8);
		word += b3;	  
		}
		else
		{
		word += (0x01 << 24);
		}
		return word;
	}

	function incCounter(counter)
	{
		if ((counter[0] = incWord(counter[0])) === 0)
		{
			// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
			counter[1] = incWord(counter[1]);
		}
		return counter;
	}
	
    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
        processBlock: function (words, offset) {
            // Shortcuts
            var cipher = this._cipher
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;

            // Generate keystream
            if (iv) {
                counter = this._counter = iv.slice(0);

                // Remove IV for subsequent blocks
                this._iv = undefined;
            }
            
			incCounter(counter);
			
			var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);

            // Encrypt
            for (var i = 0; i < blockSize; i++) {
                words[offset + i] ^= keystream[i];
            }
        }
    });

    CTRGladman.Decryptor = Encryptor;

    return CTRGladman;
}());



// script:viewer/io/crypto/pad-nopadding-min.js
/*
CryptoJS v3.1
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
CryptoJS.pad.NoPadding={pad:function(){},unpad:function(){}};

// script:viewer/io/crypto/vitrium-pbkdf2.js
(function(exports, utils, CryptoJS)
{
  "use strict";
  
	exports.Sha1 = Sha1;
	exports.HMACSha1 = HMACSha1;
	exports.PBKDF2 = PBKDF2;
	exports.calcKeyHash = calcKeyHash;

//
	function Sha1()
	{
		this.count = 0;
		this.hash = new Array(5);
		this.wbuf = new Array(16);
		this.tmp = new Array(80);
		this.reset();
	}
	
	var sha1p = Sha1.prototype;
	sha1p.reset = function()
	{				
		var h = this.hash;
		h[0] = 0x67452301;
		h[1] = 0xefcdab89;
		h[2] = 0x98badcfe;
		h[3] = 0x10325476;
		h[4] = 0xc3d2e1f0;
		
		this.count = 0;
		
		var w = this.wbuf; 
		w[0] = w[1] = w[2] = w[3] = w[4] = w[5] = w[6] = w[7] = w[8] = w[9] = w[10] = w[11] = w[12] = w[13] = w[14] = w[15] = 0;	
	};

	sha1p.updateData = function(data, len)
	{
		var c0 = this.count;
		
		var pos = c0 & 63;
		var space = 64 - pos;
		
		this.count += len;
			
		
		var sp = 0;
		var wbuf = this.wbuf;
		var h = this.hash;
		var tmp =this.tmp;
		
		//console.log("update data", data, len);
		
		while(len >= space)     /* tranfer whole blocks if possible  */
		{
			memcpy(wbuf, pos, data, sp, space);
			sp += space; len -= space; space = 64; pos = 0;
			sha1_compile(h, wbuf, tmp);
		}
		
		//console.log("update data end", data, pos, sp, len);
		memcpy(wbuf, pos, data, sp, len);	
		//console.log("wbuf", wbuf);
		return this;
	};
	
	// crypto js interface
	sha1p.update = function(buffer)
	{
		this.updateData(buffer.words, buffer.sigBytes);
		return this;
	};
	
	sha1p.finalize = function(buffer)
	{
		if (buffer)
		{
			this.update(buffer);
		}
		
		return {
			words: this.flush(),
			sigBytes: 20
			};
	};
	

	var mask = [0x00000000, 0xff000000, 0xffff0000, 0xffffff00 ];

	sha1p.flush = function()
	{
		//console.log("flush");
		var m = mask;
		var count = this.count;
		var pos =  this.count & 63;
		
        // Add padding
		var wbuf = this.wbuf;
		var h = this.hash;
		
		var nBitsTotal = 8 * count;
		var nBitsLeft = 8 * pos;
		
		/*var tmp = wbuf[pos >>> 2] ;
		console.log(pos, pos%4);
	
		var a = (wbuf[pos >>> 2] >>> 24) & 0xff;
		var b = (wbuf[pos >>> 2] >>> 16) & 0xff;
		var c = (wbuf[pos >>> 2] >>> 8) & 0xff;
		var d = (wbuf[pos >>> 2]) & 0xff;
		
		console.log(a.toString(16), b.toString(16), c.toString(16), d.toString(16));
		
		var a = (wbuf[pos >>> 2] >>> 24) & 0xff;
		var b = (wbuf[pos >>> 2] >>> 16) & 0xff;
		var c = (wbuf[pos >>> 2] >>> 8) & 0xff;
		var d = (wbuf[pos >>> 2]) & 0xff;
		
		console.log(a.toString(16), b.toString(16), c.toString(16), d.toString(16));
		*/
		
		wbuf[pos >>> 2] = (wbuf[pos >>> 2] & m[pos&3])| 0x80 << (24 - (pos % 4) *8);		
		var tmp = this.tmp;
		if(pos > 55) // 64 - 9)
		{
			if(pos < 60) wbuf[15] = 0;
			sha1_compile(h, wbuf, tmp);		
			pos = 0;
		}
		else    /* compute a word index for the empty buffer positions  */
			pos = (pos >> 2) + 1;
			
		while(pos < 14) /* and zero pad all but last two positions        */
			wbuf[pos++] = 0;
		     
		
		
		
        wbuf[14] = Math.floor(nBitsTotal / 0x100000000);
        wbuf[15] = nBitsTotal;
        sha1_compile(h, wbuf, tmp);	

		//console.log(CryptoJS.enc.Hex.stringify({ words: h, sigBytes: 20 }));
		return h;
	};
	
	function sha1_compile(H, M, W)
	{

			var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];

			var i = 0;
			for (; i < 16; ++i) {          
                W[i] = M[i] | 0; 
                var t = (((a << 5) | (a >>> 27)) + e + W[i]) +  (((b & c) | (~b & d)) + 0x5a827999);
               
                e = d;
                d = c;
                c = (b << 30) | (b >>> 2);
                b = a;
                a = t;
            }
			
			for (; i < 20; ++i) {          
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = (n << 1) | (n >>> 31);
				
                var t = (((a << 5) | (a >>> 27)) + e + W[i]) +  (((b & c) | (~b & d)) + 0x5a827999);
               
                e = d;
                d = c;
                c = (b << 30) | (b >>> 2);
                b = a;
                a = t;
            }
			
			for (; i < 40; ++i) {          
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = (n << 1) | (n >>> 31);
				
                var t = (((a << 5) | (a >>> 27)) + e + W[i]) +  ((b ^ c ^ d) + 0x6ed9eba1);
               
                e = d;
                d = c;
                c = (b << 30) | (b >>> 2);
                b = a;
                a = t;
            }
			
			for (; i < 60; ++i) {          
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = (n << 1) | (n >>> 31);
				
                var t = (((a << 5) | (a >>> 27)) + e + W[i]) + (((b & c) | (b & d) | (c & d)) - 0x70e44324);
               
                e = d;
                d = c;
                c = (b << 30) | (b >>> 2);
                b = a;
                a = t;
            }
			
			for (; i < 80; ++i) {          
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = (n << 1) | (n >>> 31);
				
                var t = (((a << 5) | (a >>> 27)) + e + W[i]) + ((b ^ c ^ d) - 0x359d3e2a);
               
                e = d;
                d = c;
                c = (b << 30) | (b >>> 2);
                b = a;
                a = t;
            }
			
            // Computation
			
            /*for (var i = 0; i < 80; ++i) {
                if (i < 16) {
                    W[i] = M[i] | 0;
                } else {
                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                    W[i] = (n << 1) | (n >>> 31);
                }

                var t = ((a << 5) | (a >>> 27)) + e + W[i];
                if (i < 20) {
                    t += ((b & c) | (~b & d)) + 0x5a827999;
                } else if (i < 40) {
                    t += (b ^ c ^ d) + 0x6ed9eba1;
                } else if (i < 60) {
                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
                } else  {
                    t += (b ^ c ^ d) - 0x359d3e2a;
                }

                e = d;
                d = c;
                c = (b << 30) | (b >>> 2);
                b = a;
                a = t;
            }*/

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
            H[4] = (H[4] + e) | 0;
			
			//console.log("v step", CryptoJS.enc.Hex.stringify({ words : H, sigBytes: 20}), M);
	}
	
	function b2word(word, pos, b)
	{
		var b0 = (word >>> 24) & 0xff;
		var b1 = (word >>> 16) & 0xff;
		var b2 = (word >>> 8) & 0xff;
		var b3 = word & 0xff;
		
		switch(pos)
		{
			case 0:
				b0 = b;
			break;
			case 1:
				b1 = b;
			break;
			case 2:
				b2 = b;
			break;
			case 3:
				b3 = b;
			break;
			default:
				throw new Error("out of index: "+pos);
			break;
		};
		
		return (b0 << 24) | (b1 << 16) | (b2 << 8) | b3;
	}
	
	function memcpy(thisWords, thisSigBytes, thatWords, offset, thatSigBytes)
	{
		thisWords[thisSigBytes >>> 2] &= 0xffffffff << (32 - (thisSigBytes % 4) * 8);
		//thisSigBytes = Math.ceil(thisSigBytes / 4);
		
		// Concat
		if (thisSigBytes % 4 || offset % 4) {
			
			//var byteOffset = offset % 4;
			// Copy one byte at a time
			
			var bidx;
			var bVal;
			var dbidx;
			var dwidx;
			
			for (var i = 0; i < thatSigBytes; ++i) 
			{
				bidx = offset +i;
				bVal = (thatWords[bidx >>> 2] >>> (24 - (bidx % 4) * 8)) & 0xff;
				dbidx = (thisSigBytes + i);
				dwidx = dbidx >>> 2;
				thisWords[dwidx] = b2word(thisWords[dwidx], dbidx % 4, bVal);
			}
		} 
		else 
		{		
			var uncompletdWordOffset = thatSigBytes%4;
			var lastWholeWord = thatSigBytes - uncompletdWordOffset;
			// Copy one word at a time
			
			var i;
			for ( i = 0; i < lastWholeWord; i += 4) {	
				thisWords[(thisSigBytes + i) >>> 2] = thatWords[(offset + i) >>> 2];	
			}
			
			if (uncompletdWordOffset > 0)
			{
				var lastWord = thisWords[(thisSigBytes + i) >>> 2];
				var srcWord = thatWords[(offset + i) >>> 2];
				switch(uncompletdWordOffset)
				{					
					case 3:
						lastWord = b2word(lastWord, 2, (srcWord >>> 8)& 0xff);
					case 2:
						lastWord = b2word(lastWord, 1, (srcWord >>> 16)& 0xff);
					case 1:
						lastWord = b2word(lastWord, 0, (srcWord >>> 24)& 0xff);
					break;
				}
				
				thisWords[(thisSigBytes + i) >>> 2] = lastWord;
			}
		} 
		  
		return thisSigBytes + thatSigBytes;
	}
	
	function clamp(words, sigBytes)
	{
		words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
		sigBytes = Math.ceil(sigBytes / 4);
		return sigBytes;
	}
	
	/**
		HMAC - SHA1 
		arguments: key in words
	*/
	function HMACSha1(key)
	{
		var h = this.hasher = new Sha1();
		var hasherBlockSize = 16;
        var hasherBlockSizeBytes = hasherBlockSize * 4;
		this.tmp =  new Array(5);
		
		if (key.sigBytes > hasherBlockSizeBytes) 
		{
			key = h.finalize(key);
		}
		
		//key.sigBytes = clamp(key.words, key.sigBytes);
		
		var oKey = this._oKey = key.words.slice(0);
        var iKey = this._iKey = key.words.slice(0);

            // XOR keys with pad constants
        for (var i = 0; i < hasherBlockSize; i++) {
            oKey[i] ^= 0x5c5c5c5c;
            iKey[i] ^= 0x36363636;
        }
		
        this.reset();
	}
	
	var hmacp = HMACSha1.prototype;
	hmacp.reset = function()
	{
		var h = this.hasher;
        h.reset();
        h.updateData(this._iKey, 64);
	};
	
	hmacp.update = function(data)
	{
		this.hasher.update(data);
		return this;
	};
	
	hmacp.updateData = function(data, sigBytes)
	{
		this.hasher.updateData(data, sigBytes);
		return this;
	};
	
	hmacp.finalize = function(data)
	{
		// Compute HMAC
		var hasher = this.hasher;
		var tmp = this.tmp;
		
		var hash = hasher.hash;
		
		if (data)
		{
			hasher.update(data);
		}
		
		hasher.flush();
		
		memcpy(tmp, 0, hash, 0, 20);
				
		hasher.reset();
		hasher.updateData(this._oKey, 64);
		hasher.updateData(tmp, 20);
		
		hasher.flush();
	};
		
	function PBKDF2(password, salt, keySize,iterations)
	{
		var keyBufferSize = Math.ceil(keySize);
		var hmac = new HMACSha1(password);
	//	var hmacIn = new HMACSha1(password);

		// Initial values
		var derivedKey = new Array(keyBufferSize);
		var blockIndex = [0x00000001];

		// Generate key
		var saltWords = salt.words;
		var saltBytes = salt.sigBytes;
		
		var dkLen = 0;
		
		var hash = hmac.hasher.hash; // 5  words = 20 bytes
		var bW = new Array(5);// 5  words = 20 bytes
		var interA = new Array(5);
		
		while (dkLen < keySize)
		{
			hmac.updateData(saltWords, saltBytes).updateData(blockIndex, 4).finalize();
			memcpy(bW, 0, hash, 0, 20);
			hmac.reset();
			// Iterations
			var inter = bW;
			for (var i = 1; i < iterations; ++i)
			{
				hmac.updateData(inter, 20).finalize();
				memcpy(interA, 0, hash, 0, 20);
				inter = interA;
				
				hmac.reset();
				// XOR intermediate with block
				for (var j = 0; j < 5; ++j) {
					bW[j] ^= interA[j];
				}	
			}

			memcpy(derivedKey, dkLen*4, bW, 0, 20);
		//	derivedKey.concat(block);
			
			dkLen += 5;
			++blockIndex[0];
			
			hmac.reset();
		}
		
		return { words : derivedKey, sigBytes : keySize * 4 };
	};

	function calcKeyHash(key)
	{
	   var array = utils.u8array.parse(key);
	   var salt = CryptoJS.enc.Hex.parse("fbdb1d1b18aa6c08324b7d64b71fb76370690e1d");
	   var result = PBKDF2(array, salt, 4, 100);

	   return CryptoJS.enc.Hex.stringify(result);
	}

//
}(
vitrium.crypto,
vitrium.utils,
CryptoJS));

// script:viewer/io/crypto/crypto-typed-array-conversion.js
(function(exports)
{
	"use strict";

	exports.u8array = {
        /**
         * Converts a word array to a Uint8Array.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {Uint8Array} The Uint8Array.
         *
         * @static
         *
         * @example
         *
         *     var u8arr = utils.u8array.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
			var u8;
			if (typeof Uint8Array === "function" || typeof Uint8Array === "object")
			{
				u8 = new Uint8Array(sigBytes); 
			}
			else
			{
				
				u8 = new Array(sigBytes);
			}
             
            for (var i = 0; i < sigBytes; i++) {
                var b = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                u8[i]=b;
            }
	
			
			
            return u8;
        },

        /**
         * Converts a Uint8Array to a word array.
         *
         * @param {string} u8Str The Uint8Array.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = utils.u8array.parse(u8arr);
         */
        parse: function (u8arr, expllen) {
            // Shortcut
            var len = u8arr.length;
			if (typeof expllen === "number")
			{
				len = expllen;
			}
			
			if (typeof Uint8Array === "function" || typeof Uint8Array === "object" || _.isArray(u8arr))
			{
				// Convert
				var words = [];
				for (var i = 0; i < len; i++) {
					words[i >>> 2] |= (u8arr[i] & 0xff) << (24 - (i % 4) * 8);
				}
				
				//var words = new Uint32Array(u8arr.buffer);

				return CryptoJS.lib.WordArray.create(words, len);
			}
			else
			{
				var words = [];
				for (var i = 0; i < len; i++) {
					words[i >>> 2] |= (u8arr.readByteAt(i) & 0xff) << (24 - (i % 4) * 8);
				}

				return CryptoJS.lib.WordArray.create(words, len);
			}
        }
    };
	
}(vitrium.utils));
// script:viewer/io/crypto/single-password-key-derivation.js
(function (exports, bin, utils, crypto, CryptoJS, _, global)
{
  "use strict";
  var isTypedArraysSupported = !!global.ArrayBuffer;
  
  exports.SinglePasswordKeyDerivation = SinglePasswordKeyDerivation;
  
  function SinglePasswordKeyDerivation(entries, globalFlags)
  {
    this.entries = entries;
    this._initGlobalFlags(globalFlags);
    this.password = null;
    this.queue = null;

    this.prioritizedNames = [];
  }
  
  SinglePasswordKeyDerivation.prototype = {
    _initGlobalFlags : function (globalFlags)
    {
      var singleKey = this.singleKey = (globalFlags & 1) === 1;
      if (singleKey)
      {
        this.deriveKeys = this.deriveKeysSingle;
      }
      else
      {
        this.deriveKeys = this.deriveKeysMulti;
      }
    },
    setPassword : function(password)
    {
      if (password === null)
      {
        this.password = null;
      }
      else
      {
        this.password = CryptoJS.enc.Utf8.parse(password);

        if (!this.singleKey)
        {
           this.queue = _.clone(this.entries);

           var prioritizeNames = this.prioritizedNames;
           this.prioritizedNames = [];
           _.each(prioritizeNames, _.bind(this.prioritize, this));
        }
      }
    },
    prioritize : function(entryName)
    {
      this.prioritizedNames.push(entryName);
      if (this.queue !== null) {
         var idx = indexOfByFilename(this.queue, entryName);
         if (idx !== -1) {
            var item = this.queue.splice(idx, 1);
            item[0]._prioritized = true;

            var placeAt = indexOfFirstNotPriorizied(this.queue);
            this.queue.splice(placeAt, 0, item[0]);
         }
      }
    },
    deriveKeyForEntry : function(entry)
    {
      var utf8Pwd = this.password;
      if (utf8Pwd === null) return false;

      var computedPV = deriveKeysForEntry(entry, utf8Pwd);
      if (computedPV === entry.aesPV)
      {
        if (this.singleKey)
        {
          var entries = this.entries;
          for (var i = 0, len = this.entries.length; i < len; ++i)
          {
            var e = entries[i];
            e.aesDerivedKey = entry.aesDerivedKey;
            e.hmacKey = entry.hmacKey;
          }
        }
        return true;
      }
      else
      {
        entry.aesDerivedKey = null;
        entry.hmacKey = null;
        return false;
      }
    },
    _next : function()
    {
      return this.queue.shift();
    },
    deriveKeysSingle: function ()
    {
      var entries = this.entries;
      var utf8Pwd = this.password;
      if (utf8Pwd === null) return { invalidPassword: true };
            
      var check = true;
      var prot = null;

      for (var i =0,len=entries.length; i < len && check; ++i)
      {
        var entry = entries[i];
        
        if (entry.flags&(2)) // only two is allowed in this case
        {
          if (prot !== null)
          {
            entry.aesDerivedKey = prot.aesDerivedKey;
            entry.hmacKey = prot.hmacKey;
          }
          else
          {
            var computedPV = deriveKeysForEntry(entry, utf8Pwd);
            check = computedPV === entry.aesPV;
            if (!check)
            {
              entry.aesDerivedKey = null;
              break;
            }
            else
            {
              prot = entry;
            }
          }
        }
      }

      if (check)
      {
        return { invalidPassword : false, finished: true, entries: entries };
      }
      else
      {
        this.password = null;
        return { invalidPassword: true };
      }
    },
    deriveKeysMulti: function (limit)
    {
      if (!limit) limit = 1;

      var utf8Pwd = this.password;
      if (utf8Pwd === null) return { invalidPassword: true };
      var processed = [];
      var invalidPassword = false;
      var entry = null;
      while ((limit--) > 0 && (entry = this._next()))
      {
        if ((entry.flags & (2|4)) !== 0)
        {
          var computedPV = deriveKeysForEntry(entry, utf8Pwd);
          if (computedPV !== entry.aesPV)
          {
            invalidPassword = true;
            break;
          }
          else
          {
            processed.push(entry);
          }
        }			  
      }
            
      if (invalidPassword)
      {
        this.password = null;
        return { invalidPassword: true };
      }
      else
      {
        return { invalidPassword: false, finished: this.queue.length === 0, entries: processed };
      }
    }
  };

  function deriveKeysForEntry(entry, utf8Pwd)
  {
    
      var wordSalt =  utils.u8array.parse(entry.aesSalt);
      var keyLen = (8 * (entry.aesMode & 3) + 8);
      var key = crypto.PBKDF2(utf8Pwd, wordSalt, ((2*keyLen)+2)/4, 1000);
      
      var keyBytes =  utils.u8array.stringify(key);
      if (!isTypedArraysSupported)	// IE
      {
        var b = new vitrium.bin.DataBuffer();
        b.attachData(keyBytes);
        keyBytes = b;
      }
      
      var computedPVV = bin.getDataHelper(keyBytes.length, keyBytes).view.getUint16(keyLen*2,true);
      
      entry.aesDerivedKey = keyBytes.subarray(0, keyLen);
      entry.hmacKey = keyBytes.subarray(keyLen, keyLen+keyLen);
      return computedPVV;
    

  }

  function indexOfByFilename(arr, filename)
  {
     for (var i = 0, len = arr.length; i !== len; ++i)
     {
        if (arr[i].filename === filename)
           return i;
     }
     return -1;
  }

  function indexOfFirstNotPriorizied(arr)
  {
     for (var i = 0, len = arr.length; i !== len; ++i)
     {
        if (!arr[i]._prioritized)
           return i;
     }
     return arr.length;
  }

}(
vitrium.g4s, 
vitrium.bin, 
vitrium.utils,
vitrium.crypto,
CryptoJS,
_,
__globals__
));
// script:viewer/service/completer.js
(function(exports)
{
  "use strict";
  
  exports.Completer = Completer;
  exports.ProgressCompleter = ProgressCompleter;
  exports.Cancelable = Cancelable;
  exports.asyncSuccess = asyncSuccess;
  exports.asyncError = asyncError;
  exports.callDefered = callDefered;
  exports.run = asyncRun;
  
  function Completer(cancelCallback)
  {
    this.future = new Future(cancelCallback);  
  }
  
  Completer.prototype =
  {
    complete : function()
    {
      var f = this.future;
      f._cancelCallback = null;

      f.done = true;
      f.succeed = true;

      var args = [];
      args.push.apply(args, arguments);
      
      this._execute(f._onSucceed, args);

      args.push(true);
      this._execute(f._onCompleted, args);
      f._onFailed.length = 0;
    },
    fail : function()
    {
      var f = this.future;
      f._cancelCallback = null;

      f.done = true;
      
      var args = [];
      args.push.apply(args, arguments);

      this._execute(f._onFailed, args);

      args.push(false);
      this._execute(f._onCompleted, args);
      f._onSucceed.length = 0;      
    },
    _execute: function(callbackQueue, args)
    {
      for (var i = 0; i < callbackQueue.length; ++i)
      {
        callbackQueue[i].apply(null, args);        
      }

      callbackQueue.length = 0;
    }
  
  };
  
  function Future(cancelCallback)
  {
    this.done = false;
    this.succeed = false;
    
    this._cancelCallback = cancelCallback ? cancelCallback : null;
    this._onCompleted = [];
    this._onSucceed = [];
    this._onFailed  = [];    
  }
  
  Future.prototype = {
    success : _then,
    error : _catchError,
    completed: _whenComplete,
    then : _then,
    catchError : _catchError,
    whenComplete: _whenComplete,
    
    cancel : _cancel,
    abort: _cancel,
    chainSuccess : function(completer)
    {
      this.then(function () { completer.complete.apply(completer, arguments); });
      return this;
    },
    chainError: function(completer)
    {
      this.catchError(function () { completer.fail.apply(completer, arguments); });
      return this;
    },
    runWhenSucceed : function(callback)
    {
      if (this.done && this.succeed)
      {        
        setTimeout(callback, 0);
      }
      else if (!this.done)
      {
        this.then(callback);
      }
      
      return this;
    },
    runWhenFailed : function(callback)
    {
      if (this.done && !this.succeed)
      {
        setTimeout(function(){ callback(); }, 0);
      }
      else if (!this.done)
      {
        this.catchError(callback);
      }
      
      return this;
    }
  };
  
  function _cancel()
  {
    this.done = true;
    this._onCompleted.length = 0;
    this._onSucceed.length = 0;
    this._onFailed.length = 0;
    
    if (this._cancelCallback)
    {
      this._cancelCallback();
      this._cancelCallback = null;
    }
    
  }
  
  function _then(callback)
  {
    this._onSucceed.push(callback);
    return this;
  }
  
  function _catchError(callback)
  {
    this._onFailed.push(callback);
    return this;
  }
  
  function _whenComplete(callback)
  {
    this._onCompleted.push(callback);
    return this;
  }
  

  function asyncSuccess(completer, data, extendedData)
  {
    var id = setTimeout(function ()
    {
      completer.complete(data, extendedData);
    }, 0);

    completer._oldCancelCallback = completer._cancelCallback;
    completer._cancelCallback = function ()
    {
      clearTimeout(id);
      if (this._oldCancelCallback) this._oldCancelCallback();
    };
  }


  function asyncError(completer, reason)
  {
    var id = setTimeout(function ()
    {
      completer.fail(reason);
    }, 0);

    completer._oldCancelCallback = completer._cancelCallback;
    completer._cancelCallback = function ()
    {
      clearTimeout(id);
      if (this._oldCancelCallback) this._oldCancelCallback();
    };
  }

  function asyncRun(fcnt)
  {
    setTimeout(fcnt, 1);
  }

  function callDefered(callback) {
     var completer = new Completer();

     setTimeout(function () {
        try {
           completer.complete(callback());
        }
        catch (e) {
           completer.fail(e);
        }

     }, 1);

     return completer.future;
  }

  function Cancelable()
  {
    this.canceled = false;
    this._asyncTask = null;
    var self = this;
    this.cancelCallback = function () { self.cancel(); };
  }
  Cancelable.prototype =
  {
     set asyncTask(_task)
     {
        if (!_task)
        {
           if (typeof _task === "undefined")
           {
              try {
                 throw new Error();
              } catch (e)
              {
                 if ("console" in window)
                 {
                    console.log(e)
                 }
              }
           }

           this._asyncTask = null;
        }
        else
        {
           this._asyncTask = _task;
        }
     },
     get asyncTask()
     {
        return this._asyncTask;
     },
    cancel: function ()
    {
      this.canceled = true;
      if(this.asyncTask !== null)
      {
        var task = this.asyncTask;
        if ("abort" in task)
        {
          task.abort();
        }
        else if ("terminate" in task)
        {
          task.terminate();
        }
        else if ("cancel" in task)
        {
          task.cancel();
        }

        this.asyncTask = null;
      }
    }
  };
  Cancelable.prototype.abort = Cancelable.prototype.cancel;
  Cancelable.prototype.terminate = Cancelable.prototype.cancel;

  function ProgressCompleter(cancelCallback)
  {
    Completer.call(this, cancelCallback);
    this.future = new ProgressFuture(cancelCallback);
  }

  ProgressCompleter.prototype = Object.create(Completer.prototype);
  ProgressCompleter.prototype.constructor = ProgressCompleter;
  ProgressCompleter.prototype.progress = function (progress)
  {
    this.future.currentProgress = progress;
    this._executeProgress(this.future._onProgress, progress);
  };
  ProgressCompleter.prototype._executeProgress = function (callbackQueue, progress)
  {
    for (var i = 0, len = callbackQueue.length; i < len; ++i)
    {
      callbackQueue[i](progress);
    }
  };
  

  function ProgressFuture(cancelCallback)
  {
    Future.call(this, cancelCallback);
    this._onProgress = [];
    this.currentProgress = 0;
  }
  ProgressFuture.prototype = Object.create(Future.prototype);
  ProgressFuture.prototype.constructor = ProgressFuture;
  ProgressFuture.prototype.whenProgress = function (callback)
  {
    this._onProgress.push(callback);
    return this;
  };

}
(vitrium.async));
// script:viewer/service/completer-batch.js
(function (exports, async, _) {
   "use strict";

   exports.Batch = Batch;
   function Batch() {
      this._requests = 0;

      this._succeeded = 0;
      this._failed = 0;
      this._boundOnSuccess = _.bind(this._onSuccess, this);
      this._boundOnFailed = _.bind(this._onFailed, this);
      this._completer = new async.Completer();
      this.future = this._completer.future;
   }
   Batch.prototype = {
      addFuture: function (future) {
         ++this._requests;

         future
            .then(this._boundOnSuccess)
            .catchError(this._boundOnFailed);
      },
      _onSuccess: function () {
         ++this._succeeded;
         this._completeWhenDone();
      },
      _onFailed: function () {
         ++this._failed;
         this._completeWhenDone();
      },
      _completeWhenDone: function () {
         if (this._failed + this._succeeded === this._requests) {
            if (this._failed !== 0) this._completer.fail(this._succeeded, this._failed);
            else this._completer.complete(this._succeeded, this._failed);

            this._boundOnSuccess = null;
            this._boundOnFailed = null;
         }
      }

   };

}
(vitrium.async,
vitrium.async,
_));
// script:viewer/service/completer-group.js
(function(exports, service, async, _)
{
  "use strict";
  
  exports.CompleterGroup = CompleterGroup;
  exports.Completer =async.Completer;

  function CompleterGroup()
  {
    async.Completer.call(this);
    this.completers = [];
  }
  
  _.extend(CompleterGroup.prototype, async.Completer.prototype);
  _.extend(CompleterGroup.prototype, {
    
    add : function(completer)
    {
      this.completers.push(completer)
    },
    $superComplete : async.Completer.prototype.complete,
    complete : function(messages, data)
    {
      var c = this.completers;
      if (c.length == messages.length)
      {
        for (var i = 0, len = messages.length; i < len; ++i)
        {
          var msg = messages[i];
          if (_.isNumber(msg))
          {
            c[i].fail(msg);
          }
          else
          {
            c[i].complete(msg, data);
          }
        }
        
        this.$superComplete(messages, data);
      }
      else
      {
        this.fail(service.ERROR_CODES.UNBALANCED_RESPONSE);
      }
    },
    $superFail : async.Completer.prototype.fail,
    fail : function(errorCode)
    {
      var c = this.completers;
      for (var i = 0, len = c.length; i < len; ++i)
      {
        c[i].fail(errorCode);
      }
      
      this.$superFail(errorCode);
    }
  });
}(
vitrium.service, 
vitrium.service,
vitrium.async,
_));
// script:viewer/service/error-codes.js
(function(exports)
{
  "use strict";
  
  exports.ERROR_CODES = {
    UNBALANCED_RESPONSE : 900,
    INVALID_RESPONSE_CHECKSUM : 901,
    INVALID_RESPONSE_FORMAT : 902,
    INVALID_RESPONSE_MIMETYPE: 903
  
  };
  

}(vitrium.service));
// script:viewer/service/http-request-template.js
(function(exports, _)
{
  "use strict";
  
  exports.HTTPRequestTemplate = HTTPRequestTemplate;
  
  function HTTPRequestTemplate(url)
  {
    function Request(data, completer)
    {
      this.data = data;
      this.completer = completer;
    }
    
    Request.prototype = {    
      url : url || "",
      method : "POST",
      headers : [
        ["Content-Type" , "application/json"]
      ],
      success : function(data, xhr)
      {
        this.completer.complete(data, xhr);
      },
      error : function(reason)
      {
        this.completer.fail(reason);
      },
      addHeader: function(name, val)
      {
        if (this.headers === Request.prototype.headers)
        {
          this.headers = _.clone(this.headers);
        }
        
        this.headers.push([name, val]);     
      }
    };
    
    this._RequestClass = Request;
  }
  
  HTTPRequestTemplate.prototype = 
  {
    create : function(data, completer)
    {
      return new this._RequestClass(data, completer);
    }  
  };
}
(vitrium.service,
 _));
// script:viewer/service/http-service-caller.js
(function(exports,service, utils, log, _)
{
	"use strict";
    
  exports.HTTPServiceCaller = HTTPServiceCaller;

	function HTTPServiceCaller(url, signatureCalculator,  lang, metadata)
  {
    this.requestTemplate = new service.HTTPRequestTemplate(url);
    this.requestBuilder = new service.RequestBuilder(lang || "en", metadata || {});
    
    this.currentGroup = new service.CompleterGroup();
    
    if (!signatureCalculator) signatureCalculator = null;
    this.signatureCalculator = signatureCalculator;
    
    this.signatureHeader = "V-Sign";
    this.calculateRequestSignature = signatureCalculator !== null;
  }
  
  HTTPServiceCaller.prototype = {
    call : function(name, action, data)
    {
      var cmpl = new service.Completer();      
      this.requestBuilder.add(name, action, data);
      this.currentGroup.add(cmpl);
      
      return cmpl.future;
    },
    send : function()
    {
      
      var data = this.requestBuilder.buildJSON();
      var messageCompleter = this.currentGroup;
      
      var completer = new service.JSONParserCompleter(messageCompleter);
      this.currentGroup = new service.CompleterGroup();
      
      if (this.signatureCalculator !== null)
      {
        completer = new service.SingnatureVerifierCompleter(this.signatureCalculator, completer, this.signatureHeader);
      }
      
      var request = this.requestTemplate.create(data, completer);
      
      if (this.signatureCalculator !== null 
          && this.calculateRequestSignature)
      {
        var signature = this.signatureCalculator.calculateMessageSignature(data);
        request.addHeader(this.signatureHeader, signature);
      }
      
      utils.loadDataCORS(request);
      
      return messageCompleter.future;      
    }
  };
}
(
vitrium.service,
vitrium.service,
vitrium.utils,
vitrium.log,
_
));
// script:viewer/service/json-parser-completer.js
(function(exports, service)
{
  "use strict";
  
  exports.JSONParserCompleter = JSONParserCompleter;
  function JSONParserCompleter(completer)
  {
    this.completer = completer;  
  }
  
  JSONParserCompleter.prototype = {
    complete : function (data, xhr)
    {
      var contentType = xhr.getResponseHeader("Content-Type");
      contentType = contentType.split(";")[0];
      
      if (contentType !== "application/json")
      {
        this.fail(service.ERROR_CODES.INVALID_RESPONSE_MIMETYPE);
      }
      else
      {
        var json = null;
        try
        {
          json = JSON.parse(data);
        }
        catch(e)
        {
          this.fail(service.ERROR_CODES.INVALID_RESPONSE_FORMAT);
          return;
        }
        
        this.completer.complete(json, xhr);        
      }
    },
    fail : function(reason)
    {
      this.completer.fail(reason);
    }
  };
}
(
vitrium.service,
vitrium.service));
// script:viewer/service/request-builder.js
(function(exports)
{
	"use strict";
exports.RequestBuilder = RequestBuilder;

function RequestBuilder(lang, metadata)
{
  this._messages = [];
  
  this._request = {
    lang : lang,
    metadata : metadata,
    messages : this._messages
  };
}
  
RequestBuilder.prototype = {
  add : function(service, action, data)
  {
    this._messages.push({ 
      service : service, 
      action : action, 
      data : data
    });
  },
  buildJSON : function()
  {
    var jsonMessage = JSON.stringify(this._request);
    this._messages.length = 0;
    return jsonMessage;
  }
};

}(vitrium.service));
// script:viewer/service/rsa-sha1-signature-calculator.js
(function(exports, crypto, CryptoJS, RSAKey)
{
  "use strict";
  exports.SignatureCalulator = SignatureCalulator;
  
  
  
  function SignatureCalulator(key, exponent)
  {
    this.hasher = new crypto.Sha1();
    this.textEncoding = CryptoJS.enc.Utf8;
    this.hashEncoding = vitrium.utils.u8array;
    
    var rsaDecryptKey = this.rsaDecryptKey = new RSAKey();
    // It is a public key but we want to decrypt the signature
    rsaDecryptKey.setPrivate(key, exponent, exponent);
    
    var rsaEncryptKey = this.rsaEncryptKey = new RSAKey();
    rsaEncryptKey.setPublic(key, exponent);
  }
  
  SignatureCalulator.prototype = 
  {
    calculateMessageHash: function(message)
    {
      var wordArray = this.textEncoding.parse(message);
      this.hasher.update(wordArray);
      var hash = this.hasher.finalize();
      var enHash = this.hashEncoding.stringify(hash);
      this.hasher.reset();  
      return enHash;
    },
    calculateMessageSignature : function(message)
    {
      var hash = this.calculateMessageHash(message);
      return this.rsaEncryptKey.encryptByteArray(hash);
    },
    verifyMessageSignature: function(message, signature)
    {
      var decryptedHash = this.rsaDecryptKey.decrypt2ByteArray(signature);
      if (decryptedHash === null)
      {
        return false;
      }
      
      var hashByteArray = this.calculateMessageHash(message);
      
      if (decryptedHash.length === hashByteArray.length)
      {
        var isOk = true;
        for (var i =0, len = decryptedHash.length; i < len && isOk ;++i)
        {
          isOk = decryptedHash[i] === hashByteArray[i];
        }
        
        return isOk ;
      
      }
      else
      {
        return false;
      }
    }  
  };
  
  
}
(
vitrium.crypto,
vitrium.crypto,
CryptoJS,
RSAKey
));
// script:viewer/service/signature-verifier-completer.js
(function(exports, service)
{
  "use strict";
  
  exports.SingnatureVerifierCompleter = SingnatureVerifierCompleter;
  
  function SingnatureVerifierCompleter(signatureCalculator, completer, header)
  {
    this.signatureCalculator = signatureCalculator;
    this.completer = completer;  
    this.header = header || "V-Sign";
  }
  
  SingnatureVerifierCompleter.prototype = {
    complete : function (data, xhr)
    {
      var signature = xhr.getResponseHeader(this.header);
      // missing checksum
      if (signature === null) 
      {
        this.fail(service.ERROR_CODES.INVALID_RESPONSE_CHECKSUM);
      }
      else
      {
        if (this.signatureCalculator.verifyMessageSignature(data, signature))
        {
          this.completer.complete(data, xhr);
        }
        else
        {
          this.fail(service.ERROR_CODES.INVALID_RESPONSE_CHECKSUM);
        }
      }
    },
    fail : function(reason)
    {
      this.completer.fail(reason);
    }  
  };
}
(
vitrium.service,
vitrium.service));
// script:viewer/service/rest-client.js
/// <reference path="~/build.html" />

(function (exports, async, _)
{
   exports.RestClient = RestClient;

   function RestClient(url, beforeRequest)
   {
      if (_.isUndefined(url)) throw new Error("Url must be defined!");
      this.url = url;
      this.beforeRequest = beforeRequest ? beforeRequest : null;
   }

   RestClient.prototype = {
      sendGet : function(urlExt, queryArgs)
      {
         return this._request("GET", urlExt, queryArgs);
      },
      sendDelete: function (data, urlExt, queryArgs) {
         return this._request("DELETE", urlExt, queryArgs, data);
      },
      sendHead: function (urlExt, queryArgs) {
         return this._request("HEAD", urlExt, queryArgs);
      },
      sendPost: function (data, urlExt, queryArgs)
      {
         return this._request("POST", urlExt, queryArgs, data);
      },
      sendPut: function (data, urlExt, queryArgs) {
         return this._request("PUT", urlExt, queryArgs, data);
      },
      sendPatch: function (data, urlExt, queryArgs) {
         return this._request("PATCH", urlExt, queryArgs, data);
      },
      _request: function(method, urlExt, queryArgs, data)
      {
         if (!data) data = "";
         else data = JSON.stringify(data);

         var completer = new async.Completer(function () {
            if (req)
            {
               req.abort();
               req = null;
            }
         });

         var req = $.ajax({
            converters: {
               "json": function (result)
               {
                  if (result === "")
                  {
                     result = null;
                  }
                  return JSON.parse(result);
               }
            },
            type: method,
            beforeSend: this.beforeRequest ? _.bind(this.beforeRequest, this) : function () { },
            url: this._formatUrl(this.url, urlExt, queryArgs),
            dataType: 'json',
            contentType: 'application/json',
            data: data,
            processData: false,
            cache: false,
            success: function (data, a, xhr)
            {
               completer.complete(data, xhr);
            },
            error: function (xhr, b, c)
            {
               var msg;
               
               try
               {
                   msg = xhr.responseText;
                  if (msg)
                  {
                     msg = JSON.parse(msg);
                  }
               }
               catch(e)
               {
                  if (c.message) msg = c.message;
               }

               completer.fail(xhr.status, msg, xhr);
            }
         });

         return completer.future;
      },
      _formatUrl: function (baseUrl, extUrl, queryArgs)
      {
         if (!extUrl) extUrl = "";

         var buffer = [baseUrl, extUrl];
         var hasFirstQuery = baseUrl.indexOf("?") !== -1 || extUrl.indexOf("?") !== -1;
         _.each(queryArgs, function(val, key)
         {
            if (hasFirstQuery)
            {
               buffer.push("&");
            }
            else
            {
               buffer.push("?");
               hasFirstQuery = true;
            }
            buffer.push(key);
            buffer.push("=");
            buffer.push(encodeURIComponent(val));
         });

         return buffer.join("");
      }
   };

}(
vitrium.service,
vitrium.async,
_));
// script:viewer/service/service-caller-adapter.js
(function (exports, service, async, log, _) {
   "use strict";

   exports.ServiceCallerAdapter = ServiceCallerAdapter;
   function ServiceCallerAdapter(serviceToRestMapping)
   {
      this.serviceToRestMapping = serviceToRestMapping;

      this.currentBatch = null;
      this.currentMappings = null;
   }

   ServiceCallerAdapter.prototype = {
      call: function (name, action, data)
      {
         if (this.currentBatch === null)
         {
            this.currentBatch = new async.Batch();
            this.currentMappings = [];
         }

         var key = name + "." + action;
         var mapping = _.find(this.serviceToRestMapping, function (mapping) { return mapping.canBeCalled(key); });
         if (!mapping) throw new Error("No mapping found for: " + key);

         if (this.currentMappings.indexOf(mapping) === -1) this.currentMappings.push(mapping);
         
         var future = mapping.batch(key, data);

         this.currentBatch.addFuture(future);

         return future;
      },
      send: function ()
      {
         _.each(this.currentMappings, function (mapping) {
            mapping.execute();
         });

         var completer = new async.Completer();

         var future = this.currentBatch.future;
         future.then(function () {
            completer.complete();
         });
         future.catchError(function (succeeded, faild) {
            if (succeeded > 0)
            {
               completer.complete();
            }else
            {
               completer.fail();
            }
         });

         this.currentBatch = null;
         this.currentMappings = null;

         return completer.future;
      }
   };


   exports.ServiceMapping = ServiceMapping; 
   function ServiceMapping(providerCallback)
   {
      this.providerCallback = providerCallback;
      this.calls = {};
      this.currentBatch = {};
   }

   ServiceMapping.prototype = {
      add: function(key, attr)
      {
         this.calls[key] = { attr: attr ? attr : null };
         return this;
      },
      canBeCalled: function(key)
      {
         return key in this.calls;
      },
      batch: function(key, data)
      {
         if (!_.isEmpty(data)) log.debug("[ServiceMapping] there is no support for passing data back to server.");

         var completer = this.currentBatch[key];
         if (!completer)
         {
            completer = new async.Completer();
            this.currentBatch[key] = completer;
         }
                  
         return completer.future;
      },
      execute: function()
      {
         var batch = this.currentBatch;
         var self = this;
         this.providerCallback().then(function (data) {
            _.each(batch, function (completer, key) {
               var attr = self.calls[key].attr;
               if (!attr) {
                  completer.complete(data);
               }
               else if (attr in data)
               {
                  completer.complete(data[attr]);
               }
               else
               {
                  completer.fail(404);
               }
            });
         })
         .catchError(function(code, message)
         { 
            _.each(batch, function (completer) { completer.fail(code, message); });
         });
         this.currentBatch = {};
      }

   };

   exports.DirectMapping = DirectMapping;
   function DirectMapping(prefix, callback)
   {
      this.prefix = prefix;
      this.callback = callback;
      this._current = [];
   }

   DirectMapping.prototype = {
      canBeCalled: function (key) {
         return key.indexOf(this.prefix) === 0;
      },
      batch: function (key, data) {
         var completer = new async.Completer();

         this._current.push({ key: key, data: data, completer: completer });

         return completer.future;
      },
      execute: function ()
      {
         var self = this;
         _.each(this._current, function (task) {
            self.callback(task.key, task.data).then(function (response) {
               task.completer.complete(response);
            })
            .catchError(function (a, b) {
               task.completer.fail(a, b);
            });
         });

         this._current = [];
      }
   };

   exports.createKeyMappingFunction = function (mapping)
   {
      return function(key, data)
      {
         if (!(key in mapping)) throw new Error("Mapping for " + key + " is not defined");
         return mapping[key](data);
      }
   };

}
(
vitrium.service,
vitrium.service,
vitrium.async,
vitrium.log,
_
));
// script:viewer/webviewer-rest-adapter.js
/// <reference path="~/build.html" />

(function (exports, service) {
   "use strict";

   exports.createRestCompatibleServiceCaller = function (baseUrl)
   {
      var restClient = new service.RestClient(baseUrl);
      
      var initMapping = new service.ServiceMapping(function () {
         return restClient.sendGet("/info");
      }).add("Document.describe", "document")
      .add("Document.getWatermarks", "watermarks")
      .add("Event.subscribe", "events");

      var eventsMapping = new service.ServiceMapping(function () {
         return restClient.sendGet("/events");
      }).add("Event.poll");


      var annotationsMapping = new service.DirectMapping("Annotation", service.createKeyMappingFunction({
         _url : "/annotations",
         "Annotation.describe" : function()
         {
            return restClient.sendGet(this._url);
         },
         "Annotation.save" : function(data)
         {
            return restClient.sendPost(data, this._url)
         },
         "Annotation.saveMany" : function(data)
         {
            return restClient.sendPost(data, this._url+"many")
         },
         "Annotation.delete" : function(data)
         {
            return restClient.sendDelete(data, this._url);
         },
         "Annotation.deleteMany" : function(data)
         {
            return restClient.sendDelete(data, this._url+"many")
         }
      }));
    

      return new service.ServiceCallerAdapter([initMapping, eventsMapping, annotationsMapping]);
   };


}
(
vitrium.viewer,
vitrium.service,
_
));
// script:viewer/object-parser.js
(function (exports, vitrium,  _) {
  
  "use strict";
  exports.ObjectParser = ObjectParser;
  exports.CooperativeObjectParser = CooperativeObjectParser;
//
  
	function ObjectParser(handlers, ctx)
	{
		this.path = [];
		this.handlers = handlers;
		this.ctx = ctx;
	}
	
	var EMPTY_ARRAY = [];
	if (Object.freeze) Object.freeze(EMPTY_ARRAY);
	
  ObjectParser.prototype = {
		process : function(object)
    {	
      if (!object) return;
          
      var path = this.path;
      var handlers = this.handlers;
      var ctx = this.ctx;
      path.push(object);
      
      if (_.isUndefined(object.children)) object.children = EMPTY_ARRAY;
      
      var children = object.children;
      var len = children.length;
      //logger.debug(object.name+":beg");

      for (var ci = 0; ci < len; ++ci)
      {
        var child = children[ci];
        if (!child)
        {
          vitrium.log.warn("child of "+JSON.stringify(object)+" is null");
          continue;
        }
        // this just remove Xps. prefix
        
  //
        var name = child.name;
        // Xps. prefix end
        
        var properties = child.properties;
        if (_.isUndefined(properties))
        {	
          properties = child.properties = EMPTY_ARRAY;
        }
        
        for (var i = 0; i < handlers.length; ++i)
        {	
          handlers[i].begin(name, properties, child, ctx, path, this);
        }
        
        if (!ctx.block)
        {
          this.process(child);
        }
        
        for (var i = handlers.length -1; i >= 0; --i)
        {
          handlers[i].end(name, properties, child, ctx, path, this);
        }
      }

      path.pop();
      //logger.debug(object.name+":end");
    }
	};
	
	function CooperativeObjectParser(handlers, ctx)
	{
		this.path = [];
		this.handlers = handlers;
		this.ctx = ctx;
		
		this.begTime = Date.now();
		this.operationCounter = 0;
		
		this.interrupted = false;
		this.interruptedCallback = null;
		
		this.paused = false;
		this.pausedStep = null;
		
		if (vitrium.is_mobile)
		{
			this.pauseEach = 20;
			this.pauseDelay = 0;
		}
		else
		{
			this.pauseEach = 20;
			this.pauseDelay = 10;
		}		
	}
		
	CooperativeObjectParser.prototype.process = function(object, finishCallback)
	{	
	
		if (!finishCallback)
		{
			throw new Error("finish callback must be defined");
		}
		
		if (!object) return;
		
		
	
		
		var path = this.path;
		var handlers = this.handlers;
		var ctx = this.ctx;
		path.push(object);
		//logger.debug(object.name+":beg");
		
		if (_.isUndefined(object.children)) object.children = EMPTY_ARRAY;
		
		var children = object.children;
		var len = children.length;
		
		var ci = 0;
		var self = this;
		function step()
		{
				var h = handlers;
				var child = children[ci++];
				if (!child)
				{
					vitrium.log.warn("child of "+JSON.stringify(object)+" is null");
					step();
				}
				// this just remove Xps. prefix
				
//
				var name = child.name;			
				
				// Xps. prefix end
				var properties = child.properties;
				if (_.isUndefined(properties))
				{	
					properties = child.properties = EMPTY_ARRAY;
				}
				
			
				for (var i = 0; i < h.length; ++i)
				{	
					h[i].begin(name, properties, child, ctx, path, self);
				}
				
				if (!ctx.block)
				{
					self.process(child, endStep);
				}
				else
				{
					endStep();
				}	
				
				function endStep()
				{
					var p = properties;
					for (var i = h.length -1; i >= 0; --i)
					{
						h[i].end(name, p, child, ctx, path, self);
					}
					
					finishStep();
				}
				
				function finishStep()
				{					
					var counter = ++self.operationCounter;
					
					if ((counter % 50) === 0 || ((counter % 20) === 0 && Date.now() - self.begTime > self.pauseEach))
					{
						setTimeout(function()
						{
							
							if (self.interrupted)
							{
								//logger.debug("interrupted");
								if (self.interruptedCallback)
								{
									self.interruptedCallback(self, ctx);
								}
							}
							else
							{	
								if (self.paused)
								{	
									self.pausedStep = function() {
										if (self.interrupted)
										{
										//	logger.debug("interrupted");
											if (self.interruptedCallback)
											{
												self.interruptedCallback(self, ctx);
											}
										}
										else
										{
											self.pausedStep = null;
											self.begTime = Date.now();
											finishStep();
										}
									};
								}
								else
								{
									self.begTime = Date.now();
									finishStep();
								}
							}	
						}, self.pauseDelay);
								
						return;
					}
									
					if (ci < len)
					{							
						step();
					}
					else
					{
					//	logger.debug(object.name + ":end");
						path.pop();
						finishCallback();
					}
				}
		}
		
		if (ci < len)
		{
			step();
		}
		else
		{
			//logger.debug(object.name + ":end");
			path.pop();
			finishCallback();
		}
			
	};	
	
//

	
		
}(vitrium.json, vitrium, _));
// script:viewer/advanced-object-parser.js
(function (exports, vitrium, _)
{
 "use strict";
 exports.AdvancedObjectParser = AdvancedObjectParser;

 var EMPTY_ARRAY = [];
 var ST_INITIALIZED = 0;
 var ST_PROCESS_OBJECT = 1;
 var ST_PROCESS_OBJECT_CHILDREN = 2;
 var ST_PROCESS_OBJECT_CHILDREN_BEGIN = 3;
 var ST_PROCESS_OBJECT_CHILDREN_END = 4;
 var ST_DONE = 5;
 var HANDLERS_PER_STEP = 3;
 
function StatePool()
{
	this.pool = [];
}

StatePool.prototype = {
	create : function(st, i, object, child)
	{
		var obj  = this.pool.pop();
		if (!obj)
		{
			return { st : st, i : i, object : object, child : child};
		}
		else
		{
			obj.st = st;
			obj.i = i;
			obj.object = object;
			obj.child = child;
			
			return obj;
		}
	}, 
	free : function(obj)
	{
		obj.object = null;
		obj.child = null;
		
		this.pool.push(obj);
	}
};

var gSP = new StatePool();
 
 
 function AdvancedObjectParser(handlers, ctx, object, finishCallback)
 {
	vitrium.Task.call(this);
  this.path = [];

  this.interruptedCallback = null;


  this.handlers = handlers;
  this.ctx = ctx;

  if (!finishCallback)
  {
    throw new Error("finish callback must be defined");
  }
  this.finishCallback = finishCallback;

  this.stack = [
    gSP.create(ST_INITIALIZED, 0, null,null), 
    gSP.create(ST_PROCESS_OBJECT, 0, object, null)
  ];
 }

 
 AdvancedObjectParser.prototype =
 {
  process : function (object)
  {
   var state = this._top();
   if (state.st === ST_INITIALIZED)
   {
   }
   else
   {
    throw new Error("state is: "+this.state + " but it should be ST_INITIALIZED");
   }
  },
  step : function()
  {
	if (this.interrupted)
	{
		this.stack.splice(1);
		this.path = null;
		this._top().st = ST_DONE;
		this.done = true;
		
		if (this.interruptedCallback)
		{
		 this.interruptedCallback(this, this.ctx);
		 this.interruptedCallback = null;
		}
		return;
	}
  
   var state = this._top();
     //console.log(state);
    switch(state.st)
    {
     case ST_PROCESS_OBJECT:

      var object = state.object;
      if (_.isUndefined(object))
      {
       this._popState();
      }
      else if (_.isUndefined(object.children))
      {
       object.children = EMPTY_ARRAY;
      }

      this.path.push(object);
      state.st = ST_PROCESS_OBJECT_CHILDREN;
      state.i = 0;
     break;
     case ST_PROCESS_OBJECT_CHILDREN:
      var object = state.object;
      var children = object.children;

      if (state.i < children.length && !this.ctx.block)
      {
       var child = children[state.i++];

//

       var properties = child.properties;
       if (_.isUndefined(properties))
       {
        properties = child.properties = EMPTY_ARRAY;
       }
		//console.log("["+this._id()+"] beg:"+child.name);
       this._pushState(gSP.create(ST_PROCESS_OBJECT_CHILDREN_BEGIN,0, null, child));
      }
      else
      {
       this.path.pop();
       this._popState();
      }
     break;
     case ST_PROCESS_OBJECT_CHILDREN_BEGIN:
       var h = this.handlers;
       var i = state.i, len =h.length, sI = state.i;
       var child = state.child;
       var n = child.name;
       var p = child.properties;
		
       for (; i < len && i - sI < HANDLERS_PER_STEP && this.semaphore === 0;++i)
       {
        h[i].begin(n, p, child, this.ctx, this.path, this);
       }

       state.i = i;
       if (i === len)
       {
		
        state.st = ST_PROCESS_OBJECT_CHILDREN_END;
        this._pushState(gSP.create(ST_PROCESS_OBJECT,0,state.child, null));
       }
     break;
     case ST_PROCESS_OBJECT_CHILDREN_END:
       var h = this.handlers;
       var child = state.child;
       var n = child.name;
       var p = child.properties;
	  
       var i = state.i, len =h.length, sI = state.i;
		
       for (;i > 0 && sI - i < HANDLERS_PER_STEP && this.semaphore === 0;)
       {
			h[--i].end(n, p, child, this.ctx, this.path, this);
       }
       state.i = i;

       if (i === 0)
       {
        this._popState();
		// console.log("["+this._id()+"] end:"+n);
       }
     break;
     case ST_INITIALIZED:
       state.st = ST_DONE;
       this.finishCallback();
       this.finishCallback = null;
	   this.done = true;
     break;
    }
  },
  _top : function()
  {
   return this.stack[this.stack.length-1]
  },
  _pushState : function(state)
  {
   this.stack.push(state);
  },
  _popState : function()
  {
	gSP.free(this.stack.pop());
  },
  _id : function()
  {
	return this.ctx.renderArguments.pageInfo.number;
  }
 };
_.extend(AdvancedObjectParser.prototype, vitrium.Task.prototype);

}(
vitrium.json,
vitrium,
_
));

// script:viewer/draw-image.js
/// <reference path="~/build.html" />

(function (exports, vitrium, $)
{
  "use strict";
  var isSafari = !!$.browser.safari;
  var isMobileSafari = vitrium.is_mobile && isSafari;

  if (isSafari)
  {
    exports.drawImage = drawImageSafari;
  }
  else
  {
    exports.drawImage = drawImageGeneral;
  }

  function drawImageGeneral(ctx, image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight)
  {
    ctx.drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
  }

  //2048 is minimum for OpenGL ES 2.0 that is supported on all iOS
  var IMAGE_RES_LIMIT = isMobileSafari ? 2048 : 4096;
  function drawImageSafari(ctx, image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight)
  {
    var hSteps = ((swidth / IMAGE_RES_LIMIT) + (swidth % IMAGE_RES_LIMIT === 0 ? 0 : 1)) | 0;
    var vSteps = ((sheight / IMAGE_RES_LIMIT) + (dwidth % IMAGE_RES_LIMIT === 0 ? 0 : 1)) | 0;

    if (hSteps === 1 && vSteps === 1)
    {
      ctx.drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
    }
    else
    {
      var hRatio = dwidth / swidth;
      var vRatio = dheight / sheight;

      var ox = 0;
      var owidth = IMAGE_RES_LIMIT * hRatio;

      for (var h = 0; h < hSteps; ++h)
      {
        var oy = 0;
        var oheight = IMAGE_RES_LIMIT * vRatio;

        var x = IMAGE_RES_LIMIT * h;
        var width = IMAGE_RES_LIMIT;
        if (x + width > swidth)
        {
          width = swidth - x;
          owidth = width * hRatio;
        }

        for (var v = 0; v < vSteps; ++v)
        {
          var y = IMAGE_RES_LIMIT * v;
          var height = IMAGE_RES_LIMIT;

          if (y + height > sheight)
          {
            height = sheight - y;
            oheight = height * vRatio;
          }

          ctx.drawImage(image, x, y, width, height, ox, oy, owidth, oheight);
          oy += oheight;
        }

        ox += owidth;
      }
    }
  }
}
(vitrium.utils, vitrium, jQuery));



// script:viewer/brush.js
/// <reference path="~/build.html" />

(function (exports, vitrium, geometry, xps, utils, _, $)
{
  "use strict";

  var Point = geometry.Point;

  _.extend(exports, {
    SolidColorBrush : SolidColorBrush,
    LinearGradientBrush : LinearGradientBrush,
    RadialGradientBrush : RadialGradientBrush,
    ImageBrush : ImageBrush
  });
        
  function Brush(ctx, opacity, opacityMask)
  {
    this.ctx = ctx;
    this.opacity = isNaN(opacity) ? 1.0 : opacity;
    this.brush = "#ddd";
    this.imageSmoothing = true;
    this.isRAW = false;
    
    this.opacityMask = _.isUndefined(opacityMask) ? null : opacityMask ;
  };
  
  Brush.prototype = {
    setImageSmoothing: function(ctx, val)
    {      
      if ("mozImageSmoothingEnabled" in ctx)
      {
        ctx.mozImageSmoothingEnabled = val;
      }
      else if ("webkitImageSmoothingEnabled" in ctx)
      {
        ctx.webkitImageSmoothingEnabled = val;
      }
      else if ("imageSmoothingEnabled" in ctx)
      {
        ctx.imageSmoothingEnabled = val;
      }
    },
    tryEnableAsync: function()
    {
      return false;
    },
    beforeBrush : function (fill)
    {
      //this.ctx.save();
      this.ctx.globalAlpha = this.opacity;
      if (fill)
      {
        this.ctx.fillStyle = this.brush;
      }
      else
      {
        this.ctx.strokeStyle = this.brush;
      }
    },
    afterBrush : function()
    {
      //	this.ctx.restore();
    },
    fill : function()
    {			
      this.beforeBrush(true);
      var ctx = this.ctx;
      var sm = this.imageSmoothing;
      if (!sm)
      {
        this.setImageSmoothing(ctx, false);
        
      }
      
      
      if (ctx.argFillRule)
      {
        this.ctx.fill(ctx.argFillRule);
      }
      else
      {	
        this.ctx.fill();
      }
      
      if (!sm)
      {
        this.setImageSmoothing(ctx, true);
      }
      this.afterBrush();
    },
    stroke : function()
    {
      this.beforeBrush(false);
      this.ctx.stroke();
      this.afterBrush();
    },
    fillText : function(text, x, y)
    {
      this.beforeBrush(true);
      this.ctx.fillText(text, x, y);
      this.afterBrush();
    },
    strokeText : function(text, x, y)
    {
      this.beforeBrush(false);
      this.ctx.strokeText(text, x, y);
      this.afterBrush();
    }	
  };
    
  function SolidColorBrush(ctx, opacity, color, opacityMask)
  {
    Brush.call(this, ctx, opacity, opacityMask);
    this.brush = color;
  }
  _.extend(SolidColorBrush.prototype, Brush.prototype);	
  
  
  function SpecialBrush(ctx, opacity, transform, opacityMask)
  {
    Brush.call(this, ctx, opacity, opacityMask);
    this.transform = transform;
  }
  
  _.extend(SpecialBrush.prototype, Brush.prototype);
  SpecialBrush.prototype.superBeforeBrush = Brush.prototype.beforeBrush;
  SpecialBrush.prototype.beforeBrush = function(fill) 
  {
      
    var t = this.transform;
    if (t)
    {
      this.ctx.save();
      this.ctx.transform(t.a, t.b, t.c, t.d, t.e, t.f);
    }
    this.superBeforeBrush(fill);
  };
  SpecialBrush.prototype.afterBrush = function()
  {
    if (this.transform)
    {
      this.ctx.restore();
    }
  }
  
  
  function LinearGradientBrush(ctx, opacity, transform, startPoint, endPoint, opacityMask)
  {
    SpecialBrush.call(this, ctx, opacity, transform, opacityMask);
    this.brush  = ctx.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
  }
  _.extend(LinearGradientBrush.prototype, SpecialBrush.prototype);
  LinearGradientBrush.prototype.addColorStop = addColorStop;
  
  function RadialGradientBrush(ctx, opacity, transform, origin, center, radiusX, radiusY, opacityMask)
  {
    SpecialBrush.call(this, ctx, opacity, transform, opacityMask);
    this.brush  = ctx.createRadialGradient(origin.x, origin.y, 0,  center.x ,  center.y, radiusY);
  }
  _.extend(RadialGradientBrush.prototype, SpecialBrush.prototype);
  RadialGradientBrush.prototype.addColorStop = addColorStop;
    
  
  function addColorStop(offset, color)
  {
    this.brush.addColorStop(offset, color);
  }
  
  
  
  function ImageBrush(ctx, opacity, transform, viewbox, viewport, tileMode, imageSource, matrixStack, fileProvider, tag, opacityMask, objectProcessor)
  {
    SpecialBrush.call(this, ctx, opacity, transform, opacityMask);
    this.fileProvider = fileProvider;

    this.matrixStack = matrixStack;
    this.viewbox = viewbox;
    this.viewport = viewport;
    this.tileMode = tileMode;
    this.imageSource = imageSource;
    this.tag = tag;
    //	this.asyncImageService = vitrium.viewer.ImageAsyncServiceClient.getInstance();
    this.objectProcessor = objectProcessor;
   
    this.rectangleModeAttributes = null;
    /*this._canvas = null;
    this._pattern = null;
    this._ctx = null;
    this._mode = null;*/
  }

  _.extend(ImageBrush.prototype, SpecialBrush.prototype);
  ImageBrush.prototype.beforeSpecialBrush = SpecialBrush.prototype.beforeBrush;
  ImageBrush.prototype.beforeBrush = beforeImageBrush;
  ImageBrush.prototype.createImageBrushCanvas = createImageBrushCanvas;
  ImageBrush.prototype.mergeOpacityMask = mergeOpacityMask;
  
  if ($.browser.safari || !vitrium.is_mobile)
  {
    ImageBrush.prototype.tryEnableAsync = function ()
    {
      // Safari cannot handle drawing in UI thread into HW accelerated canvas 
      return false;//!!this.opacityMask;
    }
  }
  else
  {
    ImageBrush.prototype.tryEnableAsync = function ()
    {
      return !!this.opacityMask;
    }
  }
  
  
  ImageBrush.prototype.fill = function()
  {			
    this.beforeBrush(true);
    var ctx = this.ctx;
    var sm = this.imageSmoothing;
    if (!sm)
    {
      this.setImageSmoothing(ctx, false);
    }
    
    if (this.rectangleModeAttributes !== null)
    {
      this.directRender();
    }
    else
    {    
      if (ctx.argFillRule)
      {
        ctx.fill(ctx.argFillRule);
      }
      else
      {	
        ctx.fill();
      }
    }
    
    if (!sm)
    {
      this.setImageSmoothing(ctx, true);
    }
    
    this.afterBrush();
  };
  
  ImageBrush.prototype.cache = function(canvas, mode)
  {
    this._canvas = canvas;
    this._mode = mode;
    //	this._ctx = this.ctx;		
    
    //	console.log(canvas.width ,canvas.height);
  };
  
  ImageBrush.prototype.directRender = function()
  {
  
    var attrs = this.rectangleModeAttributes;
    /*{
              image : image,
              sx : sx,
              sy : sy,
              sWidth : sWidth,
              sHeight : sHeight,
              viewport : viewport,
              brushRect : rectangle
    }*/
    var ctx = this.ctx;
    ctx.save();
    
    var brushRect = attrs.brushRect;
    ctx.beginPath();
    ctx.rect(brushRect.x*attrs.scaleX, brushRect.y*attrs.scaleY, brushRect.width*attrs.scaleX, brushRect.height*attrs.scaleY);
    ctx.clip();
    
  //  ctx.translate(brushRect.x * attrs.scaleX, brushRect.y * attrs.scaleY);
    utils.drawImage(ctx, attrs.image, attrs.sx, attrs.sy, attrs.sWidth, attrs.sHeight, attrs.viewport.x, attrs.viewport.y, attrs.viewport.width, attrs.viewport.height);
    //ctx.drawImage(attrs.image, attrs.sx, attrs.sy, attrs.sWidth, attrs.sHeight, attrs.viewport.x, attrs.viewport.y, attrs.viewport.width, attrs.viewport.height);

    ctx.restore();
  };
  
  ImageBrush.prototype.restoreFromCache = function()
  {
    if (this.rectangleModeAttributes !== null)
    {
      return true;
    }
    
    if (this._canvas)
    {
      this.brush = this.ctx.createPattern(this._canvas, this._mode);      
      return true;
    }
    else
    {
      return false;
    }
  };
  
  ImageBrush.prototype.asyncFill = function(callback) {
      var self = this;
      this.beforeBrush(true, function ()
      {
       // self.objectProcessor.__debug__.mark();

        var ctx = self.ctx;
        var sm = self.imageSmoothing;
        if (!sm)
        {
          self.setImageSmoothing(ctx, false);
        }
        
        if (self.rectangleModeAttributes !== null)
        {
          self.directRender();
        }
        else
        {    
          if (ctx.argFillRule)
          {
            ctx.fill(ctx.argFillRule);
          }
          else
          {	
            ctx.fill();
          }
        }
        
        if (!sm)
        {
          self.setImageSmoothing(ctx, true);
        }
        
        self.afterBrush();
        callback();
      });
  };
  
  ImageBrush.prototype.asyncStroke = function(callback)
  {
    var self = this;
    this.beforeBrush(false, function()
    { 
      self.ctx.stroke();
      self.afterBrush();
      callback();
    });
  };
  
  ImageBrush.prototype.convertPatternMode = function(tileMode)
  {
    if ($.browser.firefox && (!tileMode || tileMode === "None"))
    {
      //HACK this solves 012 compatibility, firefox scales no-repeat pattern
      tileMode = "Tile";
    }
          
    var canvasPatternMode;
    switch (tileMode)
    {
      case "None":
        canvasPatternMode = "no-repeat";
      break;
      case "Tile":
        canvasPatternMode = "repeat";
      break;
      //not implemented FlipX, FlipY, FlipXY, there is no equivalent in HTML5 canvas
      default:
        canvasPatternMode = "no-repeat";
      break;							
    }
    
    return canvasPatternMode;
  };
  
  
  ImageBrush.prototype.createBrushTexture = function(image, tileMode, sx, sy, sWidth, sHeight, viewport)
  {
   // this.objectProcessor.__debug__.mark();

    var canvas = document.createElement("canvas");
    var cWidth =  Math.ceil(viewport.width + viewport.x);
    var cHeight =  Math.ceil(viewport.height + viewport.y);
        
    if (this.rectangleModeAttributes === null  && $.browser.firefox && (!tileMode || tileMode === "None"))
    {
      //HACK this solves 012 compatibility, firefox scales no-repeat pattern
      var c = this.ctx.canvas;
      cWidth = Math.ceil(Math.max(viewport.x+ viewport.width, c.width));
      cHeight = Math.ceil(Math.max(viewport.y+viewport.height, c.height));
    }
        
    canvas.width = cWidth;
    canvas.height = cHeight;
    
    var context  = canvas.getContext("2d");
    this.setImageSmoothing(context, false);

    utils.drawImage(context, image, sx, sy, sWidth, sHeight, viewport.x, viewport.y, viewport.width, viewport.height);
    
    return canvas;
  };
  
  ImageBrush.prototype.applyOpacityMask = function(canvas, canvasPatternMode)
  {
    //this.objectProcessor.__debug__.mark();
    if (this.rectangleModeAttributes === null)
    {
      this.brush = this.ctx.createPattern(canvas, canvasPatternMode);
      this.cache(canvas, canvasPatternMode);
    }
    else
    {
      this.rectangleModeAttributes.image = canvas;
      var attrs = this.rectangleModeAttributes;
      // FIXED opacity mask is already cropped as necessary
      attrs.sx = 0;
      attrs.sy = 0;
      attrs.sWidth = canvas.width;
      attrs.sHeight = canvas.height;
    }
  };
  
  ImageBrush.prototype.finishTextureBeforeBrush = function(canvas, tileMode, fill, callback)
  {
    var self = this;
    var canvasPatternMode = this.convertPatternMode(tileMode);
    var context = canvas.getContext("2d");
    if (callback)
    {
    //  this.objectProcessor.__debug__.mark();

      if (this.opacityMask)
      {
      //  this.objectProcessor.__debug__.mark();

        this.mergeOpacityMask(context, function()
        {
//self.objectProcessor.__debug__.mark();
          if (!self.objectProcessor.interrupted)
          {
            self.applyOpacityMask (canvas, canvasPatternMode);  
            self.beforeSpecialBrush(fill);

            callback();
          }
          else
          {
      //      self.objectProcessor.__debug__.mark();

            self.objectProcessor.post();
          }
        });
      }
      else
      {
  //      this.objectProcessor.__debug__.mark();

        setTimeout(function()
        {
          //self.objectProcessor.__debug__.mark();

          if (!self.objectProcessor.interrupted)
          {
            self.brush = self.ctx.createPattern(canvas, canvasPatternMode);
            self.cache(canvas, canvasPatternMode);
            self.beforeSpecialBrush(fill);
            callback();
          }
          else
          {
            //self.objectProcessor.__debug__.mark();

            self.objectProcessor.post();
          }
        }, 0);
      }
    }
    else
    {
      //self.objectProcessor.__debug__.mark();

      if (this.opacityMask)
      {
        //self.objectProcessor.__debug__.mark();

        this.mergeOpacityMask(context);
        this.applyOpacityMask (canvas, canvasPatternMode);  
      }
      else
      {
       // self.objectProcessor.__debug__.mark();

        self.brush = self.ctx.createPattern(canvas, canvasPatternMode);
        self.cache(canvas, canvasPatternMode);
       }
    }
  };
  

  function beforeImageBrush(fill, callback)
  {
      var self = this;
      var sync = true;
      
      var matrixStack = this.matrixStack;
      var transform = this.transform;
      
      var viewbox = this.viewbox;
      var viewport =this.viewport;
      var tileMode =this.tileMode;
      
      var t = matrixStack.top();
      if (transform)
      {
        t = t.multiply(transform);					
      }
              
      var tScale = t.getScale();
      var scaleX = tScale.x; //Math.abs(t.a);
      var scaleY = tScale.y; //Math.abs(t.d);
      
      var rotation = Math.atan2(t.c, t.a) * 180/Math.PI;

      if (scaleX > 1 || scaleY > 1)
      {		
        self.ctx.transform(1/scaleX,0,0,1/scaleY,0, 0);
      }	
    
      if (!this.restoreFromCache())
      {
        //self.objectProcessor.__debug__.mark();

        var image = this.fileProvider.getImage(this.imageSource);
        if (image)
        {	
          var widthPX = image.width;
          var heightPX  = image.height;
          //console.log(" width:"+widthPX + " height:"+heightPX);
          
          var metadata = image.metadata ;
          var hDPI = metadata.hDPI;
          var vDPI = metadata.vDPI;
                      
          var sx =  hDPI * viewbox.x / 96;
          var sy =   vDPI * viewbox.y / 96;
          var sWidth =   hDPI * viewbox.width / 96;
          var sHeight =  vDPI * viewbox.height / 96;			

          sWidth = Math.max(Math.min(widthPX - sx, sWidth), 0);
          sHeight = Math.max(Math.min(heightPX - sy, sHeight), 0);
        
          if (scaleX == 0 || scaleY == 0)
          {
            var vpDim = t.multiplyPoint(new Point(viewport.width, viewport.height));
            //console.log(t.toString(), viewport, vpDim);
          
            viewport.width =  vpDim.x;
            viewport.height = vpDim.y;
          }
          else if (scaleX > 1 || scaleY > 1)
          {
            viewport.width *=  scaleX;
            viewport.height *= scaleY;
            viewport.x *= scaleX ;
            viewport.y *= scaleY ;
          }

          viewport.width =  Math.ceil(Math.abs(viewport.width));
          viewport.height = Math.ceil(Math.abs(viewport.height));
          viewport.x = Math.ceil(viewport.x);
          viewport.y = Math.ceil(viewport.y) ;
         
          var rectangle = null;
          if (fill)
          {
            var rectanglePathDetector = new geometry.RectanglePathDetector();
            xps.parsePathData(rectanglePathDetector, self.ctx.vCurrentPath);
            rectangle = rectanglePathDetector.dimensions;
            if (rectangle === null)
            {
              rectanglePathDetector.closePath();
              rectangle = rectanglePathDetector.dimensions;
            }
          }
          
        //  self.objectProcessor.__debug__.mark("rectangle !== null: " + (rectangle !== null) + " tileMode="+tileMode);


          if (rectangle !== null && (!tileMode || tileMode === "None"))
          {
            this.rectangleModeAttributes = {
              image : image,
              sx : sx,
              sy : sy,
              sWidth : sWidth,
              sHeight : sHeight,
              viewport : viewport,
              brushRect : rectangle,
              scaleX : scaleX,
              scaleY : scaleY
            };
            
          //  self.objectProcessor.__debug__.mark();
          }
                    
          if (this.rectangleModeAttributes !== null && !this.opacityMask)
          {
            if (callback)
            {
              setTimeout(function()
              {
                //self.objectProcessor.__debug__.mark();
                if (!self.objectProcessor.interrupted)
                {
                  self.beforeSpecialBrush(fill);		
                  callback();
                }
                else
                {
                  //self.objectProcessor.__debug__.mark();
                  self.objectProcessor.post();
                }
              }, 0);
            }
          }
          else
          {          
            try
            {
         //     self.objectProcessor.__debug__.mark();
              var canvas = this.createBrushTexture(image, tileMode, sx, sy, sWidth, sHeight, viewport)
              this.finishTextureBeforeBrush(canvas, tileMode, fill, callback);
      //        self.objectProcessor.__debug__.mark();
            }
            catch(e)
            {
        //      self.objectProcessor.__debug__.mark();
              vitrium.log.warn(e.stack);
              if (callback)
              {
                setTimeout(function()
                {
      //            self.objectProcessor.__debug__.mark();
                  if (!self.objectProcessor.interrupted)
                  {
                  self.beforeSpecialBrush(fill);		
                  callback();
                  }
                  else
                  {
              //      self.objectProcessor.__debug__.mark();
                    self.objectProcessor.post();
                  }
                }, 0);
              }
            }
          }
        }
        else
        {
          
     //     self.objectProcessor.__debug__.mark();
          vitrium.log.error("unable to get image for imageSource:" + this.imageSource + " page: " + self.objectProcessor.number);
          if (callback)
          {
            setTimeout(function ()
            {
              //            self.objectProcessor.__debug__.mark();
              if (!self.objectProcessor.interrupted)
              {
                self.beforeSpecialBrush(fill);
                callback();
              }
              else
              {
                self.objectProcessor.post();
              }
            }, 0);
          }
        }
    
        if (!callback)
        {
         // self.objectProcessor.__debug__.mark();
          this.beforeSpecialBrush(fill);		
        }
       /* else
        {
       //   self.objectProcessor.__debug__.mark();
        }*/
    } 
    else
    {
      this.beforeSpecialBrush(fill);		
      if (callback)
      {
     //   self.objectProcessor.__debug__.mark();
        callback();
        
      }
      else
      {
     //   self.objectProcessor.__debug__.mark();
      }
    }
  }
  
  function mergeOpacityMask(context, callback)
  {
    var self = this;
    var maskCtx = this.opacityMask.createImageBrushCanvas(this.rectangleModeAttributes !== null);
    if (!callback)
    {
      var maskCanvas = maskCtx.canvas;
      var mask = maskCtx.getImageData(0,0,maskCanvas.width, maskCanvas.height);
      var canvas = context.canvas;
      var brushImageData = context.getImageData(0,0,canvas.width, canvas.height);
      utils.applyOpacityMask(brushImageData, mask);
      context.putImageData(brushImageData, 0, 0);
     // self.objectProcessor.__debug__.mark();
    }
    else
    {		
      var maskCanvas = maskCtx.canvas;
      var maskImageData = maskCtx.getImageData(0,0,maskCanvas.width, maskCanvas.height);
      var canvas = context.canvas;
      var brushImageData = context.getImageData(0,0,canvas.width, canvas.height);
      
      var process = new utils.OpacityMaskProcess(brushImageData, maskImageData, function ()
      {
      //  self.objectProcessor.__debug__.mark();
        context.putImageData(brushImageData, 0, 0);
        callback(context);
       // self.objectProcessor.__debug__.mark();
      });
      process.parentTask = vitrium.globalTaskScheduler.currentTask;
      process.parentTask.childTask = process;
      vitrium.globalTaskScheduler.addTask(process);
      //self.objectProcessor.__debug__.mark();
    //	this.asyncImageService.applyOpacityMask(context, maskCtx, callback);
    }
  }
  
  function createImageBrushCanvas(isRectangleOptimized)
  {
    var self = this;
    var sync = true;
  //  self.objectProcessor.__debug__.mark();

    var matrixStack = this.matrixStack;
    var transform = this.transform;
    
    var viewbox = this.viewbox;
    var viewport =this.viewport;
    var tileMode =this.tileMode;
    
    var image = this.fileProvider.getImage(this.imageSource);
    if (image)
    {
      var t = matrixStack.top();
      if (transform)
      {
        t = t.multiply(transform);
      }
      var scaleX = Math.abs(t.a);
      var scaleY = Math.abs(t.d);
            
      var widthPX = image.width;
      var heightPX  = image.height;
      //console.log(" width:"+widthPX + " height:"+heightPX);
      
      var metadata = image.metadata ;
      var hDPI = metadata.hDPI;
      var vDPI = metadata.vDPI;
                  
      var sx =  hDPI * viewbox.x / 96;
      var sy =   vDPI * viewbox.y / 96;
      var sWidth =   hDPI * viewbox.width / 96;
      var sHeight =  vDPI * viewbox.height / 96;			

      //console.log(" dpi sx:"+sx + " sy:"+sy+ " sWidth:"+sWidth+ " sHeight:"+sHeight+ " image dpi:"+imageDPI);
      sWidth = Math.max(Math.min(widthPX - sx, sWidth), 0);
      sHeight = Math.max(Math.min(heightPX - sy, sHeight), 0);
      
      if (scaleX > 1 || scaleY > 1)
      {
          viewport.width *=  scaleX;
          viewport.height *= scaleY;
          viewport.x *= scaleX ;
          viewport.y *= scaleY ;
      }
    
      

      viewport.width =  Math.ceil(viewport.width);
      viewport.height = Math.ceil(viewport.height);
      viewport.x = Math.ceil(viewport.x);
      viewport.y = Math.ceil(viewport.y) ;
      try
      {
        var canvas = document.createElement("canvas");
        var cWidth =  Math.ceil(viewport.width + viewport.x);
        var cHeight =  Math.ceil(viewport.height + viewport.y);
        
        if (!isRectangleOptimized && $.browser.firefox && (!tileMode || tileMode === "None"))
        {
          //HACK this solves 012 compatibility, firefox scales no-repeat pattern
          var c = this.ctx.canvas;
          cWidth = Math.ceil(Math.max(viewport.x+ viewport.width, c.width));
          cHeight = Math.ceil(Math.max(viewport.y+viewport.height, c.height));
          
          tileMode = "Tile";
        }
        
        canvas.width =cWidth;
        canvas.height =cHeight;
        
        var context  = canvas.getContext("2d");
        /*  if ('imageSmoothingEnabled' in context) {
          context.imageSmoothingEnabled = false;
          self.ctx.imageSmoothingEnabled = false;
          } 
        else  if ('webkitImageSmoothingEnabled ' in context) {
          context.webkitImageSmoothingEnabled  = false;
          self.ctx.webkitImageSmoothingEnabled = false;
          } 
          else {
          context.mozImageSmoothingEnabled = false;
          self.ctx.mozImageSmoothingEnabled = false;
          }*/
        self.setImageSmoothing(context, false);
       /* if (image.vIsPNG)
        {
          self.imageSmoothing = false;
        }
        else
        {
          self.imageSmoothing = true;
        }*/
        utils.drawImage(context, image, sx, sy, sWidth, sHeight, viewport.x, viewport.y, viewport.width, viewport.height);
        
        
        return context;
      }
      catch(e)
      {
        vitrium.log.warn(e.stack);
      }
    }
    return null;
  }
}(
vitrium.viewer, 
vitrium,  
vitrium.geometry,  
vitrium.xps,
vitrium.utils,
_,
jQuery));
// script:viewer/resource-dictionary.js
(function(exports, vitrium, _)
{
	"use strict";
	
	exports.ResourceDictionary = ResourceDictionary;
	function ResourceDictionary(parent, scope)
	{
		if (!parent) parent = null;
		this.scope = scope;
		
		this.dict = {};
		this.parent = parent;
	}
  
  ResourceDictionary.prototype = {
    RD_PATTERN : /{(.+)}/,
		getForPropertyValue : function(property)
    {
      if (_.isString(property))
      {
        var m = property.match(this.RD_PATTERN);
        if (m && m.length === 2)
        {
          return this.lookup(m[1]);
        }
      }
      return null;
    },
		lookup : function(key)
    {
    //	vitrium.log.debug("dict lookup:"+key);
      var val = this.dict[key];
      if (_.isUndefined(val))
      {
        var p = this.parent;
        if (p)
        {
          return p.lookup(key);
        }
      }
      return val;
    },
		store : function(key, val)
    {
      //vitrium.log.debug("dict store: "+key+" "+val);
      this.dict[key] = val;
    }
  };
  
}(
vitrium.viewer, 
vitrium, 
_));

// script:viewer/page-renderer.js
//jquery and underscore 
(function (exports, vitrium, geometry, xps, _, $, window)
{
  "use strict";
  var viewer = exports;
  var Point = geometry.Point;
  var Matrix = geometry.Matrix;
  var processPathData = xps.parsePathData;
  var parsePoint = xps.parsePoint;
  var parseRectangle = xps.parseRectangle;
  var convertColor = xps.convertColor;
  var setFillRule = xps.setFillRule;
  var renderErrorIcon = vitrium.viewer.renderErrorIcon;

  /**
Tags
*/
  var T_FIXED_PAGE = "FP";  //FixedPage
  var T_CANVAS = "C";  //Canvas
  var T_PATH = "P";  //Path
  var T_GLYPHS = "G";  //Glyphs
  var T_MATRIX_TRANSFORM = "MT";  //MatrixTransform
  var T_SOLID_COLOR_BRUSH = "SB";  //SolidColorBrush
  var T_IMAGE_BRUSH = "IB";  //ImageBrush
  var T_LINEAR_GRADIENT_BRUSH = "LB";  //LinearGradientBrush
  var T_VISUAL_BRUSH = "VB";  //VisualBrush
  var T_RADIAL_GRADIENT_BRUSH = "RB";  //RadialGradientBrush
  var T_PATH_OPACITY_MASK = "PM";  //Path.OpacityMask
  var T_GRADIENT_STOP = "GS";  //GradientStop
  var T_RESOURCE_DICTIONARY = "RD";  //ResourceDictionary
  var T_PATH_GEOMETRY = "PG";  //PathGeometry
  var T_CANVAS_CLIP = "CC";  //Canvas.Clip
  var T_GLYPHS_CLIP = "GC";  //Glyphs.Clip
  var T_PATH_CLIP = "PC";  //Path.Clip
  var T_PATH_RENDER_TRANSFORM = "PT";  //Path.RenderTransform
  var T_TEXT_BLOCK = "TB";  //TextBlock
  var T_GRID = "H";  //Grid
  var T_FIXED_PAGE_RESOURCES = "FR";  //FixedPage.Resources
  var T_GLYPHS_FILL = "GF";  //Glyphs.Fill
  var T_PATH_FILL = "PF";  //Path.Fill
  var T_PATH_STROKE = "PS";  //Path.Stroke
  var T_GLYPHS_STROKE = "GT";  //Glyphs.Stroke
  var T_GLYPHS_OPACITY_MASK = "GM";  //Glyphs.OpacityMask

  /**
Properties
*/
  var P_MATRIX = "M";  //Matrix
  var P_RENDER_TRANSFORM = "RT";  //RenderTransform
  var P_OPACITY = "O";  //Opacity
  var P_CLIP = "C";  //Clip
  var P_VIEWBOX = "V";  //Viewbox
  var P_VIEWPORT = "W";  //Viewport
  var P_TILE_MODE = "TM";  //TileMode
  var P_IMAGE_SOURCE = "IS";  //ImageSource
  var P_START_POINT = "SP";  //StartPoint
  var P_END_POINT = "EP";  //EndPoint
  var P_GRADIENT_ORIGIN = "GO";  //GradientOrigin
  var P_CENTER = "D";  //Center
  var P_RADIUS_X = "RX";  //RadiusX
  var P_RADIUS_Y = "RY";  //RadiusY
  var P_FILL = "F";  //Fill
  var P_STROKE = "S";  //Stroke
  var P_STROKE_THICKNESS = "ST";  //StrokeThickness
  var P_STROKE_LINE_JOIN = "SJ";  //StrokeLineJoin
  var P_STROKE_MITER_LIMIT = "SL";  //StrokeMiterLimit
  var P_STROKE_DASH_OFFSET = "SO";  //StrokeDashOffset
  var P_STROKE_DASH_ARRAY = "SA";  //StrokeDashArray
  var P_STROKE_END_LINE_CAP = "SC";  //StrokeEndLineCap
  var P_STROKE_START_LINE_CAP = "SD";  //StrokeStartLineCap
  var P_STROKE_DASH_CAP = "SE";  //StrokeDashCap
  var P_DATA = "E";  //Data
  var P_FIXED_PAGE_NAVIGATE_URI = "FU";  //FixedPage.NavigateUri
  var P_NAME = "N";  //Name
  var P_FIGURES = "G";  //Figures
  var P_UNICODE_STRING = "US";  //UnicodeString
  var P_OFFSET = "P";  //Offset
  var P_COLOR = "H";  //Color
  var P_SOURCE = "T";  //Source
  var P_X_KEY = "XK";  //x:Key
  var P_FONT_RENDERING_EM_SIZE = "FS";  //FontRenderingEmSize
  var P_STYLE_SIMULATIONS = "SS";  //StyleSimulations
  var P_FONT_URI = "FV";  //FontUri
  var P_INDICES = "I";  //Indices
  var P_WIDTH = "X";  //Width
  var P_HEIGHT = "J";  //Height
  var P_ORIGIN_X = "OX";  //OriginX
  var P_ORIGIN_Y = "OY";  //OriginY
  var P_TRANSFORM = "U";  //Transform
  var P_IS_SIDEWAYS = "IT";  //IsSideways
  var P_BIDI_LEVEL = "BL";  //BidiLevel

  //var dpiMultiplier = 72.0 / 96.0;
  var dpiMultiplier = 1.0;

  _.extend(exports, {
    PageRenderer: PageRenderer,
    Point: Point,
    processPathData: processPathData,
    convertColor: convertColor
  });





  function PageRenderer(doc, fileProvider, layers)
  {
    this.doc = doc;
    this.fileProvider = fileProvider;
    
    var len = layers.length;
    var layerInstances = new Array(len);
    this.layers = layerInstances;
    var gl = this.glyphProcessors = [];
    var linkProcessors = this.linkProcessors = [];
    var nameProcessors = this.nameProcessors = [];

    // create layer instances for page

    for (var i = 0; i < len; ++i)
    {
      var layer = layerInstances[i] = layers[i](fileProvider);
      if (_.isFunction(layer.addText))
      {
        gl.push(layer);
      }

      if (_.isFunction(layer.addLink))
      {
        linkProcessors.push(layer);
      }

      if (_.isFunction(layer.addName))
      {
        nameProcessors.push(layer);
      }
    }
  }

  PageRenderer.prototype = {
    renderPage: renderPage,
    createAsyncRenderer: createAsyncRenderer,
    createRenderingContext: createRenderingContext,
    renderError: renderError,
    free: free
  };

  function createAsyncRenderer(canvas, scale, pageNumber, pageInfo, pageData, parseMetaContent)
  {

    if (_.isEmpty(pageData))
    {
      var t = new vitrium.Task();
      t.self = this;
      t.step = function ()
      {
        if (!this.interrupted)
        {
          this.self.renderError(canvas, scale, pageInfo, pageNumber, "missing-page", vitrium.i18n._T("message-cannot-load-page"));
        }
        this.self = null;
        this.done = true;
      };
      return t;
    }
    else
    {
      var renderingContext = this.createRenderingContext(canvas, scale, pageNumber, pageInfo, pageData, parseMetaContent);
      return new vitrium.json.AdvancedObjectParser(renderingContext.handlers, renderingContext, pageData, renderingContext.finishCallback);
    }
  }

  function createRenderingContext(canvas, scale, pageNumber, pageInfo, pageData, parseMetaContent)
  {
    var ctx = canvas.getContext("2d");

    var matrix = Matrix.identity();
    ctx.save();
    ctx.scale(scale, scale);

    var matrixStack = [matrix];
    matrixStack.top = function (rMatrix)
    {
      if (rMatrix)
      {
        this[this.length - 1] = rMatrix;
      }
      return this[this.length - 1];
    };

    var textSelection = this.textSelection;

    var handlers = [
        ResourceDictionaryHandler,
        ContextSaver,
        ContextTransform,
        ContextClip,
        OpacityHandler,
        ContextBrush,
        ColorStopHandler,
        PathHandler,
        GlyphsHandler
    ];

    var glyphProcessors= this.glyphProcessors;
    var linkProcessors =  this.linkProcessors;
    var nameProcessors = this.nameProcessors;

    if (parseMetaContent)
    {
      var layers = this.layers;
      var len = layers.length;

      for (var i = 0; i < len; ++i)
      {
        layers[i].begin(pageNumber);
      }

    }
    else
    {
      glyphProcessors = [];
      linkProcessors = [];
      nameProcessors = [];
    }

    var parserCtx = {
      canvas: canvas,
      ctx: ctx,
      document: this.doc,
      glyphProcessors: glyphProcessors,
      linkProcessors: linkProcessors,
      nameProcessors: nameProcessors,
      imageRequestTag: "img_" + (pageNumber),
      dict: new vitrium.viewer.ResourceDictionary(),
      handlers: handlers,
      renderArguments: {
        scale: scale,
        pageNumber: pageNumber,
        pageInfo: pageInfo,
        pageData: pageData,
        ltr: true
      },
      pageInstance: this,
      matrixStack: matrixStack,
      createBrushes: true,
      brushes: null,
      br: null,
      finishCallback: function ()
      {
        ctx.restore();
        pageData.brushCache = parserCtx.br.cache && parserCtx.br.cache.length > 0 ? parserCtx.br.cache : null;
        if (parseMetaContent)
        {
          for (var i = 0; i < len; ++i)
          {
            layers[i].end();
          }
        }
      }
    };

    if (pageData.brushCache)
    {
      parserCtx.br = { cache: pageData.brushCache, i: 0 };
      parserCtx.createBrushes = false;
    }
    else
    {
      parserCtx.br = { cache: [] };
    }

    return parserCtx;
  }

  function renderPage(canvas, scale, pageNumber, pageInfo, pageData, parseMetaContent)
  {
    //console.log("render:"+pageInfo.number);
    var self = this;
    if (_.isEmpty(pageData))
    {
      this.renderError(canvas, scale, pageInfo, pageNumber, "missing-page", vitrium.i18n._T("message-cannot-load-page"));
      return false;
    }
    else
    {
      var renderingContext = this.createRenderingContext(canvas, scale, pageNumber, pageInfo, pageData, parseMetaContent);
      var pageParser = new vitrium.json.ObjectParser(renderingContext.handlers, renderingContext);
      pageParser.process(pageData);
      renderingContext.finishCallback();
      return true;
    }
  }

  function free()
  {
    var layers = this.layers;
    var len = layers.length;
    for (var i = 0; i < len; ++i)
    {
      layers[i].freeMemory();
    }
  }

  function renderError(canvas, scale, pageInfo, pageNumber, type, message)
  {
    var ctx = canvas.getContext("2d");
    ctx.save();

    ctx.scale(scale, scale);

    var imgW = pageInfo.width / 12;
    var imgH = imgW;
    var margin = imgW / 2;

    ctx.save();
    ctx.translate(margin, margin);
    renderErrorIcon(ctx, imgW / 48);
    ctx.restore();

    ctx.fillStyle = 'black';
    var fontH = 18;
    var w = imgW;

    var totalMargin = margin * 4;
    var pw = pageInfo.width - totalMargin;

    ctx.font = fontH + 'px Arial, Helvetica, sans-serif';
    if (ctx.measureText(message).width > pw)
    {
      for (; fontH >= 1; --fontH)
      {
        ctx.font = fontH + 'px Arial, Helvetica, sans-serif';
        if (ctx.measureText(message).width <= pw)
        {
          break;
        }
      }
    }
    else
    {
      for (; fontH < 100; ++fontH)
      {
        ctx.font = fontH + 'px Arial, Helvetica, sans-serif';
        if (ctx.measureText(message).width > pw)
        {
          ctx.font = (fontH - 2) + 'px Arial, Helvetica, sans-serif';
          break;
        }
      }
      /*console.log(message, imgW + margin, imgH);*/

    }
    ctx.fillText(message, imgW + 2 * margin, margin + (imgH / 2));
    ctx.restore();
  }

  var ContextSaver = {
    begin: function (name, props, object, parseCtx, path)
    {
      if (name === T_CANVAS || name === T_PATH || name === T_GLYPHS)
      {
        parseCtx.ctx.save();
        parseCtx.matrixStack.push(parseCtx.matrixStack.top());
      }
    },
    end: function (name, props, object, parseCtx, path)
    {
      if (name === T_CANVAS || name === T_PATH || name === T_GLYPHS)
      {
        parseCtx.ctx.restore();
        parseCtx.matrixStack.pop();
      }
    }
  };




  var ContextTransform = {
    begin: function (name, props, object, parseCtx, path)
    {
      var transform;
      if (name === T_MATRIX_TRANSFORM)
      {
        transform = props[P_MATRIX];
      }
      else
      {
        transform = props[P_RENDER_TRANSFORM];
      }

      if (transform)
      {
        if (isResourceRef(transform))
        {
          var pageParser = new vitrium.json.ObjectParser(parseCtx.handlers, parseCtx);
          pageParser.process({ children: [parseCtx.dict.getForPropertyValue(transform)] });
        }
        else
        {
          transform = Matrix.fromXPS(transform);
          transform.transform(parseCtx.ctx);

          parseCtx.matrixStack.top(parseCtx.matrixStack.top().multiply(transform));
          /*  var t = parseCtx.matrixStack.top();
            console.log(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f);
            console.log(t.a, t.b, t.c, t.d, t.e, t.f);*/
        }

        //console.log(parseCtx.matrixStack);
      }
    },
    end: function (name, props, object, parseCtx, path)
    {

    }
  };

  var OpacityHandler = {
    begin: function (name, props, object, parseCtx, path)
    {
      if (_.isUndefined(parseCtx.opacity)) parseCtx.opacity = 1.0;
      if (_.isUndefined(parseCtx.opacityStack)) parseCtx.opacityStack = [];

      var stack = parseCtx.opacityStack;

      var opacity = props[P_OPACITY];
      if (!_.isUndefined(opacity))
      {
        var co = parseFloat(opacity);
        if (co === 0.0 || isNaN(co))
        {
          parseCtx.block = true;
        }

        stack.push(parseCtx.opacity);
        parseCtx.opacity *= co;
      }
    },
    end: function (name, props, object, parseCtx, path)
    {
      if (!_.isUndefined(props[P_OPACITY]))
      {
        var stack = parseCtx.opacityStack;
        var co = parseFloat(props[P_OPACITY]);
        if (co === 0.0 || isNaN(co))
        {
          parseCtx.block = false;
        }

        parseCtx.opacity = stack.pop();
      }
    }
  };

  var ContextClip = {
    begin: function (name, props, object, parseCtx, path)
    {
      var clip = props[P_CLIP];
      if (clip || T_CANVAS_CLIP === name || T_GLYPHS_CLIP === name || T_PATH_CLIP === name)
      {
        var ctx = parseCtx.ctx;
        parseCtx.fillRule = ctx.fillRule || ctx.mozFillRule || ctx.webkitFillRule || ctx.msFillRule;
        setFillRule(parseCtx.ctx, "evenodd");
      }

      if (clip)
      {

        if (isResourceRef(clip))
        {
          var pageParser = new vitrium.json.ObjectParser(parseCtx.handlers, parseCtx);
          pageParser.process({ children: [parseCtx.dict.getForPropertyValue(clip)] });
        }
        else
        {
          ctxClipAttribute(parseCtx.ctx, clip);
        }

        if (parseCtx.fillRule)
        {
          setFillRule(parseCtx.ctx, parseCtx.fillRule);
          parseCtx.fillRule = null;
        }
      }
    },
    end: function (name, props, object, parseCtx, path)
    {
      if (T_CANVAS_CLIP === name || T_GLYPHS_CLIP === name || T_PATH_CLIP === name)
      {
        //vitrium.log.warn("Not implemented: "+name);
        if (parseCtx.ctx.argFillRule)
        {

          parseCtx.ctx.clip(parseCtx.ctx.argFillRule);
        }
        else
        {
          parseCtx.ctx.clip();
        }

        if (parseCtx.fillRule)
        {
          setFillRule(parseCtx.ctx, parseCtx.fillRule);
          parseCtx.fillRule = null;
        }
      }

    }
  };

  var ContextBrush = {
    begin: function (name, props, object, parseCtx, path, objectProcessor)
    {
      var brush = null;
      var opacity = parseCtx.opacity;
      var opacityMask = _.isBoolean(parseCtx.opacityMask) ? parseCtx.opacityMask : false;

      var tString = props[P_TRANSFORM];
      var transform;
      if (tString)
      {
        transform = Matrix.fromXPS(tString);
      }
      else
      {
        transform = Matrix.identity();
      }

      if (name === T_SOLID_COLOR_BRUSH)
      {
        brush = new viewer.SolidColorBrush(parseCtx.ctx, opacity, convertColor(props[P_COLOR]), parseCtx.opacityMaskBrush);
      }
      else if (name === T_IMAGE_BRUSH)
      {
        if (parseCtx.createBrushes)
        {
          brush = new viewer.ImageBrush(parseCtx.ctx, opacity,
              transform, parseRectangle(props[P_VIEWBOX]),
              parseRectangle(props[P_VIEWPORT]),
              props[P_TILE_MODE] || "None",
              props[P_IMAGE_SOURCE],
              parseCtx.matrixStack,
              parseCtx.pageInstance.fileProvider, parseCtx.imageRequestTag, parseCtx.opacityMaskBrush, objectProcessor);

          parseCtx.br.cache.push(brush);
        }
        else
        {
          brush = parseCtx.br.cache[parseCtx.br.i++];
          viewer.ImageBrush.call(brush, parseCtx.ctx, opacity,
transform, parseRectangle(props[P_VIEWBOX]),
parseRectangle(props[P_VIEWPORT]),
props[P_TILE_MODE] || "None",
props[P_IMAGE_SOURCE],
parseCtx.matrixStack,
parseCtx.pageInstance.fileProvider, parseCtx.imageRequestTag, parseCtx.opacityMaskBrush, objectProcessor);
        }

      }
      else if (name === T_LINEAR_GRADIENT_BRUSH)
      {
        var startPoint = parsePoint(props[P_START_POINT]);
        var endPoint = parsePoint(props[P_END_POINT]);

        brush = new viewer.LinearGradientBrush(parseCtx.ctx, opacity, transform, startPoint, endPoint, parseCtx.opacityMaskBrush);
      }
      else if (name === T_RADIAL_GRADIENT_BRUSH)
      {
        var origin = parsePoint(props[P_GRADIENT_ORIGIN]);
        var center = parsePoint(props[P_CENTER]);
        var radiusX = parseFloat(props[P_RADIUS_X]);
        var radiusY = parseFloat(props[P_RADIUS_Y]);

        brush = new viewer.RadialGradientBrush(parseCtx.ctx, opacity, transform, origin, center, radiusX, radiusY, parseCtx.opacityMaskBrush);
      }
      else if (name === T_VISUAL_BRUSH)
      {
        brush = new viewer.SolidColorBrush(parseCtx.ctx, opacity, "black", parseCtx.opacityMaskBrush);
        parseCtx.block = true; // dont parse child nodes!!
      }

      if (brush)
      {
        if (parseCtx.fill)
        {
          parseCtx.fillBrush = brush;
        }
        else if (opacityMask)
        {
          parseCtx.opacityMaskBrush = brush;
        }
        else
        {
          parseCtx.strokeBrush = brush;
        }
        parseCtx.brush = brush;
      }


      if (name === T_PATH || name === T_GLYPHS)
      {
        var fill = props[P_FILL];
        var stroke = props[P_STROKE];

        var tOpacity = props[P_OPACITY];

        if (!_.isUndefined(tOpacity))
        {
          opacity = parseFloat(tOpacity) * opacity;
        }

        if (fill)
        {
          if (isResourceRef(fill))
          {
            parseCtx.fillBrush = parseCtx.dict.getForPropertyValue(fill);
          }
          else
          {
            parseCtx.fillBrush = new viewer.SolidColorBrush(parseCtx.ctx, opacity, convertColor(fill));
          }
        }

        if (stroke)
        {
          if (isResourceRef(stroke))
          {
            parseCtx.strokeBrush = parseCtx.dict.getForPropertyValue(stroke);
          }
          else
          {
            parseCtx.strokeBrush = new viewer.SolidColorBrush(parseCtx.ctx, opacity, convertColor(stroke));
          }
        }

        var lineWidth = props[P_STROKE_THICKNESS];
        if (lineWidth)
        {
          parseCtx.ctx.lineWidth = parseFloat(lineWidth);
        }
        else
        {
          parseCtx.ctx.lineWidth = 1;
        }

        var lineJoin = props[P_STROKE_LINE_JOIN];
        if (lineJoin)
        {
          lineJoin = lineJoin.toLowerCase();
          parseCtx.ctx.lineJoin = lineJoin;
        }
        else
        {
          lineJoin = "miter";
          parseCtx.ctx.lineJoin = lineJoin;
        }
        var scale = parseCtx.matrixStack.top().getScale();
        var cor = parseCtx.ctx.lineWidth / scale.x;

        if (lineJoin === "miter")
        {
          var limit = props[P_STROKE_MITER_LIMIT];
          //	console.log(limit);
          if (limit)
          {
            parseCtx.ctx.miterLimit = parseFloat(limit) * cor;
          }
          else
          {
            parseCtx.ctx.miterLimit = 10.0 * cor;
          }
        }

        var strokeDashOffset = props[P_STROKE_DASH_OFFSET];
        if (!strokeDashOffset)
        {
          strokeDashOffset = 0.0;
        }

        var strokeDashArray = props[P_STROKE_DASH_ARRAY];
        if (parseCtx.ctx.setLineDash || "mozDash" in parseCtx.ctx || "webkitLineDash" in parseCtx.ctx)		//IE9 does not support setLineDash
        {
          if (strokeDashArray)
          {
            strokeDashArray = strokeDashArray.split(" ");
            var len = strokeDashArray.length;


            for (var i = 0; i < len; ++i)
            {
              var val = strokeDashArray[i] = parseFloat(strokeDashArray[i]) * cor;
              if (val === 0)
              {
                strokeDashArray[i] = 1;
              }
            }
            //console.log(strokeDashArray, cor,  object.properties);

          }
          else
          {
            strokeDashArray = [];
          }


          var c = parseCtx.ctx;
          if ("mozDash" in c)
          {
            c.mozDash = strokeDashArray;
            c.mozDashOffset = strokeDashOffset;
          }
          else if ("webkitLineDash" in c)
          {
            c.webkitLineDash = strokeDashArray;
            c.webkitLineDashOffset = strokeDashOffset;
          }
          else
          {
            c.setLineDash(strokeDashArray);
            c.lineDashOffset = strokeDashOffset;
          }
        }

        var lineCap = props[P_STROKE_START_LINE_CAP] || props[P_STROKE_END_LINE_CAP] || "Flat";

        switch (lineCap)
        {
          case "Square":
            lineCap = "square";
            break;
          case "Round":
            lineCap = "round";
            break;
          case "Triangle":
          case "Flat":
          default:
            lineCap = "butt";
            break;
        }

        parseCtx.ctx.lineCap = lineCap;


      }
      else
      {
        parseCtx.fill = T_GLYPHS_FILL === name || T_PATH_FILL === name;
        parseCtx.stroke = T_GLYPHS_STROKE === name || T_PATH_STROKE === name;
        parseCtx.opacityMask = T_GLYPHS_OPACITY_MASK === name || T_PATH_OPACITY_MASK === name;
      }
    },
    end: function (name, props, object, parseCtx, path)
    {
      if (T_PATH_FILL === name || T_GLYPHS_FILL === name)
      {
        parseCtx.fill = false;
      }
      else if (T_PATH_STROKE === name || T_GLYPHS_STROKE === name)
      {
        parseCtx.stroke = false;
      }
      else if (name === T_PATH || name === T_GLYPHS)
      {
        parseCtx.fillBrush = null;
        parseCtx.strokeBrush = null;
        parseCtx.opacityMaskBrush = null;
      }
      else if (T_GLYPHS_OPACITY_MASK === name || T_PATH_OPACITY_MASK === name)
      {
        parseCtx.opacityMask = false;
      }
      else if (
name === T_SOLID_COLOR_BRUSH ||
name === T_IMAGE_BRUSH ||
name === T_LINEAR_GRADIENT_BRUSH ||
name === T_RADIAL_GRADIENT_BRUSH ||
name === T_VISUAL_BRUSH)
      {
        parseCtx.brush = null;
        parseCtx.block = false;
      }
    }
  };


  var PathHandler = {
    begin: function (name, props, object, parseCtx, path, objectProcessor)
    {
      if (name === T_PATH)
      {
        parseCtx.ctx.beginPath();
      }

    },
    end: function (name, props, object, parseCtx, path, objectProcessor)
    {
      if (name === T_PATH)
      {
        var ctx = parseCtx.ctx;
        var fillBrush = parseCtx.fillBrush;
        var strokeBrush = parseCtx.strokeBrush;

        var data = props[P_DATA];
        if (data)
        {
          if (isResourceRef(data))
          {
            var pageParser = new vitrium.json.ObjectParser(parseCtx.handlers, parseCtx);
            pageParser.process({ children: [parseCtx.dict.getForPropertyValue(data)] });
          }
          else
          {
            processPathData(ctx, data);
          }
        }

        var URI = props[P_FIXED_PAGE_NAVIGATE_URI];
        if (_.isString(URI) && URI.length > 0)
        {
          var lp = parseCtx.linkProcessors;
          var top = parseCtx.matrixStack.top();
          for (var i = 0, len = lp.length; i < len ; ++i)
          {
            lp[i].addLink(top, URI, name, object);
          }
        }


        var refName = props[P_NAME];
        if (_.isString(refName) && refName.length > 0)
        {
          var np = parseCtx.nameProcessors;
          var top = parseCtx.matrixStack.top();
          for (var i = 0, len = lp.length; i < len ; ++i)
          {
            np[i].addName(top, refName, name, object);
          }
        }

        var async = false;
        if (fillBrush)
        {
          if (objectProcessor.wait && fillBrush.tryEnableAsync())
          {
            async = true;
            objectProcessor.wait();
           // var trace = objectProcessor.__debug__ = new vitrium.debug.Tracer();

            fillBrush.asyncFill(function ()
            {
              if (strokeBrush)
              {
                if (strokeBrush.tryEnableAsync())
                {
                  objectProcessor.wait();
         
                  strokeBrush.asyncStroke(function ()
                  {
         
                    objectProcessor.post();
                  });
                }
                else
                {
                  strokeBrush.stroke();
                }
              }
              
              objectProcessor.post();
         
            });

         /*   setTimeout(function ()
            {
              //deadlock detected
              if (objectProcessor.semaphore > 0) 
              {
                // let's print out a trace message
                trace.print();
              }
            }, 10000);*/
          }
          else
          {
            fillBrush.fill();
          }
        }

        if (!async && strokeBrush)
        {
          if (objectProcessor.wait && strokeBrush.tryEnableAsync())
          {
            objectProcessor.wait();
            strokeBrush.asyncStroke(function ()
            {
              objectProcessor.post();
            });
          }
          else
          {
            strokeBrush.stroke();
          }
        }
      }
      else if (name === T_PATH_GEOMETRY)
      {
        var ctx = parseCtx.ctx;

        var figures = props[P_FIGURES];
        if (figures)
        {
          var pt = props[P_TRANSFORM];
          if (pt)
          {
            ctx.save();
            Matrix.fromXPS(pt).transform(ctx);
          }

          processPathData(ctx, figures);

          if (pt)
          {
            ctx.restore();
          }
        }
      }
    }
  };

  var GlyphsHandler = {
    begin: function (name, props, object, parseCtx, path)
    {
    },
    end: function (name, props, object, parseCtx, path)
    {
      if (name === T_GLYPHS && (parseCtx.strokeBrush || parseCtx.fillBrush))
      {
        handleGlyphs(parseCtx.ctx, object, parseCtx, props);
      }
      else if (name === T_GLYPHS)
      {
        vitrium.log.warn("Glyphs are not rendered:" + props[P_UNICODE_STRING]);
      }
    }
  };

  var ColorStopHandler = {
    begin: function (name, props, object, parseCtx, path)
    {
      if (parseCtx.brush)
      {
        if (name === T_GRADIENT_STOP)
        {
          parseCtx.brush.addColorStop(parseFloat(props[P_OFFSET]), convertColor(props[P_COLOR]));
        }
      }
    },
    end: function (name, props, object, parseCtx, path)
    { }
  };

  /**
  RESOURCE DICTIONARY HANDLERS
*/

  function isResourceRef(val)
  {
    return val && typeof (val) === "string" && val[0] === "{";
  }

  var ResourceDictionaryHandler = {
    begin: function (name, props, object, parseCtx, path)
    {
      if (name === T_RESOURCE_DICTIONARY)
      {
        // do not process any child and 
        parseCtx.block = true;
        parseCtx.dict = new vitrium.viewer.ResourceDictionary(parseCtx.dict, path[path.length - 1]);



        var handlers = [
  ContextBrush,
  DictionarySaverHandler
        ];

        var dictionaryParser = new vitrium.json.ObjectParser(handlers, {
          dict: parseCtx.dict,
          ctx: parseCtx.ctx,
          br: parseCtx.br,
          createBrushes: parseCtx.createBrushes,
          pageInstance: { fileProvider: parseCtx.pageInstance.fileProvider },
          matrixStack: parseCtx.matrixStack,
          dictParser: true
        }, null, true);

        var source = props[P_SOURCE];
        if (source)
        {
          dictionaryParser.process(parseCtx.pageInstance.fileProvider.getResource(source));
        }
        else
        {
          dictionaryParser.process(object);
        }

      }
    },
    end: function (name, props, object, parseCtx, path)
    {
      if (name === T_RESOURCE_DICTIONARY)
      {
        parseCtx.block = false;
      }
      else if (name === T_CANVAS)
      {
        if (!parseCtx.dictParser && parseCtx.dict.scope === object)
        {
          parseCtx.dict = parseCtx.dict.parent; // dictionary is out of scope
        }
      }
    }
  };

  var DictionarySaverHandler = {
    begin: function (name, props, object, parseCtx)
    {
      var key = props[P_X_KEY];
      if (!key) return;

      if (parseCtx.brush &&
    (name === T_SOLID_COLOR_BRUSH ||
  name === T_IMAGE_BRUSH ||
  name === T_LINEAR_GRADIENT_BRUSH ||
  name === T_RADIAL_GRADIENT_BRUSH ||
  name === T_VISUAL_BRUSH))
      {
        parseCtx.dict.store(key, parseCtx.brush);
      }
      else if (
name === T_PATH_GEOMETRY ||
name === T_PATH ||
name === T_GLYPHS ||
name === T_CANVAS ||
name === T_MATRIX_TRANSFORM)
      {
        parseCtx.dict.store(key, object);
      }
    },
    end: function () { }
  };


  function renderString(parseCtx, string, font, x, y, width, unicodeString, widths, URI, refName)
  {
    /*
_.each(parseCtx.matrixStack, function(matrix)
{
  console.log(matrix.toString());	
});*/
    var fillBrush = parseCtx.fillBrush;
    if (fillBrush)
    {
      fillBrush.fillText(string, x, y);
    }

    var strokeBrush = parseCtx.strokeBrush;
    if (strokeBrush)
    {
      strokeBrush.strokeText(string, x, y);
    }

    if (strokeBrush || fillBrush)
    {
      var glyphProcessors = parseCtx.glyphProcessors;

      for (var i = glyphProcessors.length; i--;)
      {
        glyphProcessors[i].addText(string, font, x, y, width, parseCtx.matrixStack.top(), unicodeString, widths);
      }
    }


    if (URI && URI.length > 0)
    {
      var rect = { x: x, y: y - font.size, width: width, height: font.size };
      var lp = parseCtx.linkProcessors;
      for (var i = 0, len = lp.length; i < len ; ++i)
      {
        lp[i].addLink(parseCtx.matrixStack.top(), URI, T_GLYPHS, rect);
      }
    }


    if (refName && refName.length > 0)
    {
      var rect = { x: x, y: y - font.size, width: width, height: font.size };
      var np = parseCtx.nameProcessors;
      for (var i = 0, len = np.length; i < len; ++i)
      {
        np[i].addName(parseCtx.matrixStack.top(), refName, T_GLYPHS, rect);
      }
    }
  }

  function renderSidewaysString(parseCtx, ctx, string, unicodeString, x, y, rx, ry, width, font, URI, refName)
  {
    var fillBrush = parseCtx.fillBrush;
    if (fillBrush)
    {
      fillBrush.ctx = ctx;
      fillBrush.fillText(string, x, y);
    }

    var strokeBrush = parseCtx.strokeBrush;
    if (strokeBrush)
    {
      strokeBrush.ctx = ctx;
      strokeBrush.strokeText(string, x, y);
    }

    if (strokeBrush || fillBrush)
    {
      var glyphProcessors = parseCtx.glyphProcessors;

      for (var i = glyphProcessors.length; i--;)
      {
        var m = parseCtx.matrixStack.top();


        glyphProcessors[i].addText(string, font, rx, ry, width, m, unicodeString, true);
      }
    }


    if (URI && URI.length > 0)
    {
      var rect = { x: rx, y: ry, width: width, height: font.size };
      var lp = parseCtx.linkProcessors;
      for (var i = 0, len = lp.length; i < len ; ++i)
      {
        lp[i].addLink(parseCtx.matrixStack.top(), URI, T_GLYPHS, rect);
      }
    }


    if (refName && refName.length > 0)
    {
      var rect = { x: rx, y: ry, width: width, height: font.size };
      var np = parseCtx.nameProcessors;
      for (var i = 0, len = np.length; i < len; ++i)
      {
        np[i].addName(parseCtx.matrixStack.top(), refName, T_GLYPHS, rect);
      }
    }
  }


  var FONT_MULTIPLICATOR = vitrium.is_mobile ? 1 : 15;


  var USE_FONT_SCALE_OPT = !("firefox" in $.browser); //firefox behaves correctly
  function handleGlyphs(ctx, glyphs, parseCtx, props)
  {

    var fontSize = props[P_FONT_RENDERING_EM_SIZE];
    if (_.isUndefined(fontSize))
    {
      fontSize = 1.0;
    }

    var style = props[P_STYLE_SIMULATIONS];
    if (style == "ItalicSimulation")
    {
      style = "italic";
    }
    else if (style == "BoldSimulation")
    {
      style = "bold";
    }
    else if (style == "BoldItalicSimulation")
    {
      style = "italic bold";
    }
    else
    {
      style = "";
    }

    var family = props[P_FONT_URI] || "sans-serif";

    var matrixStack = parseCtx.matrixStack;
    var matrix = matrixStack.top();


    var scale = parseCtx.renderArguments.scale;

    //HACK this is for increasing accuracy for text rendering  and opera hinting;
    //console.log(fontSize);

    var a = 1;
    var d = 1;
    var p = 1;

    if (USE_FONT_SCALE_OPT)
    {
      /*if (fontSize < 8)
{*/
      var tscale = matrix.getScale();

      a = tscale.x * FONT_MULTIPLICATOR;
      d = tscale.y * FONT_MULTIPLICATOR;
      p = d / a;
      a = a * p;

      /*	}*/

      if (a === 0)
      {
        a = 1;
      }

      if (d === 0)
      {
        d = 1;
      }

      if (fontSize * d < 1.0)
      {
        return;
      }
    }
    else if (fontSize * matrix.getScale().y < 1.0)
    {
      return;
    }




    fontSize = fontSize * d;
    ctx.save();
    ctx.scale(1 / a, 1 / d);

    var n = Matrix.identity();
    n.a = 1 / a;
    n.d = 1 / d;
    
    matrixStack.push(matrix.multiply(n));

    var font = (style + " " + fontSize + "px '" + family + "'");
    var fontObj = { style: style, size: fontSize, family: family };

    ctx.font = font;
    fontObj.spaceSize = ctx.measureText(" ").width;

    var advanceWidth = 0.0;
    var advanceWidths = [];

    var string = props[P_UNICODE_STRING];
    var isSideways = props[P_IS_SIDEWAYS] === "true";

    var originX = props[P_ORIGIN_X] * a;
    var originY = props[P_ORIGIN_Y] * d;

    if (!originX)
    {
      originX = 0;
    }

    if (!originY)
    {
      originY = 0;
    }

    var leftToRight;
    if (props[P_BIDI_LEVEL])
    {
      leftToRight = parseInt(props[P_BIDI_LEVEL], 10) % 2 == 0;
    }
    else
    {
      leftToRight = true;
    }

    if (isSideways && !leftToRight)
    {
      viewer.log.error("invalid attribute combination: isSideways = true and leftToRight = false");
      return;
    }

    var indices = props[P_INDICES];

    if (leftToRight && !ctx.ltr)
    {
      ctx.canvas.dir = "ltr";
      ctx.ltr = true;
    }
    else if (!leftToRight && ctx.ltr)
    {
      ctx.canvas.dir = "rtl";
      ctx.ltr = false;
    }

    if (!indices)
    {
      indices = new Array(string.length);
      for (var i = 0; i < string.length; ++i)
      {
        indices[i] = "";
      }
    }
    else
    {
      indices = indices.split(";");
    }

    if (!leftToRight)
    {
      string = string.split("").reverse().join("");
      indices = indices.reverse();
    }

    var renderedStringBuffer = new Array(indices.length);
    var unicodeStringBuffer = new Array(indices.length);

    var sIdx = 0;
    var rsIdx = 0;
    var idx = 0;

    var currentX = originX;

    var URI = props[P_FIXED_PAGE_NAVIGATE_URI];
    var refName = props[P_NAME];

    function renderBuffer()
    {
      var renderedString = renderedStringBuffer.join("");
      var len = renderedString.length;
      var widths = new Array(len);

      for (var i = 0; i < len; ++i)
      {
        widths[i] = ctx.measureText(renderedStringBuffer[i]).width;
      }

      var unicodeString = unicodeStringBuffer;

      if (renderedString.length > 0)
      {
        var width = ctx.measureText(renderedString).width;

        renderString(parseCtx, renderedString, fontObj, currentX, originY, width, unicodeString, widths, URI, refName);
        currentX = addX(currentX, width);
      }

      renderedStringBuffer = new Array(indices.length - idx);
      unicodeStringBuffer = new Array(indices.length - idx);
      rsIdx = 0;
    }

    var pauseIncStringIdx = 0;
    var pausedCh = null;

    function getChar()
    {
      if (pausedCh)
      {
        return pausedCh;
      }
      else if (string)
      {
        return string[sIdx];
      }
      else
      {
        return null;
      }
    }

    function addX(a, b)
    {
      if (leftToRight)
      {
        return a + b;
      }
      else
      {
        return a - b;
      }
    }


    var d = parseCtx.document;
    var iLen = indices.length;
    var parsedIndices = props["KKI"];
    if (!_.isArray(parsedIndices))
    {
      var parsedIndices = new Array(iLen);
      for (idx = 0; idx < iLen; ++idx)
      {
        var ch = getChar();
        var index = new Index(d.fontsManager, family, indices[idx], ch, fontSize);
        parsedIndices[idx] = index;

        if (pauseIncStringIdx != 0)
        {
          --pauseIncStringIdx;
        }
        else
        {
          pausedCh = null;

          pauseIncStringIdx = index.clusterGlyphCount - 1;
          if (pauseIncStringIdx != 0)
          {
            pausedCh = string[sIdx];
          }

          sIdx += index.clusterCodeUnitCount;
        }
      }
      props["KKI"] = parsedIndices;
    }


    if (isSideways)
    {
      var ANGLE = -Math.PI / 2;
      var cosAngle = Math.cos(Math.PI / 2);
      var sinAngle = Math.sin(Math.PI / 2);
      for (idx = 0; idx < iLen; ++idx)
      {
        var index = parsedIndices[idx];
        if (index.valid)
        {
          var ch = index.orgCh;
          var width = ctx.measureText(index.ch).width;

          ctx.save();

          var rx = addX(currentX, index.uOffset);
          var ry = (originY - index.vOffset) - (width / 2);

          var topM = matrixStack.top()
          topM = topM.multiply(new Matrix(1, 0, 0, 1, rx + width, ry));
          ctx.translate(rx + width, ry);
          ctx.rotate(ANGLE);
          topM.multiply(new Matrix(cosAngle, -sinAngle, sinAngle, cosAngle, 0, 0));
          ctx.translate(-(rx + width), -ry);
          topM = topM.multiply(new Matrix(1, 0, 0, 1, -(rx + width), -ry));

          matrixStack.push(topM);

          renderSidewaysString(parseCtx, ctx, index.ch, ch, rx, ry, rx, ry - fontSize, width, fontObj, URI, refName);

          /*ctx.rect(rx, ry-fontSize, width,  fontSize);
ctx.stroke();*/
          matrixStack.pop();
          ctx.restore();

          if (index.advanceWidth != 0.0)
          {
            currentX = addX(currentX, addX(index.advanceWidth, index.uOffset));
          }
          else
          {
            //FIXME
            currentX = addX(currentX, fontSize);		// 1/6 just guess
          }

        }
      }
    }
    else
    {
      for (idx = 0; idx < iLen; ++idx)
      {
        var index = parsedIndices[idx];
        if (index.valid)
        {
          var ch = index.orgCh;
          //console.log(ch, index.ch);
          if (index.advanceWidth !== null)
          {
            renderBuffer();

            var width = addX(index.advanceWidth, index.uOffset);

            renderString(parseCtx, index.ch, fontObj, addX(currentX, index.uOffset), originY - (index.vOffset), width, ch, null, URI, refName);
            currentX = addX(currentX, width);
          }
          else
          {
            unicodeStringBuffer[rsIdx] = ch;
            renderedStringBuffer[rsIdx++] = index.ch;
          }
        }
      }
    }


    renderBuffer();

    matrixStack.pop();
    ctx.restore();
  }

  function Index(fntMng, font, description, ch, fontSize)
  {
    var valid = ch != null;

    if (!valid)
    {
      this.valid = false;
      return;
    }
    this.orgCh = ch;
    var values;

    // defaults
    var clusterCodeUnitCount = 1;
    var clusterGlyphCount = 1;
    var advanceWidth = null;
    var uOffset = 0.0;
    var vOffset = 0.0;

    var rightParIdx = description.indexOf(")");
    if (rightParIdx === -1)
    {
      values = description.split(",");
    }
    else if (description.indexOf("(") === 0)
    {
      var clusterMapping = description.substring(1, rightParIdx);
      clusterMapping = clusterMapping.split(":");
      if (clusterMapping.length === 0)
      {
        valid = false;
      }
      else if (clusterMapping.length >= 1)
      {
        clusterCodeUnitCount = parseInt(clusterMapping[0], 10);
        if (clusterMapping.length == 2)
        {
          clusterGlyphCount = parseInt(clusterMapping[1], 10);
        }

        if (clusterCodeUnitCount == 0 || clusterGlyphCount == 0)
        {
          valid = false;
        }
        else
        {
          values = description.substring(rightParIdx + 1).split(",");
        }
      }
    }

    for (var i = 0; i < values.length; ++i)
    {
      var val;
      if (i == 0)
      {
        val = parseInt(values[i], 10);
      }
      else
      {
        val = parseFloat(values[i]);
      }

      if (!isNaN(val))
      {
        switch (i)
        {
          case 0: //glyph index

             var ich = fntMng.glyphIdxToChar(font, val);// not yet supported

            if (ich !== null)
            {

              ch = ich;
            }
            /*	else
                {
                        console.log(val,ch);
                }*/
            //	vitrium.log.warn("Glyph index is not supported: "+val+ " for: "+ch);
            break;
          case 1: //advanceWidth
            advanceWidth = val * fontSize / 100.0;
            break;
          case 2: //uOffset
            uOffset = val * fontSize / 100.0;
            break;
          case 3: //vOffset
            vOffset = val * fontSize / 100.0;
            break;
          default:
            valid = false; // format error
            break;
        }
      }
    }

    if (valid)
    {
      this.clusterCodeUnitCount = clusterCodeUnitCount;
      this.clusterGlyphCount = clusterGlyphCount;

      this.ch = ch;
      this.advanceWidth = advanceWidth;
      this.uOffset = uOffset;
      this.vOffset = vOffset;
      this.valid = true;
    }
    else
    {
      this.valid = false;
    }
  }

  /**
  Canvas attributes
*/


  function ctxClipAttribute(ctx, clip)
  {
    ctx.beginPath();
    processPathData(ctx, clip);
    if (ctx.argFillRule)
    {
      ctx.clip(ctx.argFillRule);
    }
    else
    {
      ctx.clip();
    }
  }

  function pushContext(parseCtx, context)
  {
    if (!parseCtx.contextStack)
    {
      parseCtx.contextStack = [];
    }
    parseCtx.contextStack.push(parseCtx.ctx);
    parseCtx.ctx = context;
  }

  function popContext(parseCtx)
  {
    var old = parseCtx.ctx;
    parseCtx.ctx = parseCtx.contextStack.pop();

    return old;
  }



}(
vitrium.viewer,
vitrium,
vitrium.geometry,
vitrium.xps,
_,
jQuery,
__globals__));
// script:viewer/rectangle-processor.js
(function (exports, vitrium, pools, _, $, document, Backbone) {

	"use strict";
	
	var Point = vitrium.geometry.Point;
	var Rectangle = vitrium.geometry.Rectangle;
	var isIntersected = vitrium.geometry.isIntersected;
	
	var GLOBAL_RECTANGLE_POOL = pools.GLOBAL_RECTANGLE_POOL;
	var GLOBAL_POINT_POOL = pools.GLOBAL_RECTANGLE_POOL;
	
	var RECTANGLE_ARRAY_POOL = new pools.RectangleArrayPool(GLOBAL_RECTANGLE_POOL);
	
	_.extend(exports,
	{
		GlyphsToRectanglesProcessor : GlyphsToRectanglesProcessor,
		GlyphsToRectanglesProcessorFactory : GlyphsToRectanglesProcessorFactory,
		RectangleStorage : RectangleStorage,
		TextRectangle : Rectangle
	});

	function GlyphsToRectanglesProcessorFactory(rectangleStorage)
	{
		this.getInstance = function ()
		{
			return new GlyphsToRectanglesProcessor(rectangleStorage);
		};
	};
	
	function GlyphsToRectanglesProcessor(rectangleStorage)
	{
		this.pageNumber = null;
		this.rectangleStorage = rectangleStorage;
		this.add = false;
		this.fontsReady = false;
	}
	var TEMP_POINT = new Point(0,0);
	GlyphsToRectanglesProcessor.prototype = {
		freeMemory : function()
		{
			this.rectangleStorage.free(this.pageNumber);
		},
		begin : function (pageNumber)
		{
		    this.pageNumber = pageNumber;
			this.add = this.rectangleStorage.begin(pageNumber);
		},
		end : function (processor)
		{			
			if (this.add)
			{
				this.rectangleStorage.commit(this.pageNumber);
			}
		},
		addText : function (text, font, x, y, width, transform, unicodeText, widths, isSideWays)
		{
			if (!this.add) return;
			var rP = GLOBAL_RECTANGLE_POOL;
			var pP = GLOBAL_POINT_POOL;
			var tPoint = TEMP_POINT;
			var fontSize = font.size;
			if (_.isArray(widths))
			{
				var rS = this.rectangleStorage;
				
				for (var i = 0, len = widths.length; i < len; ++i)
				{
						var glyphWidth = widths[i];
						tPoint.x = x;
						tPoint.y = y;
						
						transform.inPlaceMultiplyPoint(tPoint);
						var dX = glyphWidth * transform.a;
						var dY = fontSize*transform.d;
					
						tPoint.y -= dY;
						dY *= 1.25;
						
						rS.add(this.pageNumber, rP.create(unicodeText[i], tPoint.x, tPoint.y,dX, dY, 0));
						x += glyphWidth;
				}	
				/*console.log(text);
				console.log(x,y,transform.toString(), tPoint.x, tPoint.y);*/
			}
			else
			{
		
				tPoint.x = x;
				tPoint.y = y;
						
				transform.inPlaceMultiplyPoint(tPoint);

				
				var dX = width * transform.a;
				var dY = fontSize*transform.d;
				
				
				if (!isSideWays)
				{			
					tPoint.y -= dY;
					dY *= 1.25;
				}
				
			/*	console.log(unicodeText)
				console.log(x,y,transform.toString(), tPoint.x, tPoint.y);*/
				//console.log(point, dimension, transform.toString());
				this.rectangleStorage.add(this.pageNumber, rP.create(unicodeText, tPoint.x, tPoint.y,dX, dY, 0));
			}
		}
	};
	
	function RectangleStorage()
	{
		this.pages = {};
		this._tmp = {};
		
		this.tmpRectangle = GLOBAL_RECTANGLE_POOL.create(null, 0, 0, 0, 0, 0);
	//	this.tmpRectangle2 = GLOBAL_RECTANGLE_POOL.create(null, 0, 0, 0, 0, 0);
		this.freeCallback = _.bind(this.onArrFreed, this);
	}
	
	RectangleStorage.prototype = {
		begin :function(pageNumber)
		{
			var rects = this.pages[pageNumber];
			if (_.isArray(rects))
			{
				rects.incRef();
				return false;
			}
			
			this.rollback(pageNumber);
						
			var arr = this._tmp[pageNumber] = RECTANGLE_ARRAY_POOL.create(0);
			arr.incRef();
			arr._pageNumber = pageNumber;

			return true;
		},
		onArrFreed : function(arr)
		{
			this.pages[arr._pageNumber] = null;
			arr._pageNumber = null;
			arr.callback = null;
		},
		rollback : function(pageNumber)
		{
			var tmp = this._tmp;
			var a = tmp[pageNumber];
			if (_.isArray(a))
			{
				a.decRef();
				tmp[pageNumber] = null;
				return true;
			}
			return false;
		},
		commit : function(pageNumber)
		{
			var tmp = this._tmp;
			var rects = tmp[pageNumber];
			if (_.isArray(rects))
			{
				rects.callback = this.freeCallback;
				this.pages[pageNumber] = rects;
				tmp[pageNumber] = null;
				
				this.trigger("finished", pageNumber);
			}
			else
			{
				vitrium.log.error("[RectangleStorage] Unbalanced commit call!");
			}			
		},
		getHandle : function(pageNumber)
		{
			var a = this.pages[pageNumber];
			if (_.isArray(a))
			{
				return a;
			}
			else
			{
				return null;
			}
		},
		add : function(pageNumber, rect)
		{
			this._tmp[pageNumber].push(rect);
		},
		free : function(pageNumber)
		{	
			var arr = this.pages[pageNumber];
			if (arr)
			{
				arr.decRef();
			}
		},		
		getRectangles : function(page, from, forward)
		{
			var rects = this.pages[page];
			if (rects)
			{
				var len = rects.length;
				if (from < 0)
				{
					from = len + from;
				}
				
				if (from < len && from >= 0)
				{
					if (forward)
					{
						return rects.slice(from, len);
					}
					else
					{
						return rects.slice(0,from+1);
					}
				}
				else
				{
					return [];
				}			
			}
			else
			{
				return null;
			}
		},
		intersect : function(pageNumber, result, queryRect)
		{
			var rects = this.pages[pageNumber];
			if (!rects) return;
			
			var sin = Math.sin, cos = Math.cos;
			var rI = 0;
			for (var i = rects.length; i --; )
			{
				var r = rects[i];
				if (queryRect.isIntersectedFast(r, cos, sin))
				{
					result[rI++] = r;
				}
			}
			result.length = rI;
		},	
		selectTextFlow : function(pageDimensions, pageNumber, result, queryRect, endWithLast, selectInvert)
		{
			var rects = this.pages[pageNumber];
			if (!rects) return;
			
			var first = null;
			var last = null;
			
			var sin = Math.sin, cos = Math.cos, sqrt = Math.sqrt;
			if (selectInvert)
			{
				var cQuery = this.tmpRectangle;
				var left = queryRect.x + queryRect.w;
				cQuery.init(left, queryRect.y, pageDimensions.x - left, pageDimensions.y - queryRect.y, 0, null);
				//fill.push(cQuery);
				var len = rects.length;
				var distance = 1000000;
				
				for (var i = 0; i < len; ++i)
				{
					var r = rects[i];
					if (cQuery.isIntersectedFast(r, cos, sin))
					{
						var dX = cQuery.x - (r.x + r.w / 2);
						var dY = cQuery.y - (r.y + r.h / 2);
						var tD =sqrt(dX*dX+dY*dY);
						if (tD < distance)
						{
							distance = tD;
							first = i;
						}
						
					//	break;
					}
				}

				var qPX = queryRect.x;
				var qPY = queryRect.y + queryRect.h;
			//	cQuery = this.tmpRectangle2;
				cQuery.init(0, 0, qPX, qPY, 0, null);
		//		fill.push(cQuery);
				distance = 1000000;
				
				for (var i = 0; i < len; ++i)
				{
					var r = rects[i];
					if (cQuery.isIntersectedFast(r, cos, sin))
					{
						var dX = qPX - (r.x + r.w/2);
						var dY = qPY - (r.y + r.h/2);
						var tD =sqrt(dX*dX+dY*dY);
			//			console.log(i, len, tD);
						if (tD < distance)
						{
							distance = tD;
							last = i;
						}
						 
					}
				}
					
				if (first > last)
				{
					var t = last;
					last = first;
					first = t;
				}
			//	console.log(first, last, distance, qPX, qPY);
			}
			else
			{			
				for (var i = rects.length; i --; )
				{
					var r = rects[i];
					if (queryRect.isIntersectedFast(r, cos, sin))
					{
						if (last === null)
						{
							last = i;
						}
						
						first = i;
					}
				}	
			}
			
			if (endWithLast)
			{
				last = rects.length-1;
				if (first === null)
				{
					first = 0;
				}
			}
			
			var rI = 0;
			for (var i = first; i <= last;++i)
			{
				if ( i !== null)
				{
					var r = rects[i];				
					result[rI++] = r;
				}
			}
			result.length = rI;
		}
	};
	
	_.extend(RectangleStorage.prototype, Backbone.Events);
		
}(
vitrium.viewer, 
vitrium,
vitrium.utils.pools,
_, 
jQuery, 
document,
Backbone));
// script:viewer/text-flow-rectangle-storage.js
(function (exports, vitrium, _, $, document, Backbone) {

	"use strict";
	
	var Point = vitrium.geometry.Point;
	var Rectangle = vitrium.geometry.Rectangle;
	var isIntersected = vitrium.geometry.isIntersected;
	var RectangleStorage = vitrium.viewer.RectangleStorage;
	
	_.extend(exports,
	{
		TextFlowRectangleStorage : TextFlowRectangleStorage
	});

	
	function TextFlowRectangleStorage()
	{
		RectangleStorage.call(this);
		this.on("finished", this.build, this);
	}
	
	var RS = TextFlowRectangleStorage.prototype;
	_.extend(RS, RectangleStorage.prototype);
		
	RS.build = function(pageNumber)
	{
	/*	var rectangles = _.clone(this.pages[pageNumber]);
		
		rectangles.sort(function(a, b)
		{ 
			var pA = a.position;
			var aY = pA.y;
			
			var pB = b.position;
			var bY = pB.y;
			
			if (aY < bY)
			{
				return -1;
			}
			else if (aY > bY)
			{
				return 1;
			}
			else
			{
				var aX = pA.x;
				var bX = pB.x;
					
				if (aX < bX)
				{
					return -1;
				}
				else if (aX > bX)
				{
					return 1;
				}
				else
				{
					return 0;
				}
			}
		});
		
		var x = {};
		var columns = [];
		
		var lastRect = null;
		var line = [];
		for (var i = 0, len = rectangles.length; i < len;++i)
		{	
				var r = rectangles[i];
				var pos = r.position;
				var dim = r.dimensions;
			
				if (lastRect === null)
				{
					
				}
				else if (pos.y != lastRect.position.y )
				{
					line.sort(function(a,b)
					{
						var pA = a.position;
						var pB = b.position;
						var aX = pA.x;
						var bX = pB.x;
							
						if (aX < bX)
						{
							return -1;
						}
						else if (aX > bX)
						{
							return 1;
						}
						else
						{
							return 0;
						}
					});
					
					var text = [];
					for (var j = 0, llen = line.length; j <llen;++j)
					{
						text.push(line[j].text);
					}
					console.log(text.join(""));
					line = [];
				}
				else
				{
					
				}
				
				line.push(r);
				lastRect = r;
		}

		console.log(columns);*/
		
	};
	
}(
vitrium.viewer, 
vitrium, 
_,
jQuery,
document, 
Backbone));
// script:viewer/text-selection.js
/// <reference path="~/build.html" />

(function (exports, log,geometry, geometry2, _, $, Backbone)
{
  "use strict";
  var Point = geometry.Point;
    
  var MODE = {
    MOUSE : 0,
    TOUCH : 1
  };
  
  var TextSelectionModel = Backbone.Model.extend({
    defaults : {
      "selection" : null, 
      "queryRect": null,
      "mode" : MODE.MOUSE
    },
    MODE : MODE
  });

  

  
  function LazyTextSelection(controller)
  {
    this.controller = controller;
    this.selection = {};
    this.emptySelection = [];
    this.generatedGetters = [];
  }
  
  LazyTextSelection.prototype = {
    getSelection : function(pageNumber)
    {
      if (pageNumber in this.selection)
      {
        return this.selection[pageNumber];
      }
      else
      {
        var selection =  this.controller.computeSelection(pageNumber);
        if (selection)
        {
          return this.selection[pageNumber] = selection;
        }
        else
        {
          return this.emptySelection;
        }
        
      }
    },
    getAffectedPages : function()
    {
      return this.generatedGetters;
    },
    isEmpty :function()
    {
      return _.isEmpty(this.generatedGetters);
    },
    createGetterForIndex : function(idx)
    {
      this.generatedGetters.push(idx);
      
      return { 
        get : function(){
          return this.getSelection(idx);
        },
        enumerable: true,
        configurable: true
      };
    },
    reset : function()
    {
      this.selection = {};
      var getters = this.generatedGetters;
      for (var i = 0, len = getters.length; i  < len ; ++i)
      {
        var idx = getters[i];
        if (idx in this)
        {
          delete this[idx];
        }
      }
      this.generatedGetters.length = 0;
    },
    remove: function(pageIdx)
    {
      this.invalidateData(pageIdx);
      //delete pageIdx getter
      delete this[pageIdx];
    },
    invalidateData : function(pageIdx)
    {
      var sel = this.selection;
      if (pageIdx in sel)
      {
        delete sel[pageIdx];
      }
    }
  };
  
  function TextSelectionController(rectangleStorage, viewer, textSelectionModel)
  {
    this.rectangleStorage = rectangleStorage;
    this.viewer = viewer;
    this.textSelectionModel = textSelectionModel;
        
    var lazyModel = this.lazyTextSelection  = new LazyTextSelection(this);
    textSelectionModel.set("selection", lazyModel);
    
    this.startPoint = new Point(0.0,0.0);
    this.endPoint = new Point(0.0,0.0);	
    this.startPageDim = new Point(0.0, 0.0);
    this.endPageDim = new Point(0.0, 0.0);
    this.tmpPoint = new Point(0.0,0.0);
    
    this.changed  = false;
    
    this.startPage = null;
    this.endPage = null;
    
    
    this.tmpArr = [];
    this.handles =  {};
    
    this.queryRectangle = new geometry2.DataRectangle(0, 0, 0, 0, 0, null);
    
    viewer.on("document:detached", this.onDocumentDetached, this);
    rectangleStorage.on("finished", this.onRectanglesReady, this);
    
  
  }
  
  TextSelectionController.prototype = {
    destroy : function()
    {
      this.viewer.off("document:detached", null, this);
      this.cancelSelection();
    }, 
    onRectanglesReady: function(pageNumber)
    {			
      if (this.isActive() && this.startPage <= pageNumber && pageNumber <= this.endPage)
      {
        var affectedPages = this.tmpArr;
        affectedPages[0] = pageNumber;
        affectedPages.length = 1;
      
        this.textSelectionModel.trigger("changed", affectedPages, true);	
      }
    },
    onDocumentDetached : function()
    {
      this.cancelSelection();
    },
    cancelSelection : function()
    {
      if (this.isActive())
      {
        var oldStartPage = this.startPage;
        var oldEndPage = this.endPage;
        
        var affectedPages = this.tmpArr;
        affectedPages.length = 0;
        
        for (var i = oldStartPage; i <= oldEndPage; ++i)
        {
          affectedPages.push(i);
          this.decRefIfPosible(i);
        }
        
        this.startPage = null;
        this.endPage = null;
        
        this.textSelectionModel.set("queryRect" ,null);
        this.textSelectionModel.trigger("changed", affectedPages, false);
        
        this.lazyTextSelection.reset();
      }

      this.textSelectionModel.set("mode", MODE.MOUSE);
    },
    canScrollMore : function(verticalDirection)
    {
      return verticalDirection === 0 
      || (this.isActive() 
        && ( verticalDirection < 0 && this.rectangleStorage.getHandle(this.startPage) !== null)
          || (verticalDirection > 0 && this.rectangleStorage.getHandle(this.endPage) !== null));
    },
    getNextPageForDirection : function(verticalDirection)
    {
      if (this.isActive())
      {
        if (verticalDirection < 0)
        {
          return this.startPage;
        }
        else
        {
          return this.endPage;
        }
      }
      else
      {
        return null;
      }
    },
    selectWord : function(pageNumber, pos)
    {

      function isInDifferentLevel(last, rect)
      {
        if (last === null) return false;
        return Math.abs(last.y - rect.y) > last.h;
      }

      if (pageNumber !== null)
      {
        var separators = " \n\t,'\".:";
        this.cancelSelection();
        var query = this.queryRectangle;
        query.x = pos.x;
        query.y = pos.y;
        query.w = 1;
        query.h = 1;

        var handle = this.rectangleStorage.getHandle(pageNumber);
        if (handle === null)
        {
          //rectangles aren't loaded yet
          return null;
        }

        var letterIdx = -1;
        var found = null
        for (var i = 0, len = handle.length; i < len; ++i)
        {
          if (query.isIntersected(handle[i]))
          {
            letterIdx = i;
            found = handle[i];
            break;
          }
        }

        if (letterIdx === -1) return;

        
        var wordStart = separators.indexOf(found.d) === -1 ? letterIdx - 1 : letterIdx;
        var last = null;
        if (wordStart <= 0)
        {
          wordStart = 0;
        }
        else
        {
          while (wordStart--)
          {
            var rect = handle[wordStart];
            var c = rect.d;
            if (isInDifferentLevel(last, rect) || separators.indexOf(c) !== -1)
            {
              ++wordStart;
              break;
            }
            last = rect;
          }
          if (wordStart < 0)
          {
            wordStart = 0;
          }
        }       

        var last = null;
        var wordEnd = separators.indexOf(found.d) === -1 ? letterIdx + 1 : letterIdx;
        for (var len = handle.length; wordEnd < len; ++wordEnd)
        {
          var rect = handle[wordEnd];
          var c = rect.d;
          if (isInDifferentLevel(last, rect) || separators.indexOf(c) !== -1)
          {
            wordEnd--;
            break;
          }
          last = rect;
        }

        this.handles[pageNumber] = handle;
        handle.incRef();

        
       
        var lazyModel = this.lazyTextSelection;
        var selection = lazyModel.selection[pageNumber] = [];
        for (var i = wordStart, len = handle.length; i <= wordEnd && i < len; ++i)
        {
          selection.push(handle[i]);
        }

        Object.defineProperty(lazyModel, pageNumber, lazyModel.createGetterForIndex(pageNumber));
        this.startPage = pageNumber;
        this.endPage = pageNumber;
        this.textSelectionModel.trigger("changed", [pageNumber], true);
     }
      
      //TODO word selection and sentece
    },
    setSelectionPoints: function(start, end)
    {
      // start and end points are in document units cleaned from viewport
      // correct order of points
      if (end.y < start.y)
      {
        var tmp = start;
        start = end;
        end = tmp;
      }
    
      var pageIt = this.viewer.getPageIteratorBetweenDU(start, end);
      
      var lazyModel = this.lazyTextSelection;
      var getter = lazyModel.getSelection;
      
      var oldStartPage = this.startPage;
      var oldEndPage = this.endPage;
            
      var first = null, last = null;
      var affectedPages = this.tmpArr;
      affectedPages.length = 0;
  
      var onPageCoord = this.tmpPoint.assign(start);
      var mode = this.textSelectionModel.get("mode");
      var page = null;
      while(pageIt.hasNext())
      {
        page = pageIt.next();
        if (first === null)
        {
          first = page.number;
          this.startPageDim.x = page.width;
          this.startPageDim.y = page.height;
          
          onPageCoord.x -= page.x;
          onPageCoord.y -= page.y;
          
        }
        else if (mode === MODE.TOUCH)
        {
           this.cancelSelection();
          return;
          
        }
        last = page.number;
      
        if (!(last in lazyModel))
        {	
          affectedPages.push(last);
          Object.defineProperty(lazyModel, last, lazyModel.createGetterForIndex(last));
        }
      }
      
      this.endPageDim.x = page.width;
      this.endPageDim.y = page.height;
      
      //UNDEFINE old accessors and release references
      for (var i = oldStartPage; oldStartPage !== null && i <= oldEndPage;++i)
      {
        if (i < first || i > last)
        {
          lazyModel.remove(i);
          this.decRefIfPosible(i);
                    
          if (affectedPages.indexOf(i) === -1)
          {
            affectedPages.push(i);
          }
        }	
      }
      
      if (!this.startPoint.equals(onPageCoord))
      {
        if (affectedPages.indexOf(first) === -1)
        {
          affectedPages.push(first);
          lazyModel.invalidateData(first);
          this.decRefIfPosible(first);
          
        }
        this.startPoint.assign(onPageCoord);
      }
      
      onPageCoord.assign(end);
      onPageCoord.x -= page.x;
      onPageCoord.y -= page.y;
          
      if (!this.endPoint.equals(onPageCoord))
      {
        if (affectedPages.indexOf(last) === -1)
        {
          affectedPages.push(last);
          lazyModel.invalidateData(last);
          this.decRefIfPosible(last);
        }
        this.endPoint.assign(onPageCoord);	
      }
            
      this.startPage = first;
      this.endPage = last;

      affectedPages.sort();
      this.textSelectionModel.trigger("changed", affectedPages, true);
    },
    decRefIfPosible: function(i)
    {
      if (i in this.handles)
      {
        this.handles[i].decRef();
        delete this.handles[i];
      }
    },
    computeSelection : function(pageNumber)
    {
      var sX=0, sY=0, dX=0, dY=0, selectToEnd=false;
      //NOTE this method is called only once per selection
      if (this.isActive())
      {
        var handle = this.rectangleStorage.getHandle(pageNumber);
        if (handle === null)
        {
          //rectangles aren't loaded yet
          return null; 
        }
        
        handle.incRef();
        this.handles[pageNumber] = handle;
        
        
        if (this.startPage === pageNumber && pageNumber === this.endPage)
        {
          var startPoint = this.startPoint;
          var endPoint = this.endPoint;
          
          selectToEnd = endPoint.y > this.startPageDim.y;
          sX = startPoint.x;
          sY = startPoint.y;
          dX = endPoint.x - startPoint.x;
          dY  = endPoint.y - startPoint.y;
        }
        else if (this.startPage === pageNumber)
        {
          var startPoint = this.startPoint;
          var startPageDim = this.startPageDim;
          
          sX = startPoint.x;
          sY = startPoint.y;
          dX = startPageDim.x - startPoint.x;
          dY = startPageDim.y - startPoint.y;					
        }
        else if (this.endPage === pageNumber)
        {
          var endPoint = this.endPoint;
          dX = endPoint.x;
          dY = endPoint.y;
        }
        
        
        if (pageNumber !== this.startPage && pageNumber !== this.endPage)
        {
          // passing all rectangles for given page by a reference
          return handle;
        }
        else
        {
          var queryRect = this.queryRectangle;
          var result = [];
          var selectInvert = false;
          if (dX < 0)
          {
            sX += dX;
            dX = -dX;
            selectInvert =true;
          }
          
          
          //console.log(sX, sY, dX, dY, selectToEnd, selectInvert);
          queryRect.init(sX, sY, dX, dY === 0 ? 1 :dY, 0, null);
        /*	var queryDisp = {};
          var fill = queryDisp[pageNumber] = [];
          if (!selectInvert)
          {
            fill.push(queryRect);
          }
          
      //		this.textSelectionModel.set("queryRect", queryDisp);*/
      //		this.queryInit(queryRect, sX, sY, dX, dY);
          this.rectangleStorage.selectTextFlow(this.startPageDim, pageNumber, result, queryRect, selectToEnd, selectInvert /*,fill*/);
          return result;
        }
      }
      
      log.error("[TextSelection] method must be called only when it is active");
    },
    isActive : function()
    {
      return this.startPage !== null;
    },
    finish : function()
    {
      this.textSelectionModel.trigger("finished");
    }
  }
  exports.TextSelectionModel = TextSelectionModel;
  exports.TextSelectionController = TextSelectionController;

}(
vitrium.viewer, 
vitrium.log,
vitrium.geometry,
vitrium.geometry2,
_, 
jQuery, 
Backbone));
// script:viewer/rectangle-renderer-layer.js
(function(exports, Backbone, _)
{
	"use strict";
	exports.RectangleRendererLayer = RectangleRendererLayer;
	
	function RectangleRendererLayer(model, field, eventName)
	{
		this.model = model;
		this.field = field;

		if (eventName)
		{
			model.on(eventName, this.onChanged, this);
		}
		
		this.fill = "rgba(49, 79, 173, 0.31)";
		this.stroke = null;
	}
	
	RectangleRendererLayer.prototype = {
		onChanged : function(pages)
		{
			this.trigger("changed", pages);
		},
		getRectangles: function(pageNumber)
		{
			var pages  = this.model.get(this.field);
			if (_.isObject(pages))
			{
				var rects = pages[pageNumber];
				if (_.isArray(rects))
				{
					return rects;
				}
			}
			return null;
		},
		hasContent : function(pageNumber)
		{
			var rects = this.getRectangles(pageNumber);
			return rects !== null && rects.length > 0;
		},		
		render : function(pageNumber, ctx, currentTime)
		{		
			var rects = this.getRectangles(pageNumber);
				
			ctx.beginPath();
			for (var i = rects.length; i--;)
			{
				var r  = rects[i];
				
				ctx.rect(r.x, r.y, r.w, r.h);
			}
		
			var f = this.fill;
			if (f)
			{
				ctx.fillStyle = f;
				ctx.fill();
			}
			var s = this.stroke;
			if (s)
			{
				ctx.strokeStyle = s;
				ctx.lineWidth = 1;
				ctx.stroke();
			}	
		}
	};
	_.extend(RectangleRendererLayer.prototype, Backbone.Events);
	
}(
vitrium.viewer,
Backbone,
_
));

// script:viewer/text-selection-touch-handles-layer.js
/// <reference path="~/build.html" />

(function (exports, Backbone, _, $)
{
  "use strict";

  exports.TextSelectionTouchHandlesLayer = TextSelectionTouchHandlesLayer;

  function TextSelectionTouchHandlesLayer(textSelectionModel, handleSize)
  {
    this.textSelectionModel = textSelectionModel;
    this.radius = handleSize;
    
  }

  TextSelectionTouchHandlesLayer.prototype =
  {
    hasContent : function(pageNumber)
    {
      return this.textSelectionModel.get("mode") !== 0 && pageNumber in this.textSelectionModel.get("selection");
    },
    render: function (pageNumber, ctx, currentTime)
    {
      var selection = this.textSelectionModel.get("selection")[pageNumber];
      if (!_.isEmpty(selection))
      {
        ctx.strokeStyle = "blue";
        ctx.fillStyle = "dodgerblue";
        ctx.lineWidth = 1;
        ctx.globalAlpha = 1;

        var first = selection[0];
        var last = selection[selection.length - 1];
        ctx.beginPath();
        ctx.moveTo(first.x, first.y);
        ctx.lineTo(first.x, first.y + first.h);


        ctx.moveTo(last.x+last.w, last.y);
        ctx.lineTo(last.x + last.w, last.y + last.h);

        ctx.stroke();

        ctx.beginPath();
        ctx.arc(first.x, first.y - this.radius / 2 - 1.5, this.radius, 0, 2 * Math.PI, false);
        
        ctx.globalAlpha = 0.5;
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(last.x + last.w, last.y + last.h + this.radius / 2 + 1.5, this.radius, 0, 2 * Math.PI, false);
        ctx.globalAlpha = 0.5;
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.stroke();
      }
    }
  };

  _.extend(TextSelectionTouchHandlesLayer.prototype, Backbone.Events);


  

}
(vitrium.viewer,
Backbone,
_,
jQuery
));

// script:viewer/text-search.js
(function (exports, vitrium, _, Backbone)
{
  "use strict";
  
  var Mode = {
    FORWARD : 1,
    BACKWARD : -1
  };

  var HARD_SPACE_RE = /\u00a0/g;
  
  function replaceHardSpacesBySpaces(text)
  {
     if(text)
        return text.replace(HARD_SPACE_RE, " ");
     return text;
  }
      
  var SearchModel = Backbone.Model.extend({
    defaults : {
      "result" : {},
      "mode": Mode.FORWARD,
      "text" : null,
      "cursor": null,
      "beginPage" : null,
      "beginPagePass" : 0,
      "endReached" : 0,
      "longsearch" : false,
      "rectangleHandle": null
    },
    documentEndReached  : function()
    {
      this.set({"endReached" : this.get("endReached")+1});
      var cPage = this.get("cursor").page ;
      if (cPage === this.get("beginPage"))
      {
        this.searchCompleted();
      }
      else
      {
        this.trigger("search:end-reached");
      }
    },
    searchCompleted : function()
    {
      var endReached = this.get("endReached");
      if (  endReached !== this.get("beginPagePass"))
      {
        this.set({"beginPagePass" : this.get("endReached") });
        if (this.get("longsearch"))
        {
          this.set({"longsearch" : false });
        }
        
        this.trigger("search:completed");
        return true;
      }
      return false;
    },
    decRefHandle : function()
    {
      var oldHandle = this.get("rectangleHandle");
      if (oldHandle)
      {
        oldHandle.decRef();
      }
       this.set("rectangleHandle", null);
    }
  });
  
  
  
  function SearchController(model, rectangleStorage, viewer)
  {
    this.model = model;
    this.viewer = viewer;
    this.rectangleStorage = rectangleStorage;
    
    this.onDocumentAttached = _.bind(this.documentAttached, this);
    this.onDocumentDettached = _.bind(this.documentDettached, this);
    this.onRectangleStorageFinished = _.bind(this.rectangleStorageFinished, this);
    
    this.onIndexFileReturned = _.bind(this.indexFileReturned, this);
    this.onIndexFileFailed = _.bind(this.indexFileFailed, this);
    
    
    viewer.on("document:attached", this.onDocumentAttached);
    viewer.on("document:dettached", this.onDocumentDettached);
    rectangleStorage.on("finished", this.onRectangleStorageFinished);
    
    this.waitFor = null;
    this.doc= null;
    this.lastTextIndex = null;
    
    this.longSearchAbortHandle = null;
    
    model.on("change:ui-state", function(model, val){
      if (!val) model.decRefHandle();
    });
  }
  
  var SC =  SearchController.prototype;
  SC.documentAttached = function (doc)
  {
    this.doc = doc;
    doc.on("textindex:loaded", this.onIndexFileReturned);
  };
  
  SC.documentDettached = function()
  {
    this.doc.off("textindex:loaded", this.onIndexFileReturned);
    this.doc = null;
    
    this.decRefHandle();
    this.model.set(_.extend({}, this.model.defaults));
  };
  
  SC.decRefHandle = function()
  {
    this.model.decRefHandle();
  };
  
  
  SC.rectangleStorageFinished  = function(pageIdx)
  {
    if (this.waitFor === pageIdx)
    {
      this.waitFor = null;
      this.doSearchOnCursor();
      this.model.set({"longsearch": false});
    }
  };
  
  SC.search = function(text)
  {	
    if (_.isEmpty(text))
    {
      return;
    }
    
     var model = this.model;
     var page = this.viewer.getCurrentPage();
     var position = 0;
     
     var mode = this.model.get("mode");
     
     if (mode === Mode.BACKWARD)
     {
      --page;
      if (page < 0)
      {
        page = this.viewer.getNumberOfPages() -1; 
      }
    
      position = -1;
     }
     
     this.decRefHandle();
     model.set({"text": text, "result" : {}, 
     "cursor":
    {
        "pos" :  position,
        "page": page
    },
     "beginPage" : page
     });
     
    this.doSearchOnCursor();
  };
  
  SC.doSearchOnCursor = function()
  {
    var model = this.model;
    var mode = model.get("mode");
    var cursor = model.get("cursor");
    
    if (cursor.page === model.get("beginPage"))
    {
      if (model.searchCompleted())
      {
        return;
      }
    }
    
    
    var rectangles = this.rectangleStorage.getRectangles(cursor.page, cursor.pos, mode === Mode.FORWARD);
    if (_.isArray(rectangles))
    {
      if  (rectangles.length === 0)
      {
        this.nextPage();
        return;
      }
      
      var result = this.doSearchOnRectangles(rectangles, mode, model.get("text"), cursor);
      if (result === null)
      {
          this.nextPage();
          return;
      }
      else
      {
        var handle = this.rectangleStorage.getHandle(cursor.page);
        handle.incRef();
        
        var oldHandle = model.get("rectangleHandle");
        if (oldHandle)
        {
          oldHandle.decRef();
        }
        model.set("rectangleHandle", handle);
        
        var rectRes = {};
        rectRes[cursor.page] = result;
        model.set({"result" : rectRes});
        
        var r = result[0];
        var p = r.getStartPoint();
      //	p.y -= 100;
        
        this.viewer.scrollToPoint(cursor.page, p);
        
        model.trigger("changed", [cursor.page]);
      }
    }
    else
    {
      this.findFirstOccurence();
    }
  };
  
  SC.findFirstOccurence = function()
  {
    var model = this.model;
    
    
    var cursor = model.get("cursor");
    if (cursor.page < 0)
    {
      cursor.page = this.viewer.getNumberOfPages() + cursor.page; 
    }
    else if (cursor.page >= this.viewer.getNumberOfPages())
    {
      cursor.page = 0;
    }
    
    
    var index = this.lastTextIndex;
    if (_.isObject(index) && index[cursor.page])
    {
      this.searchOnIndexedFile(index);
    }
    else
    {
      model.set({"longsearch": true});
    
      this.longSearchAbortHandle = this.doc.requestTextIndexFileForPage(cursor.page);		
    }
  };
  
  SC.abortLongSearch = function()
  {
    if (this.longSearchAbortHandle) this.longSearchAbortHandle();
    this.longSearchAbortHandle = null;
    this.model.set({"longsearch":false});
  };
  
  SC.indexFileReturned = function(idx, fileArray)
  {	
    this.longSearchAbortHandle = null;
    if (fileArray === "no-text")
    {
      this.nextPage();
    }
    else
    {
      var file = fileArray[0].data;
      var indexedFile = {};

      for (var i = 0, len=file.length; i < len; ++i)
      {
        var f = file[i];
        indexedFile[parseInt(f.page)-1] = replaceHardSpacesBySpaces(f.text);
      }
      
      this.lastTextIndex = indexedFile;			
      this.searchOnIndexedFile(indexedFile);
    }
  }
  
  SC.searchOnIndexedFile = function(indexedFile)
  {
    
    var model = this.model;
    var mode = model.get("mode");
    var searchText = model.get("text").toLowerCase();
    var cursor = model.get("cursor");
    var p = cursor.page;
    
    var beginPage = model.get("beginPage");
    
    if (mode === Mode.FORWARD)
    {
      for (var text = indexedFile[p]; p !== beginPage && text && text.toLowerCase().indexOf(searchText) === -1; text = indexedFile[++p])
      {
      }
    }
    else
    {
      for (var text = indexedFile[p]; p !== beginPage && text && text.toLowerCase().indexOf(searchText) === -1; text = indexedFile[--p])
      {}
    }
    
    
    var numberOfPages = this.viewer.getNumberOfPages();
    if (p === beginPage)
    {
      if (model.searchCompleted())
      {
        return;
      }
    }
    
    if (p < 0 || p >=  numberOfPages)
    {
      cursor.page = 0;
      cursor.pos = 0;
      model.documentEndReached();
    }
    else
    {
      cursor.page = p;
      
      
      if (indexedFile[p]) //found
      {
        // just check if user does not scroll to page
        if (_.isArray(this.rectangleStorage.getRectangles(cursor.page, 0, mode === Mode.FORWARD)))
        {
          // ok now is page loaded
          this.doSearchOnCursor();
        }
        else
        {
          this.waitFor = p;
          model.set({"longsearch": true});
          //now we have to wait for rectangles
          this.viewer.scrollTo(p);
        }
      }
      else // not found
      {
        this.findFirstOccurence();
      }
    }
  };
  
  SC.indexFileFailed = function(e)
  {
    var model =this.model;
    model.set({"longsearch": false});
    model.trigger("longsearch:failed", e);
  };	
  
  SC.nextPage = function()
  {	
    
    var model = this.model;
    var mode = model.get("mode");
    var cursor = model.get("cursor");
    cursor.pos = (mode === Mode.FORWARD) ? 0 : -1;
    var lastPage = cursor.page;
    cursor.page += mode;
    
    var beginPage = model.get("beginPage");
    
    if (cursor.page === beginPage)
    {
      if (model.searchCompleted())
      {
        return;
      }
    }
    
    var pageCount = this.viewer.getNumberOfPages();
    if (cursor.page < 0 || cursor.page >=  pageCount)
    {
      model.set({"longsearch": false});
      
      if (cursor.page >= pageCount)
      {
        cursor.page = 0;
        cursor.pos = 0;
      }
      else
      {
        cursor.page = pageCount + cursor.page;
        cursor.pos =-1;
      }
      
      model.documentEndReached();
    }
    else
    {
      this.doSearchOnCursor();
    }
    
    model.trigger("changed", [lastPage]);
  };
  
  SC.next = function()
  {
    var model = this.model;
    var mode = model.get("mode");
    
    var cursor = model.get("cursor");
    if (mode === Mode.FORWARD)
    {
      cursor.pos += model.get("text").length;
    }
    else
    {
      cursor.pos -= model.get("text").length;
    }
    
    this.doSearchOnCursor();
  }
  
  
  SC.doSearchOnRectangles = function(rectangles, mode, text, cursor)
  {
     var lcText = text.toLowerCase();

     var rectText = replaceHardSpacesBySpaces(join(rectangles).toLowerCase());
    var fIdx = -1;
    if (mode === Mode.FORWARD)
    {
       fIdx = rectText.indexOf(lcText);
    }
    else
    {
       fIdx = rectText.lastIndexOf(lcText);
    }
    
    if (fIdx !== -1)
    {	
      cursor.pos = (mode === Mode.FORWARD) ? cursor.pos + fIdx: fIdx;
      return rectangles.slice(fIdx,fIdx+ text.length);
    }
    else
    {
      return null;
    }
  };
  
  
  function join(rectangles)
  {
    var buffer = new Array(rectangles.length);
    for (var i  = 0, len = rectangles.length; i < len; ++i)
    {
      buffer[i] = rectangles[i].d;
    }
    
    return buffer.join("");
  };
  
  exports.SearchModel = SearchModel;
  exports.SearchController = SearchController;
  exports.SearchMode = Mode;

}
(
vitrium.viewer, 
vitrium, 
_, 
Backbone));
// script:viewer/fs/fs-model.js
(function (exports, Backbone, _)
{
	"use strict";
	
	var FsNodeModel = Backbone.Model.extend({
		defaults : {
			id : "0",
			action : "open",
			type : null,
			name : null
		},
		initialize : function (data)
		{
			data.list = data.list || [];
			data.actions = data.actions || [];
			data.nodes = data.nodes || [];
			this.set(data);
		}, 
		mount : function (node)
		{
			var nodes = this.get("nodes");
			nodes.push(node);
			
			var list  = this.get("list");
			list.push(node.toJSON());
			
			this.trigger("change:list", this, list);
			
			var self = this;
			node.on("change", function()
			{	
				var _list = list;
				var id = node.get("id");
				
				var updated = node.toJSON();
				
				for (var i = 0, len = list.length; i <len;++i)
				{
					if (id ===_list[i].id)
					{
						_list[i] = updated ;
						break;
					}
				}
				
				self.trigger("change:list-item", self, updated);
			});
		},
		open : function(id, controller)
		{
			var nodes = this.get("nodes");
			for (var i = 0, len=nodes.length; i < len; ++i)
			{
				var node = nodes[i];
				if (node.get("id") === id)
				{
					controller.push(node);
					break;
				}
			}
		},
		name : function (id)
		{
			var list = this.get("list");
			
			for(var i = 0, len = list.length; i < len ; ++i)
			{
				var item = list[i];
				if (item.id === id)
				{
					return item.name;
				}
			}
			return null;
		}
	});
	
	exports["FsNodeModel"] = FsNodeModel;
}(
vitrium.fs,
Backbone,
_
));
// script:viewer/fs/fs-browser-view.js
(function (exports, _, $, Backbone, i18n, document)
{
	"use strict";
	var fs = exports;
	exports["FSBrowserView"] = FSBrowserView;
	exports["ContainerRenderer"] = ContainerRenderer;
	exports["NameView"] = NameView;
	exports["ListView"] = ListView;
	exports["ActionView"]  = ActionView;
	exports["Dialog"] = Dialog;
	exports["InputDialog"] = InputDialog;
	exports["EditModeButton"] = EditModeButton;
	exports["generateViewID"] = generateViewID;
	
	var _T = i18n._T;
	
	var CSS_LOADING_STRUCTURE = "<div class='fs-loading'></div>";
	
	var viewID = 0;
	function generateViewID()
	{
		return viewID++;
	}
	
	function FSBrowserView(el, model, uiHandlers, changeDuration, loadingImg)
	{ 
		this.el = $(el);		
		this.loadingImg = loadingImg || $(CSS_LOADING_STRUCTURE);
		
		this.wrap = $("<div class='fs-wrap'>").appendTo(this.el);
		this.lockScreen = $("<div class='fs-lock-screen fs-lock-screen-off fs-lock-screen-none'></div>").appendTo(this.wrap);
		this.lockScreenAnimationTimer = null;		
		
		this.model = null;
		this.elStack = [];
		
		this.uiHandlers = uiHandlers;
		
		
		this.onOnNodePushed = _.bind(this.__onNodePushed, this);
		this.onOnNodePopped = _.bind(this.__onNodePopped, this);
		
		if (changeDuration)
		{
			this.duration = changeDuration;
		}
		else
		{
			this.duration = 0;
		}
		
		this.attachModel(model);
	}
	
	FSBrowserView.prototype = {
		attachModel : function (model)
		{	
			this.detachModel();
			this.model = model;
			
			model.on("node:pushed", this.onOnNodePushed);
			model.on("node:popped", this.onOnNodePopped);
			
			this.asyncTaskHandler = new fs.AsyncTaskHandler(model, {
				start : _.bind(this.showLoading, this),
				completed : _.bind(this.hideLockscreen, this)
			});
		
		},
		detachModel: function()
		{
			var m = this.model;
			if (m)
			{
				model.off("node:pushed", this.onOnNodePushed);
				model.off("node:popped", this.onOnNodePopped);
				this.model = null;
				
				this.asyncTaskHandler.destroy();
				this.asyncTaskHandler = null;
			}
		},
		showLoading: function()
		{
			this.showLockscreen(this.loadingImg);
		},
		showLockscreen : showLockscreen,
		hideLockscreen: hideLockscreen,
		prepareRender : function(node)
		{
			var type = node.get("type");
			
			var fsLevel = $("<div class='fs-level fs-level-new'>").addClass("fs-type-"+type);
			
			if (this.elStack.length !== 0)
			{
				 fsLevel.addClass("fs-level-top-animation");
			}
			
			var handlers = this.uiHandlers[type];
			if (!node.views) node.views = {};
			
			var el = this.wrap;
			for (var i = 0, len = handlers ? handlers.length : 0; i < len; ++i)
			{
				handlers[i].render(node, fsLevel);
			}
			
			this.elStack.push(fsLevel);
			fsLevel.appendTo(el);			
			return fsLevel;
		},
		__onNodePushed : function(model, node)
		{
			var lastEl = top(this.elStack);
			var newTop = this.prepareRender(node);
			var fallbackTimer = null;
			if (lastEl) 
			{
				lastEl.addClass("fs-level-up");			
				setTimeout(function()
				{
					newTop.removeClass("fs-level-top-animation");
				}, 20);
				
				lastEl.on("transitionend" , end);
				
				var duration = this.duration*1000*1.2;
				 fallbackTimer = setTimeout(end, duration);
			}
			
			function end(){
					lastEl.addClass("fs-level-up-done");
					newTop.removeClass("fs-level-new");

					lastEl.off("transitionend", end);
					clearTimeout(fallbackTimer);
				}
		},
		__onNodePopped: function(model, node)
		{			
			var currentEl = this.elStack.pop();			
			var lastEl = top(this.elStack);
			
			var el = this.el;
			var height = el.height();
			currentEl.addClass("fs-popped");
			currentEl.addClass("fs-level-new");

			lastEl.removeClass("fs-level-up-done");	
			
			var duration = this.duration*1000*1.2;
			
			setTimeout(function()
			{
				lastEl.removeClass("fs-level-up");	
				lastEl.on("transitionend" , function end(){
					lastEl.off("transitionend", end);
					currentEl.remove();
					clearTimeout(id);
				});
				// I have to be sure that underlaying element will be removed
				var id = setTimeout(function(){
					currentEl.remove();
				},duration);
			}, 20);
		}
	};
	

	function top(arr)
	{
		var idx = arr.length - 1;
		if (idx < 0)
		{
			return null;
		}
		else
		{
			return arr[idx];
		}
	}
	
	/**
		BASIC TYPE HANDLERS
	*/
	
	function ContainerRenderer(className, handlers)
	{
		this.className = className;
		this.handlers = handlers;
	}
	ContainerRenderer.prototype = 
	{
		render : function(node, el)
		{
			var handlers = this.handlers;
			var cEl = $("<div>").addClass(this.className);
			for (var i = 0, len = handlers ? handlers.length : 0; i < len; ++i)
			{
				handlers[i].render(node, cEl);
			}
			cEl.appendTo(el);
		}
	};
	
	
	function NameView(model, controller)
	{
		this.id = generateViewID();
		
		this.model = model;
		this.controller = controller;
		this.tmpl = _.template("<div class='name'><% if (type != 'root') { %><button type='button' class='btn back'><i class='icon-arrow-left'></i></button><% } else {%><%}%></div><h3 class='fs-level-name'><%=name%></h3>");
		
		this.update = _.bind(this.__update, this);
		this.onPopped = _.bind(this.__onPopped, this);
		this.onBack = _.bind(this.__onBack, this);
		
		model.on("node:popped", this.onPopped);
	}
	
	NameView.prototype = {
		render : function(node, el)
		{
			node.on("name:change", this.update);
						
			var display = $(this.tmpl({ type : node.get("type"), name : node.get("name")}));
			display.appendTo(el);
			display.on("tap click", "button", this.onBack);
			
			node.views[this.id] = display;
		},
		__update : function (node, name)
		{
			var display = node.views[this.id];
			display.find("span").text(display);			
		},
		__onBack : function(e)
		{
			this.controller.pop();
		},
		__onPopped: function(model, node)
		{
			node.off("name:change", this.update);
			node.views[this.id] = null;
		}
	};
	
	
	function ListView(model, controller,  icons, actions, filter, tmpl)
	{
		this.id = generateViewID();
		
		this.model = model;
		this.controller = controller;
		
		this.icons = icons;
		this.actions = actions || []; // [ { id : "move", icon : "icon-move", cssClass : "btn-danger"}]		
		this.tmpl = tmpl || _.template("<tr data-item-id='<%=escape(item.id)%>'><td class='fs-node-type-<%=item.type%>' ><%=supported.actions||'' %><div class='name'><a href='#' data-action='<%=item.action %>'><i class='<%=icon %>'></i>&nbsp;<%=item.name%></a></div></td></tr>");

		this.actionsTemplate = _.template('<% for (var i = 0, len=item.actions.length; i < len; ++i) { %> \
																			<% if (i == 0) { %>\
																					<div class="fs-inline-actions btn-group">\
																			<%} var action = item.actions[i]; %>\
																				<button type="button" href="#" class="btn btn-small <%=action.cssClass||""%>" data-action="<%=action.id%>">\
																					<%if (action.icon) {%>\
																					<i class="<%=action.icon%>"></i>&nbsp;\
																					<%}%>\
																					<span><%=action.tile || i18n._T("fs-action-"+action.id+"-title") %></span>\
																					</button>\
																			\
																			<% if (i == len -1) { %>\
																						</div>\
																			<%} %>\
																	<%}%>');
		
		this.update = _.bind(this.__update, this);
		this.updateItem = _.bind(this.__updateItem, this);
		this.removeItem = _.bind(this.__removeItem, this);
		this.onPopped = _.bind(this.__onPopped, this);
		this.onAction= _.bind(this.__onAction, this);
		
		this.stack = [];
		this.filter = filter ? filter : null;
		
		model.on("change:mode", this.onModeChanged, this);
		model.on("node:popped", this.onPopped);
		
	}
	
	ListView.prototype = {
		render : function(node, el)
		{
			node.on("change:list", this.update);
			node.on("change:list-item", this.updateItem);
			node.on("remove:list-item", this.removeItem);
								
			var display = $("<table class='fs-list table table-striped'></table>");
			if ($.browser && $.browser.safari)
			{
				display.addClass("fs-list-safari");
			}
			
			this.stack.push({display: display, node: node});
			
			if (this.model.get("mode") === "view")
			{
				display.addClass("fs-view-mode");
			}
		
			
			var wrap =  $("<div class='fs-list-wrap'></div>");
			wrap.append(display);
			
			node.views[this.id] = { el : el, display :display, wrap :wrap};
			this.__update(node, node.get("list"));
		},
		__update : function (node, list)
		{
			var data= node.views[this.id];
			var display = data.display;
			
			data.wrap.remove();
			display.empty();
			var tmpl = this.tmpl;
			var actionsTemplate = this.actionsTemplate;
			var icons = this.icons;
			var defActions  = this.actions;
			var obj = { item : null, supported : {}};
			
			var filter = this.filter;
			var i = 0;
			if (filter)
			{
				
				for(var len=list?list.length:0; i < len; ++i)
				{
					var item = list[i];
					if (filter(item))
					{
						display.append(this.__renderItem(obj,item,defActions, icons, actionsTemplate,tmpl));
					}
				}			
			}
			else
			{
				for(var len=list?list.length:0; i < len; ++i)
				{
					var item = list[i];
					display.append(this.__renderItem(obj,item,defActions, icons, actionsTemplate,tmpl));
				}
			}
			
			if (i === 0)
			{
				display.append("<tr class='fs-empty-row'><td>"+_T("fs-empty-folder")+"</td></tr>");
			}
			
			data.wrap.appendTo(data.el);
			display.on("tap click", "a, button", this.onAction);
		},
		__renderItem: function(obj, item, defActions, icons, actionsTemplate, tmpl)
		{
			var icon = icons[item.type];
			if (!icon)
			{
				icon  = "fa fa-file-text-o";
			}
			
			obj.icon = icon;
			obj.item = item;
			
			var actions = [];
			var editActions = item.editActions;
			if (!_.isEmpty(editActions))
			{
				for (var a = 0, alen = defActions.length; a <  alen;++a)
				{
					var action  = defActions[a];
					if (editActions.indexOf(action.id) !== -1)
					{
						actions.push(action);
					}
				}
			}
			
			obj.supported.actions = actionsTemplate({ item : { actions: actions}, i18n : i18n});
			return $(tmpl(obj));
		},
		__updateItem: function (node, item, id)
		{
			var _id = id || item.id;		
			var el = node.views[this.id].display.find("*[data-item-id='"+escape(_id)+"']");
			$(this.__renderItem({supported : {}},item,this.actions, this.icons, this.actionsTemplate,this.tmpl)).insertAfter(el);
			el.remove();
		},
		__removeItem: function (node, item, id)
		{
			var _id = id || item.id;		
			var li = node.views[this.id].display.find("*[data-item-id='"+escape(_id)+"']");
			li.remove();
		},
		__onAction : function(e)
		{
			if (e.type ==="click") e.preventDefault();
			var el = $(e.currentTarget);
			var action = el.attr("data-action");
			if (!action)
			{
				action = el.parents("*[data-action]").attr("data-action");
			}
			
			
			var itemId = unescape(el.parents("*[data-item-id]").attr("data-item-id"));
		
			this.controller.execute(action, itemId);
		},
		__onPopped: function(model, node)
		{
			node.off("change:list", this.update);
			node.off("change:list-item", this.updateItem);
			node.off("remove:list-item", this.removeItem);
			
			node.views[this.id] = null;
			
			var s = this.stack;
			for (var i = 0, len=s.length; i < len; ++i)
			{
				var item = s[i];
				if (item.node  === node)
				{
					if (i + 1 == len)
					{
						s.pop();
					}
					else
					{
						this.stack = _.without(s, item);
					}
					break;
				}
			}
		},
		onModeChanged: function(model, mode)
		{
			var s = this.stack;
			for (var i = 0, len = s.length; i < len;++i)
			{
				if (mode === "view")
				{
					s[i].display.addClass("fs-view-mode");
				}
				else
				{
					s[i].display.removeClass("fs-view-mode");
				}
			}
		}
	};
	
	function EditModeButton(model, view, btnGroup)
	{
		this.model = model;
		this.view = view;
		
		this.onPopped = _.bind(this.__onPopped, this);
		this.onSwitchButtonClicked = _.bind(this.__onSwitchButtonClicked,this);
		this.elements = [];
		model.on("change:mode", this.onModeChanged, this);
		model.on("node:popped", this.onPopped);
	}
	
	EditModeButton.prototype = { 
		render : function(node, el)
		{
			var model = this.model;
	
			var buttonEl = $('<div class="btn-group fs-mode"><button type="button" class="btn fs-action-switch"></a></div>');
			buttonEl.on("tap click", "button.fs-action-switch", this.onSwitchButtonClicked);
			
			
			this.view.render(node, buttonEl);
			el.find(".btn-action").addClass("fs-hide");
			
			this.elements.push({ node: node , el : buttonEl.appendTo(el)});
			
			this.onModeChanged(model, model.get("mode"));
	//		node.on("node:popped", this.onPopped);
		},
		onModeChanged: function(model, val)
		{
			var title, icon, addClass, remClass; 
			
			
			if (val === "view")
			{
				title = _T("fs-mode-edit");
				icon = "icon-pencil";
				
				addClass = "btn-danger";
				remClass = "btn-primary";
			}
			else if (val === "edit")
			{
				title = _T("fs-mode-view");
				icon = "icon-eye-open";
				
				addClass = "btn-primary";
				remClass = "btn-danger";
			}
			else
			{
				return;
			}
			
			var elements = this.elements;
			for (var i =0, len = elements.length; i < len; ++i)
			{
				var el = elements[i].el;
				if (val === "view")
				{
					$(el[0].parentElement).find(".btn-action").addClass("fs-hide");
				}
				else
				{
					$(el[0].parentElement).find(".btn-action").removeClass("fs-hide");
				}
				
				var button  = el.find(".fs-action-switch");
				button.addClass(addClass).removeClass(remClass);
				button.html("<i class='"+icon+"'></i>&nbsp;<span>"+title+"</span>");
			}
			
			
		},
		__onSwitchButtonClicked: function(e)
		{
			var model = this.model;
			var mode =  model.get("mode") ;
			var newMode =  mode === "view" ? "edit" : "view";
			model.set("mode",newMode);
		},
		__onPopped: function(model, node)
		{
			var elements= this.elements;
			if (elements.length > 0)
			{
				if (elements[elements.length-1].node === node)
				{
					elements.pop();
				}
				else
				{
					for (var i = 0, len = elements.length; i < len; ++i)
					{
						var el  = elements[i];
						if (el.node === node) 
						{
							this.elements = _.without(elements, el);
							break;
						}
					}
				}
			}
		}
	};
	
	
	function ActionView(model, controller, icons, displayAll)
	{
		this.id = generateViewID();
		this.model = model;
		this.controller = controller;
		this.icons = icons || {};
		this.displayAll = !!displayAll;
		
		this.tmpl = _.template("<a class='btn btn-action' href='#' data-action='<%=action.id %>' <% if (action.title) { %> title='<%=action.title%>'  <% } %> ><% if (visual.icon) {%><i class='<%=visual.icon %>'></i>&nbsp;<%}%><span><% if (action.title){ %><%=action.title%><%} else { %><%=i18n._T('fs-action-'+action.id+'-title')%><%}%></span></a>");
		
		this.update = _.bind(this.__update, this);

		this.onPopped = _.bind(this.__onPopped, this);
		this.onAction= _.bind(this.__onAction, this);
		
		model.on("node:popped", this.onPopped);
	}
	
	ActionView.prototype = {
		render : function(node, el)
		{
			node.on("change:actions", this.update);
								
			node.views[this.id] = { el : el, display : []};
			this.__update(node, node.get("actions"));
		},
		__update : function (node, list)
		{
			var data= node.views[this.id];
			
			var display = data.display;
			data.el.hide();
			
			for (var i = 0, len= display.length; i < len; ++i)
			{
				display[i].remove();
			}
			data.display = []	;
			
			var tmpl = this.tmpl;
			var icons = this.icons;
			var obj = { "action" : null, "visual": {}, "i18n":i18n};
			var displayAll = this.displayAll;
			
			for(var i = 0, len=list?list.length:0; i < len; ++i)
			{
				var a = list[i];
				obj.action = a;
				obj.visual.icon = icons[a.id];
				if (displayAll || obj.visual.icon)
				{
					var el = $(tmpl(obj));
					el.click(this.onAction);
					display.push(el);
				}
	
			}
			
			var el = data.el;
			for (var i = display.length; i--;)
			{
				el.prepend(display[i]);
			}
			
			el.show();
		},
		__onAction : function(e)
		{
			e.preventDefault();
			var el = $(e.currentTarget);
			if (!el.parent("ul").hasClass("fs-hide"))
			{
				var action = el.attr("data-action");			
				if (!action)
				{
					action = el.parents("*[data-action]").attr("data-action");
				}
				this.controller.execute(action);
			}
		},
		__onPopped: function(model, node)
		{
			node.off("change:actions", this.update);
			node.views[this.id] = null;
		}
	};	
	
	var DIALOG_TEMPLATE = _.template('<div class="modal <%=dialog.cssClass||"" %>">\
		  <div class="modal-header">\
			<button type="button" class="close" aria-hidden="true" data-action="close"><i class="fa fa-times"></i></button>\
			<h3><%=dialog.title||"&nbsp;" %></h3>\
		  </div>\
		  <div class="modal-body">\
			<%=dialog.body||""%>\
		  </div>\
			<%=buttons %>\
	</div>');
	
	var BUTTONS_TEMPLATE =  _.template('<% for (var i = 0, len=dialog.buttons.length; i < len; ++i) { %>\
		  <% if (i == 0) { %><div class="modal-footer"><% } %> \
			<% var button = dialog.buttons[i];%>\
			<button type="button" class="btn <%=button.cssClass||"" %> btn-id-<%=button.id||"" %>" data-action="<%=button.id%>" title="<%=button.title || button.label%>"><%=button.label || button.title %></button>\
			\
			<% if (i == len -1) { %></div><% } %> \
		  <% } %>');
	
	function Dialog(view, options)
	{
		this.view = view;
		var el = this.el = $("<div class='fs-center-parent'><div class='fs-dialog'></div></div>");		
		var template = this.template = options.template || DIALOG_TEMPLATE;
		var buttonsTemplate = this.buttonsTemplate = options.buttonsTemplate || BUTTONS_TEMPLATE;
		
		var buttons = buttonsTemplate({ dialog : options});
		
		var content = null;
		if (_.isString(options.body))
		{
			content = template({ dialog : options , buttons : buttons});
			content = $(content);	
		}
		else
		{
			var bodyEl = options.body;
			options.body = null;
			content = template({ dialog : options , buttons : buttons});
			content = $(content);	
			content.find(".modal-body").append(bodyEl);
		}
		
		var dEl = el.find(".fs-dialog");
		if (_.isString(options.cssClass))
		{
			el.find(".modal").addClass(options.cssClass);
		}
		
		this.content = content;
		
		dEl.append(content);
		el.on("tap click", ".modal-header *[data-action], .modal-footer *[data-action]", _.bind(this.onButton, this));
		
		this.loadingImg = options.loadingImg || $(CSS_LOADING_STRUCTURE);
		this.lockScreen = $("<div class='fs-lock-screen fs-lock-screen-off fs-lock-screen-none'></div>").appendTo(el.find(".modal"));
		this.lockScreenVisible = false;
		
		
		this.onKeyPress = _.bind(this.__onKeyPress, this);
		this.messageContainer = new MessageContainer(el.find(".modal-body"));
	}
	
	Dialog.prototype = _.extend({
		__onKeyPress : function(evt)
		{
			if (!this.lockScreenVisible)
			{
				if (evt.which === 27) //esc
				{
					this.keyDown = true;
					this.triggerButtonAction("close");
					evt.preventDefault();
					evt.stopPropagation();
					return false;
				}
				else if (evt.which ===13)
				{
					var primaryAction = this.el.find(".btn-primary");
					if (primaryAction.length === 1)
					{
						if (!primaryAction.hasClass("no-key"))
						{
							this.keyDown = false;
							primaryAction.click();
							evt.preventDefault();
							evt.stopPropagation();
							return false;
						}
					}
				}
			}
			return true;			
		},
		updateBody : function(content)
		{
			if (_.isString(content))
			{
				this.el.find(".modal-body").html(content);
			}
			else
			{
				this.el.find(".modal-body").empty().append(content);
			}
		},		
		updateTitle : function (title)
		{
			this.el.find(".modal-header h3").html(title);
		},
		updateButtons: function(buttons)
		{
			var buttons = this.buttonsTemplate({dialog: {buttons: buttons }}).replace(/^\s+|\s+$/g, '');
			this.el.find(".modal-footer").remove();
			$(buttons).insertAfter(this.el.find(".modal-body"));
		},
		show: function(dontShowLockScreen)
		{
			this.el.removeClass("modal-hide");
			if (!dontShowLockScreen)
			{
				this.view.showLockscreen(this.el, this);
			}
			
			this.trigger("view:show", true, this);
			
			$(document).on("keyup", this.onKeyPress)	
		},
		hide : function(dontHideLockScreent)
		{
			$(document).off("keyup", this.onKeyPress);			
			
	    	this.el.addClass("modal-hide");
			if (!dontHideLockScreent)
			{
				this.view.hideLockscreen(this.el, this);
			}
			
			this.trigger("view:show", false, this);
		},
		onButton : function (e)
		{
		  if (e.type === "click") e.preventDefault();

			var action = $(e.currentTarget).attr("data-action");
			if (!_.isEmpty(action))
			{
				this.triggerButtonAction(action);			
			}
		},
		triggerButtonAction: function(action)
		{
			var evt = {
				prevented : false,
				target : this,
				preventDefault : function()
				{
					this.prevented = true;
				}
			};
			this.trigger("button:"+action, evt);
			
			if (!evt.prevented)
			{
				this.hide();
			}
		},
		showLockscreen: showLockscreen,
		hideLockscreen: hideLockscreen,
		showLoading : function()
		{
			this.showLockscreen(this.loadingImg);
		},
		hideLoading: function()
		{
			this.hideLockscreen(this.loadingImg);
		},
		displayMessages :   function (messages)
		{
			var messageContainer = this.messageContainer;
			
			for (var i =0, len=messages.length; i < len; ++i)
			{
				var message = messages[i];
				messageContainer.addMessage(message);
			}
		
		},
		clearMessages: function()
		{
			this.messageContainer.remove();
		}
	}, Backbone.Events);
	
	var INPUT_DIALOG_TEMPLATE = _.template('\
	<div class="control-group"><label><%=field.label|| "" %></label>\
    <input type="text" placeholder="<%=field.placeholder || "" %>"  value="<%=field.value|| "" %>" />\
	</div>\
	<% if (field.help && field.help.length > 0) { %>\
	<div class="messages">\
		<span class="help-block message-default"><%=field.help|| "" %></span>\
   </div>\<%}%>\
	');
	
	function InputDialog(view, options)
	{
		if (!options.field)
		{
			throw new Error("Field must be specified!");
		}
		var template = options.inputDialogTemplate || INPUT_DIALOG_TEMPLATE;
		var body = (options.body || "") + template(options);
		options.body = body;
		this.validateAfter = options.field.validateAfter || [];
		
		Dialog.call(this, view,options);
		this.on("view:show", _.bind(this.onShow, this));
	}
	
	InputDialog.prototype = _.extend(_.clone(Dialog.prototype), {
		onShow : function(visible)
		{
			if (visible)
			{
				this.el.find("input").focus().select();
			}
			else
			{
				$(this.el[0].parentElement).find(".fs-level").focus();
			}
		},
		onButton: function(e)
		{
			e.preventDefault();
			this.el.find(".control-group").removeClass("error");
			
			
			var action = $(e.currentTarget).attr("data-action");
			if (this.validateAfter.indexOf(action) === -1)
			{
				Dialog.prototype.onButton.call(this, e);
			}
			else
			{
				var self = this;
				var validationEvent = {
					stringValue : this.el.find(".control-group input").val(),
					waitCount : 0,
					messages: [],
					wait: function()
					{
						this.waitCount += 1;
					},
					post: function()
					{
						this.waitCount -= 1;
						
						if (this.waitCount === 0)
						{
							self.hideLoading();
							if (this.messages.length > 0)
							{
								
								self.displayMessages(this.messages);
							}
							else
							{
								Dialog.prototype.onButton.call(self, e);
								
							}
							this.waitCount = null;
						}
						
					}
				};
				
				this.trigger("validate:"+action, validationEvent);
				if (validationEvent.waitCount > 0)
				{
					this.showLoading();
				}
				else if (validationEvent.messages.length > 0 && validationEvent.waitCount !== null)
				{
					self.displayMessages(validationEvent.messages);
				}
				else if (validationEvent.waitCount !== null)
				{
					Dialog.prototype.onButton.call(self, e);
				}
			}
		},		
		displayMessages: function (messages)
		{
			var elMessages = this.el.find(".control-group").addClass("error");
			elMessages.find(".message-validation").remove();
			
			var elInput = elMessages.find("input");
			for (var i =0, len=messages.length; i < len; ++i)
			{
				$("<span class='help-inline message-validation'>"+ _T(messages[i])+"</span>").insertAfter(elInput);
			}
		}
	});
	
	
		function showLockscreen(content)
		{
			this.el.addClass("fs-screen-locked");
			var lockScreen = this.lockScreen;
			lockScreen.empty();
			
			if (content)
			{
				lockScreen.append(content);
			}			
			
			
			
			lockScreen.removeClass("fs-lock-screen-none");
			
			var self = this;
			this.lockScreenAnimationTimer = setTimeout(function()
			{
				lockScreen.removeClass("fs-lock-screen-off");
				self.lockScreenAnimationTimer = null;
			}, 17);
			
			this.lockScreenVisible = true;
		}
		
		function hideLockscreen()
		{
			this.el.removeClass("fs-screen-locked");
			var lockScreen = this.lockScreen;
			var fallbackTimer = null;
			if (this.lockScreenAnimationTimer)
			{
				clearTimeout(this.lockScreenAnimationTimer);
				this.lockScreenAnimationTimer = null;				
				lockScreen.addClass("fs-lock-screen-none");
				//lockScreen.empty();
			}
			else
			{
				lockScreen.addClass("fs-lock-screen-off");		

				lockScreen.on("transitionend", end);
				var duration = this.duration*1000*1.2;
				fallbackTimer = setTimeout(end, duration);
			}
			
			function end()
			{
				lockScreen.addClass("fs-lock-screen-none").off("transitionend", end);//.empty();
				clearTimeout(fallbackTimer);
			}
			this.lockScreenVisible = false;
		}
	
	var CONTAINER_STATE_HIDDEN = 0;
	var CONTAINER_STATE_VISIBLE = 2;

	function MessageContainer(parentEl, cssClass)
	{
		this.parentEl = parentEl;
		this.el = $("<div class='"+(cssClass || "fs-messages")+"'></div>").hide().appendTo(parentEl);
		this.messageCounter = 0;
		
		this.state = CONTAINER_STATE_HIDDEN;
		
		this.messages = [];
	}
	
	MessageContainer.prototype = {
		destroy: function()
		{
			if (this.el)
			{
				this.el.remove();
				this.parentEl = null;
				this.el = null;
			}
		},
		addMessage : function(message)
		{
			++this.messageCounter;
			this.onMessageCounterChanged();
			
			var msg = new MessageView(this, message);
			var idx =this.messages.length;
			this.messages[idx] = msg;
			msg.idx = idx;
			msg.el.appendTo(this.el);
		},
		remove : function(messageView)
		{
			if (messageView)
			{
				messageView.el.remove();
				--this.messageCounter;
				this.onMessageCounterChanged();
				
				var idx = messageView.idx;
				var messages =this.messages;
				if (idx === (messages.length-1))
				{
					messages.pop();
				}
				else
				{
					var newMessages = [];
					for (var i = 0, len = messages.length; i < len; ++i)
					{
						if (idx !== i )
						{
							newMessages.push(messages[i]); 
						}
					}	
					
					for (var i = 0, len = newMessages.length; i < len; ++i)
					{
						newMessages[i].idx = i;
					}
					this.messages = newMessages;
				}
			}
			else
			{
				var messages =this.messages;
				for (var i = 0, len = messages.length; i < len; ++i)
				{
					messages[i].close();
				}	
				
				this.messages = [];
			}
		},
		onMessageCounterChanged : function()
		{
			switch(this.state)
			{
				case CONTAINER_STATE_HIDDEN:
					if (this.messageCounter > 0)
					{
						this.el.fadeIn("fast");
						this.state = CONTAINER_STATE_VISIBLE;
					}
				break;
				case CONTAINER_STATE_VISIBLE:
					if (this.messageCounter === 0)
					{
						this.el.fadeOut("fast");
						this.state = CONTAINER_STATE_HIDDEN;
					}
				break;			
			};
		}
	};
	
	function MessageView(container, message)
	{
		this.container = container;
		var type = message.type || "error";
		var text = _.isString(message) ? message : message.text;
		var closeButton = type === "error" ? '<button type="button" class="close" data-dismiss="alert">&times;</button>' : "";
		var el = this.el = $("<div class='alert alert-"+type+"'>"+closeButton+ _T(text, message.args)+"</div>");
		
		
		if (type !== "error" && !message.persistent)
		{
			setTimeout( _.bind(this.close, this), 2000);
		}
		else
		{
			el.find("button").on("click", _.bind(this.close, this));
		}
	}
	
	MessageView.prototype = {
		close : function()
		{
			var container = this.container;
			var self = this;
			this.el.fadeOut("fast", function(){ container.remove(self); });
		}
	};

}(
vitrium.fs,
_,
$,
Backbone,
vitrium.i18n,
document
));
// script:viewer/fs/fs-browser-actions-ui.js
(function (exports, Backbone, _, i18n)
{
	"use strict";
	var fs = exports;
	var _T = i18n._T;
	
	exports["CreateFolderActionView"] = CreateFolderActionView;
	exports["RenameActionView"] = RenameActionView;
	exports["DeleteActionView"] = DeleteActionView;
	exports["MoveActionView"] = MoveActionView;
	
	
	var RESERVED_CHARACTERS = [/*"<", ">", ":", "\"", "\\", */"/"/*, "|", "?","*"*/];
	var RESERVED_WORDS = [/*"CON", "PRN", "AUX", "NUL", 
													"COM1", "COM2", "COM3", "COM4", 
													"COM5", "COM6", "COM7", "COM8", 
													"COM9",	"LPT1", "LPT2", "LPT3", 
													"LPT4", "LPT5", "LPT6", "LPT7", 
													"LPT8", "LPT9"*/];
													
													
	
	function CreateFolderActionView(model, view, controller)
	{
		this.model = model;
		this.view = view;
		this.controller = controller;
					
		this.currentDialog = null;
		this.validationEvent = null;
		
		this.onAction = _.bind(this.__onAction, this);
		this.onValidate = _.bind(this.__onValidate, this);
		this.onNotImplemented = _.bind(this.__notImplemented, this);
		this.onFolderCreated = _.bind(this.__onFolderCreated, this);
		this.onFolderCreationFailed = _.bind(this.__onFolderCreationFailed, this);
		
		model.on("action:create-folder", this.onAction);
		model.on("action:doCreateFolder", this.onNotImplemented);
		
		model.on("action-success:doCreateFolder", this.onFolderCreated);
		model.on("action-error:doCreateFolder", this.onFolderCreationFailed);
		
	}

	
	CreateFolderActionView.prototype = {
		__onRefreshAll : function()
		{
			if (this.currentDialog) {
				this.currentDialog.hide();
				this.currentDialog = null;
				this.model.off("refreshAll", this.__onRefreshAll, this);
			}
		},
		__onAction : function()
		{
			this.model.on("refreshAll", this.__onRefreshAll, this);
			var dialog = this.currentDialog =  new fs.InputDialog(this.view, { 
						title : _T("fs-action-create-folder-title") ,
						field : {
							label : _T("fs-action-create-folder-label"),
						/*	help  : _T("fs-action-create-folder-help"),*/
							placeholder : _T("fs-action-create-folder-label"),
							
							validateAfter : ["create"]
						},
						buttons : [
							{ id : "close", title : _T("fs-cancel")},
							{ id : "create", title: _T("fs-action-create-folder-title") , cssClass :"btn-primary"}
						]
					});
			
			dialog.on("validate:create", this.onValidate);
			dialog.show();
		},
		__onValidate : function(evt)
		{
			var val = evt.stringValue;
						        
			if (!_.isEmpty(val))
			{		
				// trim 
				val  = val.replace(/^\s+|\s+$/g, '');
			}

			if (_.isEmpty(val))
			{
				evt.messages.push("fs-action-err-empty");
			}
			else if (isValidName(val))
			{	
				this.validationEvent  = evt;
				evt.wait();
				this.controller.execute("doCreateFolder", evt.stringValue);
			}
			else
			{
				evt.messages.push("fs-action-err-invalid");
			}
		},
		__onFolderCreated: function()
		{
			if (this.validationEvent)
			{
				this.validationEvent.post();
				this.validationEvent = null;
				this.model.off("refreshAll", this.__onRefreshAll, this);
			}
		},
		__onFolderCreationFailed: function(messages)
		{
		
			if (this.validationEvent)
			{
				if (!_.isArray(messages))
				{
					 messages = [messages];
				}
				
				this.validationEvent.messages.push.apply(this.validationEvent.messages, messages);
				
				this.validationEvent.post();
				this.validationEvent = null;
			}
		}, 
		__notImplemented: function()
		{
			var self = this;
			this.__onFolderCreationFailed("fs-action-create-folder-err-not-implemented");
	
		}
	};
	
	/**
		Rename
	*/
	
	
	function RenameActionView(model, view, controller)
	{
		this.model = model;
		this.view = view;
		this.controller = controller;
					
		this.currentDialog = null;
		this.validationEvent = null;
		
		this.onValidate = _.bind(this.__onValidate, this);
		
		model.on("action:item-rename", this.__onAction, this);
		
		model.on("action:doItemRename", this.__notImplemented, this);
		model.on("action-success:doItemRename", this.__onItemRenamed, this);
		model.on("action-error:doItemRename", this.__onItemRenameFailed, this);
		
		
		
		this.id = null;
	}

	
	RenameActionView.prototype = {
		__onRefreshAll : function(evt)
		{
			if (this.currentDialog) {
				if (!evt.preventDefault) 
				{
					this.currentDialog.hide();
				}
				this.currentDialog = null;
				this.model.off("refreshAll", this.__onRefreshAll, this);
			}
		},
		__onAction : function(controller, id, node)
		{
			var name = node.name(id);
			this.id = id;
			
			this.model.on("refreshAll", this.__onRefreshAll, this);
			
			var dialog = this.currentDialog =  new fs.InputDialog(this.view, { 
						title : _T("fs-action-item-rename-title") ,
						field : {
							label : _T("fs-action-item-rename-label", [name]),
							/*help  : _T("fs-action-item-rename-help"),*/
							placeholder : _T("fs-action-item-rename-label", [name]),
							validateAfter : ["rename"],
							value : name
						},
						buttons : [
							{ id : "close", title : _T("fs-cancel")},
							{ id : "rename", title: _T("fs-action-item-rename-title") , cssClass :"btn-primary"}
						]
					});
			
			dialog.on("validate:rename", this.onValidate);
			dialog.on("button:close", this.__onRefreshAll, this);
			dialog.show();
			
		},
		__onValidate : function(evt)
		{
			var val = evt.stringValue;
						        
			if (!_.isEmpty(val))
			{		
				// trim 
				val  = val.replace(/^\s+|\s+$/g, '');
			}

			if (_.isEmpty(val))
			{
				evt.messages.push("fs-action-err-empty");
			}
			else if (isValidName(val))
			{	
				this.validationEvent  = evt;
				evt.wait();
				this.controller.execute("doItemRename", { id : this.id, name : evt.stringValue});
			}
			else
			{
				evt.messages.push("fs-action-err-invalid");
			}
		},
		__onItemRenamed: function()
		{
			if (this.validationEvent)
			{
				this.validationEvent.post();
				this.validationEvent = null;
				this.model.off("refreshAll", this.__onRefreshAll, this);
			}
		},
		__onItemRenameFailed: function(messages)
		{
		
			if (this.validationEvent)
			{
				if (!_.isArray(messages))
				{
					 messages = [messages];
				}
				
				this.validationEvent.messages.push.apply(this.validationEvent.messages, messages);
				
				this.validationEvent.post();
				this.validationEvent = null;
			}
		}, 
		__notImplemented: function()
		{
			var self = this;
			this.__onItemRenameFailed("fs-action-item-rename-err-not-implemented");
	
		}
		
	};
	
	function isValidName(val)
	{
		var reservedCharacters = RESERVED_CHARACTERS;
		var reservedWords = RESERVED_WORDS;
		
		var failed = false;
		for (var i = 0, len = reservedWords.length; i < len && !failed; ++i)
		{
			failed = val ===  reservedWords[i];
		}
		
		for (var i = 0, len = reservedCharacters.length; i < len && !failed; ++i)
		{
			failed = val.indexOf(reservedCharacters[i]) !== -1;
		}
				
		return !failed;
	}
	
	/**
		Delete
	*/
	
	function DeleteActionView(model, view, controller)
	{
		this.model = model;
		this.view = view;
		this.controller = controller;
					
		this.currentDialog = null;
		this.validationEvent = null;
		

		this.onDelete = _.bind(this.__onDelete, this);
		
		model.on("action:item-delete", this.__onAction, this);
		
		model.on("action:doItemDelete", this.__notImplemented, this);
		model.on("action-success:doItemDelete", this.__onItemDeleted, this);
		model.on("action-error:doItemDelete", this.__onItemDeleteFailed, this);
		
		
		this.id = null;
		
	}

	
	DeleteActionView.prototype = {
		__onAction : function(controller, id, node)
		{
			this.model.on("refreshAll", this.__onItemDeleted, this);
			var name = node.name(id);
			this.id = id;
			
			var dialog = this.currentDialog =  new fs.Dialog(this.view, { 
						title : _T("fs-action-item-delete-title") ,
						body: _T("fs-action-item-delete-question", [name]),
						buttons : [
							{ id : "close", title : _T("fs-cancel")},
							{ id : "do-delete", title: _T("fs-action-item-delete-title") , cssClass :"btn-primary btn-danger"}
						]
					});
			
			dialog.on("button:do-delete", this.onDelete);
			dialog.on("button:close", this.__onItemDeleted, this);
			dialog.show();
			
		},
		__onDelete : function(evt)
		{	
			evt.preventDefault();
			
			this.currentDialog.showLoading();
			this.controller.execute("doItemDelete",  this.id);
			
		},
		__onItemDeleted: function()
		{
			if (this.currentDialog)  
			{
				this.currentDialog.hideLoading();
				this.currentDialog.hide();
				
				this.model.off("refreshAll", this.__onItemDeleted, this);
			}
			
			this.currentDialog = null;
		},
		__onItemDeleteFailed: function(messages)
		{
			if (this.currentDialog)
			{
				if (!_.isArray(messages))
				{
					 messages = [messages];
				}
				
				var html = "";
				for (var i =0, len = messages.length; i < len; ++i)
				{
					html += "<div class='alert alert-error'>"+ _T(messages[i])+"</div>";
				}
								
				this.currentDialog.updateBody(html);
				this.currentDialog.hideLoading();
			}
		}, 
		__notImplemented: function()
		{
			var self = this;
			this.__onItemDeleteFailed("fs-action-item-delete-err-not-implemented");
	
		}
		
	};
	
	function MoveActionView(model, view, controller, animationTime)
	{
		this.model = model;
		this.view = view;
		this.controller = controller;
		this.currentDialog = null;
		this.currentController = null;
		this.currentNode = null;
		
		this.animationTime = animationTime || 0.5;
		this.moveToNode = null;
		
		model.on("action:item-move", this.__onAction, this);
		model.on("action:doItemMove", this.__notImplemented, this);
		
		model.on("action-success:doItemMove", this.__onItemMoved, this);
		model.on("action-error:doItemMove", this.__onItemMoveFailed, this);
	
	}
	
	MoveActionView.prototype = {
		__onAction : function(refController, id, node)
		{
			this.model.on("refreshAll", this.__onItemMoved, this);
			var name = node.name(id);
			this.currentNode = node;
					
			this.id = id;
			var model = new fs.BrowserModel();
			model.on("node:popped", this.__onPopped, this);
			
			var controller = this.currentController = new fs.BrowserController(model);	
			
			var handlers = [
				new fs.ContainerRenderer("fs-top", [new fs.NameView(model, controller)]),
				new fs.ContainerRenderer("fs-cb", []), new fs.ListView(model, controller, {	"folder" : "icon-folder-open"	}, [], function filter(item){
					//dont display item type of folder with same id and files
					return (item.type === "folder" &&  item.id !== id);
				}, _.template("<tr data-item-id='<%=item.id%>'><td class='fs-node-type-<%=item.type%>' ><%=supported.actions||'' %><div class='name'><% if (item.type === 'folder') {%><a href='#' data-action='<%=item.action %>'><%}%><i class='<%=icon %>'></i>&nbsp;<%=item.name%><% if (item.type === 'folder') {%></a><%}%></div></td></tr>"))	];			
						
			var dialog = this.currentDialog =  new fs.Dialog(this.view, { 
						cssClass : "fs-file-dialog",
						title : _T("fs-action-item-move-dialog-title", [name]) ,
						body: "",
						buttons : [
							{ id : "close", title : _T("fs-cancel")},
							{ id : "move", title: "" , cssClass :"btn-primary"}
						]
					});
			
			var view = new fs.FSBrowserView(dialog.el.find(".modal-body"), model, {	"root" : handlers,	"folder": handlers}, this.animationTime);

			model.on("node:pushed", function(model, node)
			{
				node.on("invalidate", onInvalidate);				
				
			});
			model.on("node:popped", function(model, node)
			{
				node.off("invalidate", onInvalidate);
			});
			
			function onInvalidate(id)
			{
				controller.pop(id);				
			}
			
			var stack = this.model.get("stack");
			for (var i = 0, len = stack.length; i  < len; ++i)
			{
				if (i + 1 == len)
				{
						model.on("node:pushed", this.__onPushed, this);
				}
				controller.push(stack[i]);
			}
			
			dialog.on("button:move", _.bind(this.onMoveButton, this));
			dialog.on("button:close", _.bind(this.onCloseButton, this));
			
			dialog.show();
		},
		__onPushed : function(model,  node)
		{
			this.moveToNode = node;
			this.currentDialog.el.find(".btn-id-move").text(_T("fs-action-item-move-to", [node.get("name")]));
		},
		__onPopped: function(model,  node, current)
		{	
			this.moveToNode = current;
			if (this.currentDialog)
			{
				this.currentDialog.el.find(".btn-id-move").text(_T("fs-action-item-move-to", [current.get("name")]));
			}
		},
		onMoveButton : function(evt)
		{
			evt.preventDefault();
			
			this.currentDialog.showLoading();
			this.controller.execute("doItemMove", { id : this.id, destination: this.moveToNode.get("id") });
			
		},
		__onItemMoved: function()
		{
			if (this.currentDialog)
			{
				this.currentDialog.hide();
				this.onCloseButton();
			}
		
		},
		__onItemMoveFailed: function(messages)
		{
			if (this.currentDialog)
			{
				if (!_.isArray(messages))
				{
					 messages = [messages];
				}
				
				this.currentDialog.displayMessages(messages);
				this.currentDialog.hideLoading();
			}			
		}, 
		__notImplemented: function()
		{
			var self = this;
			this.__onItemMoveFailed("fs-action-item-move-err-not-implemented");
		},
		onCloseButton : function()
		{
			this.currentController = null;
			this.currentNode = null;
			this.currentDialog = null;
			
			this.model.off("refreshAll", this.__onItemMoved, this);
		},
		refresh : function()
		{	
			if (this.currentNode) this.currentNode.refresh();
			if (this.currentController) this.currentController.refreshAll();
		},
		onInvalidate : function()
		{
			if (this.currentDialog) {
				this.currentDialog.hide();
				this.currentNode.off("invalidate", this.onInvalidate, this);
			}
		}
	};
	
	
	
}(vitrium.fs,
Backbone,
_,
vitrium.i18n));
// script:viewer/fs/fs-browser-controller.js
(function (exports, Backbone, _)
{
	"use strict";
	var fs = exports;
	
	var BrowserModel = Backbone.Model.extend({
		defaults : {
			"mode" : "view"
		},
		initialize  :  function()
		{
			this.set("stack", []);
		}
	});
	
	exports["BrowserModel"] = BrowserModel;
	exports["BrowserController"] = BrowserController;
	exports["AsyncTask"] = AsyncTask;
	exports["AsyncTaskHandler"] = AsyncTaskHandler;
	
	function BrowserController(model)
	{
		this.model = model;
	}
	
	BrowserController.prototype = {
		push : function(node)
		{
			var model = this.model;
			var stack = model.get("stack");
			
			var topNode = top(stack);
			if (topNode != null)
			{
				topNode.trigger("node:lost-top", topNode, node);
			}
			stack.push(node);
			
			model.trigger("node:pushed", model, node, topNode);			
			node.trigger("node:pushed", model, node, topNode);
			node.trigger("node:is-top", model, node, topNode);
		},
		pop : function(id)
		{
			var model = this.model;
			var stack = model.get("stack");
			
			if (id)
			{
				var i;
				for ( i = stack.length; i--; )
				{
					var node = stack[i];
					if (node.get("id")  === id)
					{
						break;
					}
				}
				
				if (i !== -1)
				{
					var num = stack.length - i ;
					for (var j = 0; j < num;++j)
					{
						this.pop();
					}
				}
			}
			else if (stack.length > 1)
			{
				var topNode = stack.pop();
				var currentNode = top(stack);
				
				model.trigger("node:popped", model, topNode, currentNode);
				topNode.trigger("node:popped", model, topNode, currentNode);
				currentNode.trigger("node:is-top", model, currentNode, topNode);
			}
		},
		/**
			Message dispatcher
			order: 
				- method in node on top of stack level,
				- local method
				- trigger "action:"+ action event
		*/
		execute: function(action, arg)
		{
			var model = this.model;
			var t = top(model.get("stack"));
			
			var handler = t[action];
			if (handler)
			{
				handler.call(t, arg, this, t);
			}
			else if (!handler)
			{
				handler = this["action-"+action];
				if (handler)
				{
					handler.call(this, arg, t);
				}
				else
				{
					model.trigger("action:"+action, this, arg, t);
				}
			}
		},
		trigger: function ()
		{
			var args =[];
			args.push.apply(args, arguments);
			
			this.model.trigger(args[0], args.slice(1, args.length));
		},
		actionResultSuccess:  function ()
		{
			var args =[];
			args.push.apply(args, arguments);
			
			this.model.trigger("action-success:"+args[0], args.slice(1, args.length));
			this.model.trigger("action-success",args[0], args.slice(1, args.length));
		},
		actionResultError:  function ()
		{
			var args =[];
			args.push.apply(args, arguments);
			
			this.model.trigger("action-error:"+args[0], args.slice(1, args.length));
			this.model.trigger("action-error",args[0], args.slice(1, args.length));
		},
		refresh: function(id)
		{
			var stack = this.model.get("stack");
			for (var i = 0, len=stack.length; i < len; ++i)
			{	
				var node = stack[i];
				if (node.get("id") === id)
				{
					node.refresh();
					break;
				}
			}			
		},
		refreshAll : function()
		{
			var stack = this.model.get("stack");
			for (var i = stack.length; i--;)
			{	
				var node = stack[i];
				node.refresh();
			}
			
			this.model.trigger("refreshAll");
		}
	};
	
	function top(arr)
	{
		var idx = arr.length - 1;
		if (idx < 0)
		{
			return null;
		}
		else
		{
			return arr[idx];
		}
	}
	
	function AsyncTask(abort, model, name)
	{
		this._abort = abort;
		this.model = model;
		this.name = name;
	}
	
	AsyncTask.prototype = {
		start: function(arg)
		{
			this.model.trigger("async:start", this.name, arg, this);
		},
		end: function(arg)
		{
			this.model.trigger("async:end", this.name, arg);
		},
		error: function(arg)
		{
			this.model.trigger("async:error", this.name, arg);
		},
		abort: function(arg)
		{
			if (_.isFunction(this._abort)) {
				this._abort();
				this.model.trigger("async:abort", this.name, arg);
			}
			else if (this._abort && _.isFunction(this._abort.abort))  
			{
				this._abort.abort();
				this.model.trigger("async:abort", this.name, arg);
			}
		}
	};
	
	function AsyncTaskHandler(model, handlers, name)
	{
		this.model = model;
		
		if(!name) name = null;
		this.name = name;
		this.handlers = handlers || {};		
		
		this.reg();
	}
	
	AsyncTaskHandler.prototype  = {
		onStart : 	_createHandler("start"),
		onEnd: 		_createHandler("end"),
		onError: 	_createHandler("error"),
		onAbort: 	_createHandler("abort"),
		onCompleted: 	_createHandler("completed"),
		reg: function()
		{
			var m = this.model;
			var handlers = this.handlers;
			if (handlers.start) 
			{
				var s = this._start = _.bind(this.onStart, this);
				m.on("async:start", s);
			}
			
			if (handlers.end)
			{
				var e = this._end = _.bind(this.onEnd, this);
				m.on("async:end", e);
			}
			
			if (handlers.error)
			{
				var e = this._error = _.bind(this.onError, this);
				m.on("async:error", e);				
			}
			
			if (handlers.abort)
			{
				var a = this._abort = _.bind(this.onAbort, this);
				m.on("async:abort", a);			
			}
			
			if (handlers.completed)
			{
				var c = this._completed = _.bind(this.onCompleted, this);
				m.on("async:end", c);	
				m.on("async:error", c);
				m.on("async:abort", c);			
			}
		},
		destroy: function()
		{
			var m = this.model;
			var s = this._start,	e = this._end, f = this._error,
			a = this._abort, c = this._completed;
			
			if (s) 
			{
				m.off("async:start", s);
				this._start = null;
			}
			
			if (e)
			{
				m.off("async:end", e);
				this._end = null;
			}
			
			if (f)
			{
				m.off("async:error", f);				
				this._error = null;
			}
			
			if (a)
			{
				m.off("async:abort", a);			
				this._abort = null;
			}
				
			if (c)
			{
				m.off("async:end", c);	
				m.off("async:error", c);
				m.off("async:abort", c);			

				this._completed = null;
			}
		}
	};
	
	function	_createHandler(state)
	{
		return function(name, arg)
		{
			var h = this.handlers;
			var handler = h[state];
			var _name = this.name;
			if (handler)
			{
				if (_name !== null && _name === name)
				{
					handler.apply(h, arg);
				}
				else if (_name  === null)
				{
					handler.apply(h, arg);
				}
			}
		};
	}
	
		
}(
vitrium.fs,
Backbone,
_
));
// script:viewer/fs/fs-memory.js
(function (exports, Backbone, _)
{
	"use strict";
	var fs = exports;
	exports["FSServiceNode"] = FSServiceNode;	
	exports["SimpleFSService"] = SimpleFSService;	
	exports["InMemoryFSStorage"] = InMemoryFSStorage;	
	exports["FSNodes"] = FSNodes;
	
	var FSServiceNode = fs.FsNodeModel.extend({
		initialize : function(options)
		{
			var service = options.service ;
			if (!service)
			{
				throw new Error("Service must be declared!");
			}
			
			this._service = service;
			fs.FsNodeModel.prototype.initialize.call(this, options);
		},
		open : _createGlobalAsyncAction("open"),
		refresh: function()
		{
			this._service.refresh(this);
		},	
		doCreateFolder : function (arg, controller)
		{
			this._service.createFolder(this, arg, function(id) {
				controller.actionResultSuccess("doCreateFolder", id);
			},
			function(error)
			{
				controller.actionResultError("doCreateFolder", error);
			});
		},
		doItemRename: function(arg, controller)
		{
			this._service.rename(this, arg.id,arg.name, function(id)
			{
				controller.actionResultSuccess("doItemRename", id);
			},
			function(err)
			{
				controller.actionResultError("doItemRename", err);
			});
			
		},
		doItemDelete : function(id, controller)
		{
			this._service.deleteItem(this, id, function(id){
				controller.actionResultSuccess("doItemDelete", id);
			},
			function(err){
				controller.actionResultError("doItemDelete", err);				
			});
		},
		doItemMove: function(arg, controller)
		{
			var id = arg.id;
			var destId = arg.destination;
			
			this._service.moveItem(this, id, destId, function(id) {
				controller.refresh(destId);
				controller.actionResultSuccess("doItemMove", id, destId);
			},
			function(err)
			{
				controller.actionResultError("doItemMove", err);				
			});
		},
		name : function(id)
		{
			return this._service.name(id);
		}
		/*,
		doCreateFolder:  _createAsyncAction("createFolder"),
		doRenameFolder: _createAsyncAction("renameFolder"),
		doDeleteFolder: _createAsyncAction("deleteFolder")*/
	}); 
	
	function _createGlobalAsyncAction(name)
	{
		return function(arg, controller)
		{
			var task = new fs.AsyncTask(abort, controller, name);
			task.start();
			
			var self = this;
			var req = this._service[name](this, arg, controller, task);
			
			function abort()
			{
				if (req && req.abort) req.abort();
			}
			
			return task;
		};
	}
	
	
	function InMemoryFSStorage()
	{
		this.nodes = [];
	}
	InMemoryFSStorage.prototype = {
		load : function(success, error)
		{
			var nodes = _.clone(this.nodes);
			setTimeout(function()
			{
				success(nodes, null);
			}, 0);
		},
		save : function(nodes, success, error, tx)
		{
			var cnodes = _.clone(nodes);
			var self = this;
			
			setTimeout(function()
			{
				self.nodes = cnodes;
				success(null);
			}, 0);
		},
		deleteItems : function(toDelete, nodes, tx, success, error)
		{
			var  args = [nodes];
			args.push.apply(args, toDelete);
			
			var self = this;
			setTimeou(function()
			{
				self.nodes = _.without.apply(_, args);
			}, 0);
		}
	};
	
	function FSNodes(nodes)
	{
		this.nodes = nodes;
	}
	
	FSNodes.prototype = {
		find: function(id)
		{
			var nodes = this.nodes;
			for (var i = 0, len=nodes.length; i < len ; ++i)
			{
				var n = nodes[i];
				if (n.id === id)
				{
					return n;
				}
			}
			return null;			
		},
		containsFolder : function()
		{
			var folderFound = false;
			var nodes = this.nodes;
			for (var i = 0, len=nodes.length; i < len ; ++i)
			{
				var node = nodes[i];
				if(node.type === "folder")
				{
					folderFound = true;
				}
			}
			
			return folderFound;
		},
		hasFolderSiblings: function(id)
		{
			var nodes = this.nodes;
			for (var i = 0, len=nodes.length; i < len ; ++i)
			{
				var node = nodes[i];
				if(node.type === "folder" && node.id.split("/")[0] !== id)
				{
					return true;
				}
			}
			return false;
		},
		list : function(id)
		{
			var allowMoveFiles = this.containsFolder();

			var nodes = this.nodes;

			var idLen = id.length;
			var res = [];
			if (idLen === 0)
			{
				for (var i = 0, len=nodes.length; i < len ; ++i)
				{
					var n = nodes[i];
					var nId = n.id;
					if (nId.indexOf("/") === -1)
					{
						if (n.type === "folder")
						{
						
							res.push(this.createModelItem(n, this.hasFolderSiblings(nId)));
						}
						else
						{
							res.push(this.createModelItem(n, allowMoveFiles));
						}
					}
				}			
			}
			else
			{
				for (var i = 0, len=nodes.length; i < len ; ++i)
				{
					var n = nodes[i];
					var nId = n.id;
					if (nId.indexOf(id) === 0 && 
						nId.charAt(idLen) === "/" && 
						nId.lastIndexOf("/") === idLen)
					{
						res.push(this.createModelItem(n, allowMoveFiles));
					}
				}
			}
			res.sort(function(a, b) {
				var ta= a.type;
				var tb = b.type;
				if (ta === tb)
				{
					a = a.name;
					b = b.name;
					
					if (a < b)
					{
						return  -1;
					}
					else if (a > b)
					{
						return 1;
					}
					else
					{
						return 0;
					}
				}
				else
				{
					if (ta === "folder")
					{
						return -1;
					}
					else
					{
						return 1;
					}
				}
			});
			
			return res;				
		},
		createModelItem : function(n, allowMove)
		{
			var n = _.clone(n);
			var nId = n.id;
			n.name = this.name(nId);
			n.action = "open";
			n.editActions = ["item-delete", "item-rename"];
			
			if (allowMove)
			{
				n.editActions.push("item-move");
			}
			return n;
		},
		name : function (id)
		{
			var idx = id.lastIndexOf("/");
			if (idx !== -1)
			{
				return id.substring(idx+1, id.length);
			}
			else
			{
				return id;
			}
		},
		path: function(id)
		{
			var idx = id.lastIndexOf("/");
			if (idx !== -1)
			{
				return id.substring(0, idx);
			}
			else
			{
				return "";
			}
		},
		listChildren : function(id)
		{
			var nodes = this.nodes;
			var res = [];
			var parentElements = id.split("/");
			for (var i = 0, len=nodes.length; i < len ; ++i)
			{
				var n = nodes[i];
				var nId = n.id;
				if (this.path(nId) === id)
				{
					res.push(n);
				}
			}			
			
			return res;
		}
	};
	
	
	function SimpleFSService(storage, options)
	{
	
	//rootNodeType, rootNodeName, delay, fsNodesClass
		this.storage = storage;
		var type = options.rootNodeType || "root";
		var name = options.rootNodeName || "/";
		this.actions = [	{ "id" : "rename"}, 
									{"id" :"create-folder"},
									{"id" : "delete"}								
								];
		
		
		this.root = new FSServiceNode({
				"id" : "",
				"service" : this,
				"type" : type, 
				"name": name,
				"actions": this.actions
		});
				
		this.delay = _.isUndefined(options.delay)? 0 : options.delay;
		this.fsNodesClass = options.fsNodesClass || FSNodes;
	}
	
	SimpleFSService.prototype = {
		getRoot : function(callback, error)
		{
			var root =this.root;
			var fsNodesClass = this.fsNodesClass;
			this.storage.load(function(nodes)
			{
				var nodeCtx  = new fsNodesClass(nodes);
				root.set("list", nodeCtx.list(""));			
				callback(root);
			}, error);
		},
		refresh : function (current)
		{
			var fsNodesClass = this.fsNodesClass;
			this.storage.load(function(nodes)
			{
				var id = current.get("id");
				var nodeCtx  = new fsNodesClass(nodes);
				var type = current.get("type");

				var node = nodeCtx.find(id);
				if ((node !== null || type === "root") &&
					(type === "folder" || type === "root"))
				{
					current.set("list", nodeCtx.list(id));
				}
				
			
				if (node === null && type !== "root")
				{
					current.trigger("invalidate", id);
				}				
			});
		},
		open:  function (current, id,  controller, task)
		{
			var self = this;
			var fsNodesClass = this.fsNodesClass;
			var req = this.storage.load(function(nodes)
			{
				var nodeCtx  = new fsNodesClass(nodes);
				var n = nodeCtx.find(id);
				if (n !== null)
				{				
					var node =  new FSServiceNode({
							"id" : id,
							"service" : self,
							"type" : n.type, 
							"name": nodeCtx.name(id),
							"actions": self.actions,
							"list" : nodeCtx.list(id),
							"data": n
					});
					
					task.end(node);
					controller.push(node);			
				}
				else
				{
					task.error("fs-node-not-found");
				}
			},
			_.bind(task.error, task), id);
						
			return req;		
		},
		rename: function (current, id,name, success, error)
		{
			var self = this;
			var fsNodesClass = this.fsNodesClass;
			this.storage.load(function(nodes, tx)
			{
				var nodeCtx  = new fsNodesClass(nodes);
				var item = nodeCtx.find(id);
				var oldId = item.id;	
				var newId = item.id = oldId.substring(0, oldId.lastIndexOf("/")+1)+name;
				
				if (item.type === "folder")
				{
					var children =  nodeCtx.listChildren(id);
					for (var i = 0, len = children.length; i < len; ++i)
					{
						var node = children[i];
						var relativePath = node.id.substring(0,oldId.length);						
						
						node.id = 	newId +"/"+relativePath;
					}
				}				
				
				self.storage.save(nodes, function()
				{				
					var list = current.get("list");
				
					for (var i = 0, len = list.length; i < len;++i)
					{
						if (list[i].id === oldId)
						{
							var allowMove = (oldId.indexOf("/") ===-1 && nodeCtx.hasFolderSiblings(oldId))  || oldId.indexOf("/") !==-1;
							
							var uiItem = list[i] = nodeCtx.createModelItem(item, allowMove);
							current.set("list", nodeCtx.list(current.get("id")), { silent : true });
							current.trigger("change:list-item", current, uiItem, oldId);
							break;
						}
					}
					success(item.id);				
				}, error, tx);
			}, error, null, true);
		},
		deleteItem : function(current, id, success, error)
		{
			var self = this;
			var fsNodesClass = this.fsNodesClass;
			this.storage.load(function(nodes, tx)
			{
				var nodeCtx  = new fsNodesClass(nodes);
				var item = nodeCtx.find(id);
				if (item !== null)
				{
					var toDelete ;
					if (item.type === "folder")
					{
						toDelete = nodeCtx.listChildren(id);
						toDelete.push(item);
					}
					else
					{
						toDelete = [ item ];
					}
					
					self.storage.deleteItems(toDelete, nodes, tx, function(){
						current.set("list", nodeCtx.list(current.get("id")));//, { silent : true });
						/*current.trigger("remove:list-item", current, item, id);*/
						
						success(id);
					}, error);
				}	
				else
				{
					error("err-not-exists");
				}
			}, error,null, true);
					
		},		
		createFolder : function (current, name, success, error)
		{
			var self = this;
			var fsNodesClass = this.fsNodesClass;
			this.storage.load(function(nodes, tx)
			{
				var nodeCtx  = new fsNodesClass(nodes);
				var parentId = current.get("id");
				var newFolder;
				if (parentId !== "")
				{
					newFolder = parentId+ "/"+name;
				}
				else
				{
					newFolder =  name;
				}
				
				if (nodeCtx.find(newFolder) === null)
				{
					nodes.push({ id : newFolder, type : "folder"});
					current.set("list", nodeCtx.list(parentId));
					self.storage.save(nodes, function()
					{
						success(newFolder);
					}, error, tx);
				}
				else
				{
					error("err-folder-already-exists");
				}		
			}, error, null, true);	
		}, 
		moveItem : function(current, id, destinationId, success, error)
		{
			var self = this;
			var fsNodesClass = this.fsNodesClass;
			this.storage.load(function(nodes, tx)
			{
				var nodeCtx  = new fsNodesClass(nodes);
				
				var destinationNode;
				if (destinationId.length === 0)
				{
					destinationNode = { type : "folder", id : ""};
				}
				else
				{
					destinationNode = nodeCtx.find(destinationId);
				}
				 
				if (destinationNode.type === "folder")
				{
					var originalPath = nodeCtx.path(id);
					if (originalPath === destinationNode.id)
					{
						success(id, destinationNode.id, id);
					}
					else
					{
						var list = nodeCtx.list(destinationId);
						
						var counter = 0;
						var baseId;
						if (destinationId.length > 0)
						{
							baseId = destinationId + "/" + nodeCtx.name(id);
						}
						else
						{
							baseId = nodeCtx.name(id);
						}
						
						var newId;
						var conflict = false;
						do
						{	
							conflict = false;
							newId =  baseId;
							if (counter > 0)
							{
								newId += " ("+counter+")";
							}
							
							for (var i = 0, len = list.length; i < len; ++i)
							{
								var node = list[i];
								if (node.id === newId)
								{
									conflict = true;
									break;
								}
							}
							++counter;
						} while(conflict); 
						
						var node = nodeCtx.find(id);
						node.id = newId;
						
						if (node.type === "folder")
						{
							var children = nodeCtx.listChildren(id);
							for (var i = 0, len = children.length; i < len; ++i)
							{
								var child = children[i];
								child.id = newId + "/" + nodeCtx.name(child.id);								
							}
						}
						
											
						self.storage.save(nodes, function()
						{
							current.set("list", nodeCtx.list(current.get("id")));
							success(id, destinationNode.id, newId);
						}, error, tx);
					}					
				}
				else
				{
					error("err-node-must-be-folder");
				}	
			}, error, null, true);	
		},
		name  : FSNodes.prototype.name
	};
	

}(
vitrium.fs,
Backbone,
_
));
// script:viewer/ui/global-canvas-pool.js
(function (exports, globals)
{
  "use strict";
  exports.setContextImageSmoothing = setContextImageSmoothing;
  var GLOBAL_PIXEL_RATIO = (function ()
  {
    var canvas = document.createElement("canvas");
    var ctx = canvas.getContext("2d");

    var devicePixelRatio = window.devicePixelRatio || 1;
    var backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
          ctx.mozBackingStorePixelRatio ||
          ctx.msBackingStorePixelRatio ||
          ctx.oBackingStorePixelRatio ||
          ctx.backingStorePixelRatio || 1;

    if (globals.$.browser.firefox && window.navigator.appVersion.indexOf("Android") !== -1)
    {
      //HACK mobile firefox quality hack
      devicePixelRatio = 1.3333333;
    }

    return devicePixelRatio / backingStoreRatio;

  }());


  exports["CANVAS_POOL"] = {
    GLOBAL_PIXEL_RATIO: GLOBAL_PIXEL_RATIO,
    __isIE: globals.navigator.userAgent.indexOf("MSIE") !== -1 || globals.navigator.userAgent.indexOf("Trident") !== -1,
    __cache: [],
    __getCanvas: function ()
    {
      var result = null;
      if (true/*this.__isIE*/)
      {
        result = document.createElement("canvas");
      }
 /*      else
      {
        var cache = this.__cache;
        if (cache.length === 0)
        {
          result = document.createElement("canvas");
        }
        else
        {
          result = cache.pop();
        }
      }

     if (!result._getContext)
      {
        result._getContext = result.getContext;
        result.getContext = function (contextId, args)
        {
          if (contextId === "2d")
          {
            var ctx = this._getContext(contextId, args);
            if (!ctx._save)
            {
              ctx._save = ctx.save;
              ctx._restore = ctx.restore;
              ctx.save = save;
              ctx.restore = restore;
              ctx.clearStateStack = clearStateStack;
              ctx.clearStateStack();
            }

            return ctx;
          }
          else
          {
            return this._getContext(contextId, args);
          }
        }
      }*/
      return result;
    },
    freeCanvas: function (canvas)
    {
     /* if (!this.__isIE && this.__cache.length < 4)
      {
        // reset context
        //canvas.width = canvas.width;
        /* if (canvas.parentElement !== null)
         {
           canvas.parentElement.removeChild(canvas);
         }
        canvas.getContext("2d").clearStateStack();

        this.__cache.push(canvas);
      }
      else
  {
      */
        canvas.width = canvas.height = 0;
      /*}*/
    },
    getCanvas: function (width, height, pixelRatioLimitFunction)
    {
      var canvas = this.__getCanvas();
      this.setCanvasResolution(canvas, width, height, pixelRatioLimitFunction);

      return canvas;
    },
    setCanvasResolution: function (canvas, width, height, pixelRatioLimitFunction)
    {
      var ctx = canvas.getContext("2d");

      var scaleRatio = pixelRatioLimitFunction ? pixelRatioLimitFunction(GLOBAL_PIXEL_RATIO) : GLOBAL_PIXEL_RATIO;
      canvas.vitriumScaleRatio = scaleRatio;
      canvas.vitriumRequestedWidth = width;
      canvas.vitriumRequestedHeight = height;


      var newWidth = Math.round(width * scaleRatio);
      var newHeight = Math.round(height * scaleRatio);

      if (newWidth != canvas.width || canvas.height != newHeight)
      {
        // canvas must be  resized in order to prevent browser bitmap scaling :-)
        canvas.width = newWidth;
        canvas.height = newHeight;

      }



      /*ctx.clearStateStack();*/

      ctx.setTransform(scaleRatio, 0, 0, scaleRatio, 0, 0);
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, width, height);

      //	scale(scaleRatio, scaleRatio);

      return canvas;
    }
  };

  function save()
  {
    ++this.vitriumSaved;
    this._save();
  }

  function restore()
  {
    ++this.vitriumSaved;
    this._restore();
  }

  function clearStateStack()
  {
    var saved = this.vitriumSaved = this.vitriumSaved ? this.vitriumSaved : 0;
    for (var i = 0; i < saved ; ++i)
    {
      this.restore();
    }
    this.vitriumSaved = 0;
  }


  function setContextImageSmoothing(ctx, val)
  {
    //   if ($.browser.firefox) val = false;
    if ("mozImageSmoothingEnabled" in ctx)
    {
      ctx.mozImageSmoothingEnabled = val;
    }
    else if ("webkitImageSmoothingEnabled" in ctx)
    {
      ctx.webkitImageSmoothingEnabled = val;
    }
    else if ("imageSmoothingEnabled" in ctx)
    {
      ctx.imageSmoothingEnabled = val;
    }
    else if ("msImageSmoothingEnabled" in ctx)
    {
      ctx.msImageSmoothingEnabled = val;
    }
  };
}(
vitrium.ui,
__globals__
));
// script:viewer/form-ui.js
(function(exports, _, $, i18n)
{
	"use strict";
	
	var GLOBAL_FIELD_RENDERERS = {
		"text" : TextField,
		"textarea" : TextArea
	};
	
	exports.Form = Form;
	
	function Form(model, formDef)
	{
		this.formDef = formDef;
		
		var renderers = _.extend(_.extend({}, GLOBAL_FIELD_RENDERERS), formDef.renderers|| {});	
		var formatter = formDef.formatter || BOOTSTRAP_FORMATTER;
		
		var el = this.el = formatter.createBaseContainer(formDef);
		
		var fieldDefs = formDef.fields;
		var fields = this.fields = [];
		
		for (var i = 0, len = fieldDefs.length; i < len; ++i)
		{
			var fieldDef = fieldDefs[i];
			var field = new renderers[fieldDef.type](model, fieldDef, formDef);
		    
			var wrap = formatter.createFieldContainer(field, fieldDef, formDef);
			
			fields.push(wrap);
			wrap.el.appendTo(el);
		}		
	}
	
	Form.prototype = {
		sync : function()
		{
			var fields = this.fields;
			for (var i = 0, len=fields.length; i < len; ++i)
			{
				fields[i].sync();
			}
		},
		destroy: function()
		{
			var fields = this.fields;
			for (var i = 0, len=fields.length; i < len; ++i)
			{
				fields[i].destroy();
			}
		},
		displayMessages: function(messages)
		{
			var fields = this.fields;
			var res = false;
			for (var i = 0, len=fields.length; i < len; ++i)
			{
				var field = fields[i];
				var id = field.id;
				var message = messages[id];
				if (message)
				{
					field.displayMessage(message);
					res = true;
				}
			}

			return res;
		},
		removeMessages : function()
		{
			var fields = this.fields;
			for (var i = 0, len=fields.length; i < len; ++i)
			{
				var field = fields[i];
				field.removeMessage();
			}
		},
		focus : function(id)
		{
			var fields = this.fields;
			for (var i = 0, len=fields.length; i < len; ++i)
			{
				var field = fields[i];
				if (field.id === id)
				{
					field.focus();
				}
			}
		},
    disable : function(id, val)
		{
			var fields = this.fields;
			for (var i = 0, len=fields.length; i < len; ++i)
			{
				var field = fields[i];
				if (field.id === id)
				{
					field.disable(val);
				}
			}
		}
	};
		
	
	
	Form.registerFieldType = function(type, renderer) {
		GLOBAL_FIELD_RENDERERS[type] = renderer;
	};

	
	var BOOTSTRAP_FORMATTER = {
		createFieldContainer : function(field, fieldDef, formDef)
		{
			return new BootstrapFieldWrap(field, fieldDef, formDef);
		},
		createBaseContainer : function(formDef) {
			formDef.idPrefix = formDef.idPrefix || Math.round(Math.random()*1000000);
			return formDef.el || $("<div>");
		}
	};
	
	
	function BootstrapFieldWrap(field, fieldDef, formDef)
	{
		this.id = fieldDef.id;
		this.field = field;
		var el = this.el =  $('<div class="form-group control-group field-class-'+field.constructor.name+' field-id-'+fieldDef.id+'"><label class="control-label" for="'+formDef.idPrefix+fieldDef.id+'">'+fieldDef.label+'</label><div class="controls"></div></div>');
		
    if (!_.isEmpty(fieldDef.cssClass))
    {
      el.addClass(fieldDef.cssClass);
    }
    
    if (_.isArray(fieldDef.cssClasses))
    {
      _.each(fieldDef.cssClasses, function(clazz){ 
        el.addClass(fieldDef.clazz);
      });
    }
    
		field.el.appendTo(el.find(".controls"));
		this.lastMessageType = null;
	}
	
	BootstrapFieldWrap.prototype = {
		sync : function()
		{
			this.field.sync();
		},
		val : function(value) {
			return this.field.val(value);
		}, 
		destroy : function()
		{
			this.field.destroy();
		},
		focus : function()
		{
			this.field.focus();
		}, 
    disable: function(val)
    {
      this.field.disable(val);
    },
		displayMessage : function(msg)
		{
			var type = msg.type || "error";
			var el = this.el.find(".controls");
			if (this.lastMessageType)
			{
				this.el.removeClass(this.lastMessageType);
				this.lastMessageType = null;
			}
		
			this.el.addClass(type);
			this.lastMessageType = type;
		  
			var text = msg.text ? i18n._T(msg.text, msg.args) : msg;			
			
      
			var msgEl = el.find("span.message");
			if (msgEl.length === 0)
			{
			
				el.append('<span class="message">'+text+'</span>');
			}
			else
			{
				msgEl.html(text);
			}
		},
		removeMessage : function()
		{
			var el = this.el;
			
			if (this.lastMessageType)
			{
				el.removeClass(this.lastMessageType);
				this.lastMessageType = null;
			}
			
			el.find(".controls .message").remove();
		}
	};
	
	function TextField(model, fieldDef, formDef)
	{
		var el =  this.createElement(fieldDef, formDef);
    el.addClass("form-control");
		this.id = fieldDef.id;
		this.el = el;
		this.model = model;
		model.on("change:"+fieldDef.id, this.onModelChange, this);
		
		if (!formDef.manualSync)
		{
			this.__onSync =  _.bind(this.sync, this);
			el.on("keyup",this.__onSync).on("change", this.__onSync);
		}
		else
		{
			this.__onSync = null;
		}
		this.syncInProgress = false;
		this.val(model.get(fieldDef.id));
		
	}
	TextField.prototype = {
		createElement : function(fieldDef, formDef)
		{
			var placeholder = fieldDef.placeholder || "";
			var el = $('<input type="text" placeholder="'+placeholder+'" id="'+formDef.idPrefix+fieldDef.id+'"/>');
      if (fieldDef.maxlength)
      {
        el.attr("maxlength", fieldDef.maxlength);
      }
            
      return el;
		},
    disable: function(val)
    {
      this.el.prop("disabled", val);
    },
		sync : function()
		{	
			//this.syncInProgress = true;
			this.model.set(this.id, this.val());;
		//	this.syncInProgress = false;
		},
		val : function() {
			return this.el.val.apply(this.el, arguments);
		}, 
		onModelChange : function(model, value)
		{
			/*if (!this.syncInProgress)
			{*/
			if (this.val() !== value)
			{
				this.val(value);
			}
			//}
		},
		destroy : function()
		{
			if (this.__onSync)
			{
				this.el.off("keyup", this.__onSync).off("change", this.__onSync);
				this.__onSync = null;
			}
			
			this.model.off("change:"+this.id, this.onModelChange, this);
		},
		focus : function()
		{
			this.el.focus();
		}
	};
  
  TextField.prototype.constructor = TextField;
	
	function TextArea(model, fieldDef, formDef)
	{
		TextField.call(this, model, fieldDef, formDef);
	}
	_.extend(TextArea.prototype,TextField.prototype);
	_.extend(TextArea.prototype, {
		createElement :  function(fieldDef, formDef)
		{
			var rows = fieldDef.rows || 5;
			return $('<textarea id="'+formDef.idPrefix+fieldDef.id+'" rows="'+rows+'"></textarea>');
		}
	});
  
  TextArea.prototype.constructor = TextArea;
	
}(
vitrium.ui,
_, 
jQuery,vitrium.i18n));
// script:viewer/dismiss-box-ui.js
(function(exports, fs, global, $, _, Backbone, i18n){
   "use strict";
   
   exports.showDismissBox = showDismissBox;
   exports.showMenuScreen = showMenuScreen;
   exports.showProgressScreen = showProgressScreen;
   
   
   exports.MenuItemsModel = Backbone.Model.extend({
      defaults: {
         "title" : "",
         "choices" :[]
      }
   });
   exports.FSDialogViewAdapter = FSDialogViewAdapter;
   exports.$fadeIn = $fadeIn;
   exports.$fadeOut = $fadeOut;
   exports.DialogWindowTracker =  onDialogShowChanged;
   
   var btnTmpl = _.template("<button  type='button' class='btn <%=classes %>'  title='<%= title %>' ><%if (icon) { %> <i class='<%= icon %>'></i> <%}%> <%= label %> </button>");
   var d = $(global);
   
   var GLOBAL_VIEWER_DIALOG_LIST = {};
   
   var DIALOG_ID = 0;
   /**
      This function provides mechanism to close all opened windows when document is realoaded on background
   */
   function onDialogShowChanged(visible, dialog)
   {	
      var viewer = dialog.view.viewer;
      if (viewer)
      {
         //FIXME viewer cannot be used as argument in hash map
         var list = GLOBAL_VIEWER_DIALOG_LIST[viewer];
         if (!list)
         {
            list = GLOBAL_VIEWER_DIALOG_LIST[viewer] = {};
         }
         
         if (visible)
         {
            var dialogID = ++DIALOG_ID;
            dialog.DIALOG_ID = dialogID;
            list[dialogID] = dialog;
         }
         else
         {
            delete list[dialog.DIALOG_ID];
         }
         
         if (_.isEmpty(list) && !viewer["DIALOG_LIST_CALLBACK"])
         {
            viewer.off("document:detached", viewer["DIALOG_LIST_CALLBACK"]);
            viewer["DIALOG_LIST_CALLBACK"] = null;
         }
         else if (!viewer["DIALOG_LIST_CALLBACK"])
         {
            var callback = viewer["DIALOG_LIST_CALLBACK"] = function()
            {
               for (var dialogID in list)
               {
                  var dialog = list[dialogID];
                  dialog.triggerButtonAction("close");
                  dialog.hide();
               }
            };
            viewer.on("document:detached", callback);
         }
      }
   }
   
   function ensureClosedDialogs(viewer, view)
  {
    // the same view means that they are stacked
    if (viewer.currentOverlay && viewer.currentOverlay !== view)
    {
      viewer.currentOverlay.destroyAll();
    }
    viewer.currentOverlay = view;
  }
   
   
   function showDismissBox(viewer, type, title, message, options)
   {
      var view = (options ? options.view : null )|| new FSDialogViewAdapter(viewer);
    ensureClosedDialogs(viewer, view);
    
      var dialog = new fs.Dialog(view, {
         title : title,
         cssClass: "alert-"+type,
         body : message,
         buttons: (options  && options.buttons) ? options.buttons : [{ id : "close", title : i18n._T("menu-close") }]			
      });
   
      dialog.on("view:show", onDialogShowChanged);
      dialog.show();

      return dialog;		
   }

   
   function CenterPositioner(dialog, win)
   {
      this.win = win;
      this.dialog = dialog;
      this.handler = _.bind(this.centerPosition, this);
      
      win.on("resize", this.handler);
   }
   
   CenterPositioner.prototype = {
      centerPosition : function()
      {
         var w = this.win;
         var width = w.width();
         var height = w.height();
         var dw = this.dialog.width();
         var left, top;
         if (dw < width)
         {
            left = (width / 2) - dw / 2 ;
            
         }
         else
         {
            left = 0;
         }	
         top = (height / 2) - this.dialog.height() / 2 ;			
         this.dialog.css({
                        "left" : left +"px",
                        "top": top +"px"});
      },
      destroy : function()
      {
         this.win.off("resize", this.handler);
         this.handler = null;
         this.win = null;
         this.dialog = null;
      }
   };
   
   function GlobalCloseKeysManager(keys, close, next)
   {
      this.keys = keys || [27];
      this.close = close;
      this.next = next;
      this.handler = _.bind(this.handleKey, this);
      $(global.document).on("keydown", this.handler);
   }
   
   GlobalCloseKeysManager.prototype = {
      handleKey : function(e)
      {
         var k = e.which;
         if (this.keys.indexOf(k) !== -1)
         {
            e.preventDefault();
            e.stopPropagation();
            
            this.close();
      
            return false;
         }
         else
         {
            return  this.next ? this.next(e) : true;
         }
      },
      destroy : function()
      {
         $(global.document).off("keydown", this.handler);
         this.handler = null;
         this.close = null;
         this.next = null;
      }
   };
   
   
   var menuItemTmpl = _.template("<li></li>");

   function showMenuScreen(viewer, model, options)
   {
      var optView = options ? options.view : null;
      var view =  optView || new FSDialogViewAdapter(viewer);
    ensureClosedDialogs(viewer, view);
    
      var ul = $("<ul class='nav nav-tabs nav-stacked'></ul>");
      ul.on("tap click", "li", choiceClicked);
      
      var dialog = new fs.Dialog(view, {
         title : model.get("title"),
         body : ul,
         buttons: [
            { id : "close", title : i18n._T("menu-close") }
         ]			
      });
      
      model.on("change:choices", renderChoices);
      model.on("change:title", renderTitle);
         
      renderChoices(model, model.get("choices"));
         
      function renderChoices(model, choices)
      {	
         var nav = ul;
         nav.css({"display" : "none"});
         nav.empty();
         
         for (var i = 0, len=choices.length; i < len; ++i)
         {
            var choice = choices[i];
            if ((choice.toolHidden & 2) === 0)
               $("<li  choice-id='"+choice.id+"'><a src='#' choice-id='"+choice.id+"'>"+choice.title+"</a></li>").appendTo(nav);
         }
         
         nav.css({"display" : "block"});
      }
      
      function renderTitle(model, title)
      {
         dialog.updateTitle(title);
      }
      
      dialog.on("button:close", function()
      {
         viewer.setControlsLock(false);
         model.trigger("closed");
         
         model.off("change:choices", renderChoices);
         model.off("change:title", renderTitle);
      });
      
      
      function choiceClicked(e)
      {
         if (e.type === "click") e.preventDefault();
                  
         var choiceId = $(e.target).attr("choice-id");
         
         model.trigger("action:"+choiceId, dialog, e);
         model.trigger("clicked",choiceId, dialog, e);
      }
      
      dialog.on("view:show", onDialogShowChanged);
      dialog.show();
      
      return dialog;
   }
   
   function $fadeIn(el, callback)
   {
      var elStyle = el.style;
      if (setTransition(elStyle, "none"))
      {
         elStyle.opacity = 0;
         
         requestAnimationFrame(function()
         {
            setTransition(elStyle, "opacity 0.5s ease-out");
            elStyle.opacity = 1;

            if (callback)
            {
              setTimeout(function ()
              {
                requestAnimationFrame(function ()
                {
                  setTransition(elStyle, "none");
                  callback(el);
                });

              }, 600);
            }
         });
      }
      else if (callback)
      {
        requestAnimationFrame(function ()
         {
            callback(el);
         });
      }
   }
   
   function $fadeOut(el, callback)
   {
      var elStyle = el.style;
      
      if (setTransition(elStyle, "opacity 0.5s ease-out"))
      {
        requestAnimationFrame(function ()
         {	
            elStyle.opacity = 0;

            if (callback)
            {
              setTimeout(function ()
              {
                requestAnimationFrame(function ()
                {
                  callback(el);
                  setTransition(elStyle, "none");
                });
              }, 600);
            }
         });
      }
      else if (callback)
      {
        requestAnimationFrame(function ()
         {
            callback(el);
         });
      }
   }
   
   function setTransition(style, val)
   {
      var transitions = ["transition", "webkitTransition", "MozTransition", "msTransition"];
      for (var i = 0, len = transitions.length; i < len; ++i)
      {
         var transition = transitions[i];
         if (transition in style)
         {
            style[transition] = val;
            return true;
         }
      }
      return false;
   }
   
   function showProgressScreen(viewer, model, options)
   {
      
      var view =  (options ? options.view : null ) || new FSDialogViewAdapter(viewer);
      ensureClosedDialogs(viewer, view);
    
      var progressBar = $("<div class='progress progress-striped active'><div class='bar'style='width: 0%;'></div>");
      var dialog = new fs.Dialog(view, {
         cssClass : "progress-dialog",
         title : model.get("title"),
         body : progressBar,
         buttons: model.get("buttons")
      });
      
      model.on("change:title", renderTitle);
      model.on("change:progress", function(model, progress)
      {
         if (progress === "done")
         {
            progressBar.removeClass("active").remove();
         }
         else
         {
            progressBar.find(".bar").css({"width": progress +"%"});
         }
      });
      model.on("change:buttons", function (model, buttons){   dialog.updateButtons(buttons);	});
      
      function renderTitle(model, title)
      {
         dialog.updateTitle(title);
      }
      
      dialog.on("view:show", onDialogShowChanged);
      dialog.show();
      
      return dialog;
   }
   
   function FSDialogViewAdapter(viewer)
   {
      this.viewer = viewer;
      this.stack = [];
   }
   
   FSDialogViewAdapter.prototype = {
      showLockscreen: function(el, dialog)
      {
         var viewer = this.viewer;
         viewer.dialogParentEl.append(el);

         if (isHighPriority(el))
         {
            viewer.dialogParentEl.addClass("high-priority");
         }

         var stack = this.stack;
         if (stack.length === 0)
         {			
            viewer.setControlsLock(true);
         }
         else
         {
            stack[stack.length-1].dialog.hide(true);
         }
         stack.push({ el : el, dialog : dialog });
      },
      hideLockscreen: function(el, dialog)
      {
         var viewer = this.viewer;
         var stack = this.stack;
         var lastDialog = stack.pop();
         if(lastDialog)
         {
            lastDialog.el.remove();
         }
         
         if (stack.length === 0)
         {			
            viewer.dialogParentEl.removeClass("high-priority");
            this.viewer.setControlsLock(false);
         }
         else
         {
            var newDialogFrame = stack[stack.length - 1];
            newDialogFrame.dialog.show(true);

            if (isHighPriority(newDialogFrame.el))
            {
               viewer.dialogParentEl.addClass("high-priority");
            }
            else
            {
               viewer.dialogParentEl.removeClass("high-priority");
            }
         }
      },
      destroyAll : function()
      {
         var stack = this.stack;
         for (var i = stack.length; i--; )
         {
            stack[i].dialog.hide();
         }
      }
   };

   function isHighPriority(el)
   {
      return el.find(".modal.alert-error").length !== 0 || el.find(".modal.alert-info").length !== 0;
   }

})(
vitrium.viewer,
vitrium.fs,
__globals__, 
jQuery,
_,
Backbone,
vitrium.i18n);


// script:viewer/copy-fake-view.js
/// <reference path="~/build.html" />

(function (exports,viewerNM, utils, geometry, geometry2, ui, document, _, $)
{
  "use strict";

  exports.CopyFakeView = CopyFakeView;
  exports.selectText = selectText;
  
  var tileSize = 20;

  function CopyFakeView(viewer, selectionmodel, selectioncontroller)
  {
    this.viewer = viewer;

    this.viewer.on("mousemove", this.onMouseMove, this);
    this.model = selectionmodel;
    this.controller = selectioncontroller;
    var div = this.div = $("<div class='vitrium-fake-text-selection'></div>").css({ width: tileSize + "px", height: tileSize + "px", fontSize: (tileSize / 2) + "px" });
    div[0].addEventListener("mouseup", function ()
    {
      // HACK that forces chrome to work correctly with text selection 
      selectText(div[0]);
    });

    this.eventPipes = new utils.EventPipeGroup([
      new viewerNM.$EventPipe(div, "click keydown keyup keypress focus focusout", viewer),
      new viewerNM.$MouseWheelEventPipe(div, viewer),
      new viewerNM.$EventPipe(div, "mousedown", { trigger: _.bind(function (type, evt) { if (evt.which === 1) { this.viewer.trigger(type, evt, this.viewer.state);} }, this) })
    ]);
    
    

    this.content = this.div;
   /* div.on("mousedown", function (evt)
    {
      $(this).focus();
      selectText(this);
      evt.preventDefault();

      console.log("ctx");
    });
    */
    this.isInDOM = false;
    this.updateSelection = new ui.UISync(this.onUpdateSelection, this, 0);
    this.updatePosition = new ui.UISync(this.onUpdatePosition, this, 1);

   /* this.selectTask = new ui.DelayTask(_.bind(function ()
    {
      if (this.isInDOM)
      {
        selectText(this.div[0]);
      }
      
    }, this), 250, false);*/

    selectionmodel.on("changed", this.onSelectionChanged, this);
    
    this.rects = {};
    this.activeSelection = false;
    this.mousePosition = new geometry.Point(0, 0);

    
  }
  var TMP = new geometry2.Rectangle(0, 0, 0, 0, 0);
  CopyFakeView.prototype = {
    destroy : function()
    {
      this.div.remove();
      this.rects = null;
      this.updatePosition.destroy();
      this.updateSelection.destroy();
      this.updatePosition = null;
      this.updateSelection = null;
      this.model.off("changed", this.onSelectionChanged, this);
      this.viewer.off("mousemove", this.onMouseMove, this);
      this.viewer = null;
      

    },
    onViewportChanged : function(dirty, pages, scale)
    {
      
      var rects = this.rects;
      var tmp = TMP;
      var calculator = new ContinuousRectanglesCalculator();
      for(var i = 0, len=pages.length; i <len; ++i)
      {
        var page = pages[i];
        var rect = rects[page.number];
        if (rect)
        {
          var w = rect.w * scale | 0;
          var h = rect.h * scale | 0;
          var x = rect.x * scale | 0;
          var y = rect.y * scale | 0;


          if (x > page.width)
          {
            continue;
          }
          if (y > page.height)
          {
            continue;
          }
          var diffX = x + w - page.width;
          if (diffX > 0)
          {
            w -= diffX;
          }

          var diffY = y + h - page.height;
          if (diffY > 0)
          {
            h -= diffY;
          }

          x += page.x;
          y += page.y;
        
          tmp.x = x;
          tmp.y = y;
          tmp.w = w;
          tmp.h = h;
          
          calculator.add(tmp);
        }
      }

      if (calculator.rect !== null && this.model.get("mode") === 0)
      {
        tmp = calculator.rect;
        var offset = this.viewer.absoluteDim;
        tmp.x += offset.x;
        tmp.y += offset.y;
        
        var pos = this.mousePosition.clone();
        pos.x -= tileSize / 2 + 1;
        pos.y -= tileSize / 2+1;

        pos.x = Math.max(tmp.x, pos.x);
        pos.y = Math.max(tmp.y, pos.y);

        pos.x = Math.min(tmp.x + tmp.w, pos.x);
        pos.y = Math.min(tmp.y + tmp.h, pos.y);

        if (pos.x < offset.left || pos.y < offset.top)
        {
          this.div.remove();
          this.eventPipes.off();
          this.isInDOM = false;

        }
        else
        {
          this.div.css({
            left: (pos.x | 0) + "px",
            top: (pos.y | 0) + "px"
          });

          if (!this.isInDOM)
          {
            this.div.prependTo("body");
            this.isInDOM = true;
            this.eventPipes.on();
          }
          selectText(this.content[0]);
        }
      }
      else
      {
        this.div.remove();
        this.eventPipes.off();
        this.isInDOM = false;
      }

    },
    onUpdatePosition : function(context)
    {
      this.onViewportChanged(true, context.pages, context.scale);
    },
    onUpdateSelection : function(context)
    {
      if (this.activeSelection)
      {
        var sel = this.model.get("selection");

        var pages = _.uniq(sel.getAffectedPages());
        pages.sort();

        var buffer = [];
   
        for (var i = 0, len = pages.length; i < len; ++i)
        {
          var page = pages[i];

          var calculator = new ContinuousRectanglesCalculator();          
          var rects = sel.getSelection(page);

          for (var s = 0, slen = rects.length; s < slen; ++s)
          {
            var rect = rects[s];
            calculator.add(rect);

            buffer.push(rect.d);
          }
          buffer.push("\n");
          this.rects[page] = calculator.rect;
        }
        this.content.text(buffer.join(""));
      }
      else
      {
        this.rects = {};
      }
      
    },
    onSelectionChanged : function(affectedPages, active)
    {
      
      if (!this.activeSelection && active)
      {
        this.viewer.on("change:viewport", this.onViewportChanged, this);
      }
      else if (!active && this.activeSelection)
      {
        this.viewer.off("change:viewport", this.onViewportChanged, this);
      }

      this.activeSelection = active;
      this.viewer.uiLoop.runAsync(this.updateSelection);
      this.viewer.uiLoop.runAsync(this.updatePosition);
    },
    onMouseMove : function(evt)
    {
      var p = this.mousePosition;
      p.x = evt.pageX;
      p.y = evt.pageY;

      this.viewer.uiLoop.runAsync(this.updatePosition);
    }
    
  };

  function selectText(element)
  {
    var doc = document, text = element, range, selection;
    if (doc.body.createTextRange)
    { //ms
      range = doc.body.createTextRange();
      range.moveToElementText(text);
      range.select();
    } 
   else if (window.getSelection)
    { //all others
      selection = window.getSelection();
      range = doc.createRange();
      range.selectNodeContents(text);
      selection.removeAllRanges();
      selection.addRange(range);
   }   
  }



  function ContinuousRectanglesCalculator()
  {
    this.rect = null;
  }

  ContinuousRectanglesCalculator.prototype = {
    add: function (rect)
    {
      if (this.rect === null)
      {
        this.rect = rect.clone();
      }
      else
      {
        this.rect.x = Math.min(rect.x, this.rect.x);
        this.rect.y = Math.min(rect.y, this.rect.y);


        var sE = this.rect.getEndPoint();
        var rE = rect.getEndPoint();

        sE.x = Math.max(rE.x, sE.x);
        sE.y = Math.max(rE.y, sE.y);

        this.rect.w = sE.x - this.rect.x;
        this.rect.h = sE.y - this.rect.y;
      }
    }
  };

  

}(
vitrium.viewer,
vitrium.viewer,
vitrium.utils,
vitrium.geometry,
vitrium.geometry2,
vitrium.ui,
document,
_,
jQuery));
// script:viewer/watermarks-layer.js
/// <reference path="~/build.html" />

(function(exports, vitrium, Backbone, log, geometry, _)
{
   "use strict";
   exports.WatermarksLayer = WatermarksLayer;
   
   function WatermarksLayer(viewer, model, types)
   {
      this.viewer = viewer;
      this.model = model;
      
      this.watermarkTypeHandlers = _.extend({
         "fixedPositionTextbox": fixedPositionTextboxHandler,
         "userSpecific": handlePPDFUserspecificWatermark,
         "generic" : handleGenericWatermark
      }, types);
      
      
      model.on("watermarks:change", this.onChanged, this);		
   }
   
   WatermarksLayer.prototype = {
      onChanged : function(pages)
      {
        this.trigger("changed", pages);
      },
      hasContent : function(page)
      {
         var r = this.model.getWatermarksForPage(page);
         return r !== null && r.length > 0;
      },
      render : function(page, ctx, time)
      {			
         var waterMarks = this.model.getWatermarksForPage(page);
         //FIXME it  breaks encapsulation
         var pageInfo = this.viewer.documentInfo.pages[page];
         
         ctx.save();
         var hs = this.watermarkTypeHandlers;
         for (var i = 0, len=waterMarks.length; i < len; ++i)
         {
            var w = waterMarks[i];
            var handler = hs[w.type];
            if (handler)
            {
               handler(ctx, w, pageInfo);
            }
            else
            {
               vitrium.log.warn("handler for watermark not found: "+w.type);
            }			
         }
         
         ctx.restore();
      }
   };
   
   _.extend(WatermarksLayer.prototype, Backbone.Events);

   function fixedPositionTextboxHandler(ctx, options, pageInfo)
   {
      ctx.save();
      var text = options.text;
      if (_.isEmpty(text))
      {
         //text is mandatory
         return;
      }
      
        
      var font = pickFallbackFont(options.fontFamily);
      var style = options.fontStyle;
      var weight = options.fontWeight;
      
      var begX = options.offsetXPosition; 
      var begY = options.offsetYPosition;
    
       var w = options.width;
      var h = options.height;
      
      var padding  = options.padding;
      if (!padding) padding = 0;

      var x = options.offsetX;
      var y = options.offsetY;
      
      var dimensionsDir = options.__dimensions;
      if (!dimensionsDir)
      {
         dimensionsDir = options.__dimensions = {};
      }
      
      var rotation = -1*options.rotation;
      var cleanRotation =( rotation )% 360;
      if (cleanRotation < 0)
      {
         cleanRotation += 360;
      }

       
      
      var id = pageInfo.width+":"+pageInfo.height+":"+cleanRotation+":"+text;
      var dimensions  = dimensionsDir[id];
      

      if (!dimensions )
      {
          var lines = text.split("_newLine_")
          dimensionsDir[id] = dimensions = fitToWidth(ctx, h, w, font, style, weight, lines, cleanRotation, 10);
      }
      
      
      if ((begX === "right" && x >= 0) || (begX === "left" && x< 0))
      {
            x =  pageInfo.width - Math.abs(x) - w;
      }
      else if ((begX === "right" && x < 0))
      {
         x = (-1)*x;
      }
      
      
      if ((begY === "bottom" && y >= 0) || (begY === "top" && y < 0))
      {
         y =  pageInfo.height - Math.abs(y)- h;			
      }
      else if(begY === "bottom" && y < 0)
      {
         y = (-1)*y;
      }
   
      
      //Limits according test case 5
      x = Math.min(pageInfo.width-w, x);
      y = Math.min(pageInfo.height-h, y);
      
      /*ctx.beginPath();
      ctx.strokeStyle = "black";
      ctx.rect(x, y , w, h);
      ctx.stroke();*/
   
      var halign = options.horizontalAlignment;
      if (cleanRotation === 90  || cleanRotation === 270)
      {
         halign = "center";
      }
      else if (cleanRotation === 180)
      {
         y -= dimensions.height;
         if (halign == "left")
         {
            halign = "right";
         }
         else if (halign == "right")
         {
            halign = "left";
         }
         
      }
      
      
      

      
   //	console.log(options.horizontalAlignment, x);
      
      if (cleanRotation === 90  || cleanRotation === 270)
      {
            y += dimensions.width / 2 - (dimensions.height / 2);
            if (cleanRotation === 270)
            {
               x += dimensions.height;
            }
      }	
      else if (cleanRotation === 180)
      {
         y += (h-20)/ 2;
      }
      else
      {
         y += 5 + dimensions.height - ((h-20)/ 2) + (dimensions.height / 2);
      }
      
      // vertical center 5 = half of top padding, 20 = top and bottom padding
      
      
      
      
      ctx.globalAlpha = options.opacity;
      //ctx.textBaseline = 'al';
      ctx.fillStyle = vitrium.viewer.convertColor(options.foregroundColor);
      ctx.font = style + " " + weight + " " +dimensions.lineHeight+"px  "+font;
      
      if (cleanRotation)
      {
          var cX = alignHorizontal(halign, x, w, dimensions.width) + dimensions.width / 2;
         var cY = y + dimensions.height / 2;
         
         ctx.translate(cX, cY);
         ctx.rotate(Math.PI / (180 / cleanRotation));
         ctx.translate(-cX, -cY);
      }

      for (var i = 0, len = dimensions.lines.length; i < len; ++i)
      {
          var tX = alignHorizontal(halign, x, w, dimensions.lineWidths[i]);
          ctx.fillText(dimensions.lines[i], tX, y);
          y += dimensions.lineHeight;
          
      }

   

      
      ctx.restore();
   }

   function alignHorizontal(aligment, x, w, lineWidth)
   {
       switch (aligment)
       {
           case "left":
               x += 10;
               break;
           case "right":
               x += w - lineWidth- 10;
               break;
           case "center":
               x += (w / 2) - (lineWidth / 2);
               break;
           default: break;
       };

       return x;
   }
   
   function fitToWidth(ctx, height, width, font, style, weight, lines, rotation, padding)
   {
      if (rotation === 90  || rotation === 270)
      {
         var owidth = width;
         width = height;
         height = owidth;
      }
      else
      {
         width -= 2*padding;
         height -= 2*padding;
      }
      
      var fheight = height / lines.length;
      var twidth;
      var lineWidths = [];
      do
      {
          ctx.font = style + " " + weight + " " + fheight + "px " + font;
          var maxWidth = 0;
          for (var i = 0; i < lines.length; ++i)
          {
              var line = lines[i];
              var lineWidth = lineWidths[i] = ctx.measureText(line).width;
              maxWidth = Math.max(maxWidth, lineWidth);
          }

          twidth = maxWidth;
      
         if (twidth <= width)
         {
            break;
         }
         else
         {				
            fheight *= width / twidth;
         }
      } 
      while(fheight > 0); 
      
      return {
          height: fheight * lines.length,
            lineHeight: fheight,
         width: twidth,
         lines: lines,
            lineWidths: lineWidths
      };
   };
   

   /**
      http://www.w3schools.com/cssref/css_websafe_fonts.asp
   */
   var FALLBACK_FONTS = [
      ["Georgia", "serif"],
      ["Palatino Linotype", "Book Antiqua", "Palatino", "serif"],
      ["Times New Roman", "Times", "serif"],
      ["Arial", "Helvetica", "sans-serif"],
      ["Arial Black", "Gadget", "sans-serif"],
      ["Comic Sans MS", "cursive", "sans-serif"],
      ["Impact", "Charcoal", "sans-serif"],
      ["Lucida Sans Unicode", "Lucida Grande", "sans-serif"],
      ["Tahoma", "Geneva", "sans-serif"],
      ["Trebuchet MS", "Helvetica", "sans-serif"],
      ["Verdana", "Geneva", "sans-serif"],
      ["Courier New", "Courier", "monospace"],
      ["Lucida Console", "Monaco", "monospace"]
   ];

   function pickFallbackFont(name)
   {
      if (!name)
      {
         return "'sans-serif'";
      }
      
      var FB = FALLBACK_FONTS;
      var i, len, gi;
      for (i = 0, len=FB.length; i < len; ++i)
      {
         var group = FB[i];
         if ((gi = group.indexOf(name)) !== -1)
         {
            break;
         }
      }
      
      if (gi === -1)
      {
         return "'"+name+"','sans-serif'";
      }
      else
      {
         var result  = [];
         var group = FB[i];
         result.push("'"+name+"'");
         for(i = 0, len = group.length; i < len; ++i)
         {
            if (i !== gi)
            {
               result.push("'"+group[i]+"'");
            }
         }

         return result.join(",");
      }
   }

   

   /*
      user specific watermark
   */

   var makeCanvasFontString = (function () {
      var SUPPORTED_FONTS = {
         courier: "Courier, monospace", 
         helvetica : "Helvetica, sans-serif", 
         symbol : "symbol", 
         times: "Times, serif",
         // this font is not supported at the moment
         zapfdingbats : null
     };

      var FONT_EFFECTS = {
         bold: "bold",
         oblique: "oblique",
         italic: "italic",
         bolditalic: "italic bold",
         boldoblique: "oblique bold",
         roman: ""
      };
    
      return function (fontName, size) {
         var fontParts = fontName.split("-");
         var fontFamilyName = SUPPORTED_FONTS[fontParts[0].toLowerCase()];
         if (!fontFamilyName) {
            log.debug("[Watermarks] unsupported font used (" + fontParts[0] + ") falling back to monospace.");
            fontFamilyName = "monospace";
         }

         var fontString = size + "px " + fontFamilyName;

         if (fontParts.length === 2) {
            var effect = FONT_EFFECTS[fontParts[1].toLowerCase()];
            if (!effect)
            {
               log.debug("[Watermarks] unsupported effect used ("+fontParts[1]+")")
            }
            fontString = effect + " " + fontString;
         }

         return fontString;
      };
   }());


   function PageRanges(rangeString)
   {
      var parts = rangeString.replace(/ /g, "").split(",");
      
      var ranges = [];
      for (var i = 0, len=parts.length; i < len; ++i)
      {
         var part = parts[i].split("-");
         if (part.length === 1)
         {
            if (_.isEmpty(part[0])) continue;

            var value = parseInt(part[0], 10);
            ranges.push({ from: value, to: value });
         }
         else if (part.length === 2)
         {
            if (_.isEmpty(part[0])) continue;
            if (_.isEmpty(part[1])) continue;

            ranges.push({ from : parseInt(part[0], 10), to : parseInt(part[1], 10)})
         }
      }

      ranges.sort(function (a, b) {
         if (a.from < b.from)
         {
            return -1;
         }
         else if (a.from > b.from)
         {
            return 1;
         }
         else
         {
            return 0;
         }
      });

      this._ranges = ranges;
   }

   PageRanges.prototype.isPageInRange = function(page)
   {
      var ranges = this._ranges;
      for(var i = 0, len=ranges.length; i < len; ++i)
      {
         var range = ranges[i];
         if (page < range.from) break;
         if (page >= range.from && page <= range.to) return true;
      }

      return false;
   }

   function canSkipRendering(options, pageInfo)
   {
      if ("VisibleOnScreen" in options && !options.VisibleOnScreen) return true;

      var skipPageRanges = options.__skipPagesRanges;
      if (!skipPageRanges)
         skipPageRanges = options.__skipPagesRanges = new PageRanges(options.SkipPages || "");

      if (skipPageRanges.isPageInRange(pageInfo.number)) {
         //skip
         return true;
      }
      
      return false;
   }

   var handlePPDFUserspecificWatermark = (function () {
      function sign(num)
      {
         if (num < 0) return -1;
         if (num === 0) return 0;
         if (num > 0) return 1;
      }

      function get96DPIRectangle(options, pageInfo)
      {
         var wWidth = DPI_72_TO_96(options.Width);
         var wHeight = DPI_72_TO_96(options.Height);
         var wX = DPI_72_TO_96(options.PositionX);
         var wY = DPI_72_TO_96(options.PositionY)*(-1);

         var pageWidth = pageInfo.width;
         var pageHeight = pageInfo.height;

         var w = wWidth <= 1
                 ? pageWidth * wWidth
         : (wWidth > pageWidth) ? pageWidth : wWidth;

         var h = wHeight <= 1
             ? pageHeight *wHeight
         : (wHeight > pageHeight) ? pageHeight : wHeight;

         var x = Math.abs(wX) + w > pageWidth
            ? (pageWidth - w) * sign(wX)
            : wX;
         x = x >= 0
            ? (x <= 1 ? pageWidth * x : x)
            : pageWidth + /* term below is negative */
              (x >= -1 ? pageWidth * x : x) - w;

         var y = Math.abs(wY) + h > pageHeight
            ? (pageHeight - h) * sign(wY)
            : wY;
         y = y >= 0
            ? (y <= 1 ? pageHeight * y : y)
            : pageHeight + /* term below is negative */
              (y >= -1 ? pageHeight * y : y) - h;

         return new geometry.Rectangle(x, y, w, h, 0);
      }

    


      return function (ctx, options, pageInfo) {
         /// <param name="ctx" type="CanvasRenderingContext2D" />
       
         if (canSkipRendering(options, pageInfo))
         {
            return;
         }

         ctx.save();
                

         var boxRectangle = options.__boxRectangle;
         if (!boxRectangle) 
            boxRectangle = options.__boxRectangle = get96DPIRectangle(options, pageInfo);
         
         ctx.translate(boxRectangle.x, boxRectangle.y);
         ctx.beginPath();
         ctx.rect(0, 0, boxRectangle.w, boxRectangle.h);
         

         //
         
         ctx.clip();
         
         var fontSize = PT_TO_PX(options.FontSize || 12);
         ctx.font = makeCanvasFontString(options.FontName, fontSize);
         ctx.fillStyle = cssColor(options.Color);
         ctx.textBaseline = "top";
         
         
         var lines = options.TextualContent.split(/_newLine_|\n/g);
         var y = 0;
         var halfBoxW = boxRectangle.w / 2;
         var halfBoxH = boxRectangle.h / 2;
         var rotation = _.isUndefined(options.Rotation)?0:options.Rotation;

        // ctx.fillStyle = "red";
        // ctx.fillRect(0, 0, 100, 100);

         if (rotation != 0)
         {
            ctx.translate(halfBoxW, halfBoxH);
            ctx.rotate(Math.PI * (-rotation)/180);
            ctx.translate(0, -fontSize);
         }
        
        
        
     //    ctx.fillStyle = "blue";
       //  ctx.fillRect(0, 0, 100, 100);
         
         for (var i = 0, len = lines.length; i < len; ++i)
         {
            var line = lines[i];
            var halfWidth = ctx.measureText(line).width/2;
            var x = halfBoxW - halfWidth;
            ctx.fillText(line, x, y);
            y += fontSize;
         }
         ctx.restore();

      };
   }());


   var handleGenericWatermark = (function () {

      function clearRotation(rotation)
      {
         if (rotation < 0)
            return 360 + rotation % 360;

         return rotation % 360;
      }

      function align(p, a, capacity, align)
      {
         if (align === 0) return p;
         if (align === 1) return p + (capacity/2) - (a/2);
         return p + capacity - a;		
      }

      function calculateLargestProportionalRect(angle, origWidth, origHeight)
      {
         var w0, h0;
         if (origWidth <= origHeight) {
            w0 = origWidth;
            h0 = origHeight;
         }
         else {
            w0 = origHeight;
            h0 = origWidth;
         }
         // Angle normalization in range [-PI..PI)
         var ang = angle - Math.floor((angle + Math.PI) / (2 * Math.PI)) * 2 * Math.PI;
         ang = Math.abs(ang);
         if (ang > Math.PI / 2)
            ang = Math.PI - ang;
         var c = w0 / (h0 * Math.sin(ang) + w0 * Math.cos(ang));
         var w, h;
         if (origWidth <= origHeight) {
            w = w0 * c;
            h = h0 * c;
         }
         else {
            w = h0 * c;
            h = w0 * c;
         }
         return {
            w: w,
            h: h
         }
      }

     
      return function (ctx, options, pageInfo) {
         /// <param name="ctx" type="CanvasRenderingContext2D" />
         if (canSkipRendering(options, pageInfo))
         {
            return;
         }

         ctx.save();
         ctx.globalAlpha = options.Opacity || 1.0; 
         ctx.fillStyle = cssColor(options.Color);
         ctx.strokeStyle = "red";

         var hasFontSize = !!options.FontSize;
         
         var degRotation = _.isUndefined(options.Rotation) ? 0 : clearRotation(options.Rotation)*-1;
         var rotation = Math.PI * degRotation / 180;
         var propRect = calculateLargestProportionalRect(rotation, pageInfo.width, pageInfo.height);
         var fontSize = hasFontSize ? PT_TO_PX(options.FontSize) : propRect.h;

       
         ctx.translate(pageInfo.width / 2, pageInfo.height / 2);
         ctx.rotate(rotation)
         ctx.translate(-propRect.w / 2, -propRect.h / 2);
         
         fitTextIntoRectangle(ctx, options.TextualContent, propRect.w, propRect.h, 1, 1);
         /*
         ctx.beginPath();
         ctx.rect(0,0, propRect.w, propRect.h);
         ctx.stroke();
         */
         ctx.restore();

         function fitTextIntoRectangle(ctx, text, w, h, valign, halign)
         {
            ctx.textBaseline = "top";

            var fontHeight = fontSize;
            ctx.font = makeCanvasFontString(options.FontName, fontSize);
            //	ctx.scale(20, 20);
            var width = ctx.measureText(text).width;
            //ctx.scale(1/20, 1/20);

            if (!hasFontSize && width > w)
            {
               fontHeight = (h * ((w - 1) / width));
               ctx.font = makeCanvasFontString(options.FontName, fontHeight);
               width = w - 1;
            }

            ctx.fillText(text, align(0, width, w, halign), align(0, fontHeight, h, valign));
         }
      };
   }());


   var DPI_CONST = 96 / 72;
   function DPI_72_TO_96(a72) {
      return a72 * DPI_CONST;
   }

   function PT_TO_PX(size)
   {
      return size * DPI_CONST;
   }
   
   function cssColor(color) {
      if (color && color.indexOf(",") !== -1) {
         return "rgb(" + color + ")";
      }

      if (!color)
      {
         return "gray";
      }
      else
      {
         return color.replace(/ /g, "").toLowerCase();
      }
   }
}(
vitrium.viewer, 
vitrium,
Backbone,
vitrium.log,
vitrium.geometry2,
_
));
// script:viewer/watermarks-model.js
(function(exports, vitrium,_, Backbone)
{
	"use strict";
	exports.WatermarksModel = WatermarksModel;
	
	function WatermarksModel(viewer)
	{
		this.watermarks = [];
		if (viewer)
		{
			viewer.on("document:attached", this.onDocumentAttached, this);
			viewer.on("document:detached", this.onDocumentDetached, this);
		}
	}
	
	var WM = WatermarksModel.prototype;
	_.extend(WM, Backbone.Events);

	WM.onDocumentAttached = function(document)
	{
		document.on("info:loaded", this.onInfoLoaded, this);
	};
	
	WM.getWatermarks = function()
	{
		return _.clone(this.watermarks);
	};
	
	WM.onDocumentDetached = function(document)
	{
		document.off("info:loaded", this.onInfoLoaded, this);
	};
	
	WM.onInfoLoaded = function(info)
	{
		this.setWatermarks(info.watermarks || this.watermarks);
	};
	
	WM.isWatermarkOnPage = function(page)
	{
		// for initial release we support range : "all"
		return this.watermarks.length > 0;
	};
	
	WM.getWatermarksForPage = function(page)
	{
		return this.watermarks;
	};
	
	WM.addWatermarks = function(watermarks)
	{
		if (_.isArray(watermarks))
		{
			this.watermarks.push.apply(this.watermarks, watermarks);
		}
		else
		{
			this.watermarks.push(watermarks);
		}
		
		this.trigger("watermarks:change");
	};
	
	WM.clearWatermarks = function()
	{
		this.setWatermarks([]);
	};
	
	WM.setWatermarks = function(neww)
	{
		if (_.isEmpty(neww))
    {
      neww = [];
    }
    
		if (! _.isArray(neww))
		{
			neww = [neww];
		}
		
		this.watermarks = neww;
		this.trigger("watermarks:change");
	};
	

}(
vitrium.viewer, 
vitrium, 
_, 
Backbone));
// script:viewer/annotations-model.js
/// <reference path="~/build.html" />

(function (exports, geometry, geometry2, _)
{
  "use strict";
  
  exports.AnnotationsModel = AnnotationsModel;
  exports.FreeHighlightAnnotation = FreeHighlightAnnotation;
  exports.TextHighlightAnnotation = TextHighlightAnnotation;
  exports.NoteAnnotation = NoteAnnotation;

  function AnnotationsModel()
  {
    this._pages = {};    
  }

  AnnotationsModel.prototype =
  {
    clone : function()
    {
      var m = new AnnotationsModel();
      _.each(this._pages, function (annotations, pageNubmer)
      {
        this._pages[pageNubmer] = _.clone(annotations);
      }, m);
      return m;
    },
    deepClone : function()
    {
       var m = new AnnotationsModel();
       m.parseFromJSON(this.toFlatRepr());

       return m;
    },
    parseFromJSON : function(annotationsPOD)
    {
       _.each(annotationsPOD, function (annotationPOD)
      {
         var annotation = createAnnotationFromPOD(annotationPOD);       
         this.add(annotation.page, annotation);
      }, this);
    },
    toFlatRepr : function()
    {
      var result = [];
      _.each(this._pages, function (page)
      {
        for (var i = 0, len=page.length; i < len;++i)
        {
          this.push(page[i]);
        }
      }, result);

      return result;
    },
    add : function(page, annotation)
    {
      var annotations = this._pages[page];
      if (_.isEmpty(annotations))
      {
        annotations = [];
        this._pages[page] = annotations;
      }
      //annotation.id = "temp:"+(this._counter++);
      annotation.page = page;
      annotations.push(annotation);
    },
    replace: function(annotation, newAnnotation)
    {
      var annotations = this.getAnnotations(annotation.page)
      var idx = annotations.indexOf(annotation);
      annotations[idx] = newAnnotation;
    },
    changePage : function(annotation, newPage)
    {
      if (annotation.page !== newPage)
      {
        this._pages[annotation.page] = _.without(this._pages[annotation.page], annotation);
        this.add(newPage, annotation);
      }
    },
    getAnnotations : function(page)
    {
      if (page in this._pages)
      {
        return this._pages[page];
      }
      else
      {
        return null;
      }
    },
    removeAnnotation : function(page, annotationIdx)
    {
      var annotations = this.getAnnotations(page);
      if (annotations === null) throw new Error("there are no annotations on page " + page);

      var toRemove = annotations[annotationIdx];
      this._pages[page] = _.without(annotations, toRemove);
    },
    clearPage : function(page)
    {
      this._pages[page] = null;
    },
    clearDocument : function()
    {
      this._pages = {};
    },
    getAllNotes: function()
    {
      var result = [];
      _.each(this._pages, function (page, idx)
      {
        _.each(page, function (annotation)
        {
          if (annotation.type === "note") this.push(annotation);
        }, this);
      }, result);

      result.sort(function (a, b)
      {
        if (a.page === b.page)
        {
          return a.position.y - b.position.y;
        }
        else
        {
          return a.page - b.page;
        }
      });

      return result;
    },
    applyUncommitedChanges: function(cmds, generator)
    {
       for (var i = 0, len = cmds ? cmds.length : 0; i !== len; ++i)
       {
          var row = cmds[i];
          var cmd = row.cmd;
          var rowid = row.rowid;

          switch (cmd.action)
          {
             case "save":
                cmd.annotation = this._handleSaveCmd(cmd.annotation);
                break;
             case "saveMany":
                var annotations = [];
                _.each(cmd.annotations, function (annotation) { annotations.push(this._handleSaveCmd(annotation)); }, this);
                cmd.annotations = annotations
                break;
             case "delete":
                this._handleDeleteCmd(cmd.annotation);
                break;
             case "deleteMany":
                _.each(cmd.annotations, function (annotation) { this._handleDeleteCmd(annotation); }, this);
                break;
          }

          generator({ rowid: rowid, cmd: cmd, state: this.toFlatRepr() });
       }
    },
    findByCid: function(cid)
    {
       var r = _.find(this.toFlatRepr(), function (annotation) { return annotation.cid === cid; });
       if (!r) return null;

       return r;
    },
    _handleSaveCmd : function(annotation)
    {
       var original = findAnnotation(this._pages, annotation.id, annotation.cid);
       if (original && original.page !== annotation.page)
       {
          this._handleDeleteCmd(original);
       }

       var annotations = this.getAnnotations(annotation.page);
       var originalAnnotationIdx = indexOfAnnotationById(annotations, annotation.id);

       var replacemenent = createAnnotationFromPOD(annotation);

       if (originalAnnotationIdx !== -1 || (originalAnnotationIdx = indexOfAnnotationByCid(annotations, annotation.cid)) !== -1)
       {
          annotations[originalAnnotationIdx] = replacemenent;
       }
       else
       {
          this.add(annotation.page, replacemenent);
       }

       return replacemenent;
    },
    _handleDeleteCmd : function(annotation)
    {
       var annotations = this.getAnnotations(annotation.page);
       var originalAnnotationIdx = indexOfAnnotationById(annotations, annotation.id);
       if (originalAnnotationIdx !== -1 || (originalAnnotationIdx = indexOfAnnotationByCid(annotations, annotation.cid)) !== -1)
       {
          annotations.splice(originalAnnotationIdx, 1);
       }    
    }
  };

  function findAnnotation(pages, id, cid)
  {
     var annotation = null;
     var page = _.find(pages, function (page, idx) {
        return !!_.find(page, function (ann) {
           if ((id && ann.id === id) || (cid && ann.cid === cid))
           {
              annotation = ann;
              return true;
           }
           else
           {
              return false;
           }
        });
     });

     return annotation;
  }

  function createAnnotationFromPOD(pod)
  {
     var annotation;
     switch (pod.type) {
        case "texthighlight":
           annotation = new TextHighlightAnnotation();
           break;
        case "freehighlight":
           annotation = new FreeHighlightAnnotation();
           break;
        case "note":
           annotation = new NoteAnnotation();
           break;
        default:
           return null;
     }
     annotation.fromJSON(pod);

     if (annotation.cid)
     {
        var cid = parseInt(annotation.cid.split("-")[1], 16);
        cid = Math.max(cid, CID_COUNTER);
        if (_.isNumber(cid))
        {
           CID_COUNTER = cid;
        }
     }
   
   
     return annotation;
  }

  function indexOfAnnotationById(annotations, id)
  {
     if (id === null) return -1;
     if (annotations !== null)
     {
        for (var i = 0, len = annotations.length; i !== len; ++i)
        {
           if (annotations[i].id === id)
              return i;
        }
     }
     
      return -1;
  }

  function indexOfAnnotationByCid(annotations, cid)
  {
     if (cid === null) return -1;

     if (annotations !== null)
     {
        for (var i = 0, len = annotations.length; i !== len; ++i)
        {
           if (annotations[i].cid === cid)
              return i;
        }
     }
     
     return -1;
  }

  function getAnnotationById(annotations, id) {
     var idx = indexOfAnnotationById(annotations, id);
     if (idx === -1)
        return null;

     return annotations[idx];
  }

  function getAnnotationByCid(annotations, cid) {
     var idx = indexOfAnnotationByCid(annotations, cid);
     if (idx === -1)
        return null;

     return annotations[idx];
  }

  var WINDOW_ID = Math.round(Math.abs(Math.random() * Math.pow(10, 10))).toString(16);
  var CID_COUNTER = 0;

  function getCID()
  {
     return WINDOW_ID +"-"+(++CID_COUNTER).toString(16);
  }

  function Annotation(type)
  {
     this.type = type;
     this.page = null;
     this.id = null;
     this.date = null;
     this.user = null;

     this.cid = getCID();
  }  

  function FreeHighlightAnnotation()
  {
    Annotation.call(this, "freehighlight");
    this.color = "blue";
    this.path = [];
    this.lineWidth = 20;
  }
  FreeHighlightAnnotation.prototype = Object.create(Annotation.prototype);

  FreeHighlightAnnotation.prototype.addPoint = function (p)
  {
    this.path.push(p);
  };
  FreeHighlightAnnotation.prototype.fromJSON = function (json)
  {
     _copyProperties(this, json);
    var path = this.path;
    for (var i = 0, len = path.length; i < len; ++i)
    {
      var p = path[i];
      path[i] = geometry.Point.prototype.clone.call(p);
    }
  };

  FreeHighlightAnnotation.prototype.simplify = function (trashold)
  {
    this.path = geometry.simplifyPath(this.path, trashold);
  };



  function TextHighlightAnnotation()
  {
    Annotation.call(this, "texthighlight");
    this.color = "blue";
    this.rectangles = [];
  }
  TextHighlightAnnotation.prototype = Object.create(Annotation.prototype);

  TextHighlightAnnotation.prototype.addRectangle= function (p)
  {
    this.rectangles.push(p);
  };

  TextHighlightAnnotation.prototype.fromJSON = function (json)
  {
    _copyProperties(this, json);
    var rectangles = this.rectangles;
    for (var i = 0, len = rectangles.length; i < len; ++i)
    {
      var r = rectangles[i];
      rectangles[i] = geometry2.DataRectangle.prototype.clone.call(r);
    }
  };

  TextHighlightAnnotation.prototype.simplify = function (trashold)
  {
    //this.path = geometry.simplifyPath(this.path, trashold);
  };

  function NoteAnnotation()
  {
    Annotation.call(this, "note");
    this.position = null;
    this.text = null;
  }
  NoteAnnotation.prototype = Object.create(NoteAnnotation.prototype);
  NoteAnnotation.prototype.clone = function()
  {
    var n = new NoteAnnotation();
    n.page = this.page;
    n.position = this.position.clone();
    n.id = this.id;
    n.date = this.date;
    n.user = this.user;
    n.text = this.text;
    n.cid = this.cid;

    return n;
  }
  NoteAnnotation.prototype.toString = function ()
  {
    return this.text;
  };

  NoteAnnotation.prototype.fromJSON = function (json)
  {
     _copyProperties(this, json);

    var p = this.position;
    this.position = geometry.Point.prototype.clone.call(p);
  };
  
  function AnnotationSynchronizator(serviceCaller)
  {
    this._serviceCaller = serviceCaller;

  }

  function _copyProperties(destObj, srcObj)
  {

     var properties = Object.getOwnPropertyNames(destObj);
     for (var i = 0, len=properties.length; i !== len;++i)
     {
        var k = properties[i];
        if (k === "cid" && !srcObj["cid"])
           continue;

        destObj[k] = srcObj[k];
        
     }
  }
}
(
vitrium.viewer,
vitrium.geometry,
vitrium.geometry2,
_));



// script:viewer/history-model.js
/// <reference path="~/build.html" />

(function (exports, Backbone, _)
{
  "use strict";

  exports.HistoryModel = HistoryModel;

  function HistoryState(history, action, state)
  {
    this.history = history; 
    this.action = action; //the action that 
    this.state = state;
    this.active = true;
    this.doCmd = null;
    this.undoCmd = null;
  }

  HistoryState.prototype = 
  {
    commit : function(pages)
    {
      this.history.commit(pages);
    },
    cancel : function(pages)
    {
      this.history.cancel(pages);
    },
    triggerChange: function(pages)
    {
      this.history.triggerChange(pages);
    }
  };

  function HistoryModel(intialstate)
  {
    var st = new HistoryState(this, null, intialstate);
    st.active = false;

    this._states = [st];
    this._undoneState = [];
  }

  HistoryModel.prototype = Object.create(Backbone.Events);
  HistoryModel.prototype.getCurrentState = function()
  {
    return this._states[this._states.length-1];
  };
  HistoryModel.prototype.edit = function(action, doCmd, undoCmd)
  {
    if (arguments.length !== 3) throw new Error("All arguments are mandatory!");

    var historyState = this._states[this._states.length-1];
    if (historyState.active) throw new Error("State must be commited or reverted");
    var st = new HistoryState(this, action, historyState.state.clone());
    st.doCmd = doCmd;
    st.undoCmd = undoCmd;

    this._states.push(st);

    this.triggerHistoryChange();
    return st;
  };
  
  HistoryModel.prototype.commit = function(pages)
  {
    var state = this.getCurrentState();
    if (!state.active) throw new Error("current state must be active");
    state.active = false;

    this._undoneState = [];

    this.triggerHistoryChange(pages);
    this.syncDoCmd();
  };

  HistoryModel.prototype.cancel = function(pages)
  {
    var state = this.getCurrentState();
    if (state.active)
    {
      this._states.pop();
      this.triggerBoth(pages);
    }
    else
    {
      throw new Error("Current task cannot be canceled. It is not active.");
    }
  };

  HistoryModel.prototype.revertTo = function(state)
  {
    var idx = this._states.indexOf(state);
    if (idx !== -1)
    {
      this._states.length = idx + 1;
      this._undoneState.length = 0;
      this.triggerBoth();
    }
    else 
    {
      idx = this._undoneState.indexOf(state);
      if (idx !== -1)
      {
        var num = this._undoneState.length - idx;
        for (var i = 0; i < num ;++i)
        {
          this.redo(true);
        }
      }
      else
      {
        this.reset();
      }
    }
    
  };

  HistoryModel.prototype.findByCid = function (cid)
  {
     var states = this._states;
     for (var i = states.length - 1; i !== -1; --i)
     {
        var s = states[i];
        var r = s.state.findByCid(cid);
        if (r !== null)
        {
           return r;
        }
     }

     return null;
  };

  HistoryModel.prototype.reset = function () {
     this._states.length = 1;
     this._undoneState.length = 0;

     this.triggerBoth();
  };

  HistoryModel.prototype.undo = function()
  {
    if (this.getCurrentState().active)
    {
      throw new Error("Current task must be finished.");
    }

    if (this._states.length > 1)
    {
      // this has to be before following, because it gets undo cmd from current state
      this.syncUndoCmd();

      this._undoneState.push(this._states.pop());
      this.triggerBoth();      
    }
    else
    {
      throw new Error("There is nothing to be undone");
    }    
  };

  

  HistoryModel.prototype.redo = function (nosync)
  {
    if (!nosync && this.getCurrentState().active)
    {
      throw new Error("Current task must be finished.");
    }

    if (this._undoneState.length > 0)
    {
      this._states.push(this._undoneState.pop());
      this.triggerBoth();

      if (!nosync) this.syncDoCmd();
    }
    else
    {
      throw new Error("There is nothing to be redone");
    }
  };

  HistoryModel.prototype.triggerBoth = function (pages)
  {
    this.triggerChange(pages);
    this.triggerHistoryChange();
  };

  HistoryModel.prototype.triggerHistoryChange = function()
  {
    var notActive = !this.getCurrentState().active;
    this.trigger("history:changed", this, this._states.length > 1 && notActive, this._undoneState.length > 0 && notActive);
  };

  HistoryModel.prototype.triggerChange = function (pages)
  {
    this.trigger("changed", pages);
  };

  HistoryModel.prototype.syncDoCmd = function (pages)
  {
    var cmd = this.getCurrentState().doCmd;
    if(cmd !== null)
    {
      this.trigger("model:sync", cmd, this.getCurrentState().state, true);
    }
    
  };

  HistoryModel.prototype.syncUndoCmd = function (pages)
  {
    var cmd = this.getCurrentState().undoCmd;
    if (cmd !== null)
    {
      this.trigger("model:sync", cmd, this.getCurrentState().state, false);
    }
  };

  HistoryModel.prototype.setModel = function (model)
  {
    HistoryModel.call(this, model);
    this.triggerChange();
    this.triggerHistoryChange();
  };

}
(vitrium.utils, 
Backbone, 
_));

// script:viewer/annotations-controller.js
/// <reference path="~/build.html" />

(function (exports, v, utils, geometry, geometry2, ui, i18n, Backbone, _)
{
  "use strict";
  var MOUSE_TOLERANCE = 1;
  var STATES = v.STATES;
  var ST_READY = STATES.get("READY");
  var ST_HIGHLIGHT = STATES.declare("ST_HIGHLIGHT");
  var ST_NOTE_DRAGGING = STATES.declare("ST_NOTE_DRAGGING");

  
  exports.NotesInteractionController = NotesInteractionController;
  exports.AnnotationsControlerModel = Backbone.Model.extend({
    defaults: {
      activatedAction: null,
      activatedActionModel: null,
      colorSelectionModel: null,
      selectedToolModel: null
    },
    
    initialize: function (annotationsController, textSelectionModel)
    {
      this.annotationsController = annotationsController;
      this.textSelectionModel = textSelectionModel;

      this.toolsModels = [];

      var colorSelectionModel = new ColorSelectorModel();
      colorSelectionModel.on("click:colorSelection", this.onColorClicked, this);
      this.set("colorSelectorModel", colorSelectionModel);

      this.addToolSelectionModel("toolSelectorModel", new HighlightToolSelectorModel());
      this.addToolSelectionModel("noteSelectorModel", new NoteSelectorModel());

      this.on("change:activatedAction", this.onChangeActivatedAction, this);
    },
    destroy: function ()
    {
        _.each(this.toolsModels, function (m) { m.off(); });
        this.get("colorSelectorModel").off();
    },
    addToolSelectionModel : function(name, model)
    {
      model.on("click:toolSelection", this.onToolSelected, this);

      this.set(name, model);
      this.toolsModels.push(model);
      return model;
    },
    onToolSelected : function(toolModel)
    {

      var tool = toolModel.getSelectedTool();
      if (tool === null) this.annotationsController.deactivate();
      else this.annotationsController.activate(tool, this.get("colorSelectorModel"));

      this.trigger("click:toolSelection", this);
    },
    onChangeActivatedAction : function(self, action)
    {
      _.each(this.toolsModels, function(model){
        model.selectTool(action);
      });
    },
    onColorClicked : function()
    {
      if (!this.textSelectionModel.get("selection").isEmpty())
      {
        this.annotationsController.activate("texthighlight", this.get("colorSelectorModel"));
      }
      else if (this.get("activatedAction") !== "texthighlight")
      {
        this.annotationsController.activate("freehighlight", this.get("colorSelectorModel"));
      }
    }
  });

  var ColorSelectorModel = Backbone.Model.extend({
    defaults: {
      colorSelectionList: ["red", "OrangeRed", "Fuchsia", "Orange", "Yellow", "LawnGreen", "Blue", "LightBlue"],
      colorSelection: 0
    },
    getSelectedColor: function ()
    {
      var sel = this.get("colorSelection");
      if (sel === -1) return null;
      return this.get("colorSelectionList")[sel];
    }
  });

  var HighlightToolSelectorModel = Backbone.Model.extend({
    defaults: {
      toolSelectionList: [null, "freehighlight", "texthighlight", "eraser"],
      toolSelection: 0
    },
    getSelectedTool: function ()
    {
      var sel = this.get("toolSelection");
      if (sel === -1) return null;
      return this.get("toolSelectionList")[sel];
    },
    selectTool: function (tool)
    {
      var idx = this.get("toolSelectionList").indexOf(tool);
      if (idx !== -1)
      {
        this.set("toolSelection", idx);
      }
      else
      {
        this.set("toolSelection", 0);
      }
    }
  });

  var NoteSelectorModel = Backbone.Model.extend({
    defaults: {
      toolSelectionList: [null, "note", "eraser"],
      toolSelection: 0
    },
    getSelectedTool: function ()
    {
      var sel = this.get("toolSelection");
      if (sel === -1) return null;
      return this.get("toolSelectionList")[sel];
    },
    selectTool: function (tool)
    {
      var idx = this.get("toolSelectionList").indexOf(tool);
      if (idx !== -1)
      {
        this.set("toolSelection", idx);
      }
      else
      {
        this.set("toolSelection", 0);
      }
    }
  });


  exports.AnnotationsController = AnnotationsController;
  function AnnotationsController(viewer, controllerModel, model)
  {
    this.viewer = viewer;
    this.controllerModel = controllerModel;
    this.model = model;

    this.controllers = {
      "freehighlight": new FreehighlightsController(),
      "texthighlight" : new TextHighlightController(this),
      "eraser": new EraserController(),
      "note": new NoteController()
    };
  }

  AnnotationsController.prototype = {
    activate : function (type, model)
    {
      var action = this.controllerModel.get("activatedAction");
      if (action === type) return;

      if (action !== null) this.deactivate(action);
      this.onActivate(type, model);
    },
    deactivate : function(type)
    {
      if (arguments.length === 0) type = this.controllerModel.get("activatedAction");
      if (type)
      {
        this.onDeactivate(type);
      }
    },
    onActivate : function(type, actionModel)
    {
      this.controllers[type].activate(this.viewer, this.model, actionModel, this);
      this.controllerModel.set("activatedAction", type);
      this.controllerModel.set("activatedActionModel", actionModel);
    },
    onDeactivate: function(type)
    {
      this.controllers[type].deactivate();
      this.controllerModel.set("activatedAction", null);
      this.controllerModel.set("activatedActionModel", null);
    },
    showAnnotation : function(annotation)
    {
      if (annotation.type === "note")
      {
        this.viewer.scrollToPoint(annotation.page, annotation.position);
      }
      else
      {
        throw new Error("Annotation of type: " + annotation.type + " is unsuported");
      }

    },
    editNote : function(note)
    {
      this.deactivate();
      if (note.type === "note")
      {
        v.showNoteFormDialog(this.viewer, new v.NoteFormModel(note), _.bind(function (saved, model)
        {
          if (saved)
          {
            var annotation = new v.NoteAnnotation();
            annotation.fromJSON(model.toJSON());

            var editState = this.model.edit("note",
              { action: "save", annotation: annotation },
              { action: "save", annotation: note });

            editState.state.replace(note, annotation);
            editState.triggerChange([annotation.page]);
            editState.commit([annotation.page]);
          }
        }, this), false);
      }
      else
      {
        throw new Error("Only note is supported to edit");
      }
    },
    deleteAnnotation: function(annotation)
    {
      var editState = this.model.edit("delete-" + annotation.type,
        { action: "delete", annotation: annotation },
        { action: "save", annotation: annotation });

      var idx = editState.state.getAnnotations(annotation.page).indexOf(annotation);
      editState.state.removeAnnotation(annotation.page, idx);

      editState.triggerChange([annotation.page]);
      editState.commit([annotation.page]);
    },
    findNoteAtPoint: function (pagePoint)
    {
      var dr = this.viewer.documentRenderer;
      var pageNumber = dr.getPageNumberByCoordinates(pagePoint.x, pagePoint.y, MOUSE_TOLERANCE);
      if (pageNumber !== null)
      {
        dr.translateCoordinatesToPage(pagePoint, pageNumber);
        var scale = this.viewer.scale;
        var annotations = this.model.getCurrentState().state.getAnnotations(pageNumber);
        for (var i = 0, len = annotations !== null ? annotations.length : 0; i < len; ++i)
        {
          var annotation = annotations[i];
          if (annotation.type === "note")
          {
            var position = annotation.position;
            var rect = v.getPosibleNoteRectangle(position, scale);

            if (rect.isPointIn(pagePoint))
            {
              return annotation;
            }
          }
        }
      }
      return null;
    }
  };
  AnnotationsController.prototype.destroy = AnnotationsController.prototype.deactivate;

  function FreehighlightsController()
  {
    this.viewer = null;
    this.model = null;
    this.actionModel = null;

    this.current = null;
    this.activePaths = [];    
  }

  FreehighlightsController.prototype = {
    activate : function(viewer, model, actionModel)
    {
      this.viewer = viewer;
      this.model = model;
      this.actionModel = actionModel;

      viewer
       .on("mousedown", this.onMouseDown, this, -1)
       .on("mouseup", this.onMouseUp, this, -1)
       .on("mousemove", this.onMouseMove, this, -1)
        .on("ftouchstart", this.onDragStart, this, -1)
        .on("ftouchmove", this.onDrag, this, -1)
        .on("ftouchend", this.onDragEnd, this, -1)
      /*  .on("touch", this.blockIfActive, this, -1)
      .on("dragstart", this.blockIfActive, this, -1)
       .on("drag", this.blockIfActive, this, -1)
       .on("dragend", this.blockIfActive, this, -1)
      .on("transformstart", this.blockIfActive, this, -1)
      .on("transformend", this.blockIfActive, this, -1)
      .on("pinch", this.blockIfActive, this, -1);*/

    },
    blockIfActive : function()
    {
      return this.current !== null;     


    },
    deactivate : function()
    {
      this.viewer
       .off("mousedown", this.onMouseDown, this)
       .off("mouseup", this.onMouseUp, this)
       .off("mousemove", this.onMouseMove, this)
      .off("ftouchstart", this.onDragStart, this)
      .off("ftouchmove", this.onDrag, this)
      .off("ftouchend", this.onDragEnd, this)
      /* .off("touch", this.blockIfActive, this)
       .off("dragstart", this.blockIfActive, this)
       .off("drag", this.blockIfActive, this)
       .off("dragend", this.blockIfActive, this)
      .off("transformstart", this.blockIfActive, this)
      .off("transformend", this.blockIfActive, this)
      .off("pinch", this.blockIfActive, this);*/

      this.viewer = null;
      this.model = null;
      this.actionModel = null;

      if (this.current) this.current.cancel();
    },
    _getTouches : function(evt)
    {
      return evt.gesture.touches;
    },
    onDragStart : function(evt)
    {
      var touches = this._getTouches(evt);
      var res = false;
      
      
      for (var i = this.activePaths.length, len = touches.length; i < len; ++i)
      { 
        var created = this.createNewPath(touches[i]);; 
        res = res || created;
      }
      if (res)
      {
        evt.preventDefault();
        evt.stopPropagation();
      }
      return res;
    },
    onDragEnd : function (evt)
    {
      if (this.current !== null)
      {
        this.onCreationEnd();
        
        evt.preventDefault();
        evt.stopPropagation();
        
        return true;
      }
    },
    onDrag : function(evt)
    {
      if (this.current !== null)
      {
        var touches = this._getTouches(evt);
        var paths = this.activePaths;
        var pages = [];
        for (var i = 0, len = touches.length; i < len; ++i)
        {
          var path = paths[i];
          pages.push(path.page);
          this.insertPagePointToPath(path, touches[i]);        
        }
        this.current.triggerChange(pages);
        evt.preventDefault();
        evt.stopPropagation();
        return true;
      }
    },
    onMouseDown : function(evt)
    {
      return this.createNewPath(evt);
    },
    onMouseUp : function(evt)
    {
      if (this.current !== null)
      {
        this.onCreationEnd();
        return true;
      }
    },
    onMouseMove: function (evt)
    {
      if (this.current !== null)
      {
        if ("preventDefault" in evt) evt.preventDefault();

        this.insertPagePointToPath(this.activePaths[0], evt);
        this.current.triggerChange([this.activePaths[0].page]);
        return true;
      }
    },
    onCreationEnd : function()
    {
      var pages = [];
      var paths = this.activePaths;

      for (var i = 0, len = paths.length; i < len; ++i)
      {
        var path = paths[i];
        path.simplify(10);
        pages.push(path.page);
      }
      
      this.current.triggerChange(pages);
      this.current.commit(pages);
      var self = this;
      setTimeout(function ()
      {
        //HACK
        self.viewer.state.pop();
      }, 100);
      
      this.current = null;
      this.activePaths = [];
      
    },
    createNewPath: function (evt)
    {
      var dr = this.viewer.documentRenderer;
      var pageNumber = this.pageNumber = dr.getPageNumberByCoordinates(evt.pageX, evt.pageY, MOUSE_TOLERANCE)
      if (pageNumber !== null)
      {
          if ("preventDefault" in evt) evt.preventDefault();

        var path = new v.FreeHighlightAnnotation();
        if (this.current === null)
        {
          this.current = this.model.edit("freehighlight",
            { action: "save", annotation: path },
            { action: "delete", annotation: path });

          this.viewer.state.push(ST_HIGHLIGHT);
        }
        
        path.page = pageNumber;
      
        path.color = this.actionModel.getSelectedColor();
        this.current.state.add(pageNumber, path);
        this.insertPagePointToPath(path, evt);
        this.activePaths.push(path);
        return true;
      }
      return false;
    },
    insertPagePointToPath: function(path, evt)
    {
      var dr = this.viewer.documentRenderer;
      var mPoint = new geometry.Point(evt.pageX, evt.pageY);
      dr.translateCoordinatesToPage(mPoint, path.page);
      
      path.addPoint(mPoint);
     // this.current.triggerChange([path.page]);
    }
  };



  function EraserController()
  {
    this.viewer = null;
    this.model = null;
    this.actionModel = null;
    this.annotationController = null;
  }
  EraserController.prototype = {
    activate: function (viewer, model, actionModel, annotationController)
    {
      this.viewer = viewer;
      this.model = model;
      this.actionModel = actionModel;
      this.annotationController = annotationController;

      viewer
        .on("mousedown", this.onClick, this, -3)
        .on("tap", this.onTap, this, -3);
    },
    deactivate: function()
    {
      this.viewer
        .off("mousedown", this.onClick, this)
        .off("tap", this.onTap, this);
    },
    onClick : function(evt)
    {
      return this.removeAnnotationOnPoint(new geometry.Point(evt.pageX, evt.pageY));
    },
    onTap : function(evt)
    {
      return this.onClick(evt.gesture.touches[0]);
    },
    removeAnnotationOnPoint: function(pagePoint)
    {
      var note = this.annotationController.findNoteAtPoint(pagePoint.clone());

      if (note !== null)
      {
        this.annotationController.deleteAnnotation(note);         
        return true;
      }

      var dr = this.viewer.documentRenderer;
      var pageNumber = dr.getPageNumberByCoordinates(pagePoint.x, pagePoint.y, MOUSE_TOLERANCE);
      if (pageNumber !== null)
      {
        dr.translateCoordinatesToPage(pagePoint, pageNumber);
        var annotationIdx = this.findAnnotationAt(pageNumber, pagePoint);
        if (annotationIdx !== -1)
        {
          var old = this.model.getCurrentState().state.getAnnotations(pageNumber)[annotationIdx];
          var edit = this.model.edit("eraser",
            { action: "delete", annotation: old },
            { action: "save", annotation: old});
          edit.state.removeAnnotation(pageNumber, annotationIdx);
          
          edit.triggerChange([pageNumber]);
          edit.commit([pageNumber]);

          return true;
        }
      }      
      return false;
    },
    findAnnotationAt : function(pageNumber, point)
    {
      var annotations = this.model.getCurrentState().state.getAnnotations(pageNumber);
      if (!_.isEmpty(annotations))
      {
        

        var ctx = ui.createHitTestCanvasContext();
        var i = annotations.length;
        while (i--)
        {
          var annotation = annotations[i];
          if (annotation.type === "freehighlight")
          {
            v.renderFreehandHighlightPath(ctx, annotation, false);
            // let's trace path if the point lies on it
            if (ctx.isPointInStroke(point.x, point.y))
            {
              return i;
            }
          }
        }

        var i = annotations.length;
        while (i--)
        {
          var annotation = annotations[i];
          if (annotation.type === "texthighlight")
          {
            ctx.beginPath();
            v.renderTextHighlightPath(ctx, annotation);
            // let's trace path if the point lies on it
            if (ctx.isPointInPath(point.x, point.y))
            {
              return i;
            }
          }
        }
      }
      return -1;
    }
  };

    

  function TextHighlightController(actionController)
  {
    this.actionController = actionController;
    this.viewer = null;
    this.model = null;
    this.actionModel = null;
  }
  TextHighlightController.prototype = {
    activate: function (viewer, model, actionModel)
    {
      this.viewer = viewer;
      this.model = model;
      this.actionModel = actionModel;

      if (this.createSelectionHighlight())
      {
        // controller is activated after this call, so I have to postpone deactivation
        viewer.textSelectionController.cancelSelection();
        setTimeout(_.bind(this.actionController.deactivate,this.actionController),0);
      }
      viewer.textSelectionModel.on("finished", this.onSelectionFinished, this);

    },
    deactivate: function ()
    {
      this.viewer.textSelectionModel.off("finished", this.onSelectionFinished, this);
    },
    onSelectionFinished : function()
    {
      this.createSelectionHighlight();
      this.viewer.textSelectionController.cancelSelection();
    },
    createSelectionHighlight :function()
    {
      var selection = this.viewer.textSelectionModel.get("selection");
      if (!selection.isEmpty())
      {
        var pages = selection.getAffectedPages();
        var doAction = { action: "saveMany", annotations: [] };
        var undoAction = { action: "deleteMany", annotations: doAction.annotations };

        var edit = this.model.edit("texthighlight", doAction, undoAction);

        var color = this.actionModel.getSelectedColor();
        for (var i = 0, len = pages.length; i < len; ++i)
        {
          var page = pages[i];
          var ps = selection.getSelection(page);
          var annotation = new v.TextHighlightAnnotation();
          annotation.color = color;
          for (var r = 0, rlen = ps.length; r < rlen; ++r)
          {
            annotation.addRectangle(ps[r].clone());
          }

          annotation.simplify();
          edit.state.add(page, annotation);

          doAction.annotations.push(annotation);
        }
        
        edit.triggerChange(pages);
        edit.commit(pages);
        return true;
      }
      return false;
    }
  };

  function NoteController()
  {
    this.viewer = null;
    this.model = null;
    this.actionModel = null;
    this.controller = null;

    this.editState = null;
  }
  NoteController.prototype = {
    activate: function (viewer, model, actionModel, controller)
    {
      this.viewer = viewer;
      this.model = model;
      this.actionModel = actionModel;
      this.controller = controller;

      viewer
        .on("mousedown", this.onClick, this, -1)
        .on("tap", this.onTap, this, -1);
    },
    deactivate: function ()
    {
      this.viewer
        .off("mousedown", this.onClick, this)
        .off("tap", this.onTap, this);

      this.viewer = null;
      this.model = null;
      this.actionModel = null;
      this.controller = null;
    },
    onClick: function (evt)
    {
      return this.addNoteAtPoint(new geometry.Point(evt.pageX, evt.pageY));
    },
    onTap: function (evt)
    {
      return this.onClick(evt.gesture.touches[0]);
    },
    addNoteAtPoint: function (pagePoint)
    {
      var dr = this.viewer.documentRenderer;
      var pageNumber = dr.getPageNumberByCoordinates(pagePoint.x, pagePoint.y, MOUSE_TOLERANCE);
      if (pageNumber !== null)
      {
        dr.translateCoordinatesToPage(pagePoint, pageNumber);

        v.showNoteFormDialog(this.viewer, new v.NoteFormModel({position : pagePoint, page : pageNumber}), _.bind(this.onNoteDialogClosed, this), true);        

        return true;
      }
        return false;
      },
      onNoteDialogClosed: function(saved, model)
      {
        if (saved)
        {
          var annotation = new v.NoteAnnotation();
          _.extend(annotation, model.toJSON());
                    
          var editState = this.model.edit("note",   
            { action: "save", annotation: annotation},
            { action: "delete", annotation: annotation});

          editState.state.add(annotation.page, annotation);
          editState.triggerChange([annotation.page]);
          editState.commit([annotation.page]);
        }
        

        this.controller.deactivate();
      }

  };



  function NotesInteractionController(viewer, annotationsModel, notesSelectionController, annotationController, cursorModel)
  {
    this.viewer = viewer;
    this.annotationsModel = annotationsModel;
    this.notesSelectionController = notesSelectionController;
    this.annotationController = annotationController;
    this.cursorModel = cursorModel;


    this.currentEditModel = null;
    this.initialPosition = null;
    this.initialNotePosition = null;
    this.findPoint = null;
    this.note = null;
    this.originalNote = null;
    this.changed = false;
    this.firstMousePos = null;
    this.pointerCursor = v.Cursor.create("pointer", 1);
    this.moveCursor = v.Cursor.create("move", 1);
    this.currentMousePosition = new geometry.Point(0, 0);
      viewer
      .on("change:viewport", this.onRelativeMousePositionChanged, this)
      .on("mousedown", this.onMouseDown, this, -2)
      .on("dblclick", this.onDoubleClicked, this, -2)
      .on("mouseup", this.onMouseUp, this, -2)
      .on("mousemove", this.onMouseMove, this, -2)
      .on("ftouchstart", this.onDragStart, this, -2)
      .on("ftouchmove", this.onDrag, this, -2)
      .on("ftouchend", this.onDragEnd, this, -2);

  }

  NotesInteractionController.prototype = {
      destroy : function()
      {
          this.viewer
      .off("change:viewport", this.onRelativeMousePositionChanged, this)
      .off("mousedown", this.onMouseDown, this, -2)
      .off("mouseup", this.onMouseUp, this, -2)
      .off("mousemove", this.onMouseMove, this, -2)
      .off("ftouchstart", this.onDragStart, this, -2)
      .off("ftouchmove", this.onDrag, this, -2)
      .off("ftouchend", this.onDragEnd, this, -2);
        if (this.viewer.state.current() === ST_NOTE_DRAGGING)
        {
            this.viewer.state.pop();
        }
      },
    onDragStart : function(evt, state)
    {
      return this.onMouseDown(evt.gesture.touches[0], state);
    },
    onDragEnd: function(evt, state)
    {
      return this.onMouseUp(evt.gesture.touches[0], state);
    },
    onDrag : function(evt, state)
    {
      return this.onMouseMove(evt.gesture.touches[0], state);

    },
    onDoubleClicked : function(evt, state)
    {
      //TODO edit note
    },
    onMouseDown : function(evt, state)
    {
      if (state.current() === ST_READY)
      {
        var point = new geometry.Point(evt.pageX, evt.pageY);
        this.firstMousePos = point.clone();
        var note = this.annotationController.findNoteAtPoint(point.clone());
       
        this.changed = false;
        if (note !== null)
        {
          if ("preventDefault" in evt) evt.preventDefault();

          state.push(ST_NOTE_DRAGGING);
          
          this.findPoint = point.clone();
          this.initialPosition = this.viewer.translateCoordinatesToPage(point, note.page);
          this.initialNotePosition = note.position.clone();
          this.originalNote = note;
          this.note = note.clone();
          this.currentEditModel = this.annotationsModel.edit("note-drag",
            { action: "save", annotation: this.note },
            { action: "save", annotation: note });

          this.currentEditModel.state.replace(note, this.note);
          this.notesSelectionController.drag(this.note);
          this.notesSelectionController.select(this.note);

          return true;
        }
        else
        {
          return false;
        }
      }
    },
    onMouseMove : function(evt, state)
    {
        if (state.current() === ST_NOTE_DRAGGING)
        {

            if ("preventDefault" in evt) evt.preventDefault();


            var mPoint = new geometry.Point(evt.pageX, evt.pageY);
            if (this.changed || mPoint.distance(this.firstMousePos) > 5)
            {
                this.cursorModel.push(this.moveCursor);

                this.changed = true;
                var point = this.viewer.translateCoordinatesToPage(mPoint, this.note.page);


                var deltaX = (this.initialPosition.x - point.x);
                var deltaY = (this.initialPosition.y - point.y);



                this.note.position.x = this.initialNotePosition.x - deltaX;
                this.note.position.y = this.initialNotePosition.y - deltaY;


                this.currentEditModel.triggerChange([this.note.page]);
            }

            return true;
        }
        else
        {
            var pos = this.currentMousePosition;
            pos.x = evt.pageX;
            pos.y = evt.pageY;
            this.onRelativeMousePositionChanged();   
        }
    },
    onRelativeMousePositionChanged : function()
    {
        if (this.annotationController.findNoteAtPoint(this.currentMousePosition.clone()))
        {
            this.cursorModel.push(this.pointerCursor);
        }
        else
        {
            this.cursorModel.pop(this.pointerCursor);
        }
    },
    onMouseUp : function(evt, state)
    {
      if (state.current() === ST_NOTE_DRAGGING)
      {
        var pagePoint = new geometry.Point(evt.pageX, evt.pageY);
        var dr = this.viewer.documentRenderer;
        var pageNumber = dr.getPageNumberByCoordinates(pagePoint.x, pagePoint.y, MOUSE_TOLERANCE);


        if (this.changed && pageNumber !== null)
        {
          this.cursorModel.pop(this.moveCursor);

          var pages = [];
          if (this.note.page !== pageNumber)
          {
            pages.push(this.note.page, pageNumber);
            pages.sort();

            var point = this.viewer.translateCoordinatesToPage(pagePoint, pageNumber);
            this.note.position = point;
            this.currentEditModel.state.changePage(this.note, pageNumber);
          }
          this.currentEditModel.triggerChange(pages);
          this.currentEditModel.commit();
        }
        else
        {

          this.currentEditModel.cancel();
          var note = this.annotationController.findNoteAtPoint(this.findPoint.clone());
          this.notesSelectionController.select(note);
        }

        this.notesSelectionController.drag(null);
        state.pop();
        return true;
      }
    }
  };
  
  exports.AnnotationSelectionModel = Backbone.Model.extend({
    defaults : {
      selected: null,
      dragged : null
    },
    isSelected :function(a)
    {
      return a === this.get("selected");
    },
    isDragged : function(a)
    {
      return a === this.get("dragged");
    },
    select: function (a)
    {
      var old = this.get("selected");
      this.set("selected", a);

      this.triggerChange(old, a);
    },
    drag : function(a)
    {
      var old = this.get("dragged");
      this.set("dragged", a);

      this.triggerChange(old, a);
    },
    triggerChange : function(old, a)
    {
      var pages = [];
      if (a !== null)
      {
        pages.push(a.page);
      }

      if (old !== null && (a === null || old.page !== a.page))
      {
        pages.push(old.page);
        pages.sort();
      }
      this.trigger("changed", pages);
    }
  });


}
(vitrium.viewer,
vitrium.viewer,
vitrium.utils,
vitrium.geometry,
vitrium.geometry2,
vitrium.ui,
vitrium.i18n,
Backbone,
_
));

// script:viewer/annotations-service-sync.js
/// <reference path="~/build.html" />

(function (exports, v, async, log, utils, _, Backbone)
{
  "use strict";

  var ANNOTATION_SERVICE_NAME = "Annotation";
  exports.AnnotationServiceSync = AnnotationServiceSync;
  var AnnotationSyncState = {
     SYNCHRONIZED: 0,
     SYNCHRONIZING: 1,
     FAILED: 2
  };
  exports.AnnotationSyncState = AnnotationSyncState;

  function AnnotationServiceSync(historyModel, serviceCaller, queueId)
  {
    this.historyModel = historyModel;
    this.serviceCaller = serviceCaller;

    historyModel.on("model:sync", this.onModelSync, this);
    
    //this._queue = [];
    this._persistentQueue = null;
    var self = this;
    var completer = new async.Completer();;
    this._persistentQueueFuture = completer.future.then(function () {
       self._persistentQueueFuture = null;
    });

    this.queueId = queueId;
    utils.openPersistentQueue("sync:" + queueId, _.bind(this.queueErrorHandler, this)).then(function (queue) {
       self._persistentQueue = queue;
       
       completer.complete();
       
    })
    .error(function (e) {
       log.error("[AnnotationServiceSync] unable to init persitent queue");
       self._persistentQueue = new utils.DefferedQueue();
       completer.complete();
    });

    this._currentlyExecuted = null;
    this._syncFailed = false;
    this._syncFailedTimer = null;

    this._state = AnnotationSyncState.SYNCHRONIZED;
    this._lastSyncState = { versionId: 0, annotations: [] };

    this._queue = [];

    Backbone.Events.on("storage:erased", this.onStorageErased, this);
  }

  AnnotationServiceSync.prototype = 
  {
     onStorageErased: function(url)
     {
        log.debug("[AnnotationServiceSync] onStorageErased", url);

        if (this.queueId.indexOf(url) !== -1)
        {
           this.exec(function () {
              this._persistentQueue.deleteAll();
           });
        }
     },
     destroy: function()
     {
        Backbone.Events.off("storage:erased", this.onStorageErased, this);
     },
     changeState: function(state)
     {
        if (this._state !== state) {
           this._state = state;
           this.trigger("sync:state", state);
        }
     },
    cancelSync : function()
    {
      this.historyModel.reset();    
    },
    load : function()
    {
       log.debug("[AnnotationServiceSync] load");
       this.changeState(AnnotationSyncState.SYNCHRONIZING);

       var future = this.serviceCaller.call(ANNOTATION_SERVICE_NAME, "describe");
       future.then(_.bind(this.replaceModel, this));
       future.catchError(_.bind(function (e)
         {
            log.error("[AnnotationServiceSync]", e);
            this.trigger("error:load", e, this);

            this.replaceModel(this._lastSyncState);
         }, this));


      return future;
    },
    replaceModel: function(data)
    {
       this._lastSyncState = data;
       log.debug("[AnnotationServiceSync] versionId:", data.versionId);

       var model = new v.AnnotationsModel();
       model.parseFromJSON(data.annotations);
       this.exec(modelMerge);

       function modelMerge() {
          var self = this;
          var queue = [];
          this._persistentQueue.all().then(function (cmds) {
             model.applyUncommitedChanges(cmds, function (item) {
                queue.push(item);
             });

             self.historyModel.setModel(model);
             self._queue = queue;

             if (queue.length !== 0) {
                self.executeIfPosible();
             }
             else {
                self.changeState(AnnotationSyncState.SYNCHRONIZED);
             }
          })
          .catchError(function (e) {
             self.historyModel.setModel(model);
          });
       }
    },
    exec: function(fnct)
    {
       if (this._persistentQueue === null)
          this._persistentQueueFuture.then(_.bind(fnct, this));
       else
          fnct.call(this);
    },
    onModelSync: function(cmd, state)
    {
       //log.debug("[AnnotationServiceSync] onModelSync", cmd);

       var cids = getAffectedCids(cmd);

       var changed = [];
       var toRemove = _.filter(this._queue, function (item) {
          if (item.cmd.annotation)
          {
             return cids.indexOf(item.cmd.annotation.cid) !== -1;
          }
          else if (item.cmd.annotations)
          {
             var present = _.filter(item.cmd.annotations, function (a) { return cids.indexOf(a.cid) !== -1; });
             if (present.length === item.cmd.annotations.length)
             {
                return true;
             }
             else {
                var arg = [item.cmd.annotations];
                arg.push.apply(arg, present);
                item.cmd.annotations = _.without.apply(_, arg);
                changed.push(item);
                return false;
             }
          }
       });

       if (toRemove.length !== 0) {
          var args = [this._queue];
          args.push.apply(args, toRemove);

          this._queue = _.without.apply(_, args);

          log.debug("[AnnotationServiceSync] removed from queue", toRemove);
       }

       if (cmd.action === "delete")
       {
          if (cmd.annotation.id) {
             this._queue.push({ cmd: cmd, state: state.toFlatRepr() });
             log.debug("[AnnotationServiceSync] 0 pushed", cmd.action, cmd);
          }
       }
       else if (cmd.action === "deleteMany")
       {
          var annotationsWithId = _.filter(cmd.annotations, function (ann) { return !!ann.id; });
          cmd.annotations = annotationsWithId;
          if (annotationsWithId.length !== 0)
          {
             this._queue.push({ cmd: cmd, state: state.toFlatRepr() });
             log.debug("[AnnotationServiceSync] 1 pushed", cmd.action, cmd);

          }
       }
       else
       {
          this._queue.push({ cmd: cmd, state: state.toFlatRepr() });
          log.debug("[AnnotationServiceSync] 2 pushed", cmd.action, cmd);
       }

       if (_.find(changed, function (r) { return _.isNumber(r.rowid); }) ||
          _.find(toRemove, function (r) { return _.isNumber(r.rowid); })) {
          this.exec(function () {
             var self = this;
             this._persistentQueue.transaction(function (tx) {
                for (var i = 0, len = changed.length; i !== len; ++i) {
                   var c = changed[i];
                   if (_.isNumber(c.rowid)) {
                      tx.push(c);
                   }
                }

                for (var i = 0, len = toRemove.length; i !== len; ++i) {
                   var r = toRemove[i];
                   if (_.isNumber(r.rowid)) {
                      tx.deleteItem(r);
                   }
                }
             });
          });
       }

       this.executeIfPosible();
    },
    trySync: function()
    {
       this.clearTimer();
       this.executeIfPosible();
    },
    executeIfPosible: function()
    {
       if (this._currentlyExecuted === null) {
          this.changeState(AnnotationSyncState.SYNCHRONIZING);

          var item = this._queue.shift();
          if (item) {
             var self = this;
             this._currentlyExecuted = this.doSync(item.cmd, item.state)
              .whenComplete(function () {
                 if (_.isNumber(item.rowid) &&
                    !self._syncFailed)
                 {
                    self.exec(function () {
                       log.debug("[AnnotationServiceSync] removing from storage", item);

                       self._persistentQueue.deleteItem(item);
                    });
                 }
                  
                 if (self._syncFailed)
                 {
                    self._queue.unshift(item);
                    if (_.find(self._queue, function (i) { return !_.isNumber(i.rowid); })) {
                       self.exec(function () {
                          self._persistentQueue.transaction(function (tx) {
                             _.each(self._queue, function (item) {
                                if (!_.isNumber(item.rowid)) {
                                   log.debug("[AnnotationServiceSync] saving to storage", item);

                                   tx.push(item).then(function (rowid) {
                                      item.rowid = rowid;
                                   });
                                }
                             });
                          });
                       });
                    }
                 }
              })
             .whenComplete(_.bind(this.cleanUpExecution, this));
          }
          else {
             this.changeState(AnnotationSyncState.SYNCHRONIZED);
          }
       }
    },
    queueErrorHandler: function(e)
    {
       log.error("[AnnotationServiceSync] queueErrorHandler", e);
       this._currentlyExecuted = null;
    },
    cleanUpExecution : function()
    {
       this._currentlyExecuted = null;
       if (!this._syncFailed)
       {
          this.executeIfPosible();
       }
       else if (this._syncFailedTimer !== null)
       {
          this._syncFailedTimer = setTimeout(_.bind(function(){
             this._syncFailedTimer = null;
             this.executeIfPosible();
          }, this), 30000);
       }
    },
    clearTimer: function()
    {
       clearTimeout(this._syncFailedTimer);
       this._syncFailedTimer = null;
    },
    doSync : function(cmd,state)
    {
      var action = cmd.action;
      var msg = {
        versionId: this._lastSyncState.versionId,
      };
      if (action === "save")
      {
        msg.annotation = cmd.annotation;
      }
      else if (action === "delete" && cmd.annotation.id !== null)
      {
         msg.annotationId = cmd.annotation.id;
      }
      else if (action === "saveMany")
      {
        msg.annotations = cmd.annotations;
      }
      else if (action === "deleteMany")
      {
        msg.annotationIds = [];
        _.each(cmd.annotations, function (a)
        {
          if (a.id !== null)
          {
            this.push(a.id);
          }
        }, msg.annotationIds);
      }


      var future = this.serviceCaller.call(ANNOTATION_SERVICE_NAME, action, msg);
      future.then(_.bind(function (data)
      {
        if (action === "save")
        {
           var cid = cmd.annotation.cid;
           cmd.annotation.fromJSON(data.annotation);
           cmd.annotation.cid = cid;
            this.historyModel.triggerChange([data.annotation.page]);  
        }
        else if (action === "saveMany")
        {
          var pages = [];
          for (var i = 0, len = data.annotations.length; i < len; ++i)
          {
             var ann = cmd.annotations[i];
             var cid = ann.cid;
             ann.fromJSON(data.annotations[i]);
             ann.cid = cid;

             var p = ann.page;
             if (pages.indexOf(p) === -1) pages.push(p);
          }

          pages.sort();
          this.historyModel.triggerChange(pages);
        }
        else if (action === "delete")
        {
           cmd.annotation.id = null;
           
        }
        else if (action === "deleteMany")
        {
           _.each(cmd.annotations, function (a) {
                  a.id = null;
           }, this);
        }

        this._syncFailed = false;
        if (state)        
        {
           assertIds(state);
           this._lastSyncState = {
              versionId : data.newVersionId,
              annotations : state
           };

           this.trigger("model:synced", this._lastSyncState);
        }
        else
        {
           this.trigger("model:refresh");
        }
      }, this))
      .catchError(_.bind(function (e)
      {
        if (e === 409)
        {
           this._syncFailed = false;
          this.trigger("model:refresh");
        }
        else
        {
           this.trigger("error:sync", e, this);
           this._syncFailed = true;
           this.changeState(AnnotationSyncState.FAILED);
        }
      }, this));
      this.serviceCaller.send();
      return future;
    }
  };
  _.extend(AnnotationServiceSync.prototype, Backbone.Events);

  function getAffectedCids(cmd)
  {
     var cids = null;
     if (cmd.annotation)
        cids = [cmd.annotation.cid];
     else if (cmd.annotations)
        cids = _.pluck(cmd.annotations, "cid");
     else
        throw new Error("annotation or annotations must be member of cmd");

     return cids;
  }

  function assertIds(state)
  {
     var notId = _.find(state, function (ann) {
        return !ann.id;
     });

     if (notId) {
        log.debug(notId);
        throw new Error("id must be specified");
     }
  }

}
(vitrium.viewer,
vitrium.viewer,
vitrium.async,
vitrium.log,
vitrium.utils,
_,
Backbone));

// script:viewer/annotations-layer-view.js
/// <reference path="~/build.html" />

(function (exports, ui, geometry, geometry2, _)
{
  "use strict";
  exports.AnnotationsLayerView = AnnotationsLayerView;
  exports.renderFreehandHighlightPath = renderFreehandHighlightPath;
  exports.renderTextHighlightPath = renderTextHighlightPath;
  exports.getPosibleNoteRectangle = getPosibleNoteRectangle;

  function AnnotationsLayerView(model, viewer, annotationSelectionModel)
  {
    /// <field name="model" type="vitrium.utils.HistoryModel></field>
    this.model = model;
    this.viewer = viewer;
    this.annotationSelectionModel = annotationSelectionModel;
    this.noteIcon = getNoteIcon(false, false);
    this.selectedIcon = getNoteIcon(true, false);

    var draggIcon = getNoteIcon(true, true);
    draggIcon.style.width = draggIcon.vitriumRequestedWidth+"px";
    draggIcon.style.height = draggIcon.vitriumRequestedHeight + "px";
    this.draggedIcon = new ui.DomSizedWidget(draggIcon);

    this.noteBubble = new ui.Bubble();
    this.noteInBubble = null;

    viewer.on("change:viewport", this.onViewportChanged, this);
  }

  AnnotationsLayerView.prototype =
  {
    destroy : function()
    {
        if (this.noteBubble.parent)
        {
            this.viewer.remove(this.noteBubble);
            this.noteInBubble = null;
        }
        this.viewer.off("change:viewport", this.onViewportChanged, this);
    },
    on : function()
    {
      this.annotationSelectionModel.on.apply(this.annotationSelectionModel, arguments);
      return this.model.on.apply(this.model, arguments);
    },
    off : function()
    {
      this.annotationSelectionModel.off.apply(this.annotationSelectionModel, arguments);
      return this.model.off.apply(this.model, arguments);
    },
    getAnnotations : function(pageNumber)
    {
      return this.model.getCurrentState().state.getAnnotations(pageNumber);
    },
    hasContent : function(pageNumber)
    {
      var res = !_.isEmpty(this.getAnnotations(pageNumber));
      if (!res && this.noteBubble.parent !== null && this.noteInBubble !== null && this.noteInBubble.page === pageNumber)
      {
        this.removeBubble();
      }

      return res;
    },
    render: function (pageNumber, ctx, currentTime)
    {

      var annotations = this.getAnnotations(pageNumber);
      if (!_.isEmpty(annotations))
      {
        ctx.save();
        ctx.globalAlpha = 0.3;
        var last = null;
        for (var i = 0, len = annotations.length; i < len; ++i)
        {
          var annotation = annotations[i];
          if (annotation.type === "texthighlight")
          {
            //
            if (last === null || annotation.color !== last.color)
            {
              if (last !== null)
              {
                ctx.fill();
              }

              ctx.fillStyle = annotation.color;
              ctx.beginPath(); 
            }

            renderTextHighlightPath(ctx, annotation);
            //
            last = annotation;
          }
        }
      

        if (last !== null)
        {
          ctx.fill();
        }
        ctx.restore();

        for (var i=0, len=annotations.length; i <len;++i)
        {
          var annotation = annotations[i];
          if (annotation.type === "freehighlight")
          {
            ctx.save();
            renderFreehandHighlightPath(ctx, annotation, true);
            ctx.restore();
          }
        }

        var scale = this.viewer.scale;
        ctx.save();
      // ctx.setTransform(ctx.canvas.vitriumScaleRatio, 0, 0, ctx.canvas.vitriumScaleRatio, 0, 0);
        ui.setContextImageSmoothing(ctx, false);

        var dragging = false;
        var selected = false;

        for (var i = 0, len = annotations.length; i < len; ++i)
        {
          var annotation = annotations[i];
          if (annotation.type === "note")
          {
            var pos = annotation.position;
         
            var icon = null;
            if (this.annotationSelectionModel.isDragged(annotation))
            {
              dragging = true;
              var cpos = this.viewer.documentRenderer.translateCoordinatesFromPageToDOMRelative(pos.clone(), pageNumber);
              var c = this.draggedIcon.el.vitriumRequestedWidth / 2;
              this.draggedIcon.dim = new geometry2.Rectangle(cpos.x - c, cpos.y-c, 0, 0, 0);
            }
            else if (this.annotationSelectionModel.isSelected(annotation))
            {
              icon = this.selectedIcon;
              
              this.noteInBubble = annotation;
              this.noteBubble.updateContent(annotation.text);

              
              selected = true;
            }
            else
            {
              icon = this.noteIcon;
            }

            if (icon !== null)
            {
              var w = icon.vitriumRequestedWidth / scale;
              var r = w / 2  ;
              var x = pos.x;
              var y = pos.y;

              ctx.drawImage(icon, 0, 0, icon.width, icon.height, x - r, y - r, icon.vitriumRequestedWidth/scale, icon.vitriumRequestedHeight/scale);
            }
            
           // drawNoteIcon(ctx, annotation.position, scale, this.annotationSelectionModel.isSelected(annotation), this.annotationSelectionModel.isDragged(annotation));
          }        
        }

        if (selected && this.noteBubble.parent === null)
        {
          this.viewer.add(this.noteBubble);
       
        }
        else if (!selected && this.noteBubble.parent !== null && this.noteInBubble !== null && this.noteInBubble.page === pageNumber)
        {
          this.removeBubble();
        }

        if (selected)
        {
          var cpos = this.viewer.documentRenderer.translateCoordinatesFromPageToDOMRelative(this.noteInBubble.position.clone(), pageNumber);
          this.setBubblePosition(cpos);
        }

        if (dragging && this.draggedIcon.parent === null)
        {
          this.viewer.add(this.draggedIcon);
        }
        else if (!dragging && this.draggedIcon.parent !== null)
        {
          this.viewer.remove(this.draggedIcon);
        }

        ui.setContextImageSmoothing(ctx, true);
        ctx.restore();
      }
    },
    removeBubble : function()
    {
      this.viewer.remove(this.noteBubble);
      this.noteInBubble = null;
    },
    onViewportChanged : function(markPagesDirty, pages, scale)
    {
      
      if (this.noteInBubble !== null)
      {
        var num = this.noteInBubble.page;
        var pageIsVisible = !!_.find(pages, function (page) { return page.number === num; });

        if (!pageIsVisible)
        {
          if (this.noteBubble.parent !== null)  this.viewer.remove(this.noteBubble);
          return;
        }
        else
        {
          if (this.noteBubble.parent === null) this.viewer.add(this.noteBubble);
        }
        
        var cpos = this.viewer.documentRenderer.translateCoordinatesFromPageToDOMRelative(this.noteInBubble.position.clone(), num);
        this.setBubblePosition(cpos);
      }
    },
    setBubblePosition : function (cpos)
    {
     
      var viewerDim = this.viewer.dim;
      var bubbleDim = this.noteBubble.dim;

      // HACK this should be done cleaner 
      var  scrollableViewport = this.viewer.documentRenderer.scrollableViewport;
      var hs = scrollableViewport.hScroll;
      var vs = scrollableViewport.vScroll;
      var scrollBar = scrollableViewport.barThickness;

      var maxX = viewerDim.w - bubbleDim.w - (vs.visible ? scrollBar+2 : 0);
      var maxY = viewerDim.h - bubbleDim.h - (hs.visible ? scrollBar+2 : 0);

     
      //console.log(viewerDim.toString(), bubbleDim.toString());
      this.noteBubble.dim = new geometry2.Rectangle(Math.min(Math.max(cpos.x, 0), maxX), Math.min(Math.max(cpos.y - (ICON_WIDTH / 2) -bubbleDim.h, 0), maxY), 0, 0, 0);

    }


  };
  var distance = geometry.Point.prototype.distance;

  function renderFreehandHighlightPath(ctx, annotation, stroke)
  {
    ctx.globalAlpha = 0.5;
    ctx.strokeStyle = annotation.color;
    ctx.lineWidth = annotation.lineWidth;
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    ctx.beginPath();

    var path = annotation.path;
    var plen = path.length;
    if (plen === 1)
    {
      var point = path[0];
      ctx.moveTo(point.x, point.y);
      ctx.lineTo(point.x + 1, point.y + 1);
    }
    else if (plen > 1)
    {
      var point = path[0];
      var first = point;
      ctx.moveTo(point.x, point.y);
      for (var p = 1; p < plen; ++p)
      {
        point = path[p];
        ctx.lineTo(point.x, point.y);
      }

      //non intrusive call to make sure that I can render it even in POD
      if (distance.call(point, first) < annotation.lineWidth + 5)
      {
        ctx.closePath();
      }
    }

    if (stroke)
    {
      ctx.stroke();
    }
  }

  function renderTextHighlightPath(ctx, annotation)
  {
    var rectangles = annotation.rectangles;
    for (var i = 0, len = rectangles.length; i < len; ++i)
    {
      var r = rectangles[i];
      ctx.rect(r.x, r.y, r.w, r.h);
    }
  }


  var ICON_WIDTH = 36;
  function getPosibleNoteRectangle(pagePoint, scale)
  {
    var size = 1 / scale * ICON_WIDTH;
    var r = size / 2;
    return new geometry2.Rectangle(pagePoint.x - r, pagePoint.y - r, size, size, 0);
  }

  function getNoteIcon(selected, dragged)
  {
    var canvas = ui.CANVAS_POOL.getCanvas(ICON_WIDTH, ICON_WIDTH);
    var ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    //ctx.scale(1 / ui.CANVAS_POOL.GLOBAL_PIXEL_RATIO, 1 / ui.CANVAS_POOL.GLOBAL_PIXEL_RATIO);
    drawNoteIcon(ctx, selected, dragged);

    return canvas;
  }

  function drawNoteIcon(ctx, selected, dragged)
  {
    ctx.save();
    
   // var t = ctx.canvas.width/2;
    
    
    //ctx.translate(t,t);
    //ctx.scale(1 / scale, 1 / scale);
    
    ctx.fillStyle = selected ? 'orange' :'yellow';
    ctx.strokeStyle = "black";
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
    ctx.miterLimit = 4;
    ctx.lineWidth = 1;

    ctx.beginPath();

    ctx.moveTo(16, 8.07);
    ctx.bezierCurveTo(10.55, 8.07, 6.14, 10.98, 6.14, 14.57);
    ctx.bezierCurveTo(6.14, 17.43, 8.91, 19.85, 12.76, 20.72);
    ctx.bezierCurveTo(12.76, 20.72, 13.88, 21.27, 12.04, 23.15);
    ctx.bezierCurveTo(11.28, 23.93, 15.08, 21.94, 15.89, 21.39);
    ctx.bezierCurveTo(16.15, 21.2, 16.23, 21.15, 16.47, 21.1);
    ctx.bezierCurveTo(16.69, 21.06, 16.87, 21.06, 16.96, 21.06);
    ctx.bezierCurveTo(21.95, 20.74, 25.86, 17.97, 25.86, 14.57);
    ctx.bezierCurveTo(25.86, 10.98, 21.45, 8.07, 16, 8.07);
    ctx.closePath();

    ctx.rect(4, 4, 24, 24);

    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = 'black';

    if (dragged)
    {
      ctx.beginPath();

      if ("setLineDash" in ctx)
      {
        ctx.setLineDash([3]);
      }
      else if ("mozDash" in ctx)
      {
        ctx.mozDash = [3];
      }
      

      ctx.rect(3, 3, 26, 26);
      ctx.strokeStyle = "red";
      ctx.stroke();
    }

    ctx.restore();
  };

}
(
vitrium.viewer,
vitrium.ui,
vitrium.geometry,
vitrium.geometry2,
_));

// script:viewer/annotations-cursor-view.js
/// <reference path="~/build.html" />

(function (exports, viewer, $)
{
  "use strict";

  exports.AnnotationsActionCursorView = AnnotationsActionCursorView;
  function AnnotationsActionCursorView(viewer, annotationsControllerModel, cursorModel)
  {
    this.viewer = viewer;
    this.annotationsControllerModel = annotationsControllerModel;
    this.cursorModel = cursorModel;
    
    var c = this.cursorCanvas = document.createElement("canvas");
    c.width = 32;
    c.height = 32;

    this.cursor  = null;
    this.currentPage = null;
    viewer.on("change:pageUnderMouse", this.onChangePageUnderMouse, this);
    annotationsControllerModel.on("change:activatedAction", this.onUpdateAppearance, this);
    annotationsControllerModel.get("colorSelectorModel").on("change:colorSelection", this.onUpdateAppearance, this);

    this.renderedColor = null;
    this.image = null;
    this.displayedAction = null;

  }

  AnnotationsActionCursorView.prototype = {
      destroy : function()
      {
        this.viewer.off("change:pageUnderMouse", this.onChangePageUnderMouse, this);
        this.cursorModel.pop(this.cursor);

      },
    onChangePageUnderMouse: function (pageNumber)
    {
      this.currentPage = pageNumber;
      this.onUpdateAppearance();
    },
    onUpdateAppearance: function ()
    {
        var activatedAction = this.annotationsControllerModel.get("activatedAction"); 
      if (this.currentPage === null || activatedAction !== this.displayedAction)
      {
        // cursor must be on the page and must right tool must be selected
        this.cursorModel.pop(this.cursor);
       
      }
      if (this.currentPage !== null && activatedAction !== null)
      {
          if (activatedAction === "freehighlight")
          {
              var colorSelection = this.annotationsControllerModel.get("colorSelectorModel").getSelectedColor();
              if (colorSelection !== this.renderedColor)
              {
                  if (navigator.appVersion.indexOf("Trident") !== -1) {

                      //TODO find a solution how to support that on MSIE
                      this.image = "crosshair";
                  }
                  else {
                      var canvas = this.cursorCanvas;
                      var ctx = canvas.getContext("2d");
                      ctx.clearRect(0, 0, canvas.width, canvas.height);
                      ctx.globalAlpha = 0.75;
                      ctx.beginPath();
                      ctx.arc(32 / 2, 32 / 2, 20 / 2, 0, 2 * Math.PI);
                      ctx.fillStyle = colorSelection;
                      ctx.fill();
                      this.image = "url(" + canvas.toDataURL() + ") 16 16, auto";
                  }

                  // console.log(this.image);
                  this.renderedColor = colorSelection;
              }

              this.cursor = new viewer.Cursor(this.image, 1);
          }
          else if (activatedAction == "texthighlight")
          {
             this.cursor = viewer.Cursor.create("text", 1);
          }
          else
          {
              this.cursor = viewer.Cursor.create("crosshair", 2);
          }

          this.displayedAction = activatedAction;
        this.cursorModel.push(this.cursor);
      }
    }

  };

}
(vitrium.viewer,
  vitrium.viewer,
  jQuery));

// script:viewer/event-pipe.js
(function (exports)
{
	"use strict";
	
	exports.pipeEvents = pipeEvents;
	exports.$pipeEvents = $pipeEvents;
	exports.$EventPipe = $EventPipe;
	exports.EventPipeGroup = EventPipeGroup;
	
	var utils = exports;
	var PIPE_POOL = utils.pools.GLOBAL_ARRAY_POOL;
	
	function pipeEvents(source, sourceEventId, destination, destinationEventId)
	{
		if (!destinationEventId) destinationEventId = sourceEventId;
		
		source.on(sourceEventId,handler);
		
		function handler()
		{
			var args = PIPE_POOL.create(arguments.length+1);
			for (var i = 0, len= arguments.length; i < len; ++i)
			{
				args[i+1] = arguments[i];
			}
			args[0] = destinationEventId;
			destination.trigger.apply(destination, args);
			args.free();
		}
		return handler;
	}
	
	function $pipeEvents(source, sourceEventId, selector, destination, destinationEventId)
	{
		if (!destinationEventId) destinationEventId = sourceEventId;
		
		if (!selector)
		{
			source.on(sourceEventId,handler);
		}
		else
		{
			source.on(sourceEventId,selector, handler);
		}
		
		function handler(evt)
		{
			destination.trigger.call(destination, destinationEventId, evt);
		}
		return handler;
	}
	
	function $EventPipe(source, sourceEventId, destination, destinationEventId, selector)
	{
		this.binded = false;
		this.source = source;
		this.sourceEventId = sourceEventId;
		this.selector = selector ? selector : null;
		this.destination = destination;
		this.destinationEventId = destinationEventId ? destinationEventId : null;
		
		this.handler = _.bind(this._handler, this);
	}
	
	$EventPipe.prototype = {
		on : function()
		{
			if (!this.binded)
			{
				if (!this.selector)
				{
					this.source.on(this.sourceEventId, this.handler);
				}
				else
				{
					this.source.on(this.sourceEventId, this.selector, this.handler);
				}

				this.binded = true;
			}
		},
		off : function()
		{
			if (this.binded)
			{
				if (!this.selector)
				{
					this.source.off(this.sourceEventId, this.handler);
				}
				else
				{
					this.source.off(this.sourceEventId, this.selector, this.handler);
				}
				this.binded = false;
			}
		},
		destroy : function()
		{
			this.off();
			this.source = null;
			this.sourceEventId = null;
			this.selector = null;
			this.destination = null;
			this.destinationEventId = null;		
			this.handler = null;
		},
		_handler : function(evt)
		{
			if (this.destinationEventId)
			{
				this.destination.trigger(this.destinationEventId, evt);
			}
			else
			{
				this.destination.trigger(evt.type, evt);
			}
		}
	 };
	 
	 function EventPipeGroup(group)
	 {
		this.group = group;
	 }
	 EventPipeGroup.prototype = {
		on : function()
		{
			var g = this.group;
			for (var i = 0, len=g.length; i < len; ++i)
			{
				g[i].on();
			}
		},
		off : function()
		{
			var g = this.group;
			for (var i = 0, len=g.length; i < len; ++i)
			{
				g[i].off();
			}
		},
		destroy : function()
		{
			var g = this.group;
			for (var i = 0, len=g.length; i < len; ++i)
			{
				g[i].destroy();
			}
			this.group = null;
		}
	 };

}(
vitrium.utils,
_
));
// script:viewer/viewer-event-pipe.js
(function (exports, utils, _)
{
	"use strict";
	var $EventPipe = vitrium.utils.$EventPipe;
	exports.$EventPipe = ViewerEventPipe;
	exports.$MouseWheelEventPipe = MouseWheelEventPipe;
	
	
	function ViewerEventPipe(source, sourceEventId, destination, destinationEventId, selector)
	{
		$EventPipe.call(this, source, sourceEventId, destination, destinationEventId, selector);
		this.state = destination.state;
	}
	
	_.extend(ViewerEventPipe.prototype, $EventPipe.prototype);
	ViewerEventPipe.prototype._handler = function(evt)
	{
		var st = this.state;
		if (this.destinationEventId)
		{
			this.destination.trigger(this.destinationEventId, evt, st);
		}
		else
		{
			this.destination.trigger(evt.type, evt, st);
		}
	};
	
	function MouseWheelEventPipe(source,  destination, destinationEventId, selector)
	{
		ViewerEventPipe.call(this, source, "mousewheel", destination, destinationEventId, selector);
	}
	_.extend(MouseWheelEventPipe.prototype, $EventPipe.prototype);
	MouseWheelEventPipe.prototype._handler = function(evt, delta, deltaX, deltaY)
	{
		var st = this.state;
		if (this.destinationEventId)
		{
			this.destination.trigger(this.destinationEventId, evt, delta, deltaX, deltaY, st);
		}
		else
		{
			this.destination.trigger(evt.type, evt, delta, deltaX, deltaY, st);
		}
	};
	
}(
	vitrium.viewer,
	vitrium.utils,
	_
));
// script:viewer/ui/request-animation-frame-helper.js
(function(exports,vitrium, _, window)
{
  "use strict";
  exports.RequestAnimationFrameHelper = RequestAnimationFrameHelper;
  
  function RequestAnimationFrameHelper(renderCallback)
  {
    this.renderCallback = renderCallback;
    this.internalCallback = _.bind(this.render, this); 
    this.renderRequested = false;
    this.reqId = null;
    this.currentTime = null;
  }
  
  RequestAnimationFrameHelper.prototype = {
    request : function(fakeReq)
    {
      if (!this.reqId)
      {
        this.reqId = window.requestAnimationFrame(this.internalCallback);
      }
      
      if (!fakeReq){	this.renderRequested = true;}
      
    },
    render : function(currentTime)
    {	
      this.currentTime = currentTime;

      var r = this.renderRequested;
      this.renderRequested = false;
      this.reqId  = null;
      if (r)
      {
        this.renderCallback(currentTime);
      }		
      //this.request(true);
    },
    cancel : function()
    {
      if (this.renderRequested)
      {
        window.cancelAnimationFrame(this.reqId);
      }
    }
  };
  
  
  
  (function ()
  {
    if (window.requestAnimationFrame) return;

    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame =
          window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
    }

  window.resetLastTime = function()
  {
    lastTime = Date.now();
  };
    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function(callback, element) {
            var currTime = Date.now();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); },
              timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
}());

}(
vitrium.ui,
vitrium,
_, 
__globals__));
// script:viewer/ui/ui-loop.js
/// <reference path="~/build.html" />
(function (exports, ui, _, Backbone)
{
  "use strict";
  
  exports.UILoop = UILoop;
  exports.UISync = UISync;
  
  function UILoop(context)
  {
    this.context = context;
    this.callbacks = [];
    this.current = null;
    this.i = null;
    this.mainUIRefresh = null;
    this.frameRequester =  new ui.RequestAnimationFrameHelper(_.bind(this.step, this));
  }
  
  UILoop.prototype =
  {
    lastFrameTime : function()
    {
      return this.frameRequester.currentTime;
    },
    step : function(time)
    {
      var callbacks = this.current = this.callbacks;
      this.callbacks = [];
      
      callbacks.sort(uiSyncCompare);
      
      var c = this.context;
      // callbacks can be changed in runAsyncAsap
      for (var i = 0; i < callbacks.length ; ++i)
      {
        this.i = i;
        var s = callbacks[i];
        if (!s.canceled)
        {
          s.funct.call(s.ctx, c, time);
        }
        else
        {
          s.ignored = true;
        }
      }
      this.current = null;
      this.i = null;
    },
    runAsync : function(callback)
    {
//
      var callbacks = this.callbacks;
      if (callbacks.indexOf(callback) === -1)
      {
        callbacks.push(callback);
        this.frameRequester.request();
      }
    },
    runAsyncAsap : function(callback)
    {
//
      if (this.current === null )
      {
        this.runAsync(callback);
      }
      else if (this.current.indexOf(callback) <= this.i)
      {
        // this will get executed in the current frame
        this.current.push(callback);
      }
    },
    refresh : function()
    {
      if (this.mainUIRefresh !== null)
      {
        this.runAsync(this.mainUIRefresh);
      }
    }
  };
  _.extend(UILoop.prototype, Backbone.Events);
  
  function UISync(funct, ctx, priority)
  {
    this.funct = funct;
    this.ctx = ctx;
    this.p = priority;
    this.canceled = false;
    this.ignored = false;
  }

  UISync.prototype = {
    destroy : function()
    {
      this.canceled = true;
      this.funct = null;
      this.ctx = null;
    },
    cancel : function()
    {
      this.canceled = true;
    },
    resume: function ()
    {
      this.canceled = false;
      var ignored = this.ignored;
      this.ignored = false;
      return ignored;
    }
  };
  
  function uiSyncCompare(a, b)
  {
    var ap = a.p;
    var bp = b.p;
    if (ap > bp)
    {
      return 1;
    }
    else if (ap < bp)
    {
      return -1;
    }
    else
    {
      return 0;
    }
  }
}
(
vitrium.ui, 
vitrium.ui, 
_,
Backbone));
// script:viewer/ui/event-lifecycle-manager.js
/// <reference path="~/build.html" />

(function (exports, _)
{
    "use strict";
    exports.EventLifecycleManager = EventLifecycleManager;
    function EventLifecycleManager()
    {
        this._handlers = null;
    }

    EventLifecycleManager.prototype = {
        on : function(obj)
        {
            if (this._handlers === null) this._handlers = [];
            var rargs = [];
            for (var i = 1, len = arguments.length; i < len; ++i) rargs.push(arguments[i]);

            obj.on.apply(obj, rargs);
            rargs.push(obj);

            this._handlers.push(rargs);
            return this;
        },
        offAll : function()
        {
            var handlers = this._handlers;
            if (handlers === null) return;

            for (var i = 0, len = handlers.length; i < len ;++i)
            {
                var rargs = handlers[i];
                var obj = rargs.pop();
                obj.off.apply(obj, rargs);
            }
            this._handlers = null;
            return this;
        }
    };

}
(vitrium.ui, _));

// script:viewer/ui/layout.js
/// <reference path="~/build.html" />

(function (exports, ui, geometry2, $, _, log)
{
  "use strict";
  var ER = new geometry2.Rectangle(0, 0, 0, 0, 0);
  var DIRECTION = exports.DIRECTION = {
    LEFT: 0,
    TOP: 1,
    BOTTOM: 2,
    RIGHT: 4,
    CENTER : 8
  };

  var ORIENTATION = exports.ORIENTATION = {
    HORIZONTAL: 0x10,
    VERTICAL : 0x20
  };

  exports.BasicLayoutManager = BasicLayoutManager;
  exports.BoxLayout = BoxLayout;
  exports.HorizontalAlignLayout = HorizontalAlignLayout;

  exports.IntersectionLayoutGuard = IntersectionLayoutGuard;

  exports.DomWidget = DomWidget;
  exports.DomSizedWidget = DomSizedWidget;
  exports.ContainerWidget = ContainerWidget;
  exports.RootContainerWidget = RootContainerWidget;
  exports.LayoutWidgetProxy = LayoutWidgetProxy;
  exports.LayoutMarginProxy = LayoutMarginProxy;
  exports.LayoutCenterVertical = LayoutCenterVertical;
  exports.LayoutCenterHorizontal = LayoutCenterHorizontal;

  function LayoutManagerBase(containerWidget)
  {
    this.containerWidget = containerWidget;
    this.defaultPriority = -15;
    
    this._uiCalculateLayout = new ui.UISync(this.onLayout, this, this.defaultPriority);
    
    this._resetToDefaultSize = false;
  }
  LayoutManagerBase.prototype = {
    _calculateLayout : function(){},
    calculateLayout: function (dim)
    {
      var guard = this.containerWidget.layoutGuard;
      
      this.containerWidget.broadcastEvent("layout:before", this.containerWidget, this, dim);

      if (guard !== null)
      {
        guard.begin(this._resetToDefaultSize, dim);
        this._resetToDefaultSize = false;
        do
        {
          this._calculateLayout(dim);
        }
        while (!guard.checkLayout())
      }
      else
      {
        this._calculateLayout(dim);
      }

      this.containerWidget.broadcastEvent("layout:after", this.containerWidget, this, dim);
    },
    onLayout : function(context, time) {
      this.calculateLayout(this.containerWidget.dim);
    },
    destroy: function () { this._uiCalculateLayout.destroy(); },
    onSizeChanged : function()
    {
      this._resetToDefaultSize = true;
      this.refresh();
    },
    refresh: function ()
    {
      var uiLoop = this.containerWidget.uiLoop;
      if (uiLoop === null) return;
      // to make sure that layout is calculated in this frame
      this._uiCalculateLayout.p = uiLoop.i === null ? this.defaultPriority : uiLoop.i + 1;
      uiLoop.runAsyncAsap(this._uiCalculateLayout);      
    },
    _attach: function (box, pos)
    {
      if (box === null) return;
      if (box.on) box.on("size:change", this.onSizeChanged, this);
      if (box.onLayoutAttached) box.onLayoutAttached(pos, this);

      this.refresh();
    },
    _dettach: function (box)
    {
      if (box === null) return;

      if (box.off) box.off("size:change", this.onSizeChanged, this);
      if (box.onLayoutDetached) box.onLayoutDetached(this);

      this.refresh();
    },
    checkLayout : function()
    {
      if (this.containerWidget.layoutGuard)
      {
        return this.containerWidget.layoutGuard.checkLayout();
      }
      else
      {
        return true;
      }
    }
  };

  function HorizontalAlignLayout(containerWidget)
  {
    LayoutManagerBase.call(this, containerWidget);
    this._left = null;
    this._right = null;
    this._center = null;
    this.centerVertical = true;
  }
  HorizontalAlignLayout.prototype = Object.create(LayoutManagerBase.prototype);
  HorizontalAlignLayout.prototype._calculateLayout = function (rootDim)
  {
    //var rootDim = this.containerWidget.dim;
   // console.log("[HorizontalAlignLayout] _calculateLayout", time);
    var ol = this._left === null ? ER : this._left.dim;
    var or = this._right === null ? ER : this._right.dim;
    var oc = this._center === null ? ER : this._center.dim;

    var ld = ol.clone();
    var rd = or.clone();
    var cd = oc.clone();

    var sideH = rootDim.h;
    var halfSideH = sideH / 2;
    ld.x = 0;
    
    if (this.centerVertical)
    {
      ld.y = halfSideH - ol.h / 2;
    }
    else
    {
      ld.y = 0;
      ld.h = sideH;
    }

    rd.x = rootDim.w - rd.w;    
    if (this.centerVertical)
    {
      rd.y = halfSideH - or.h / 2;
    }
    else
    {
      rd.y = 0;
      rd.h = sideH;
    }
        
    cd.x = rootDim.w / 2 - oc.w / 2;
    
    if (this.centerVertical)
    {
     cd.y = halfSideH - oc.h / 2;
    }
    else
    {
      cd.y = 0;
      cd.h = sideH;
    }

    if (this._left !== null && !ld.equals(ol)) this._left.dim = ld;
    if (this._right !== null && !rd.equals(or)) this._right.dim = rd;
    if (this._center !== null && !cd.equals(oc)) this._center.dim = cd;
  };

  Object.defineProperties(HorizontalAlignLayout.prototype, {
    left: {
      set: function (left)
      {
        this._dettach(this._left); this._left = left; this._attach(left, DIRECTION.LEFT); return left;
      },
      get: function ()
      {
        return this._left;
      }
    },
    right: {
      set: function (right)
      {
        this._dettach(this._right); this._right = right; this._attach(right, DIRECTION.RIGHT); return right;
      },
      get: function ()
      {
        return this._right;
      }
    },
    center: {
      set: function (center)
      {
        this._dettach(this._center); this._center = center; this._attach(center, DIRECTION.CENTER); return center;
      },
      get: function ()
      {
        return this._center;
      }
    }
  });

  function BoxLayout(containerWidget)
  {
    LayoutManagerBase.call(this, containerWidget);
    this.align = DIRECTION.LEFT;
    this.widgets = [];
    this.center = false;
  }

  BoxLayout.prototype = _.extend(Object.create(LayoutManagerBase.prototype),
  {
    add : function(widget)
    {
      this.widgets.push(widget);
      this._attach(widget, this.align);
      return widget;
    },
    replace : function(idx, widget)
    {
      this._dettach(this.widgets[idx]);
      this._attach(widget, this.align);
      this.widgets[idx] = widget;
    },
    remove : function(idx)
    {
      var widget = this.widgets[idx];
      this.widgets = _.without(this.widgets, widget);
      this._dettach(widget);  
      return widget;
    },
    removeWidget: function(widget)
    {
        var idx = this.widgets.indexOf(widget);
        if (idx !== -1)
        {
            this.remove(idx);
            return true;
        }

        return false;
    },
    prepend: function(widget)
    {
        this.widgets.unshift(widget);
        this._attach(widget, this.align);
        return widget;
    },
    _calculateLayout: function (containerDim)
    {
      
      //   console.log("[BoxLayout] _calculateLayout", time);
     // var containerDim = this.containerWidget.dim;
      var pivot = 0;
      var align = this.align;
      var widgets = this.widgets;
      var center = this.center;
      if (align === DIRECTION.LEFT)
      {
         var halfHeight = containerDim.h / 2;

        for (var i = 0, len = widgets.length; i < len; ++i)
        {
          var w = widgets[i];
          var od = w.dim;
          var d = od.clone();
          d.x = pivot;
          if (this.center)
          {
             d.y = (halfHeight - d.h / 2) | 0;
          }
          else
          {
             d.h = containerDim.h;
          }
          
          pivot += d.w;
          if (!od.equals(d))
          {
            w.dim = d;
          }
          
        }
      }
      else if (align === DIRECTION.RIGHT)
      {
         var halfHeight = containerDim.h / 2;
         pivot = containerDim.w;
         var i = widgets.length;
         while (i--)
         {
            var w = widgets[i];
            var od = w.dim;
            var d = od.clone();

            pivot = d.x = pivot - d.w;
            if (this.center) {
               d.y = ((halfHeight - d.h / 2) | 0) -1;
            }
            else {
               d.h = containerDim.h;
            }

            if (!od.equals(d)) {
               w.dim = d;
            }
         }
      }
      else if (align === DIRECTION.TOP)
      {
        for (var i = 0, len = widgets.length; i < len; ++i)
        {
          var w = widgets[i];
          var od = w.dim;
          var d = od.clone();
          d.w = containerDim.w;

          d.y = pivot;
          pivot += d.h;
          if (!od.equals(d))
          {
            w.dim = d;
          }
        }
      }
      else /*align === DIRECTION.BOTTOM*/
      {
        pivot = containerDim.h;
        for (var i = 0, len = widgets.length; i < len; ++i)
        {
          var w = widgets[i];
          var od = w.dim;
          var d = od.clone();

          d.w = containerDim.w;
          pivot = d.y = pivot - d.h;
          if (!od.equals(d))
          {
            w.dim = d;
          }
        }
      }


    }
  });


  function BasicLayoutManager(containerWidget)
  {
    LayoutManagerBase.call(this, containerWidget);
    this._left = null;
    this._right = null;
    this._center = null;
    this._top = null;
    this._bottom = null;
  }

  BasicLayoutManager.prototype = _.extend(Object.create(LayoutManagerBase.prototype), {
    destroy: function ()
    {
      this._dettach(this._left);
      this._dettach(this._right);
      this._dettach(this._top);
      this._dettach(this._bottom);
      this._dettach(this._center);
    },
    _calculateLayout: function (rootDim)
    {
   //   var rootDim = this.containerWidget.dim;
      //console.log("[BasicLayoutManager] _calculateLayout", time);

      var ot = this._top === null ? ER: this._top.dim;
      var ob = this._bottom === null ? ER : this._bottom.dim;
      var ol = this._left === null ? ER : this._left.dim;
      var or = this._right === null ? ER : this._right.dim;

      var td = ot.clone();
      var bd = ob.clone();
      var ld = ol.clone();
      var rd = or.clone();

      var sideH = rootDim.h - (td.h + bd.h);
      ld.x = 0;
      ld.y = td.h;
      ld.h = sideH;

      td.x = 0;
      td.y = 0;
      td.w = rootDim.w;

      bd.x = 0;
      bd.y = ld.y + ld.h;
      bd.w = rootDim.w;

      rd.x = rootDim.w - rd.w;
      rd.y = td.h;
      rd.h = sideH;

      if (this._center !== null)
      {
        var cd = this._center.dim.clone();
        cd.x = ld.w;
        cd.y = td.h;
        cd.w = rootDim.w - (ld.w + rd.w);
        cd.h = sideH;
        this._center.dim = cd;
      }

      if (this._top !== null && !td.equals(ot)) this._top.dim = td;
      if (this._bottom !== null && !bd.equals(ob)) this._bottom.dim = bd;
      if (this._left !== null && !ld.equals(ol)) this._left.dim = ld;
      if (this._right !== null && !rd.equals(or)) this._right.dim = rd;

    }
  });
  
  Object.defineProperties(BasicLayoutManager.prototype, {
    left: {
      set: function (left)
      {
        this._dettach(this._left); this._left = left; this._attach(left, DIRECTION.LEFT); return left;
      },
      get: function ()
      {
        return this._left;
      }
    },
    right: {
      set: function (right)
      {
        this._dettach(this._right); this._right = right; this._attach(right, DIRECTION.RIGHT); return right;
      },
      get: function ()
      {
        return this._right;
      }
    },
    center: {
      set: function (center)
      {
        this._dettach(this._center); this._center = center; this._attach(center, DIRECTION.CENTER); return center;
      },
      get: function ()
      {
        return this._center;
      }
    },
    top: {
      set: function (top)
      {
        this._dettach(this._top); this._top = top; this._attach(top, DIRECTION.TOP); return top;
      },
      get: function ()
      {
        return this._top;
      }
    },
    bottom: {
      set: function (bottom)
      {
        this._dettach(this._bottom); this._bottom = bottom; this._attach(bottom, DIRECTION.BOTTOM); return bottom;
      },
      get: function ()
      {
        return this._bottom;
      }
    }
  });

  function EventListeners(ctx)
  {
    this._ctx = ctx;
    this._list = [];
    this._eventSource = null;
  }
  EventListeners.prototype = {
    set eventSource (src) {
      this.uninstall();
      this._eventSource = src;
      this.install();
      return src;
    },
    get eventSource()
    {
      return this._eventSource;
    },
    on : function(name, funct)
    {
      this._list.push({ name: name, funct: funct, installed: false });
    },
    install : function()
    {
      if (this._eventSource === null) return;

      var ev = this._eventSource;
      _.each(this._list, function (listener)
      {
        if (!listener.installed)
        {
          ev.on(listener.name, listener.funct, this._ctx);
          listener.installed = true;
        }
      }, this);
    },
    uninstall : function()
    {
      if (this._eventSource === null) return;
      var ev = this._eventSource;
      _.each(this._list, function (listener)
      {
        if (listener.installed)
        {
          ev.off(listener.name, listener.funct, this._ctx);
          listener.installed = false;
        }
      }, this);
    }
  };

  function DomWidget(el)
  {
    this.el = el;
    this.el.style.position = "absolute";
    this._dim = new geometry2.Rectangle(0, 0, 0, 0, 0);
    this._pos = -1;
    this._parent = null;
    
    this._uiRender = new ui.UISync(this.onRender, this, -20);

    this._refreshAfterParent = true;
    this._hasRoot = false;
    this.events = new EventListeners(this);
    this.eventGuard = new ui.EventLifecycleManager();
  }

  DomWidget.prototype = {
      //It registers event handler to an event source which is the first argument
      listen : function()
      {
          this.eventGuard.on.apply(this.eventGuard, arguments);
          return this;
      },
    set parent(p)
    {
      this._parent = p;
      this.onParentAttached();
      return parent;
    },
    get parent()
    {
      return this._parent;
    },
    get dim()
    {
      return this.getDim();
    },
    set dim (val)
    {
      this.setDim(val);
    },
    get absoluteDim ()
    {
      if (this._parent !== null)
      {
        var result = this._parent.absoluteDim;
        result.x += this._dim.x;
        result.y += this._dim.y;
        result.w = this._dim.w;
        result.h = this._dim.h;

        return result;
      }
      else
      {
        return this.dim;
      }
    },
    setDim: function (val)
    {
      var style = this.el.style;
      // style.WebkitTransform = "translate3d(" + val.x + "px," + val.y + "px, 0)";
      style.left = ((val.x+0.5)|0) + "px";
      style.top = ((val.y + 0.5)|0) + "px";
      style.width = ((val.w+0.5) | 0) + "px";
      style.height = ((val.h + 0.5) | 0) + "px";

      
      this._dim = val;
    },
    getDim : function()
    {
      return this._dim;
    },
    onLayoutAttached : function(pos, layout)
    {
      this._pos = pos;
    },
    onLayoutDetached : function()
    {
      this._pos = -1;
    },
    get uiLoop()
    {
      if (this.parent !== null) return this.parent.uiLoop;
      return null;
    },
    refresh: function ()
    {
      var uiLoop = this.uiLoop;
      if (uiLoop !== null)
      {
        uiLoop.runAsync(this._uiRender);
      }
      else
      {
        this._refreshAfterParent = true;
      }
    },
    onRender: function () { /* override this */ },
    broadcastEvent : function()
    {
      var uiLoop = this.uiLoop;
      if (uiLoop !== null) uiLoop.trigger.apply(uiLoop, arguments);
    },
    onParentAttached : function()
    {
      var uiLoop = this.uiLoop;
      this.events.eventSource = uiLoop;
      if (uiLoop !== null && this._refreshAfterParent)
      {
        this._refreshAfterParent = false;
        this.refresh();
      }

      if (this._hasRoot && uiLoop === null)
      {
          this._hasRoot = false;
          this.onDeactivateInternal();
      }
      else if(!this._hasRoot && uiLoop !== null)
      {
          this._hasRoot = true;
          this.onActivate();
      }
    },
    resetToDefaultSize : function()
    {

    },
    makeSmallerIfPosible :function()
    {
      return false;
    },
    makeBiggerIfPosible : function()
    {
      return false;
    },
    compareTo : function(other)
    {
      return 0;
    },
    isDetached: function()
    {
      return false;
    },
    canDetachFromLayout : function()
    {
      return false;
    },
    detachFromLayout : function()
    {

    },
    onActivate : function()
    {

    },
    onDeactivateInternal : function()
    {
        this.eventGuard.offAll();
        this.onDeactivate();
    },
    onDeactivate : function()
    {

    }
  };

  function DomSizedWidget(el)
  {
    DomWidget.call(this, el);
    this.$el = $(this.el);

    this.currentSize = 0;
    this.maxSize = 0;
    this.priority = 0;

    this._checkSizeRequested = null;
  }

  DomSizedWidget.prototype = Object.create(DomWidget.prototype);
  DomSizedWidget.prototype.setDim = function (val)
  {
    this._dim = val;
    var style = this.el.style;
    style.left = ((val.x + 0.5) | 0) + "px";
    style.top = ((val.y +0.5) | 0) + "px";
  };

  DomSizedWidget.prototype.getDim = function (val)
  {
     var el = this.$el;
     if (el.css("display") === "none") {
        this._dim.w = 0;
        this._dim.h = 0;
     }
     else {
        this._dim.w = el.innerWidth();
        this._dim.h = el.innerHeight();
     }
     return this._dim;
  };

  DomSizedWidget.prototype.resetToDefaultSize = function()
  {
    var $el = this.$el;
    for (var i = 1, len=this.currentSize; i <= len;++i)
    {
      $el.removeClass("lmode-"+i);
    }
    this.currentSize = 0;
  };

  DomSizedWidget.prototype.makeSmallerIfPosible = function()
  {
    if (this.currentSize < this.maxSize)
    {
      this.$el.addClass("lmode-"+(++this.currentSize));
      return true;
    }
    else
    {
      return false;
    }
  };

  DomSizedWidget.prototype.makeBiggerIfPosible = function()
  {
    if (this.currentSize > 0)
    {
      this.$el.removeClass("lmode-" + (this.currentSize--));
      return true;
    }
    return false;
  };

  DomSizedWidget.prototype.compareTo = function (other)
  {
    if (this.priority === other.priority)
    {
      if (this.currentSize == other.currentSize)
      {
        return 0;
      }
      else if (this.currentSize > other.currentSize)
      {
        return -1;
      }
      
      else
      {
        return 1;
      }
    }
    else
    {
      if (this.priority < other.priority)
      {
        return 1;
      }
      else if (this.priority > other.priority)
      {
        return -1;
      }
      else
      {
        return 0;
      }
    }
  };

  function LayoutWidgetProxy(widget)
  {
    this.widget = widget;
    if (widget.on) this.on = this._on;
    else this.on = null;
    if (widget.off) this.off = this._off;
    else this.off = null;
    if (widget.onLayoutAttached) this.onLayoutAttached = this._onLayoutAttached;
    else this.onLayoutAttached = null;
    if (widget.onLayoutDetached) this.onLayoutDetached = this._onLayoutDetached;
    else this.onLayoutDetached = null;
  }

  LayoutWidgetProxy.prototype =
  {
    get dim()
    {
      return this.dimOut(this.widget.dim);
    },
    set dim(d)
    {
      return this.widget.dim = this.dimIn(d);
    },
    _on : function(event, callback, ctx)
    {
      this.widget.on(event, callback, ctx);
    },
    _off : function(event, callback, ctx)
    {
      this.widget.off(event, callback, ctx);
    },
    _onLayoutAttached : function(pos, layout)
    {
      this.widget.onLayoutAttached(pos, layout);
    },
    _onLayoutDetached : function(layout)
    {
      this.widget.onLayoutDetached(layout);
    },
    dimOut : function(d)
    {
      return d;
    },
    dimIn : function(d)
    {
      return d;
    },
    onParentAttached : function()
    {
      this.widget.onParentAttached();
    },
    get parent()
    {
      return this.widget.parent;
    }
  };


  function LayoutMarginProxy(widget, margin)
  {
    LayoutWidgetProxy.call(this, widget);
    this.margin = _.extend({ top: 0, bottom: 0, left: 0, right: 0 }, margin);
  }

  LayoutMarginProxy.prototype = _.extend(Object.create(LayoutWidgetProxy.prototype),{
    dimOut : function(dim)
    {
      var d = dim.clone();
      d.w += this.margin.left + this.margin.right;
      d.h += this.margin.top + this.margin.bottom;
      return d;
    },
    dimIn : function(d)
    {
      d.x += this.margin.left;
      d.y += this.margin.top;
      return d;
    }
  });

  function LayoutCenterVertical(widget)
  {
    LayoutWidgetProxy.call(this, widget);
  }

  LayoutCenterVertical.prototype = _.extend(Object.create(LayoutWidgetProxy.prototype), {
    dimIn : function(d)
    {
      var parentDim = this.widget.parent.dim;
      var wd = this.widget.dim;
      d.y += parentDim.h / 2 - wd.h / 2;
      return d;
    }
  });

  function LayoutCenterHorizontal(widget)
  {
    LayoutWidgetProxy.call(this, widget);
  }

  LayoutCenterHorizontal.prototype = _.extend(Object.create(LayoutWidgetProxy.prototype), {
    dimIn: function (d)
    {
      var wd = this.widget.dim;
      d.x += d.w / 2 - wd.w / 2;
      return d;
    }
  });


  function ContainerWidget()
  {
    DomWidget.call(this, document.createElement("div"));
    this._containerEl = document.createElement("div");
    this._containerEl.className = "vitrium-relative-container";

    this.el.appendChild(this._containerEl);

    this._widgets = [];
    this.layoutManager = null;
    this.layoutGuard = null;
    this.events.on("RefreshLayout", this.onTriggerRefreshLayout);

    this.onInit();
  }
  ContainerWidget.prototype = _.extend(Object.create(DomWidget.prototype), {
    onInit: function () { },
    prepend : function(widget)
    {
      this._widgets.push(widget);
      if (widget.el) this._containerEl.insertBefore(widget.el, this._containerEl.firstChild);
      widget.parent = this;
      return widget;
    },
    insertBefore : function(widget, before)
    {
      this._widgets.push(widget);
      if (widget.el) this._containerEl.insertBefore(widget.el, before.el);
      widget.parent = this;
      return widget;
    },
    add : function(widget)
    {
      this._widgets.push(widget);
      if (widget.el) this._containerEl.appendChild(widget.el);
      widget.parent = this;
      return widget;
    },
    remove : function(widget)
    {
      this._widgets = _.without(this._widgets, widget);
      if (widget.el) this._containerEl.removeChild(widget.el);
      widget.parent = null;
      return widget;
    },
    replace: function(idx, widget)
    {
      var old = this._widgets[idx];
      this._containerEl.replaceChild(widget.el, old.el);
      old.parent = null;
      widget.parent = this;      
      this._widgets[idx] = widget;
    },
    setDim: function(dim)
    {
      var old = this.dim;
      if (this.layoutManager !== null)
      {
        // This is truly important, it makes sure that child element never overlap it's bounding 
        if (old.w > dim.w || old.h > dim.h)
        {
          this.layoutManager.calculateLayout(dim);
        }
        this.layoutManager.refresh();
      }

      DomWidget.prototype.setDim.call(this, dim);
    },
    onParentAttached: function ()
    {
      DomWidget.prototype.onParentAttached.call(this);
      _.each(this._widgets, function (w)
      {
        w.onParentAttached();
      });
    },
    onTriggerRefreshLayout : function()
    {
      if (this.layoutManager)
      {
        this.layoutManager.refresh();
      }
    }
  });
  
  ContainerWidget.prototype.constructor = ContainerWidget;
  
  function RootContainerWidget(uiLoop)
  {
    ContainerWidget.call(this);
    this.el.className = "vitrium-root-container";
    this.el.style.position = "static";
    this.$el = $(this.el);

    this._uiResize = new ui.UISync(this._onResize, this, -16);
    this._$window = $(window);
    this.onResize = _.bind(this.refresh, this);
    this._$window.on("resize", this.onResize);
    this._paused = false;
    this._requested = false;

    this._dimValid = false;
    this.parent = { uiLoop: uiLoop };
    this._offset = this._dim.clone();
  }

  RootContainerWidget.prototype = _.extend(Object.create(ContainerWidget.prototype), {
    pause: function ()
    {
      this._paused = true;
    },
    resume: function ()
    {
      var waspaused = this._paused;
      this._paused = false;
      if (waspaused && this._requested)
      {
        this.refresh();
      }
    },
    destroy: function ()
    {
      this._$window.off("resize", this.onResize);
      this._$window = null;
      if (this._box.destroy) this._box.destroy();
      this._box = null;
    },
    init: function ()
    {
      var style = this.el.style;
      style.position = "relative";

      this.refresh();
    },
    refresh: function ()
    {
      this.uiLoop.runAsync(this._uiResize);
    },
    _onResize: function ()
    {

      this._dimValid = false;

      if (this.paused)
      {
        this._requested = true;
      }
      else
      {
        if (vitrium.is_mobile && $.browser.safari)
        {
          //FIXME this might not be good idea if there is other stuff on the page
          //HACK iOS7 DIRECTION changed hack
          this._$window.scrollTop(0);
        }
        
        if (this.layoutManager !== null) this.layoutManager.refresh();
        this._requested = false;
      }
    },
    getDim : function()
    {
      if (!this._dimValid)
      {


        var $w = this._$window;

        var width = this.$el.width();
        var height = this.$el.height();


        var h = $w.height();
        //  alert(h+ " " + height);
        if (h === 692 && navigator.appVersion.indexOf("iPad") !== -1)
        {
          //HACK this is the workaround for iOS 7 Safari landscape bug
          h = 672;
        }

        var w = $w.width();
        if (width === 0 || height === 0)
        {
          var offset = this.$el.offset();

          if (width === 0) this._dim.w = w - offset.left;
          if (height === 0)
          {
            this._dim.h = h - offset.top;
          }
          this._offset.x = offset.left;
          this._offset.y = offset.top;
        }
        if (width !== 0) this._dim.w = width;
        if (height !== 0) this._dim.h = height;

        //   console.log(this._dim.w, width, height);
        this._dimValid = true;
      }
      return this._dim;
    }
  });
  Object.defineProperties(RootContainerWidget.prototype, {
    absoluteDim: {
      get : function()
      {
         var d = this._dim.clone();
         d.x = this._offset.x;
         d.y = this._offset.y;
         return d;
      }
    }
  });
  RootContainerWidget.prototype.constructor = RootContainerWidget;


  function IntersectionLayoutGuard(containerWidget)
  {
    this.containerWidget = containerWidget;
    this.currentSize = null;
    this.growing = false;
  }

  IntersectionLayoutGuard.prototype = {
    begin : function(forceReset, containerDim)
    {
      var dim = containerDim.clone();
      if (this.currentSize !== null)
      {
        if (dim.w > this.currentSize.w)
        {
          if (this.makeItBigger())
          {
            this.growing = true;
          }
        }
        else
        {
          this.growing = false;
        }

        this.currentSize = dim.clone();
      }
     
      if (forceReset)
      {
        this.resetToDefaultSize();
        this.growing = false;
      }

      this.currentSize = dim;
    },
    resetToDefaultSize : function()
    {
      var isBigger = false;
      _.each(this.containerWidget._widgets, function(widget)
      {
        widget.resetToDefaultSize();
      });
    },
    makeItBigger : function()
    {
      var isBigger = false;
      _.each(this.containerWidget._widgets, function(widget)
      {
        var bigger = widget.makeBiggerIfPosible();
        isBigger = isBigger || bigger;
      });

      return isBigger;
    },
    findIntersectedWidgets : function()
    {
      var sin = Math.sin, cos = Math.cos;
      var intersecting = [];
      var widgets = this.containerWidget._widgets;

      for (var i = 0, len=widgets.length; i < len; ++i)
      {
        var widget = widgets[i];
        var dim = widget.dim.clone();

        dim.x -= 5;
        dim.w += 10;
        for (var o = i + 1 ; o < len; ++o)
        {       
          var otherWidget = widgets[o];
          var odim = otherWidget.dim;
          if (dim.isIntersectedFast(odim, cos, sin))
          {
            var otherPriority = otherWidget.compareTo(widget);
            var widgetPriority = widget.compareTo(otherWidget);

            if (otherPriority >= 0)
            {
              if (intersecting.indexOf(otherWidget) === -1) intersecting.push(otherWidget);
            }
            if (widgetPriority >= 0)
            {
              if (intersecting.indexOf(widget) === -1) intersecting.push(widget);
            }           
          } 
        }
      }
      return intersecting;
    },
    checkLayout : function()
    {
      var intersecting = this.findIntersectedWidgets();
      if (intersecting.length > 0)
      {
        var hasChanged = false;
        var widgets = this.containerWidget._widgets;
        for (var i = 0, len = intersecting.length; i < len; ++i)
        {
          var widget = intersecting[i];
          var smaller = widget.makeSmallerIfPosible();
          hasChanged = hasChanged || smaller;
        }

        this.growing = false;

        if (hasChanged)
        {
        
          //let's trigger relayout
          return false;
        }
        else
        {
          log.warn("Broken layout imposible to adjust it");
          return true;
        }
      }
      else
      {
        if (this.growing)
        {
          return ! (this.growing = this.makeItBigger())
        }
        return true;
      }

    }
  };


}
(vitrium.ui,
vitrium.ui,
vitrium.geometry2,
jQuery,
_,
vitrium.log
));

// script:viewer/ui/icon-provider.js
/// <reference path="~/build.html" />

(function (exports,ui, _, $)
{
  "use strict";

  exports.IconCache = IconCache;
  exports.icon = function (id)
  {
    if (window.__vitrium_icons__ && id in window.__vitrium_icons__)
    {
      var dom = new DOMParser().parseFromString(window.__vitrium_icons__[id], "image/svg+xml");
      var img = document.createElement("div");

      img.appendChild(dom.firstChild);
   //   console.log(img);
      var w = new ui.DomWidget(img);
      img.className = "icon";
      return w;
    }
    else
    {
      return new CSSIcon(id);
    }
  };

  function CSSIcon(name)
  {
    ui.DomWidget.call(this, document.createElement("div"));
    var i = this.i = document.createElement("i");
    this.el.className = "icon";
    this.el.appendChild(i);

    i.className = "fa fa-" + name;
    //
  }

  CSSIcon.prototype = _.extend(Object.create(ui.DomWidget.prototype),{
    setDim : function(v)
    {
      ui.DomWidget.prototype.setDim.call(this, v);
      //
        this.el.style.fontSize = (v.h-8) + "px";
      //
    }
  });

  /*function svgIcon(n)
  {
    var img = document.createElement("div");
    $.get("misc/svg-icons/icons/" + n + ".svg", function (data)
    {
      img.appendChild(data.firstChild);
    });

    return img;
  }*/

  function IconCache()
  {
      this._icons = {};
  }

  IconCache.prototype =
  {
      icon : function (id)
      {
          if (id in this._icons)
          {
              return this._icons[id];
          }
          else
          {
              return this._icons[id] = ui.icon(id);
          }
      }

  };

}
(
vitrium.ui,
vitrium.ui,
_,
jQuery));

// script:viewer/ui/easing-functions.js
/// <reference path="~/build.html" />

(function (exports)
{
  "use strict";
  /*
 * Easing Functions - inspired from http://gizma.com/easing/
 * only considering the t value for the range [0, 1] => [0, 1]
 */
  var EasingFunctions = {
    // no easing, no acceleration
    linear: function (t) { return t },
    // accelerating from zero velocity
    easeInQuad: function (t) { return t * t },
    // decelerating to zero velocity
    easeOutQuad: function (t) { return t * (2 - t) },
    // acceleration until halfway, then deceleration
    easeInOutQuad: function (t) { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t },
    // accelerating from zero velocity 
    easeInCubic: function (t) { return t * t * t },
    // decelerating to zero velocity 
    easeOutCubic: function (t) { return (--t) * t * t + 1 },
    // acceleration until halfway, then deceleration 
    easeInOutCubic: function (t) { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1 },
    // accelerating from zero velocity 
    easeInQuart: function (t) { return t * t * t * t },
    // decelerating to zero velocity 
    easeOutQuart: function (t) { return 1 - (--t) * t * t * t },
    // acceleration until halfway, then deceleration
    easeInOutQuart: function (t) { return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t },
    // accelerating from zero velocity
    easeInQuint: function (t) { return t * t * t * t * t },
    // decelerating to zero velocity
    easeOutQuint: function (t) { return 1 + (--t) * t * t * t * t },
    // acceleration until halfway, then deceleration 
    easeInOutQuint: function (t) { return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t }
  };

  exports.EasingFunctions = EasingFunctions;

}
(vitrium.ui));

// script:viewer/ui/side-toolbar.js
/// <reference path="~/build.html" />

(function (exports, ui, log, vitrium, Backbone, _, $)
{
  "use strict";


  exports.SideToolbar = SideToolbar;
  exports.Toolbar = Toolbar;

  exports.SidePanel = SidePanel;
  exports.bootstrapIcon = bootstrapIcon;

  var ST_CLOSED = 0;
  var ST_OPEN = 1;
  var ST_OPENING = 2;
  var ST_OPENING_START = 3;
  var ST_CLOSING_START = 4;
  var ST_CLOSING = 5;

  
  function Toolbar()
  {
    ui.ContainerWidget.call(this);
    this.el.className = "vitrium-toolbar";
    this.layoutManager = new ui.BoxLayout(this);
    
    this.requestSelected = -1;
    this.selected = -1;
    this.oldSelection = -1;
    this.orientation = null;

    this.calculatedOrientation = null;
    this.currentX = 0;

    this.counter = 0;

    this.doLayoutSort = false;
    this.events.on("layout:before", function (widget, layout, dim)
    {
      if (this.doLayoutSort && this === widget)
      {
        layout.widgets.sort(function (a, b)
        {
          var aO = a._toolbarOrder;
          var bO = b._toolbarOrder;

          if (aO === bO)
          {
            return a._toolbarIndex - b._toolbarIndex;
          }

          return aO - bO;
        });

        this.doLayoutSort = false;
      }
    });
  }

  Toolbar.prototype = _.extend(Object.create(ui.ContainerWidget.prototype),
  {
    
    add : function(widget, order)
    {
      ui.ContainerWidget.prototype.add.call(this, widget);
      this.layoutManager.add(widget);

      this.calculatedOrientation = null;
      widget._toolbarIndex = this.counter++;
      if (typeof order !== "undefined")
      {
        widget._toolbarOrder = order;
      }
      else
      { widget._toolbarOrder = 0;};

      this.doLayoutSort = true;

      var x = this.currentX;
      this.currentX = 0;
      this.setIconsSize(x);

      return widget;
    },
    replace: function(idx, widget)
    {
      this.calculatedOrientation = null;
      var oldWidget = this._findWidget(idx);
      var oldEl = oldWidget.el;
      ui.ContainerWidget.prototype.replace.call(this, this._findIdx(idx), widget);

      this.layoutManager.replace(this.layoutManager.widgets.indexOf(oldWidget), widget);
      widget._toolbarIndex = oldWidget._toolbarIndex;
      widget._toolbarOrder = oldWidget._toolbarOrder;

      if (this.selected === idx)
      {
        this.select(idx);
        $(oldEl).removeClass("selected");
      }
      var x = this.currentX;
      this.currentX = 0;
      this.setIconsSize(x);

     
    },
    _findIdx : function(idx)
    {
      var w = this._widgets;
      for (var i = 0, len =w.length; i < len;++i)
      {
        if (w[i]._toolbarIndex === idx) return i;
      }
      return null;
    },
    _findWidget : function(idx)
    {
      return this._widgets[this._findIdx(idx)];
    },
    removeByIdx : function(idx)
    {
      var oldWidget = this._findWidget(idx);
      this.remove(oldWidget);
      this.layoutManager.remove(this.layoutManager.widgets.indexOf(oldWidget));

      if (this.selected === idx)
      {
        this.selected = -1;
        $(oldWidget.el).removeClass("selected");
      }

      return oldWidget;
    },
    select : function(idx)
    {
      if (idx=== -1 || this._findIdx(idx) !== null)
      {
        this.oldSelection = this.selected;
        this.requestSelected = idx;
        this.refresh();
      }
      else
      {
        log.error("[Toolbar] selected index is out of range");
      }
    },
    onRender : function()
    {
      if (this.oldSelection !== -1)
      {
        $(this._findWidget(this.oldSelection).el).removeClass("selected");

        if (this.requestSelected === -1)
        {
          this.selected = -1;
        }
      }
      if (this.requestSelected !== -1)
      {
        $(this._findWidget(this.requestSelected).el).addClass("selected");
        this.selected = this.requestSelected;
      }
      
      this.requestSelected = -1;
      this.oldSelection = -1;
    },
    setIconsSize: function (x)
    {
      if (this.currentX !== x)
      {
        this.calculatedOrientation = null;
        var icons = this._widgets;
        for (var i = 0, len = icons.length; i < len; ++i)
        {
          var icon = icons[i];
          var dim = icon.dim;
          dim.w = dim.h = x;
          icon.dim = dim;
        }
        this.currentX = x;
        if (this.orientation === ui.ORIENTATION.VERTICAL)
        {
          this._dim.w = x;
        }
        else
        {
          this._dim.h = x;
        }
        
        this.dim = this._dim;
        this.layoutManager.refresh();
      }
    },
    getDim : function()
    {
      if (this.calculatedOrientation !== null && this.calculatedOrientation === this.orientation)
      {
        return this._dim;
      }
      else
      {
        var dim = this._dim.clone();
        var widgets = this._widgets;
        if (this.orientation === ui.ORIENTATION.VERTICAL)
        {
          this.layoutManager.align = ui.DIRECTION.TOP;
          dim.w = Number.MIN_VALUE;
          for (var i = 0, len = widgets.length; i < len; ++i)
          {
            var d = widgets[i].dim;
            dim.w = Math.max(d.w, dim.w);
          }
        }
        else
        {
          this.layoutManager.align = ui.DIRECTION.LEFT;

          dim.h = Number.MIN_VALUE;
          for (var i = 0, len = widgets.length; i < len; ++i)
          {
            var d = widgets[i].dim;
            dim.h = Math.max(d.h, dim.h);
          }
        }
        this._dim = dim;
        this.calculatedOrientation = this.orientation;
        return dim;
      }
    }
  });

  _.extend(Toolbar.prototype, Backbone.Events);


  function SideToolbar()
  {
    ui.ContainerWidget.call(this);
    this.el.className = "vitrium-side-toolbar";
    this.el.style.zIndex = 1;

    this.layoutManager = new ui.BasicLayoutManager(this);
    //this.layoutGuard = new SideToolbarLayoutGuard(this);

    this.toolbar = this.add(new Toolbar());
    

    $(this.toolbar.el).on("tap click", ".icon", _.bind(this._onBarIconClicked, this));
    

    this._panels = [];

    this._state = ST_CLOSED;
    this._panelIdx = -1;
    this._reqPanelIdx = -1;
    

    this._startTime = null;
    this._openDuration = 500;
    
    this._closedSize = null;

    this._openOptimalSize = 300;
    this._openSize = this._openOptimalSize;
    this._openDetached = false;
    this._removedPanel = null;

    this.parentDim = null;
    this.events.on("action:ClosePanel", this.onClosePanel);
    this.events.on("action:ClosePanelIfDetached", this.closePanelIfDetached);

    this.events.on("SideToolbar:open", this.onSideToolbarOpened);

    this.events.on("layout:before", function (widget, layout, dim)
    {
      if (widget === this.parent && !dim.equals(this.parentDim))
      {
        var or = this.toolbar.orientation;
        var x = 40;
        if (or === ui.ORIENTATION.VERTICAL)
        {
          var pivot = dim.w / 15;
          if (pivot > 64)
          {
            x = 52;
          }
          else if (pivot > 48)
          {
            x = 48;
          }

          
          this.updatePanelAppearance(Math.min(dim.w - x, this._openOptimalSize), dim.w / this._openOptimalSize < 3);
        }
        else
        {
          var pivot = dim.h / 20;
        //  alert(pivot);
          if (pivot > 64)
          {
            x = 52;
          }
          else if (pivot > 48)
          {
            x = 48;
          }

          this.updatePanelAppearance(Math.min(dim.h - x, this._openOptimalSize), dim.h / this._openOptimalSize < 3);
        }

        this.setToolbarSize(x);
        this.parentDim = dim.clone();

        
      }
      

    });
  }

  SideToolbar.prototype = _.extend(Object.create(ui.ContainerWidget.prototype),
  {
    onActivate: function()
    {
      this.parentDim = null;
      this._closedSize = null;
      this.toolbar.currentX = 0;
      this.layoutManager.refresh();
    },
    isOpenDetached : function()
    {
      return this._state === ST_OPEN && this._openDetached;
    },
    updatePanelAppearance : function(openedPanelSize, openDetached)
    {
      if (this._state !== ST_CLOSED && this._state !== ST_OPENING_START)
      {
        if (this._openDetached !== openDetached)
        {
          if (openDetached)
          {
            this.layoutManager.center = null;
          }
          else
          {
            this.layoutManager.center = this._panels[this._panelIdx];
            if (this._state === ST_OPEN)
            {
              this._updateDim(this._closedSize + this._openSize);
            }
          }
        }

        this.refresh();
      }

      this._openSize = openedPanelSize;
      this._openDetached = openDetached;
    },
    setToolbarSize : function(x)
    {
      if (this._closedSize !== x)
      {
        this._closedSize = x;
        if (this._state === ST_OPEN)
        {
          this._updateDisplaySize(x, this._openSize, this._panels[this._panelIdx]);
        }
        else
        {
          this._updateDim(x);
        }

        this.toolbar.setIconsSize(x);
      }      
    },
    onLayoutAttached: function (direction, layout)
    {
      ui.DomWidget.prototype.onLayoutAttached.call(this, direction, layout);
      if (direction === ui.DIRECTION.LEFT)
      {
        this.layoutManager.left = this.toolbar;
        this.toolbar.orientation = ui.ORIENTATION.VERTICAL;
        
      }
      else if (direction === ui.DIRECTION.RIGHT)
      {
        this.layoutManager.right = this.toolbar;
        this.toolbar.orientation = ui.ORIENTATION.VERTICAL;
      }
      else if (direction === ui.DIRECTION.TOP)
      {
        this.layoutManager.top = this.toolbar;
        this.toolbar.orientation = ui.ORIENTATION.HORIZONTAL;
      }
      else
      {
        this.layoutManager.bottom = this.toolbar;
        this.toolbar.orientation = ui.ORIENTATION.HORIZONTAL;
      }

      this._updateDim(this._closedSize);
    },
    
    addPanel: function (panel, order)
    {
      this._panels.push(panel);
      var icon = panel.icon;
      icon.el.setAttribute("idx", this._panels.length - 1);
     /* icon._dim.w = icon._dim.h = 64;
      icon.dim = icon._dim;*/
    //  icon.el.className = "icon";
      panel._toolbarIndex = this.toolbar.add(icon, order)._toolbarIndex;

      panel.on("change:icon", this.onPanelIconChanged, this);
      return panel;
    },
    removePanel : function(panel)
    {
      var idx = this._panels.indexOf(panel);
      
      if (this._reqPanelIdx === idx) this._reqPanelIdx  = -1;
      if (this._panelIdx === idx)
      {
       // this._removedPanel = panel;
        this.remove(panel);
        this._panelIdx = -1;
        this.layoutManager.center = null;
        this._state = ST_CLOSED;
      }

      panel.off("change:icon", this.onPanelIconChanged, this);
      this._panels = _.without(this._panels, panel);
      this.toolbar.removeByIdx(panel._toolbarIndex);
    },
    onPanelIconChanged : function(panel, icon)
    {
      var idx = this._panels.indexOf(panel);
      icon.el.setAttribute("idx", idx);
      this.toolbar.replace(panel._toolbarIndex, icon);
    },
    onRender: function (context, time)
    {
      var panels = this._panels;
  
      if (this._state === ST_OPENING_START)
      {
        this._startTime = time;
        this._state = ST_OPENING;
        this._changePanel(panels);
          
     //   this.refresh();
      }
      else if (this._state === ST_CLOSING_START)
      {
        this._startTime = time;
        this._state = ST_CLOSING;
        
        //this.refresh();
      }

      if (this._state === ST_OPEN)
      {
        this._changePanel(panels);
        var panel = panels[this._panelIdx];
          
        this._updateDisplaySize(this._closedSize, this._openSize, panel);
      }
      else if (this._state === ST_OPENING)
      {
        var panel = panels[this._panelIdx];
        var posTime = time - this._startTime;

        var pos = this._ease(Math.min(posTime / this._openDuration, 1.0));
               
        this._updateDisplaySize(this._closedSize , (pos * this._openSize), panel);

        if (pos === 1.0)
        {
          this._state = ST_OPEN;
        }
        else
        {
          this.refresh();
        }
      }
      else if (this._state === ST_CLOSING)
      {
        var panel = panels[this._panelIdx];
        var posTime = time - this._startTime;
        var pos = this._ease(Math.min(posTime / this._openDuration, 1.0));
        this._updateDisplaySize(this._closedSize , this._openSize - (this._openSize * pos), panel);

        if (pos === 1.0)
        {
          this._state = ST_CLOSED;
        }
        else
        {
          this.refresh();
        }
      }
        
      if (this._state === ST_CLOSED)
      {
        if (this._panelIdx !== -1)
        {
          if (this._removedPanel !== null)
          {
            this.remove(this._removedPanel);
            this._removedPanel = null;
          }
          else
          {
            this.remove(this._panels[this._panelIdx]);
          }

          this.layoutManager.center = null;
          this.toolbar.select(-1);
          this.broadcastEvent("SideToolbar:closed", this, this._panels[this._panelIdx]);
        }
        this._panelIdx = -1;
      }
    },
    _changePanel :  function(panels)
    {
      if (this._reqPanelIdx !== -1)
      {
        _.each(panels, function (panel) { panel.lastOpened = false; });

        var oldPanel = null;
        if (this._panelIdx !== -1)
        {
          oldPanel = panels[this._panelIdx];

          this.remove(oldPanel);
        }

        if (this._openDetached)
        {
          this.prepend(panels[this._reqPanelIdx]);
          this.layoutManager.center = null;
        }
        else
        {
          this.layoutManager.center = this.prepend(panels[this._reqPanelIdx]);
        }
                

        this._panelIdx = this._reqPanelIdx;
        this._reqPanelIdx = -1;
        var currentPanel = this._panels[this._panelIdx];
        currentPanel.lastOpened = true;

        this.broadcastEvent("SideToolbar:opened", this, currentPanel);

        
      }
    },
    _ease : function(t)
    {
      return ui.EasingFunctions.easeInOutQuint(t);
    },
    _updateDisplaySize : function(toolbarDim, panelDim, panel)
    {
      if (this._openDetached)
      {
        this._updateDim(toolbarDim);
        this._updatePanelDim(panel, panelDim);
      }
      else
      {
        this._updateDim(toolbarDim + panelDim);
      }
    },
    _updateDim : function(dim)
    {
      var old;
      if (this._pos == ui.DIRECTION.LEFT || this._pos == ui.DIRECTION.RIGHT)
      {
        old = this._dim.w;
        if (old !== dim)  this._dim.w = dim;
      }
      else
      {
        old = this._dim.h;
        if (old !== dim) this._dim.h = dim;
      }

      if (old !== dim)
      {
        this.dim = this._dim;
        this.trigger("size:change");
        this.layoutManager.refresh();
      }
    },
    _updatePanelDim :function(panel, dim)
    {
      var d = panel._dim;
      if (this._pos == ui.DIRECTION.LEFT || this._pos == ui.DIRECTION.RIGHT)
      {
        d.w = dim;
        d.x = this._closedSize;
        d.h = this._dim.h;
      }
      else
      {
        d.h = dim;
        d.y = this._closedSize;
        d.w = this._dim.w;
      }

        panel.dim = panel._dim;
     
    },
    _onBarIconClicked : function(e)
    {
      this.openPanel(parseInt($(e.currentTarget).attr("idx"), 10));
      if (e.type === "click")
      {
        e.preventDefault();
        e.stopPropagation();
      }      
      
    },
    openPanel : function(idx)
    {
      if (this._panelIdx === idx)
      {
        this.closePanels();
        return;
      }
      if (this._reqPanelIdx === idx) return;

      

      this.toolbar.select(this._panels[idx]._toolbarIndex);
      if (this._state === ST_OPENING_START || this._state === ST_OPEN)
      {
        this._state = ST_OPEN;
      }
      else
      {
        this._state = ST_OPENING_START;
      }

      this._reqPanelIdx = idx;
      this.refresh();
      this.broadcastEvent("SideToolbar:open", this, idx);
    },
    closePanels : function()
    {
      if (this._state !== ST_CLOSED && this._state !== ST_CLOSING && this._state !== ST_CLOSING_START)
      {
        this._state = ST_CLOSING_START;
        this.refresh();
      }
    },
    onSideToolbarOpened : function(other, idx)
    {
      // if there is other opened sidebar I close this one
      if (other !== this)
      {
        this.closePanels();
      }
    },
    onClosePanel : function(panel)
    {
      if (this._state === ST_OPEN && this._panels[this._panelIdx] === panel)
      {
        this.closePanels();
      }
    },
    closePanelIfDetached : function()
    {
      if (this._state === ST_OPEN && this._openDetached)
      {
        this.closePanels();
      }
    }
  });
  _.extend(SideToolbar.prototype, Backbone.Events);

  function SidePanel(icon)
  {
    ui.ContainerWidget.call(this);
    this.icon = null;
    this.setIcon(icon);
    this.el.className = vitrium.is_mobile ? "vitrium-side-panel" : "vitrium-side-panel desktop";
    this.lastOpened = false;
  }

  SidePanel.prototype = _.extend(Object.create(ui.ContainerWidget.prototype),
  {
    setDim : function(dim)
    {
      if (this.parent !== null)
      {
        if (this.parent._state === ST_OPENING || this.parent._state === ST_CLOSING)
        {
          if (this.parent._pos === ui.DIRECTION.LEFT) // I am on left side
          {
            dim.x -= this.parent._openSize - dim.w;
            dim.w = this.parent._openSize;
          }
          else if (this.parent._pos === ui.DIRECTION.RIGHT)
          {
            dim.w = this.parent._openSize;
          }
        
          else if (this.parent._pos === ui.DIRECTION.TOP)
          {
            dim.y -= this.parent._openSize - dim.h;
            dim.h = this.parent._openSize;
          }
          else 
          {
            dim.h = this.parent._openSize;
          }
        }
      }
          
      ui.ContainerWidget.prototype.setDim.call(this, dim);
    },
    setIcon : function(icon)
    {
      this.icon = _.isElement(icon) ? new ui.DomWidget(icon) : icon;
      this.trigger("change:icon", this, this.icon);
    }
  });

  _.extend(SidePanel.prototype, Backbone.Events);


  function bootstrapIcon(id)
  {
    var div = document.createElement("div");
    div.innerHTML = "<i class='" + id + "'></i>";
    return div;
  }
}
(vitrium.ui,
vitrium.ui,
vitrium.log,
vitrium,
Backbone,
_,
jQuery));

// script:viewer/ui/labeled-side-panel.js
/// <reference path="~/build.html" />
(function (exports, ui, i18n)
{
  "use strict";

  exports.LabeledSidePanel = LabeledSidePanel;

  function ClosableLabel()
  {
    ui.ContainerWidget.call(this);
    this.el.className = "vitrium-closable-label";

    this.layoutManager = new ui.HorizontalAlignLayout(this);

    this.label = this.add(new ui.DomSizedWidget(document.createElement("div")));
    this.layoutManager.left = new ui.LayoutMarginProxy(this.label, { left: 10 });

    this.button = this.layoutManager.right = new ui.LayoutMarginProxy(this.add(new ui.DomSizedWidget(document.createElement("div"))), { right: 10 });
    this.button.widget.$el.html("<button class='btn' type='button'><i class='fa fa-times'></i></button>");

    this.button.widget.$el.find("button").on("tap click", _.bind(function ()
    {
      this.broadcastEvent("action:ClosePanel", this.parent);
    }, this));

    this.dim.h = 32;
  }

  ClosableLabel.prototype = Object.create(ui.ContainerWidget.prototype);
  ClosableLabel.prototype.onActivate = function ()
  {
     this.listen(i18n, "language:changed", this.onLanguageChanged, this);
     this.onLanguageChanged();
  };
  ClosableLabel.prototype.onLanguageChanged = function ()
  {
      this.button.widget.$el.find("button").attr("title", i18n._T("side-panel-close"));

  };



  function LabeledSidePanel(icon, labelKey)
  {
    ui.SidePanel.call(this, icon);
    this.layoutManager = new ui.BasicLayoutManager(this);
    this.label = this.layoutManager.top = this.add(new ClosableLabel());
    
    this.labelKey = labelKey;
    //FIXME should be in the activate method but because of icon it is not posible
    i18n.on("language:changed", this.onLanguageChanged, this);

    this.onLanguageChanged();
  }
  


  LabeledSidePanel.prototype = Object.create(ui.SidePanel.prototype);

  LabeledSidePanel.prototype.onLanguageChanged = function ()
  {
      var label = i18n._T(this.labelKey);
      this.setLabel(label);
      this.setIconLabel(label);
  };

  LabeledSidePanel.prototype.setIconLabel = function(label)
  {
      $(this.icon.el).attr("title", label);
      $(this.icon.i).attr("title", label);
  },
  LabeledSidePanel.prototype.setLabel = function(label)
  { 
    this.label.label.$el.text(label);
  };



}
(
vitrium.ui,
vitrium.ui,
vitrium.i18n));

// script:viewer/ui/scrollable-viewport.js
(function (exports, geometry)
{
	"use strict";
	
	var ui = exports;
	
	exports.ScrollableViewport = ScrollableViewport;
	
	function ScrollableViewport()
	{
		/**
			public attributes
		*/
		this.vScroll = new ui.ScrollBar();
		this.hScroll = new ui.ScrollBar();
		
		this.barThickness = 20;
		this.viewport = { width : 0, height : 0, innerWidth: 0, innerHeight: 0, contentWidth: 0, contentHeight:0};
	}
	
	ScrollableViewport.prototype = {
		changeDimensions: function(viewportWidth, viewportHeight, contentWidth, contentHeight)
		{
			var v = this.viewport;
			v.width = viewportWidth;
			v.height = viewportHeight;
			v.innerWidth = viewportWidth;
			v.innerHeight = viewportHeight;
			v.contentWidth = contentWidth;
			v.contentHeight = contentHeight;
			
			
			
			var changed = this.vScroll.changeDimensions(viewportHeight, contentHeight);
			var vScrollVisible = this.vScroll.visible;
			if (vScrollVisible)
			{
				viewportWidth -= this.barThickness;
				v.innerWidth = viewportWidth;
			}
			
			changed =  this.hScroll.changeDimensions(viewportWidth, contentWidth) || changed ;
			if (this.hScroll.visible)
			{
				viewportHeight -= this.barThickness;
				v.innerHeight = viewportHeight;
				
				changed = this.vScroll.changeDimensions(viewportHeight, contentHeight) || changed;
				if (!vScrollVisible && this.vScroll.visible)
				{
					viewportWidth -= this.barThickness;
					v.innerWidth = viewportWidth;
					changed =  this.hScroll.changeDimensions(viewportWidth, contentWidth) || changed ;
				}
			}
			
			return changed;
		},
		changeViewportDimensions : function(viewportWidth, viewportHeight)
		{
			var v = this.viewport;
			return this.changeDimensions(viewportWidth, viewportHeight, v.contentWidth, v.contentHeight);
		},
		changeContentDimensions : function(contentWidth, contentHeight)
		{
			var v = this.viewport;
			return this.changeDimensions(v.width, v.height, contentWidth, contentHeight);
		},
		setScrollPos : function(x, y)
		{
			var changed = this.hScroll.changeContentPosition(x);
			changed = this.vScroll.changeContentPosition(y) || changed;
			
			return changed;
		},
		setVScrollPos : function(y)
		{
			return this.vScroll.changeContentPosition(y);
		},
		setHScrollPos : function(x)
		{
			return this.hScroll.changeContentPosition(x);
		},
		setVHandlePos : function(y)
		{
			return this.vScroll.setHandlePosition(y);
		},
		setHHandlePos : function(x)
		{
			return this.hScroll.setHandlePosition(x);
		},
		scrollRelative: function(deltaX, deltaY)
		{
			var changed = false;
			if (deltaX !== 0)
			{
				changed = this.hScroll.scrollRelative(deltaX);
			}
			
			if (deltaY !== 0)
			{
				changed = this.vScroll.scrollRelative(deltaY) || changed;
			}
			
			return changed;
		}
	};
	

}(
vitrium.ui,
vitrium.geometry
));
// script:viewer/ui/list-view.js
/// <reference path="~/build.html" />

(function (exports, ui, $, _, Backbone)
{
  "use strict";

  exports.ListView = ListView;


  function ListView(model, renderItem)
  {
    ui.DomWidget.call(this, document.createElement("div"));
    this.el.className = "vitrium-list-view";
    this.$el = $(this.el);

    this.model = model;

    this.renderItem = renderItem ? renderItem : null;
    
	if ($.browser.chrome)
	{
		this.hammer = new Hammer(this.el, {
			stop_browser_behavior : {
				touchAction : ""
			}
		});
	}
	else
	{
		this.hammer = new Hammer(this.el);
	}
  
    this.hammer.on("tap", _.bind(this.onTap, this)).on("doubletap", _.bind(this.onDoubleTap, this));
    
    

    //HACK this hack fixes weird scroll behavior on touch devices
    this.hammer.on("dragend", function () { setTimeout(function () { if ($(window).scrollTop() !== 0) { $(window).scrollTop(0); }}, 0);});
    this.preventDefaultMouseBehavior = true;
  }
 

  ListView.prototype = Object.create(ui.DomWidget.prototype);
  ListView.prototype.onActivate = function ()
  {
    this.listen(this.model, "changed", this.refresh, this)
    .listen(this.$el, "mousedown", ".vitrium-list-item", _.bind(this.onListItemClicked, this))
    .listen(this.$el, "dblclick", ".vitrium-list-item", _.bind(this.onDoubleClicked, this));

      this.refresh();
  };
  ListView.prototype.handleButton = function (evt)
  {
    var $target = $(evt.target);
    if (!$target.is("[data-action],button"))
    {
      $target = $target.parents("[data-action],button");
      if ($target.length === 0)
      {
        $target = null;
      }
    }

    if ($target !== null)
    {
      var $item = $target.parents(".vitrium-list-item");
      if ($item.length === 1)
      {
        var idx = parseInt($item.attr("idx"), 10);
        var action = $target.attr("data-action");

        this.trigger("button:clicked", this.model.getItem(idx), idx, $target);

        if (!_.isEmpty(action))
        {
          this.trigger("action:"+action, this.model.getItem(idx), idx, $target);
        }
        return true;
      }      
    }
    return false;
  };

  ListView.prototype.onDoubleClicked = function (evt)
  {
    evt.preventDefault();
    evt.stopPropagation();

    var idx = $(evt.currentTarget).attr("idx");
    idx = parseInt(idx, 10);
    this.trigger("item:doubleclicked", this.model.getItem(idx), idx, this, false);
  };

  ListView.prototype.onDoubleTap = function (evt)
  {
    var idx = this.getItemIdx(evt);
    if (idx !== null)
    {
      this.trigger("item:doubleclicked", this.model.getItem(idx), idx, this, true);
    }
  };

  ListView.prototype.onTap = function (evt)
  {
    if (!this.handleButton(evt))
    {
      var idx = this.getItemIdx(evt);
      if (idx !== null)
      {
        this.trigger("item:clicked", this.model.getItem(idx), idx, this, true);
      }
    }
  };

  ListView.prototype.getItemIdx = function (evt)
  {
    var item = $(evt.target).parents(".vitrium-list-item");
    var idx = null;
    if (item.length === 1)
    {
      idx = item.attr("idx");
      idx = parseInt(idx, 10);
    }
    else if (evt.target.className.indexOf("vitrium-list-item") !== -1)
    {
      idx = $(evt.target).attr("idx");
      idx = parseInt(idx, 10);
    }
    return idx;
  };



  ListView.prototype.onListItemClicked = function (evt)
  {
    
    if (this.preventDefaultMouseBehavior  &&  evt.type === "mousedown")
    {
      evt.preventDefault();
      evt.stopPropagation();
    }

    if (!this.handleButton(evt))
    {
      var idx = $(evt.currentTarget).attr("idx");
      idx = parseInt(idx, 10);

      this.trigger("item:clicked", this.model.getItem(idx), idx, this, false);
    }
  };
  ListView.prototype.onRender = function ()
  {
  /*  if (navigator.appVersion.indexOf("Trident") === -1)
    {
      this.el.style.display = "none";
    }
    */
    var rowElements = this.$el.find(".vitrium-list-item").attr("class", "vitrium-list-item").empty();
    
    var num = this.model.getLength();
    for (var i = 0; i < num; ++i)
    {
      var item = this.model.getItem(i);
      var el = $(rowElements[i]);
      if (el.length === 0) el = $("<div class='vitrium-list-item'>").attr("idx", i);
      
      if (this.renderItem !== null)
      {
        this.renderItem(el, item, i);
      }
      else
      {
        el.text(item.toString());
      }

      this.$el.append(el);
    }
    
    for (var i = num, len = rowElements.length; i < len; ++i)
    {
      $(rowElements[i]).remove();
    }
    
    

   /* if (navigator.appVersion.indexOf("Trident") === -1)
    {
      this.el.style.display = "block";
    }*/
  };

  _.extend(ListView.prototype, Backbone.Events);

}
(vitrium.ui,
vitrium.ui,
jQuery,
_,
Backbone));

// script:viewer/annotations-sync-ui.js
/// <reference path="~/build.html" />

(function (exports,viewer, log, ui,i18n, _, $) {
   "use strict";

   var STATES = viewer.STATES;
   var ST_READY = STATES.get("READY");
   var SYNC_ERROR_SHONW = STATES.declare("SYNC_ERROR_SHONW");

   exports.SyncDisplay = SyncDisplay;
   var STATES = [
      "vst-synchronized",
      "vst-synchronizing",
      "vst-error"
   ];

   function SyncDisplay(synchronizationService)
   {
      ui.DomSizedWidget.call(this, document.createElement("div"));
      this.$el.addClass("vitrium-SyncDisplay");
      this.$el.append("<div class='error-display'><i class='fa fa-refresh'></i><span class='msg'>" + i18n._T("sync-display-error"+(vitrium.is_mobile?"-mobile":"-desktop")) + "</span></div>")
      this.$el.append("<div class='sync-display'><i class='fa fa-refresh'></i></div>");
      this.$el.append("<div class='synced-display'><i class='fa fa-check'></i></div>");

      this._synchronizationService = synchronizationService;

      this._runner = new DelayRunner(1000);
      this._hideAfterDelay = null;

      this._userTriggered = false;
      this._lastState = null;
 //     this._hammer = new Hammer(this.$el[0]);
   }
   SyncDisplay.prototype = Object.create(ui.DomSizedWidget.prototype);

   SyncDisplay.prototype.onActivate = function () {
      ui.DomSizedWidget.prototype.onActivate.call(this, arguments);
      this.listen(this._synchronizationService, "sync:state", this.onSyncStateChanged, this);
      this.listen(this.$el, "mousemove", function (e) {
         e.stopPropagation();
         e.preventDefault();
      });

      this.listen(this.$el, "mouseenter", _.bind(function (e) {
         this.parent.trigger("mouseleave", e);
      }, this));

      this.listen(this._parent, "tap", _.bind(function (e) {
         if (this._lastState === 2) {
            if (e.target === this.el || $(e.target).parents(".vitrium-SyncDisplay").length !== 0) {
               if (!this.trySync(true)) {
                  this._showMessage();
               }

               return true;
            }

            this._hideMessage();
            return false;
         }
      }, this), -10);


      this.listen(this.$el, "click", _.bind(function (e) {
         if (this._lastState === 2) {
            e.stopPropagation();
            e.preventDefault();

            this.trySync(false);
         }
      }, this));
   };

   SyncDisplay.prototype.trySync = function(fromTap)
   {
      this._runner.clear();
      if (this.$el.hasClass("show-msg") || (!fromTap && this.$el.has(":hover")))
      {
         log.debug("[SyncDisplay] trySync executed");
         this._synchronizationService.trySync();
         this._userTriggered = true;

         return true;
      }
      else
      {
         log.debug("[SyncDisplay] trySync not executed");
         return false;
      }
   };

   SyncDisplay.prototype.onSyncStateChanged = function (state) {
      this._lastState = state;
      log.debug("[SyncDisplay] onSyncStateChanged ", STATES[state]);
      if (this._hideAfterDelay !== null) {
         clearTimeout(this._hideAfterDelay);
      }

      if (state === 0)
      {
         if (this.$el.has("failed"))
         {
            this._hideAfterDelay = setTimeout(_.bind(function () {
               this.$el.removeClass("failed");
            }, this), 3000);
         }

         this.$el.removeClass("show-msg");
         this._userTriggered = false;
      }

      if (state === 1) {
         this.$el.removeClass("show-msg");
      }
      
      var hadFailed = this.$el.hasClass("failed");
      if (state === 2) {
         this.$el.addClass("failed");
      }

      if (this.$el.hasClass("failed"))
      {
         this._runner.run(_.bind(function () {
            if (!this.$el.hasClass(STATES[state])) {
               _.each(STATES, function (s, i) {
                  if (i !== state)
                     this.$el.removeClass(s);
               }, this);

               this.$el.addClass(STATES[state]);

               if (state == 2 && (this._userTriggered || !hadFailed))
               {
                  this._showMessage();

                  this._userTriggered = false;
                  this._hideAfterDelay = setTimeout(_.bind(function () {
                     this.$el.removeClass("show-msg");
                  }, this), 3000);
               }
            }
         }, this));

      }
   };

   SyncDisplay.prototype._showMessage = function () {
      this.$el.addClass("show-msg");     
   };

   SyncDisplay.prototype._hideMessage = function () {
      this.$el.removeClass("show-msg");
   };


   function DelayRunner(minTime)
   {
      this._minTime = minTime;
      this._queue = [];
      this._current = null;
      this._lastExec = null;
   }
   DelayRunner.prototype.clear = function () {

      clearTimeout(this._current);
      this._current = null;
      this._lastExec = null;
      this._queue.length = 0;

   };
   DelayRunner.prototype.run = function (task, at) {

      this._queue.push({
         task: _.bind(function () {
            task();
            this._current = null;
            this._lastExec = Date.now();
            this._exec();

         }, this),
         time: at || this._minTime
      });

      if (this._current === null) {
         this._exec();
      }
   };

   DelayRunner.prototype._exec = function () {
      var task = this._queue.shift();
      if (task)
      {
         if (this._lastExec === null)
         {
            this._current = setTimeout(task.task, 1);
         }
         else
         {
            var diff = Date.now() - this._lastExec;
            var time = task.time;
            if (diff > time)
            {
               time = 1;
            }
            else
            {
               time -= diff;
            }
            
            
            log.debug("Time: ", time, task.time);
            this._current = setTimeout(task.task, time);
         }
      }      
   };



}
(vitrium.ui,
vitrium.viewer,
vitrium.log,
vitrium.ui,
vitrium.i18n,
_, jQuery));

// script:viewer/ui/scroll-bar.js
(function (exports)
{
	"use strict";
	exports["ScrollBar"] = ScrollBar;
	
	function ScrollBar(minimumHandleSize)
	{		
		/**
			private properties
		*/
		this._minimumHandleSize = minimumHandleSize || 20;
		this._viewportSize = 0;
		this._contentSize = 0;
		
				
		/**
			readonly public properties
		*/
		this.handleSize = minimumHandleSize;
		this.handlePosition = 0;
		this.contentPosition = 0;
		
		this.procentualContentPosition = 0.0;	
		
		this.visible = false;
	}
	
	ScrollBar.prototype = {
		changeDimensions : function(viewportSize, contentSize)
		{
			contentSize = contentSize - viewportSize;
			if (this._viewportSize === viewportSize && this._contentSize === contentSize)
			{
				// no change
				return false;
			}
			
			this._viewportSize = viewportSize;
			this._contentSize = contentSize;
			
			if (contentSize < 1)
			{
				this.procentualContentPosition = this.contentPosition = this.handlePosition = 0;
				this.visible = false;
			}
			else
			{							
				var numScreens = contentSize / viewportSize;
				/*if (numScreens < 1)
				{*/
					numScreens += 1;
				/*}*/
				//console.log(numScreens, contentSize, viewportSize);
				this.handleSize = Math.max(this._minimumHandleSize, viewportSize / numScreens);
			
				this.visible = true;
				this.changeProcentualContentPosition(this.procentualContentPosition);
			}
			
			return true;
		},
		changeProcentualContentPosition : function(procentualContentPosition)
		{
			if (!this.visible)
			{
				return false;
			}
			procentualContentPosition = Math.max(Math.min(100,procentualContentPosition), 0);
			
			var contentPosition = this.contentPosition = procentualContentPosition * this._contentSize;
			this.handlePosition = this._viewportSize*procentualContentPosition - procentualContentPosition*this.handleSize;
		
			if (procentualContentPosition === this.procentualContentPosition)
			{	
				return false;
			}
			else
			{
				this.procentualContentPosition = procentualContentPosition;
				return true;
			}
		},
		changeContentPosition : function(position)
		{
			if (!this.visible || this.contentPosition === position)
			{
				// no change
				return false;
			}
			
			var contentPosition = this.contentPosition = Math.min(Math.max(0, position), this._contentSize);
			return this.changeProcentualContentPosition(contentPosition/this._contentSize);
		},
		scrollRelative: function(delta)
		{
			return this.changeContentPosition(this.contentPosition+delta);
		},
		setHandlePosition: function(pos)
		{
		
			var maxPos = this._viewportSize - this.handleSize;
			var cPosition = Math.max(Math.min(pos, maxPos), 0);

			return this.changeProcentualContentPosition(cPosition/maxPos);
		}
	};
	
}(
vitrium.ui
));
// script:viewer/ui/delay-task.js
(function (exports, _)
{
	"use strict";
	
	exports["DelayTask"] = DelayTask;
	function DelayTask(callback, delay, preserveFirst)
	{
		this._callback = _.bind(function(){ callback(this._arg); this._arg = null; }, this);
		this._preserveFirst = preserveFirst ;
		this._delay = delay;
		this._timer = 0;
		this._arg = null;
	}
	
	DelayTask.prototype = {
		execute : function(arg)
		{
			if (this._preserveFirst && !this._arg) this._arg = arg;
			else if (!this._preserveFirst) this._arg = arg;
			
			clearTimeout(this._timer);
			this._timer = setTimeout(this._callback, this._delay);
		},
		cancel : function()
		{
			clearTimeout(this._timer);
			this._timer = 0;
			this._arg= null;
		},
		destroy : function()
		{
			clearTimeout(this._timer);
			this._timer = 0;
			this._callback = null;
			this._arg = null;
		}
	};
	
}(
vitrium.ui,
_
));
// script:viewer/ui/dom-element-pool.js
(function (exports)
{
	"use strict";
	exports["DOMElementPool"] = DOMElementPool;
	
	function DOMElementPool(el, preprocessor, max)
	{
		this._el = el;
		this._preprocessor = preprocessor ? preprocessor : null;
		this._max = max ||  10;
		this._cache = [];
	}
	
	DOMElementPool.prototype = {
		create : function()
		{
			var cache = this._cache;
			
			if (cache.length === 0)
			{
				var el = document.createElement(this._el);
				this._preprocessor(el);
				
				return el;
			}
			
			return cache.pop();
		},
		free : function(el)
		{
			var cache = this._cache;
			if (cache.length < this._max)
			{
				cache.push(el);
			}
		}
	};
	
	

}(
vitrium.ui
));
// script:viewer/ui/single-instance-task-queue.js
(function (exports)
{
	"use strict";
	exports["SingleInstanceTaskQueue"] = SingleInstanceTaskQueue;

	function SingleInstanceTaskQueue(userdata)
	{
		this.userdata = userdata ? userdata : null;
		this._queue = [];
		this._backingQueue = [];
	}
	
	SingleInstanceTaskQueue.prototype = {
		destroy : function()
		{
			this.userdata = null;
			this._queue = null;
		},
		execute : function()
		{
			var q = this._queue;
			this._queue = this._backingQueue;
			this._backingQueue = q;
			
			var ud = this.userdata;
			for (var i = 0, len = q.length; i < len; ++i)
			{
				q[i](ud);
			}
			
			q.length = 0;
		}, 
		cancel : function()
		{
			this._queue.length = 0;
		},
		push : function(task)
		{
			var q = this._queue;
			for (var i = 0, len = q.length; i < len; ++i)
			{
				if (q[i] === task)
				{
					return false;
				}
			}
		
			q.push(task);
			return true;
		}
	};

}(
vitrium.ui
));
// script:viewer/ui/kintetic-scroller.js
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function (exports)
{
	"use strict";
	
	exports["KineticScroller"] = KineticScroller;
	exports["VelocityTracker"] = VelocityTracker;
	
	var DEFAULT_DURATION = 250,
    SCROLL_MODE = 0,
    FLING_MODE = 1;

	var DIRECTION_HORIZONTAL = 0;
	var DIRECTION_VERTICAL = 1;

	exports.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;
	exports.DIRECTION_VERTICAL = DIRECTION_VERTICAL;

	function KineticScroller(density, friction,  interpolatorFunct, timeFunct)
	{
		this.mMode = SCROLL_MODE;
		this.mStartX = this.mStartY = this.mFinalX = this.mFinalY = this.mMinX = this.mMaxX = this.mMinY = this.mMaxY = this.mCurrX = this.mCurrY = this.mStartTime = this.mDuration = this.mDurationReciprocal = this.mDeltaX = this.mDeltaY =  this.mViscousFluidScale = this.mViscousFluidNormalize = 0;
		this.mFinished = false;
		this.mCoeffX = 0.0;
		this.mCoeffY = 1.0;
		this.mVelocity = 0.;
    
    	
		var ppi = density * 160.0;
		
		this.mDeceleration = 9.8   // g (m/s^2)
                      * 39.37 // inch/meter
                      * ppi    // pixels per inch
                      * friction;
		this.mInterpolator = interpolatorFunct;
		this.mTimeFunct = timeFunct;
	}
	
	KineticScroller.prototype = {
		computeScrollOffset : function()
		{
				if (this.mFinished)
				{
					return false;
				}
				
				var timePassed = this.mTimeFunct() - this.mStartTime;
				if (timePassed < this.mDuration) {
				switch (this.mMode) {
				case SCROLL_MODE:
					var x = timePassed * mDurationReciprocal;
		
					if (mInterpolator === null)
						x = this.viscousFluid(x); 
					else
						x = this.mInterpolator(x);
		
					this.mCurrX = this.mStartX + Math.round(x * this.mDeltaX);
					this.mCurrY = this.mStartY + Math.round(x * this.mDeltaY);
					if ((this.mCurrX === this.mFinalX) && (this.mCurrY === this.mFinalY)) {
						this.mFinished = true;
					}
					break;
				case FLING_MODE:
					var timePassedSeconds = timePassed / 1000.0;
					var distance = (this.mVelocity * timePassedSeconds)
							- (this.mDeceleration * timePassedSeconds * timePassedSeconds / 2.0);
		
					this.mCurrX = this.mStartX + Math.round(distance * this.mCoeffX);
					// Pin to mMinX <= mCurrX <= mMaxX
					this.mCurrX = Math.min(this.mCurrX, this.mMaxX);
					this.mCurrX = Math.max(this.mCurrX, this.mMinX);
					
					this.mCurrY = this.mStartY + Math.round(distance * this.mCoeffY);
					// Pin to mMinY <= mCurrY <= mMaxY
					this.mCurrY = Math.min(this.mCurrY, this.mMaxY);
					this.mCurrY = Math.max(this.mCurrY, this.mMinY);

					if (this.mCurrX === this.mFinalX && this.mCurrY === this.mFinalY) {
						this.mFinished = true;
					}
					
					break;
				}
			}
			else {
				this.mCurrX = this.mFinalX;
				this.mCurrY = this.mFinalY;
				this.mFinished = true;
			}
			return true;
		},
		startScroll : function(startX, startY, dx, dy, duration)
		{
			if (arguments.length === 4)
			{
				this.duration = DEFAULT_DURATION;
			}
			
			
			this.mMode = SCROLL_MODE;
			this.mFinished = false;
			this.mDuration = duration;
			this.mStartTime = this.mTimeFunct();
			this.mStartX = startX;
			this.mStartY = startY;
			this.mFinalX = startX + dx;
			this.mFinalY = startY + dy;
			this.mDeltaX = dx;
			this.mDeltaY = dy;
			this.mDurationReciprocal = 1.0 / this.mDuration;
			// This controls the viscous fluid effect (how much of it)
			this.mViscousFluidScale = 8.0;
			// must be set to 1.0 (used in viscousFluid())
			this.mViscousFluidNormalize = 1.0;
			this.mViscousFluidNormalize = 1.0/ this.viscousFluid(1.0);
		},
		fling : function (startX, startY, velocityX,velocityY,minX, maxX,minY,maxY) 
		{
				this.mMode = FLING_MODE;
				this.mFinished = false;

				var velocity =  Math.sqrt(velocityX*velocityX +velocityY*velocityY);
			 
				this.mVelocity = velocity;
				this.mDuration = (1000 * velocity / this.mDeceleration); // Duration is in
																	// milliseconds
				this.mStartTime = this.mTimeFunct();
				this.mStartX = startX;
				this.mStartY = startY;

				this.mCoeffX = velocity == 0 ? 1.0 : velocityX / velocity; 
				this.mCoeffY = velocity == 0 ? 1.0: velocityY / velocity;

				var totalDistance = (velocity * velocity) / (2 * this.mDeceleration);
				//console.log(totalDistance);
				this.mMinX = minX;
				this.mMaxX = maxX;
				this.mMinY = minY;
				this.mMaxY = maxY;
				
				
				this.mFinalX = startX + Math.round(totalDistance * this.mCoeffX);
				// Pin to mMinX <= mFinalX <= mMaxX
				this.mFinalX = Math.min(this.mFinalX, this.mMaxX);
				this.mFinalX = Math.max(this.mFinalX, this.mMinX);
				
				this.mFinalY = startY + Math.round(totalDistance * this.mCoeffY);
				// Pin to mMinY <= mFinalY <= mMaxY
				this.mFinalY = Math.min(this.mFinalY, this.mMaxY);
				this.mFinalY = Math.max(this.mFinalY, this.mMinY);
		},
		viscousFluid : function (x)
		{
			x *= this.mViscousFluidScale;
			if (x < 1.0) {
				x -= (1.0 - Math.exp(-x));
			} else {
				var start = 0.36787944117;   // 1/e == exp(-1)
				x = 1.0 - Math.exp(1.0 - x);
				x = start + x * (1.0 - start);
			}
			x *= this.mViscousFluidNormalize;
			return x;
		},
		abortAnimation : function() {
			this.mCurrX = this.mFinalX;
			this.mCurrY = this.mFinalY;
			this.mFinished = true;
		},
		extendDuration : function(extend) {
			var passed = this.mTimeFunct() - this.mStartTime
			this.mDuration = passed + extend;
			this.mDurationReciprocal = 1.0 /  this.mDuration;
			this.mFinished = false;
		},
		setFinalX : function (newX) {
			this.mFinalX = newX;
			this.mDeltaX = this.mFinalX - this.mStartX;
			this.mFinished = false;
		},
		setFinalY : function(newY) {
			this.mFinalY = newY;
			this.mDeltaY = this.mFinalY - this.mStartY;
			this.mFinished = false;
		}
	};
	
	var NUM_PAST = 10, LONGEST_PAST_TIME = 200;
	function VelocityTracker()
	{
		this.mPastX = [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0];
		this.mPastY = [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0];
		this.mPastTime = [0,0,0,0,0,0,0,0,0,0];		
		
		this.mYVelocity = 0;
		this.mXVelocity = 0;
	}
	
	VelocityTracker.prototype = {
		addMovement : function(x, y, time)
		{
			var i = 0;
			var drop = -1;
			var pastTime = this.mPastTime;
			for (; i < NUM_PAST; ++i)
			{
				if (pastTime[i] === 0)
				{
					break;
				}
				else if (pastTime[i] < time - LONGEST_PAST_TIME)
				{
					drop = i;
				}
			}
			
			if (i === NUM_PAST && drop < 0)
			{
				drop = 0;
			}
			if (drop === i) drop--;
			var pastX = this.mPastX;
			var pastY = this.mPastY;
			
			if (drop >= 0) 
			{
				var start = drop+1;
				var count = NUM_PAST-drop-1;
				
				for (var d = 0; d < count; ++d)
				{
					pastX[d] = pastX[d+start];
					pastY[d] = pastY[d+start];
					pastTime[d] = pastTime[d+start];
				}
				
				i -= (drop+1);
			}
			
			pastX[i] = x;
			pastY[i] = y;
			pastTime[i] = time;
			i++;
			if (i < NUM_PAST) {
				pastTime[i] = 0;
			}
		},
		computeDirection : function()
		{
		  var pastX = this.mPastX;
		  var pastY = this.mPastY;
		  var pastTime = this.mPastTime;

		  var N = 0;
		  while (N < NUM_PAST)
		  {
		    if (pastTime[N] == 0)
		    {
		      break;
		    }
		    ++N;
		  }
		  if (N < 2) return null;

		  var sumX = 0, sumY = 0;
		  for (var i = 1, len = N; i < len; ++i)
		  {
		    sumX += Math.abs(pastX[i-1] - pastX[i]);
		    sumY += Math.abs(pastY[i-1] - pastY[i]);
		  }

		  var avgX = sumX / N;
		  var avgY = sumY / N;

		  if (avgX === 0 && avgY > 0) return DIRECTION_VERTICAL;
		  if (avgX > 0 && avgY === 0) return DIRECTION_HORIZONTAL;
		  if (avgX === avgY) return null;
      
		  var ratio = avgX / avgY;
		  //console.log(ratio);
		  if (ratio > 0.5 && ratio < 1.5)
		  {
		    return null;
		  }
		  else if (ratio >= 2)
		  {
		    return DIRECTION_HORIZONTAL;
		  }
		  else
		  {
		    return DIRECTION_VERTICAL;
		  }
		  /*if (ratio > 1.1)
		  {
		    return DIRECTION_HORIZONTAL;
		  }
		  else
		  {
		    return DIRECTION_VERTICAL;
		  }*/

		},
		computeCurrentVelocity: function(units, maxVelocity) {
			var pastX = this.mPastX, pastY = this.mPastY, pastTime = this.mPastTime;
			// Kind-of stupid.
			var oldestX = pastX[0], oldestY = pastY[0], oldestTime = pastTime[0];
			var accumX = 0;
			var accumY = 0;
			var N=0;
			while (N < NUM_PAST) {
				if (pastTime[N] == 0) {
					break;
				}
				N++;
			}
			// Skip the last received event, since it is probably pretty noisy.
			if (N > 3) N--;
        
			for (var i=1; i < N; i++) {
				var dur = (pastTime[i] - oldestTime);
				if (dur === 0) continue;
				var dist = pastX[i] - oldestX;
				var vel = (dist/dur) * units;   // pixels/frame.
				if (accumX == 0) accumX = vel;
				else accumX = (accumX + vel) * 0.5;
				
				dist = pastY[i] - oldestY;
				vel = (dist/dur) * units;   // pixels/frame.
				if (accumY == 0) accumY = vel;
				else accumY = (accumY + vel) * 0.5;
			}
			this.mXVelocity = accumX < 0.0 ? Math.max(accumX, -maxVelocity) : Math.min(accumX, maxVelocity);
			this.mYVelocity = accumY < 0.0 ? Math.max(accumY, -maxVelocity) : Math.min(accumY, maxVelocity);
		}
	};
}(
vitrium.ui
));
// script:viewer/ui/tiles-calculator.js
/// <reference path="~/build.html" />

(function (exports, geometry)
{
  "use strict";
  exports.TilesCalculator = TilesCalculator;

  function TilesCalculator(maxDimensionFunct)
  {
    this.maxDimensionFunct = maxDimensionFunct;
  }

  TilesCalculator.prototype =
  {
    calculateTiles: function (page, viewport)
    {
      /// <param name="page" type="geometry.Rectangle"></param>
      /// <param name="viewport" type="geometry.Rectangle">Viewport related to the page coordinate space</param>
      /// <returns type="Array" elementType="geometry.Rectangle"></returns>
      var maxDimensions = this.maxDimensionFunct();
      if (maxDimensions.w < page.w || maxDimensions.h < page.h)
      {

        var pivotRectangle = this._calculatePivotRectangle(page, viewport, maxDimensions);
        var result = [pivotRectangle];
        
        var leftTile = this._createLeft(pivotRectangle, page);
        var rightTile = this._createRight(pivotRectangle, page);
        var topTile = this._createTop(pivotRectangle, leftTile, rightTile, page);
        var bottomTile = this._createBottom(pivotRectangle, leftTile, rightTile, page);

        this._splitToResult(result, leftTile, maxDimensions);
        this._splitToResult(result, rightTile, maxDimensions);
        this._splitToResult(result, topTile, maxDimensions);
        this._splitToResult(result, bottomTile, maxDimensions);

        return result;
      }
      else
      {
        return [new geometry.Rectangle(0, 0, page.w, page.h, 0)];
      }
    },
    _createLeft: function (pivot, page)
    {
      /// <param name="page" type="geometry.Rectangle"></param>
      /// <param name="pivot" type="geometry.Rectangle"></param>
      /// <returns type="geometry.Rectangle" mayBeNull="true"></returns>

      if (pivot.x > 0)
      {
        return new geometry.Rectangle(0, 0, pivot.x, page.h, 0);
      }
      else
      {
        return null;
      }
    },
    _createRight: function (pivot, page)
    {
      /// <param name="page" type="geometry.Rectangle"></param>
      /// <param name="pivot" type="geometry.Rectangle"></param>
      /// <returns type="geometry.Rectangle" mayBeNull="true"></returns>
      var endX = pivot.x + pivot.w;
      if (endX < page.w)
      {
        return new geometry.Rectangle(endX, 0, page.w - endX, page.h, 0);
      }
      else
      {
        return null;
      }
    },
    _createTop: function (pivot, left, right, page)
    {
      /// <param name="pivot" type="geometry.Rectangle"></param>
      /// <param name="left" type="geometry.Rectangle"></param>
      /// <param name="right" type="geometry.Rectangle"></param>
      /// <param name="page" type="geometry.Rectangle"></param>

      /// <returns type="geometry.Rectangle" mayBeNull="true"></returns>

      if (pivot.y > 0)
      {
        var x = left === null ? 0 : left.x + left.w;
        var w = right === null ? page.w - x : page.w - right.w - x;

        return new geometry.Rectangle(x, 0, w, pivot.y, 0);
      }
      else
      {
        return null;
      }
    },
    _createBottom: function (pivot, left, right, page)
    {
      /// <param name="pivot" type="geometry.Rectangle"></param>
      /// <param name="left" type="geometry.Rectangle"></param>
      /// <param name="right" type="geometry.Rectangle"></param>
      /// <param name="page" type="geometry.Rectangle"></param>

      /// <returns type="geometry.Rectangle" mayBeNull="true"></returns>
      var endY = pivot.y + pivot.h;
      if (endY < page.h)
      {
        var x = left === null ? 0 : left.x + left.w;
        var w = right === null ? page.w - x : page.w - right.w - x;

        return new geometry.Rectangle(x, endY, w, page.h - endY, 0);
      }
      else
      {
        return null;
      }
    },
    _splitToResult: function (result, tile, maxDimensions)
    {
      /// <param name="result" type="Array"></param>
      /// <param name="tile" type="geometry.Rectangle"></param>
      /// <param name="maxDimensions" type="geometry.Rectangle"></param>

      if (tile === null) return;

      if (tile.w <= maxDimensions.w && tile.h <= maxDimensions.h)
      {
        return result.push(tile);
      }
      else
      {
        var nHorizontal = (tile.w / maxDimensions.w + (tile.w % maxDimensions.w > 0 ?1 : 0)) | 0;
        var nVertical = (tile.h / maxDimensions.h + (tile.h % maxDimensions.h > 0 ? 1 : 0)) | 0;

        var width = Math.min(maxDimensions.w, tile.w);
        var height = Math.min(maxDimensions.h, tile.h);

        var lastHorizontal = nHorizontal- 1;
        var lastVertical = nVertical - 1;
        


        for (var h = 0; h < nHorizontal; ++h)
        {
          var x = h * width;
          var w = width;
          if (h === lastHorizontal) w -= x + width - tile.w;

          for (var v = 0; v < nVertical; ++v)
          {
            var y = v * height;
            var lh = height;
            if (v === lastVertical) lh -= y + height - tile.h;

            result.push(new geometry.Rectangle(tile.x + x, tile.y + y, w, lh, 0));
          }
        }

      }

    },
    _calculatePivotRectangle: function (page, viewport, maxDimensions)
    {
      /// <param name="page" type="geometry.Rectangle">Page</param>
      /// <param name="viewport" type="geometry.Rectangle">Viewport related to the page coordinate space</param>
      /// <param name="maxDimensions" type="geometry.Rectangle">Maximum rectangle size</param>
      /// <returns type="geometry.Rectangle"></returns>
      var intersection = page.intersectWithZeroAngle(viewport);
      var pageEndPoint = page.getEndPoint();
      var center = intersection.getCenterPoint();


      var cW = maxDimensions.w / 2;
      var cH = maxDimensions.h / 2;
      var endX = center.x + cW;
      var endY = center.y + cH;
      var ideallyPositioned = geometry.Rectangle.createFromCoordinates(center.x - cW, center.y - cH, endX, endY);

      var moveX = 0;
      if (ideallyPositioned.x < 0 && endX > pageEndPoint.x)
      {
        // width of the tile is bigger than page width
        ideallyPositioned.x = 0;
        ideallyPositioned.w = page.w;
      }
      else if (ideallyPositioned.x < 0)
      {
        moveX = -ideallyPositioned.x;
      }
      else if (endX > pageEndPoint.x)
      {
        moveX = pageEndPoint.x - endX;

      }

      var moveY = 0;
      if (ideallyPositioned.y < 0 && endY > pageEndPoint.y)
      {
        // height of the tile is bigger than page height
        ideallyPositioned.y = 0;
        ideallyPositioned.h = page.h;
      }
      else if (ideallyPositioned.y < 0)
      {
        moveY = -ideallyPositioned.y;
      }
      else if (endY > pageEndPoint.y)
      {
        moveY = pageEndPoint.y -endY;
      }

      ideallyPositioned.move(moveX, moveY);
      ideallyPositioned.x = Math.max(ideallyPositioned.x, 0);
      ideallyPositioned.y = Math.max(ideallyPositioned.y, 0);
      ideallyPositioned.w = Math.min(ideallyPositioned.w, page.w);
      ideallyPositioned.h = Math.min(ideallyPositioned.h, page.h);
      // need to throw floating points away
      ideallyPositioned.x = ideallyPositioned.x | 0;
      ideallyPositioned.y = ideallyPositioned.y | 0;
      ideallyPositioned.w = ideallyPositioned.w | 0;
      ideallyPositioned.h = ideallyPositioned.h | 0;

      return ideallyPositioned;
    }
  };

}(
vitrium.ui,
vitrium.geometry2
));

// script:viewer/ui/events.js
/// <reference path="~/build.html" />

/**
This is altered implementation of Backbone.Events, that supports supressing event propagation and order on handlers
*/
(function (exports, _)
{
  "use strict";
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  var Events =  exports.Events ={

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function (name, callback, context, order)
    {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      
      events.push({ callback: callback, context: context, ctx: context || this, order: arguments.length === 4 ? order : 0, idx : events.length});
    
      events.sort(function (a, b)
      {
        if (a.order === b.order)
        {
          return a.idx - b.idx;
        }
        else
        {
          return a.order - b.order;
        }
      });

      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function (name, callback, context, order)
    {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function ()
      {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context, order);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function (name, callback, context)
    {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context)
      {
        this._events = void 0;
        return this;
      }
      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++)
      {
        name = names[i];
        if (events = this._events[name])
        {
          this._events[name] = retain = [];
          if (callback || context)
          {
            for (j = 0, k = events.length; j < k; j++)
            {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context))
              {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function (name)
    {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function (obj, name, callback)
    {
      var listeningTo = this._listeningTo;
      if (!listeningTo) return this;
      var remove = !name && !callback;
      if (!callback && typeof name === 'object') callback = this;
      if (obj) (listeningTo = {})[obj._listenId] = obj;
      for (var id in listeningTo)
      {
        obj = listeningTo[id];
        obj.off(name, callback, this);
        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function (obj, action, name, rest)
  {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object')
    {
      for (var key in name)
      {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name))
    {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++)
      {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function (events, args)
  {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2], stop = false;
    switch (args.length)
    {
      case 0: while (++i < l && !stop) stop = !!(ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l && !stop) stop = !!(ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l && !stop) stop = !!(ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l && !stop) stop = !!(ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l && !stop) stop = !!(ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

}
(vitrium.ui,
 _
));

// script:viewer/ui/path-hit-test-canvas.js
/// <reference path="~/build.html" />

(function (exports, geometry)
{
  "use strict";

  exports.createHitTestCanvasContext = function ()
  {
    var c = document.createElement("canvas");
    var ctx = c.getContext("2d");
    
    if ("isPointInStroke" in ctx)
    {
      return ctx;
    }
    else
    {
      
      ctx._moveTo = ctx.moveTo;
      ctx._lineTo = ctx.lineTo;
      ctx._closePath = ctx.closePath;
      ctx._beginPath = ctx.beginPath;
      ctx._firstPoint = null;

      ctx.beginPath = function ()
      {
        this._firstPoint = null;
        this._beginPath();
      };
      ctx.moveTo = function (x, y)
      {
        this._lastPoint = new geometry.Point(x, y);
        if (this._firstPoint === null) this._firstPoint = this._lastPoint;
        
      };
      ctx.lineTo = function (x, y)
      {
        var lw = this.lineWidth;
        var hw = lw / 2;
        var beg = this._lastPoint;
        var end = new geometry.Point(x, y);

        var distance = beg.distance(end);
        var begDirectionVector = directionVector(beg, end);
        var begNormalVector = normalVector(begDirectionVector);
        var endDirectionVector = directionVector(end, beg);
        var endNormalVector = normalVector(endDirectionVector);

        var endDirectionVector = new geometry.Point(beg.x - end.x, beg.y - end.y);

        var p0 = getPointOnDirectionVectorForDistance(beg, begNormalVector, distance, hw);
        var p1 = getPointOnDirectionVectorForDistance(end, endNormalVector, distance, -hw);
        var p2 = getPointOnDirectionVectorForDistance(end, endNormalVector, distance, hw);
        var p3 = getPointOnDirectionVectorForDistance(beg, begNormalVector, distance, -hw);


        this._moveTo(p0.x, p0.y);
        this._lineTo(p1.x, p1.y);
        this._lineTo(p2.x, p2.y);
        this._lineTo(p3.x, p3.y);
                
        this._closePath();

        this._lastPoint = end;
        if (this._firstPoint === null) this._firstPoint = this._lastPoint;
      };
      ctx.closePath = function ()
      {
        if (this._firstPoint !== null)
        {
          this.lineTo(this._firstPoint.x, this._firstPoint.y);
        }
      };
      ctx.isPointInStroke = function (x, y)
      {
        return this.isPointInPath(x, y);
      };

      return ctx;
    }
    
   

  };

  function getPointOnDirectionVectorForDistance(beg, directionVector, vectorLength, distance)
  {
    return new geometry.Point(beg.x + (distance / vectorLength * directionVector.x), beg.y + (distance / vectorLength * directionVector.y));
  }

  function directionVector(a, b)
  {
    return new geometry.Point(b.x - a.x, b.y - a.y);
  }

  function normalVector(directionVector)
  {
    return new geometry.Point(directionVector.y, -directionVector.x);
  }

}
(vitrium.ui,
vitrium.geometry));

// script:viewer/ui/choice-selector.js
/// <reference path="~/build.html" />

(function (exports, ui, Backbone, _, $, i18n)
{
  "use strict";

  exports.ChoiceSelector = ChoiceSelector;
  function ChoiceSelector(model, itemRenderer, itemName, onRenderCallback)
  {
    ui.DomSizedWidget.call(this, document.createElement("div"));
    this.el.className = "vitrium-choice-selector";
    this.model = model;
    this.itemRenderer = itemRenderer;
    this.itemName = itemName;
    this.itemListName = itemName + "List";
    this.itemListChanged = true;
    this.onRenderCallback = onRenderCallback ? onRenderCallback : null;

    this.reqSelection = this.model.get(this.itemName);
    this.selectedIdx = null;

    this.mouseDownIdx = null;
    this.lastMouseIdx = null;

    
    this.$el.on("tap click", ".vitrium-choice", _.bind(this.onChoiceClicked, this));
    this.$el.on("mousedown", ".vitrium-choice", _.bind(this.onMouseDown, this));
    this.$el.on("mouseleave", ".vitrium-choice", _.bind(this.onMouseLeave, this));
    this.$el.on("mouseenter", ".vitrium-choice", _.bind(this.onMouseEnter, this));

    this.onMouseUpHandler = _.bind(function () { this.lastMouseIdx = null; }, this)
    this.refresh();

    this.$document = $(document);
    // assume that I have to rerender everything anyway 
  }

  ChoiceSelector.prototype = _.extend(Object.create(ui.DomSizedWidget.prototype), {
      onActivate : function()
      {
          this
          .listen(this.model, "change:" + this.itemName, this.onSelectionChanged, this)
          .listen(this.model, "change:" + this.itemListName, this.onItemsChanged, this)
          .listen(this.$document, "mouseup", this.onMouseUpHandler)
          .listen(i18n, "language:changed", this.onItemsChanged, this);

          this.onItemsChanged();
          this.onSelectionChanged(this.model, this.model.get(this.itemName));
      },
    onMouseEnter: function (evt)
    {
      var idx = parseInt($(evt.currentTarget).attr("idx"), 10);
      if (this.lastMouseIdx === idx)
      {
        this.onMouseDown(evt);
      }
    },
    onMouseDown: function (evt)
    {
      this.lastMouseIdx = this.mouseDownIdx = parseInt($(evt.currentTarget).attr("idx"), 10);
      this.refresh();
    },
    onMouseLeave: function (evt)
    {
      this.mouseDownIdx = null;
      this.refresh();
    },
    onChoiceClicked: function (evt)
    {
      this.mouseDownIdx = null;
      var choiceIdx = parseInt($(evt.currentTarget).attr("idx"), 10);
      this.model.set(this.itemName, choiceIdx);
      this.model.trigger("click:" + this.itemName, this.model, choiceIdx);
    },
    onItemsChanged: function ()
    {
      this.itemListChanged = true;
      this.refresh();
    },
    onSelectionChanged: function (model, idx)
    {
      this.reqSelection = idx;
      this.refresh();
    },
    onRender: function (ctx, time)
    {
      this.$el.find(".vitrium-choice.mousedown").removeClass("mousedown");
      if (this.mouseDownIdx !== null)
      {
        this.$el.find(".vitrium-choice[idx='" + this.mouseDownIdx + "']").addClass("mousedown");
      }

      if (this.itemListChanged)
      {
        this.$el.empty();
        _.each(this.model.get(this.itemListName), function (item, idx)
        {
          this.itemRenderer($("<div class='vitrium-choice'>").appendTo(this.$el).attr("idx", idx), item, idx);
        }, this);

        this.itemListChanged = false;
        this.trigger("size:change");
      }


      if (this.reqSelection !== null)
      {
        if (this.selectedIdx !== null)
        {
          this.$el.find(".vitrium-choice[idx='" + this.selectedIdx + "']").removeClass("selected");
        }

        this.$el.find(".vitrium-choice[idx='" + this.reqSelection + "']").addClass("selected");
        this.selectedIdx = this.reqSelection;
        this.reqSelection = null;
      }

      if (this.onRenderCallback !== null)
      {
        this.onRenderCallback(ctx, time);
      }
    }
  });

  _.extend(ChoiceSelector.prototype, Backbone.Events);
}
(
vitrium.ui,
vitrium.ui,
Backbone,
_,
jQuery,
vitrium.i18n
));

// script:viewer/bubble-ui.js
/// <reference path="~/build.html" />

(function (exports, ui)
{
  "use strict";
  exports.Bubble = Bubble;
  
  function Bubble()
  {
    ui.DomSizedWidget.call(this, document.createElement("div"));
    this.el.className = "vitrium-bubble";
    this.el.innerHTML = "<div class='vitrium-bubble-content'></div>";
    this._content = null;
  }
  Bubble.prototype = Object.create(ui.DomSizedWidget.prototype);
  Bubble.prototype.updateContent = function (content)
  {
    if (this._content !== content)
    {
      this.$el.find(".vitrium-bubble-content").text(content);
      return true;
    }
    return false;
  };



}
(vitrium.ui,
vitrium.ui));

// script:viewer/document-renderers/sequential-page-layout.js
(function (exports){	"use strict";		var RET_NOT_IN_VIEPORT = 0;	var RET_IN_VIEPORT = 1;	var RET_IN_VIEPORT_END =2;			exports["SequentialPageLayout"] = SequentialPageLayout;	function SequentialPageLayout(pages, options)	{		this._options = options || 		{			horizontalSeparator : 30,			verticalSepartor : 30		};				this._ranges = null;				this.boundingBox = null;		if (pages) this.attachPages(pages);				this._cachedIt = new SequentialViewportPagesIterator(this.boundingBox, this._ranges, 0, 0, this._options.horizontalSeparator);				this._cachedViewportPages =[];	}	SequentialPageLayout.prototype = {		attachPages : function(pages)		{			var PR = PageRange;			var ranges = this._ranges = [];						var currentRange = null;			for (var i= 0, len = pages.length; i < len; ++i)			{				var page = pages[i];								if (!currentRange || !currentRange.tryAdd(page.width, page.height))				{					currentRange = new PR(i, page.width, page.height);					ranges.push(currentRange);				}			}						this.boundingBox = this.computeDocumentBoundingBox();		},		queryPages : function(scrollX, scrollY, viewportWidth, viewportHeight)		{			var it = this._cachedIt;			SequentialViewportPagesIterator.call(it, this.boundingBox, this._ranges, scrollY, viewportHeight, this._options.horizontalSeparator);			return it;		},		visiblePages : function(scrollX, scrollY, viewportWidth, viewportHeight)		{			var result = this._cachedViewportPages;					var i= 0;			for (var it = this.queryPages(scrollX, scrollY, viewportWidth, viewportHeight), p=null ; it.hasNext();)			{						p = it.next();				result[i] = p.number;				++i;			}			result.length = i;						return result;		},		getCurrentPageNumber : function(scrollX, scrollY, viewportWidth, viewportHeight)		{		//TODO is not done yet			var lastPageNumber = 0;			var lastHeightOnScreen = null;			var min = Math.min;			for (var it = this.queryPages(scrollX, scrollY, viewportWidth, viewportHeight), p=null ; it.hasNext();)			{				var p = it.next();				var current =  p.y - scrollY;				if (current < 0)				{					current +=  p.height;				}				else				{					current =  min(viewportHeight-current, p.height);				}								if (lastHeightOnScreen !== null)				{					if (current > lastHeightOnScreen)					{						return p.number;					}					else					{						return lastPageNumber;					}									}								lastHeightOnScreen = current;				lastPageNumber = p.number;			}						return lastPageNumber;		},		getPage : function(pageNumber)		{			var pageIt = this.queryPages(0, 0, this.boundingBox.width, this.boundingBox.height);			while(pageIt.hasNext())			{				var page = pageIt.next();				if (page.number === pageNumber)				{					return page;				}			}			return null;		},		computeDocumentBoundingBox : function()		{			var ranges = this._ranges;			var rangeBoundingBox = { width: 0, height: 0};			var documentBoundingBox = { width: 0, height: 0};									var horizontalSeparator = this._options.horizontalSeparator;			var verticalSepartor = this._options.verticalSepartor;			var max =  Math.max;						for (var i = 0, len = ranges.length; i < len; ++i)			{				var range = ranges[i];				range.fillBoundingBox(rangeBoundingBox, horizontalSeparator, verticalSepartor);								documentBoundingBox.width = max(documentBoundingBox.width, rangeBoundingBox.width);				documentBoundingBox.height +=  rangeBoundingBox.height;			}						documentBoundingBox.height += verticalSepartor;						return documentBoundingBox;		}	};		function SequentialViewportPagesIterator(boundingBox, ranges, scrollY, viewportHeight, horizontalSeparator)	{		this._itPage = new Page();				this._boundingBox = boundingBox,		this._ranges = ranges;		this._viewportHeight = viewportHeight;					this._rangeOutput = new PageRange(0,0.0,0.0);		this._horizontalSeparator = horizontalSeparator;		this._scrollY = scrollY;		this._y = 0;		this._i = 0;		this._rI = 0;		this._result = RET_NOT_IN_VIEPORT;	}		SequentialViewportPagesIterator.prototype = {		hasNext : function()		{			var viewportHeight = this._viewportHeight;			var horizontalSeparator = this._horizontalSeparator;			var scrollY = this._scrollY;			var ranges = this._ranges;									var rangeOutput = this._rangeOutput;			var result = this._result;							if (result === RET_NOT_IN_VIEPORT)			{				var y = this._y;				var i =this._i;				for(var len = ranges.length; i < len; ++i)				{					var range = ranges[i];					result = range.fillVisibleRange(rangeOutput, scrollY, y, viewportHeight-horizontalSeparator, horizontalSeparator);					y += rangeOutput.totalHeight;					//console.log("totalHeight: "+rangeOutput.totalHeight);										if ((result & RET_IN_VIEPORT_END) === RET_IN_VIEPORT_END || (result & RET_IN_VIEPORT) === RET_IN_VIEPORT)					{						break;					}				}								this._i = i+1;				this._rI =0;				this._y = y;				this._result = result;				return (result & RET_IN_VIEPORT) === RET_IN_VIEPORT;							}			else if ((result & RET_IN_VIEPORT) === RET_IN_VIEPORT)			{				if ( rangeOutput.start + this._rI < rangeOutput.start+rangeOutput.length)				{					return true;				}				else if ((result & RET_IN_VIEPORT_END) === RET_IN_VIEPORT_END)				{					return false;				}				else				{					this._result = RET_NOT_IN_VIEPORT;					return this.hasNext();				}			}		},		next : function()		{			if ((this._result & RET_IN_VIEPORT) === RET_IN_VIEPORT)			{				var p = this._itPage;				var boundingWidth = this._boundingBox.width;				var range = this._rangeOutput;				var hs = this._horizontalSeparator;				p.number = range.start + (this._rI++);				p.width = range.width;				p.height = range.height;				p.y = this._y + hs;					//	console.log(p.y);				p.x = boundingWidth/2 - p.width / 2;								this._y = p.y + p.height;													return p;			}			else			{				throw Error("You have to call has next first!");			}		}			};		function Page()	{			this.number = 0;		this.x = 0;		this.y = 0;		this.width = 0;		this.height = 0;	}		function PageRange(start, width, height)	{		this.width = width;		this.height = height;						this.start = start;		this.length = 1;				this.totalHeight = null;	}		PageRange.prototype = {		tryAdd : function(width, height)		{			if (width === this.width && height === this.height)			{				++this.length;				return true;			}			else			{				return false;			}		},		fillBoundingBox : function(boundingBox, horizontalSeparator, verticalSeparator)		{					/**				HSHSHSHSH				VS ******* VS				VS PAGE VS				VS ******* VS				HSHSHSHSH				VS ******* VS				VS PAGE VS				VS ******* VS			*/			var len = this.length;					boundingBox.height = this.height * len + horizontalSeparator * len;			boundingBox.width = this.width + 2*verticalSeparator;		},		fillVisibleRange : function(outputRange, scrollY, currentY, viewportHeight, horizontalSeparator)		{			var len = this.length;			var totalHeight = this.height * len + horizontalSeparator * len;			var result = RET_NOT_IN_VIEPORT;						var localScroll = scrollY - currentY;			var viewportEndY = localScroll+viewportHeight;						outputRange.height = this.height;			outputRange.width = this.width;						if (currentY+totalHeight <= scrollY)			{				//nothing is visible								outputRange.start = this.start;				outputRange.length = this.length;				outputRange.totalHeight = totalHeight;					}			else if (viewportEndY < 0)			{				result = RET_IN_VIEPORT_END ;			}			else			{				var totalPageHeight = this.height + horizontalSeparator;				var start = outputRange.start = Math.max(this.start + (localScroll/totalPageHeight)|0, this.start);							var endIdx = Math.max(Math.min((this.start+(viewportEndY/totalPageHeight))|0, this.start+this.length-1), this.start);								var outLen = outputRange.length = endIdx - start + 1;			//	console.log("from:", (start+1), "to:" ,endIdx+1, localScroll/totalPageHeight, localScroll);							//console.log(this.start, viewportEndY/totalPageHeight, viewportEndY, totalPageHeight);				var nonVisiblePortion = start - this.start;								outputRange.totalHeight =  totalPageHeight * nonVisiblePortion;								result = RET_IN_VIEPORT;								if (endIdx +1< (this.start + this.length))				{//					console.log(endIdx+": RET_IN_VIEPORT_END");					result |= RET_IN_VIEPORT_END;				}			}						return result;		}	};	}(vitrium.viewer));
// script:viewer/document-renderers/scroll-master-document-renderer.js
/// <reference path="~/build.html" />

(function (exports, vitrium, ui, utils, geometry, _, $, Backbone, window)
{
  "use strict";
  var Point = vitrium.geometry.Point;
  var DataRectangle = vitrium.geometry2.DataRectangle;
  

  exports.ScrollMasterDocumentRenderer = ScrollMasterDocumentRenderer;
  exports.PageInfo = PageInfo;
  //var isIE9 = navigator.userAgent.indexOf("MSIE 9.0") !== -1;
  var SB_VERTICAL = 1;
  var SB_HORIZONTAL = 2;
  var SB_NONE = 0;
  var SB_CORRECTION = 21;

  var STATES = vitrium.viewer.STATES;
  var ST_READY = STATES.get("READY");
  var ST_LOCKED = STATES.get("LOCKED");


  function ScrollMasterDocumentRenderer(viewer)
  {
    ui.DomWidget.call(this, document.createElement("div"));
    this.el.className = "page-container scroll-master";
    this.viewer = viewer;
    this._uiRender.cancel();

    this.scrollableViewport = new ui.ScrollableViewport();
    this.pageLayoutManager = new vitrium.viewer.SequentialPageLayout();

    this.viewportDOMOffset = new Point(0, 0);
    this.pageElements = {};

    this.resizeAfterUnlock = false;

    this.uiCalculateViewport = new ui.UISync(this.calculateFrameViewport, this, -10);
    this._uiRender.p = 10;
    
    this.markPagesDirty = false;

    this.beforeFrameSynchronizedTasks = new ui.SingleInstanceTaskQueue();
    this.afterFrameSynchronizedTasks = new ui.SingleInstanceTaskQueue();

    this.verticalScrollBar = null;
    this.horizontalScrollBar = null;
    this.verticalScrollBarHandleEl = null;
    this.horizontalScrollBarHandleEl = null;
    this.pagesAttached = false;

    this.pageElCache = new ui.DOMElementPool("div", function (el) { el.className = "page" }, 10);

    this.tmpPoint = new Point(0, 0);

    this.tmpRectangle1 = new DataRectangle(0, 0, 0, 0, 0, null);
    this.tmpRectangle2 = new DataRectangle(0, 0, 0, 0, 0, null);
    this.tmpDUVieportState = {
      scrollX: 0,
      scrollY: 0,
      width: 0,
      height: 0,
      centerHorizontalConstant: 0
    };


    this.createScrollBars();
    this.events.on("PageCanvasManager:contentChanged", this.refresh);
  }

  ScrollMasterDocumentRenderer.prototype = _.extend(Object.create(ui.DomWidget.prototype),{
    destroy: function ()
    {
      vitrium.log.debug("document renderer destroy");
      this.pages = null;
      this.pageElements = null;
      this.pageElCache = null;
      this._uiRender.cancel();
    },   
    createScrollBars: function ()
    {
      var vertical = $("<div class='sb sb-vertical'><div class='sb-handle'></div></div>");
      var horizontal = $("<div class='sb sb-horizontal'><div class='sb-handle'></div></div>");

      this.verticalScrollBarEl = vertical[0];
      this.horizontalScrollBarEl = horizontal[0];
      this.verticalScrollBarHandleEl = vertical.find(".sb-handle")[0];
      this.horizontalScrollBarHandleEl = horizontal.find(".sb-handle")[0];
    },
    setViewportDimensions: function (viewportWidth, viewportHeight)
    {
      this.scrollableViewport.changeViewportDimensions(viewportWidth, viewportHeight);
    },
    setPages: function (pages)
    {
      this._uiRender.resume();
      this.pageLayoutManager.attachPages(pages);
      this.pagesAttached = true;
      this.onViewportChanged(false);
    },
    computeScale: function ()
    {
      var vp = this.scrollableViewport.viewport;

      return this.calcScale(vp.width, vp.height);
    },
    getDUViewportState: function ()
    {
      var result = this.tmpDUVieportState;
      var scrollableViewport = this.scrollableViewport;
      var scrollX = scrollableViewport.hScroll.contentPosition;
      var scrollY = scrollableViewport.vScroll.contentPosition;

      var viewportDimensions = this.viewportDimensions;
      var viewportWidth = scrollableViewport.viewport.innerWidth;
      var viewportHeight = scrollableViewport.viewport.height;

      /**
        convert from screen units to document units
      */
      var scale = this.viewer.scale;
      var duScrollX = scrollX / scale;
      var duScrollY = scrollY / scale;
      var duViewportWidth = viewportWidth / scale;
      var duViewportHeight = viewportHeight / scale;
      var duDocumentBoundingWidth = this.pageLayoutManager.boundingBox.width;
      var duViewportCenterConstant = 0;
      if (duDocumentBoundingWidth < duViewportWidth)
      {
        duViewportCenterConstant = duViewportWidth / 2 - (duDocumentBoundingWidth / 2);
      }

      result.scrollX = duScrollX;
      result.scrollY = duScrollY;
      result.width = duViewportWidth;
      result.height = duViewportHeight;
      result.centerHorizontalConstant = duViewportCenterConstant;

      return result;
    },
    viewportPages: function ()
    {
      var duViewport = this.getDUViewportState();
      return this.pageLayoutManager.visiblePages(duViewport.scrollX, duViewport.scrollY, duViewport.width, duViewport.height);
    },
    calcScale: function (width, height)
    {
      var viewport = this.scrollableViewport;
      var duBoundingBox = this.pageLayoutManager.boundingBox;
      var scale = this.viewer.limitScale(width / duBoundingBox.width);

      this.scrollableViewport.changeDimensions(width, height, duBoundingBox.width * scale, duBoundingBox.height * scale);
      var innerWidth = this.scrollableViewport.viewport.innerWidth;
      if (innerWidth !== width)
      {
        // scrollbar is present
        scale = this.viewer.limitScale(innerWidth / duBoundingBox.width);
        this.scrollableViewport.changeDimensions(width, height, duBoundingBox.width * scale, duBoundingBox.height * scale);
      }

      return scale;
    },
    calculateFrameViewport: function ScrollMasterDocumentRenderer__calculateFrameViewport(context)
    {
      var pages = context.pages;
      if (!pages)
      {
        pages = context.pages = [];
      }

      var scrollableViewport = this.scrollableViewport;
      var scrollX = scrollableViewport.hScroll.contentPosition;
      var scrollY = scrollableViewport.vScroll.contentPosition;

      var duViewport = this.getDUViewportState();
      var duScrollX = duViewport.scrollX;
      var duScrollY = duViewport.scrollY;

      var duViewportWidth = duViewport.width;
      var duViewportHeight = duViewport.height;
      var scale = context.scale = this.viewer.scale;
      var viewportCenterConstant = duViewport.centerHorizontalConstant * scale;
      var duCenterHorizontalConstant = duViewport.centerHorizontalConstant;

      var pageIt = this.pageLayoutManager.queryPages(duScrollX, duScrollY, duViewportWidth, duViewportHeight);
      var i = 0;
      var len = pages.length;
      while (pageIt.hasNext())
      {
        var page = pageIt.next();
        if (i < len)
        {
          var data = pages[i];
          
          data.init(page, duCenterHorizontalConstant,
            duScrollX, duScrollY, viewportCenterConstant, scrollX,
            scrollY, scale);
          
          data.initQueryRectangles(scrollX, scrollY,
            scrollableViewport.viewport.width, scrollableViewport.viewport.height);
        }
        else
        {
          // has to be exactly the same as above 
          pages.push(new PageInfo(page, duCenterHorizontalConstant,
            duScrollX, duScrollY, viewportCenterConstant, scrollX,
            scrollY, scale, scrollableViewport.viewport.width,
            scrollableViewport.viewport.height));

        }
        ++i;
      }

      pages.length = i;

      var currentPage = this.pageLayoutManager.getCurrentPageNumber(duScrollX, duScrollY, duViewportWidth, duViewportHeight);
      this.viewer.trigger("change:viewport", this.markPagesDirty, pages, scale);
      this.markPagesDirty = false;
      this.viewer.setProperty("currentPage", currentPage);
    },
    onRender: function ScrollMasterDocumentRenderer__onRender(context, time)
    {
      var container = this.el;
     container.style.display = "none";
      var viewer = this.viewer;

      this.beforeFrameSynchronizedTasks.execute();

      var createdElements = _.clone(this.pageElements);
      var pageElements = {};

      var pageCanvasManager = viewer.pageCanvasManager;
      var pageElCache = this.pageElCache;

      var pages = context.pages;
      var scale = context.scale;
      for (var i = 0, len = pages.length; i < len; ++i)
      {
        var page = pages[i];
        var pageNum = page.number;

        var pageCanvasContext = pageCanvasManager.getPage(pageNum);

        //	console.log(pageCanvasContext);
        //console.log(pageCanvasContext);
        var el = createdElements[pageNum];
        if (el)
        {
          delete createdElements[pageNum];
        } else
        {
          el = pageElCache.create(); //this.renderPage(container, pageNum);
          container.appendChild(el);
        }

        var style = el.style;

        style.width = page.width + "px";
        style.height = page.height + "px";
        style.left = page.x + "px";
        style.top = page.y + "px";

        var used = [];
        var tiles = pageCanvasContext.getTiles(page, scale, time);
        for (var t = 0, tlen = tiles.length; t < tlen; ++t)
        {
          var tile = tiles[t];
          var canvas = tile.canvas;
          var rect = tile.rect;
          var cstyle = canvas.style;
          cstyle.left = ((rect.x + 0.5) | 0) + "px";
          cstyle.top = ((rect.y+0.5)|0) + "px";
          cstyle.width = ((rect.w+0.5)|0) + "px";
          cstyle.height = ((rect.h + 0.5) | 0) + "px";
          cstyle.position = "absolute";

         
         el.appendChild(canvas);
         
          used.push(canvas);
        }

        removeAllChildsExcept(el, used);
        pageElements[pageNum] = el;
      }

      _.each(createdElements, function (page)
      {
        container.removeChild(page); //page.remove();
        removeAllChilds(page);

        pageElCache.free(page);
      });

      function removeAllChilds(el)
      {
        var len = el.childNodes.length;
        while (len--)
        {
          var ch = el.lastChild;
          ch.className = "";
          el.removeChild(ch);
        }
      }

      function removeAllChildsExcept(el, except)
      {
        var current = el.firstChild;
        while (current !== null)
        {
          var next = current.nextSibling;
          if (except.indexOf(current) === -1)
          {
            el.removeChild(current);
          }
          current = next;
        } 
      }

      this.pageElements = pageElements;
      pageCanvasManager.resetDirtyLayers(pages);

      this.renderScrollbarsState(container);
      container.style.display = "block";
      this.afterFrameSynchronizedTasks.execute();
    },
    renderLayerCanvas: function (page, pageCanvasContext, pageCanvasManager, width, height, scale, time)
    {
      var layerCanvas = pageCanvasContext.layerCanvas;
      var pageNumber = page.number;
      var hasContent = pageCanvasManager.hasLayerContent(pageNumber);
      var isDirty = pageCanvasManager.isLayerDirty(pageNumber);
      if (isDirty
        || (layerCanvas !== null
          && (layerCanvas.vitriumRequestedWidth !== width
          || layerCanvas.vitriumRequestedHeight !== height))
        || (layerCanvas === null && hasContent))
      {
        //console.log("repaint", layerCanvas ? layerCanvas.vitriumRequestedWidth : -1, width, isDirty);
        // layer needs to be painted
        layerCanvas = pageCanvasContext.getLayerCanvas(width, height);

        var layers = pageCanvasManager.layers;

        var ctx = layerCanvas.getContext("2d");

        ctx.save();
        ctx.clearRect(0, 0, width, height);
        ctx.scale(scale, scale);

        for (var i = 0, len = layers.length; i < len; ++i)
        {
          var layer = layers[i];
          if (layer.hasContent(pageNumber))
          {
            ctx.save();
            layer.render(pageNumber, ctx, time, page);
            ctx.restore();
          }
        }

        ctx.restore();
      }

      if (!hasContent)
      {
        pageCanvasContext.freeLayerCanvas();
      }

      return hasContent ? layerCanvas : null;
    },
    renderScrollbarsState: function (el)
    {
      var scrollableViewport = this.scrollableViewport;
      var hsDOMEl = this.horizontalScrollBarEl;
      var vsDOMEl = this.verticalScrollBarEl;

      var hs = scrollableViewport.hScroll;
      var vs = scrollableViewport.vScroll;

      var hsInDOM = !!hsDOMEl.parentElement;
      var vsInDOM = !!vsDOMEl.parentElement;

      if (hs.visible)
      {
        var style = this.horizontalScrollBarHandleEl.style;

        style.left = hs.handlePosition + "px";
        style.width = hs.handleSize + "px";
        //console.log(style, hs.handlePosition);
        if (!hsInDOM)
        {
          el.appendChild(hsDOMEl);
        }
      }
      else if (hsInDOM)
      {
        el.removeChild(hsDOMEl);
      }

      if (vs.visible)
      {
        var style = this.verticalScrollBarHandleEl.style;

        style.top = vs.handlePosition + "px";
        style.height = vs.handleSize + "px";

        if (!vsInDOM)
        {
          el.appendChild(vsDOMEl);
        }
      }
      else if (vsInDOM)
      {
        el.removeChild(vsDOMEl);
      }
    },
    getScrollbarHandle: function (inX, inY, tolerance)
    {
      var p = this.tmpPoint;
      p.x = inX;
      p.y = inY;

      this.translateToViewportFill(p, p);
      var x = p.x, y = p.y;

      var touch = this.tmpRectangle1;
      touch.init(x, y, tolerance, tolerance, 0, null);

      var scrollableViewport = this.scrollableViewport;

      var vs = scrollableViewport.vScroll;

      var cos = Math.cos;
      var sin = Math.sin;

      if (vs.visible)
      {
        var sbHandleRectangle = this.tmpRectangle2;
        sbHandleRectangle.init(scrollableViewport.viewport.innerWidth, vs.handlePosition, scrollableViewport.barThickness, vs.handleSize, 0,null);
        if (touch.isIntersectedFast(sbHandleRectangle, cos, sin))
        {
          return SB_VERTICAL;
        }
      }

      var hs = scrollableViewport.hScroll;
      if (hs.visible)
      {
        sbHandleRectangle.init(hs.handlePosition, scrollableViewport.viewport.innerHeight, hs.handleSize, scrollableViewport.barThickness, 0,null);
        if (touch.isIntersectedFast(sbHandleRectangle, cos, sin))
        {
          return SB_HORIZONTAL;
        }
      }

      return SB_NONE;
    },
    getDirectionFromScrollbarHandle: function (handle, inX, inY)
    {
      var p = this.tmpPoint;
      p.x = inX;
      p.y = inY;

      this.translateToViewportFill(p, p);
      var x = p.x, y = p.y;

      var touch = this.tmpRectangle1;
      touch.init(x, y, 1, 1, 0,null);

      var scrollableViewport = this.scrollableViewport;
      var vs = scrollableViewport.vScroll;

      var cos = Math.cos;
      var sin = Math.sin;
      var sbHandleRectangle = this.tmpRectangle2;
      if (handle === SB_VERTICAL)
      {
        sbHandleRectangle.init(scrollableViewport.viewport.innerWidth, vs.handlePosition, scrollableViewport.barThickness, vs.handleSize, 0,null);
        if (touch.isIntersectedFast(sbHandleRectangle, cos, sin))
        {
          return 0;
        }
        else if (vs.handlePosition > y)
        {
          return -1;
        }
        else
        {
          return 1;
        }
      }
      else
      {
        var hs = scrollableViewport.hScroll;
        sbHandleRectangle.init(hs.handlePosition, scrollableViewport.viewport.innerHeight, hs.handleSize, scrollableViewport.barThickness, 0,null);
        if (touch.isIntersectedFast(sbHandleRectangle, cos, sin))
        {
          return 0;
        }
        else if (hs.handlePosition > x)
        {
          return -1;
        }
        else
        {
          return 1;
        }
      }
    },
    getScrollbarArea: function (inX, inY, tolerance)
    {
      var p = this.tmpPoint;
      p.x = inX;
      p.y = inY;

      this.translateToViewportFill(p, p);
      var x = p.x, y = p.y;

      var touch = this.tmpRectangle1;
      touch.init(x - tolerance / 2, y - tolerance / 2, tolerance, tolerance, 0, null);

      var scrollableViewport = this.scrollableViewport;

      var vs = scrollableViewport.vScroll;

      var cos = Math.cos;
      var sin = Math.sin;

      var sbHandleRectangle = this.tmpRectangle2;
      sbHandleRectangle.init(scrollableViewport.viewport.innerWidth, 0, scrollableViewport.barThickness, scrollableViewport.viewport.innerHeight, 0, null);
      if (touch.isIntersectedFast(sbHandleRectangle, cos, sin))
      {
        return SB_VERTICAL;
      }

      var hs = scrollableViewport.hScroll;
      sbHandleRectangle.init(0, scrollableViewport.viewport.innerHeight, scrollableViewport.viewport.innerWidth, scrollableViewport.barThickness, 0, null);
      if (touch.isIntersectedFast(sbHandleRectangle, cos, sin))
      {
        return SB_HORIZONTAL;
      }

      return SB_NONE;
    },
    getScrollHandlePos: function (sbType)
    {
      if (sbType === SB_VERTICAL)
      {
        return this.scrollableViewport.vScroll.handlePosition;
      }
      else if (sbType === SB_HORIZONTAL)
      {
        return this.scrollableViewport.hScroll.handlePosition;
      }
      // this should never happen
      return null;
    },
    translateCoordinatesToPage: function (coordinates, pageNumber)
    {
      this.translateToViewportFill(coordinates, coordinates);
      this.convertToDocumentUnitsFill(coordinates, coordinates);
      var page = this.pageLayoutManager.getPage(pageNumber);

      var duViewport = this.getDUViewportState();
      coordinates.x += duViewport.scrollX - duViewport.centerHorizontalConstant;;
      coordinates.y += duViewport.scrollY;
      coordinates.x -= page.x;
      coordinates.y -= page.y;

      return coordinates;
    },
    translateCoordiatesFromPageToDU : function(coordinates, pageNumber)
    {
      var page = this.pageLayoutManager.getPage(pageNumber);
      coordinates.x += page.x;
      coordinates.y += page.y;

      return coordinates;
    },
    translateCoordinatesFromPageToDOM: function (coordinates, pageNumber)
    {
      this.translateCoordiatesFromPageToDU(coordinates, pageNumber);
      
      var duViewport = this.getDUViewportState();
      coordinates.x -= duViewport.scrollX - duViewport.centerHorizontalConstant;;
      coordinates.y -= duViewport.scrollY;
      
      var scale = this.viewer.scale;
      coordinates.x *= scale;
      coordinates.y *= scale;

      var domOffset = this.absoluteDim;
      coordinates.x += domOffset.x;
      coordinates.y += domOffset.y;
      
      return coordinates;
    },
    translateCoordinatesFromPageToDOMRelative: function (coordinates, pageNumber)
    {
      this.translateCoordiatesFromPageToDU(coordinates, pageNumber);
      
      var duViewport = this.getDUViewportState();
      coordinates.x -= duViewport.scrollX - duViewport.centerHorizontalConstant;;
      coordinates.y -= duViewport.scrollY;
      
      var scale = this.viewer.scale;
      coordinates.x *= scale;
      coordinates.y *= scale;
      
      return coordinates;
    },
    centerToPointOnPage: function (pageNumber, pointOnPage)
    {
      var page = this.pageLayoutManager.getPage(pageNumber);
      //this.scrollView
      var scrollableViewport = this.scrollableViewport;
      var viewport = scrollableViewport.viewport;

      var halfViewportWidth = viewport.width / 2;
      var halfViewportHeight = viewport.height / 2;

      var scale = this.viewer.scale;
      var pX = (page.x + pointOnPage.x) * scale;
      var pY = (page.y + pointOnPage.y) * scale;

      this.setScrollPosition2(pX - halfViewportWidth, pY - halfViewportHeight);
    },
    scrollToPoint: function (pageNumber, point, op)
    {
      if (!op || op === "center")
      {
        this.centerToPointOnPage(pageNumber, point);
      }
      else if (op === "top")
      {
        var page = this.pageLayoutManager.getPage(pageNumber);
        //this.scrollView
        var scrollableViewport = this.scrollableViewport;
        var viewport = scrollableViewport.viewport;
        
        var scale = this.viewer.scale;
        var pX = (page.x + point.x) * scale;
        var pY = (page.y + point.y) * scale;

        this.setScrollPosition2(pX, pY);

      }
      
    },
    scrollTo: function (pageNumber, add)
    {

      if (!add)
      {
        add = 0;
      }

      var page = this.pageLayoutManager.getPage(pageNumber);
      this.setVScrollPos(page.y * this.viewer.scale + add);
    },
    getCurrentPage: function ()
    {
      return this.viewportPages()[0];
    },
    setScale: function (scale, oldScale)
    {
      var duBoundingBox = this.pageLayoutManager.boundingBox;
      var scrollableViewport = this.scrollableViewport;


      var contentPosition = scrollableViewport.hScroll.contentPosition;
      var viewportCenter = scrollableViewport.viewport.innerWidth / 2;
      var duCenterPoint = (contentPosition + viewportCenter) / oldScale;
      var duScrollY = scrollableViewport.vScroll.contentPosition / oldScale;

      scrollableViewport.changeContentDimensions(duBoundingBox.width * scale, duBoundingBox.height * scale);

      var newContentPosition = scrollableViewport.hScroll.contentPosition;
      var newViewportCenter = scrollableViewport.viewport.innerWidth / 2;
      var newDuCenterPoint = (newContentPosition + newViewportCenter) / scale;

      /*console.log(contentPosition, viewportCenter, duCenterPoint);
      console.log(newContentPosition, newViewportCenter, newDuCenterPoint);*/
      scrollableViewport.setScrollPos(scrollableViewport.hScroll.contentPosition + (duCenterPoint - newDuCenterPoint) * scale, duScrollY * scale);

      this.onViewportChanged(true);
    },
    onViewportChanged: function (rerenderPageContent)
    {
      if (this.pagesAttached)
      {
        this.markPagesDirty = this.markPagesDirty || rerenderPageContent;
        this.uiLoop.runAsyncAsap(this.uiCalculateViewport);
        this.refresh();
        this.viewer.pauseRendering()
      }
    },
    getPageNumberByCoordinates: function (inX, inY, tolerance)
    {
      var p = this.tmpPoint;
      p.x = inX;
      p.y = inY;

      if (!tolerance)
      {
        tolerance = 1;
      }

      this.translateToViewportFill(p, p);
      this.convertToDocumentUnitsFill(p, p);
      var duViewport = this.getDUViewportState();

      var pageIt = this.pageLayoutManager.queryPages(duViewport.scrollX, duViewport.scrollY, duViewport.width, duViewport.height);

      var coordinatesRectangle = this.tmpRectangle1;
      coordinatesRectangle.init(p.x + duViewport.scrollX, p.y + duViewport.scrollY, tolerance, tolerance, 0, null);

      var pageRectangle = this.tmpRectangle2;
      var cos = Math.cos, sin = Math.sin;

      while (pageIt.hasNext())
      {
        var page = pageIt.next();
        pageRectangle.init(page.x + duViewport.centerHorizontalConstant, page.y, page.width, page.height, 0, null);
        if (coordinatesRectangle.isIntersectedFast(pageRectangle, cos, sin))
        {
          return page.number;
        }
      }

      return null;
    },
    getPageIteratorBetweenDU: function (start, end)
    {
      var sX = start.x, eX = end.x;
      if (eX < sX)
      {
        sX = eX;
        eX = start.x;
      }

      var sY = start.y, eY = end.y;
      if (eY < sY)
      {
        sY = eY;
        eY = start.y;
      }

      var height = eY - sY;
      var width = eX - sY;

      return this.pageLayoutManager.queryPages(sX, sY, width, height);
    },
    translateToViewportFill: function (outPoint, inPoint)
    {
       var domOffset = this.absoluteDim;
      var offsetX = domOffset.x;
      var offsetY = domOffset.y;

      outPoint.x = inPoint.x - offsetX;
      outPoint.y = inPoint.y - offsetY;

      return outPoint;
    },
    convertToDocumentUnitsFill: function (outPoint, inPoint)
    {
      var scale = this.viewer.scale;
      outPoint.x = inPoint.x / scale;
      outPoint.y = inPoint.y / scale;

      return outPoint;
    },
    scrollViewportPage: function (direction)
    {
      if (this.scrollableViewport.scrollRelative(0, this.scrollableViewport.viewport.innerHeight * direction))
      {
        this.onViewportChanged(false);
      }
    },
    setScrollPosition: function (pos)
    {
      if (this.scrollableViewport.setScrollPos(pos.x, pos.y))
      {
        this.onViewportChanged(false);
        return true;
      }
      return false;
    },
    setScrollPosition2: function (x, y)
    {
      if (this.scrollableViewport.setScrollPos(x, y))
      {
        this.onViewportChanged(false);
        return true;
      }
      return false;
    },
    setVScrollPos: function (y)
    {
      if (this.scrollableViewport.setVScrollPos(y))
      {
        this.onViewportChanged(false);
        return true;
      }
      return false;
    },
    setHScrollPos: function (x)
    {
      if (this.scrollableViewport.setHScrollPos(x))
      {
        this.onViewportChanged(false);
        return true;
      }
      return false;
    },
    setHHandlePos: function (x)
    {
      if (this.scrollableViewport.setHHandlePos(x))
      {
        this.onViewportChanged(false);
        return true;
      }
      return false;
    },
    setVHandlePos: function (y)
    {
      if (this.scrollableViewport.setVHandlePos(y))
      {
        this.onViewportChanged(false);
        return true;
      }
      return false;
    },
    scrollToBeginning: function ()
    {
      if (this.scrollableViewport.setVScrollPos(0))
      {
        this.onViewportChanged(false);
        return true;
      }
      return false;
    },
    scrollToEnd: function ()
    {
      var sV = this.scrollableViewport;

      if (sV.setVScrollPos(sV.vScroll._contentSize))
      {
        this.onViewportChanged(false);
        return true;
      }
      return false;
    },
    scrollByStep: function (deltaX, deltaY)
    {
      var scale = this.viewer.scale;
      var stepX = deltaX * 30 * scale;
      var stepY = deltaY * 40 * scale;

      if (this.scrollableViewport.scrollRelative(-stepX, -stepY))
      {
        this.onViewportChanged(false);
      }
    },
    fillScrollPosition: function (pos)
    {
      var scrollableViewport = this.scrollableViewport;
      pos.x = scrollableViewport.hScroll.contentPosition;
      pos.y = scrollableViewport.vScroll.contentPosition;
      return pos;
    },
    setDim: function (dim)
    {
      ui.DomWidget.prototype.setDim.call(this, dim);

      if (this.pageLayoutManager.boundingBox && this.viewer.resizeMode === vitrium.viewer.ResizeMode.SCALE_CONTENT)
      {
        var scrollableViewport = this.scrollableViewport;
        var duScrollY = scrollableViewport.vScroll.contentPosition / this.viewer.scale;

        var scale = this.calcScale(dim.w, dim.h);

        this.viewer.setScaleInternal(scale);

        scrollableViewport.vScroll.changeContentPosition(duScrollY * scale);

        this.onViewportChanged(true);
      }
      else
      {

        this.setViewportDimensions(dim.w, dim.h);
        this.onViewportChanged(false);
      }
    },
    beforeFrame: function (callback)
    {
      this.beforeFrameSynchronizedTasks.push(callback);
    },
    afterFrame: function (callback)
    {
      this.afterFrameSynchronizedTasks.push(callback);
    }

  });

  function ElementsGuard()
  {
    this.dom = [];
    this.tmp = null;
  }

  ElementsGuard.prototype =
  {
    begin : function()
    {
      this.tmp = [];
    },
    add : function(el)
    {
      this.tmp.push(el);
    },
    commit : function()
    {
      var result = _.difference(this.dom, this.tmp);
      this.dom = this.tmp;
      this.tmp = null;
      return result;
    }
  };

  function PageInfo(page, duCenterHorizontalConstant, duScrollX, duScrollY, viewportCenterConstant, scrollX, scrollY, scale, viewportWidth, viewportHeight)
  {
    /// <field name="baseRect" type="geometry.Rectangle"></field>
    /// <field name="viewportRect" type="geometry.Rectangle"></field>

    this.init(page, duCenterHorizontalConstant, duScrollX, duScrollY, viewportCenterConstant, scrollX, scrollY, scale);
    
    this.baseRect = new geometry.Rectangle(0, 0,0, 0, 0);
    this.viewportRect = new geometry.Rectangle(0, 0, 0, 0, 0);

    this.initQueryRectangles(scrollX, scrollY, viewportWidth, viewportHeight);

  }

  PageInfo.prototype = {
    init : function(page, duCenterHorizontalConstant, duScrollX, duScrollY, viewportCenterConstant, scrollX, scrollY, scale)
    {
      this.number = page.number;

      this.x = (viewportCenterConstant + page.x * scale - scrollX + 0.5) | 0;
      this.y = (page.y * scale - scrollY + 0.5) | 0;
      this.width = (page.width * scale + 0.5) | 0;
      this.height = (page.height * scale + 0.5) | 0;

      this.pX = (viewportCenterConstant + page.x * scale + 0.5) | 0;
      this.pY = (page.y * scale + 0.5) | 0;

      this.oX = page.x;
      this.oY = page.y;
      this.duX = duCenterHorizontalConstant + page.x - duScrollX;
      this.duY = page.y - duScrollY;
      this.duWidth = page.width;
      this.duHeight = page.height;
    },
    initQueryRectangles: function (scrollX, scrollY, viewportWidth, viewportHeight)
    {
      this.baseRect.w = this.width;
      this.baseRect.h = this.height;

      this.viewportRect.x = (scrollX- this.pX +0.5)|0;
      this.viewportRect.y = (scrollY - this.pY+0.5)|0;

      this.viewportRect.w = viewportWidth;
      this.viewportRect.h = viewportHeight;
    }
  };

}(
    vitrium.viewer,
    vitrium,
    vitrium.ui,
    vitrium.utils,
    vitrium.geometry2,
    _,
    jQuery,
    Backbone,
    __globals__));
// script:viewer/document-renderers/canvas-document-renderer.js
(function (exports, ui,  _, globals) {
  "use strict";
  
  var GLOBAL_PIXEL_RATIO	= ui["CANVAS_POOL"]["GLOBAL_PIXEL_RATIO"];
  
  var $super = exports.ScrollMasterDocumentRenderer;
  var $superP = $super.prototype;
  
  exports.CanvasDocumentRenderer = CanvasDocumentRenderer;
  function CanvasDocumentRenderer(viewer, options)
  {
    $super.call(this, viewer, options);
    var c = this.el = document.createElement("canvas");
    c.className = "canvas-renderer";
  /*	var s = c.style;
    s.width = s.height = "100%";*/
    
  }
  
  var P = CanvasDocumentRenderer.prototype = Object.create($superP);
      
    
  P.setImageSmoothing = function(ctx, val)
  {
 //   if ($.browser.firefox) val = false;
    if ("mozImageSmoothingEnabled" in ctx)
    {
      ctx.mozImageSmoothingEnabled = val;
    }
    else if ("webkitImageSmoothingEnabled" in ctx)
    {
      ctx.webkitImageSmoothingEnabled = val;
    }
    else if ("imageSmoothingEnabled" in ctx)
    {
      ctx.imageSmoothingEnabled = val;
    }
    else if ("msImageSmoothingEnabled" in ctx)
    {
      ctx.msImageSmoothingEnabled = val;
    }
  };
  
  P.prepareCanvas = function(viewportWidth, viewportHeight)
  {
    var c = this.el;
    var ctx = c.getContext("2d");

    //ios fixed performance drop in landscape mode
    var width = (((viewportWidth* GLOBAL_PIXEL_RATIO)-2)+0.5)|0;
    var height = ((viewportHeight *GLOBAL_PIXEL_RATIO)+0.5)|0;
    
  
    if (c.width !== width || c.height !== height)
    {			
      c.width = width;
      c.height = height;		
      
      
    }
    else
    {
      ctx.clearRect(0, 0,  width, height);
    }
        
      
    return ctx;
  };
    
  P.onRender = function(context, time)
  {
  //  console.log("render viewport");
    this.beforeFrameSynchronizedTasks.execute();
    var viewer = this.viewer;
    var viewport = this.scrollableViewport.viewport;		
    var gpr = GLOBAL_PIXEL_RATIO;
  
    var ctx = this.prepareCanvas(viewport.width, viewport.height);
    
    ctx.save();
   // ctx.translate(0.5, 0.5);
    ctx.fillStyle = "white";
    ctx.strokeStyle = "#bbb";
    ctx.lineWidth = 1;
    var pageCanvasManager = viewer.pageCanvasManager;
    var pages = context.pages;
    var max = Math.max;
    for (var i = 0, len = pages.length; i < len; ++i)
    {
      var page = pages[i];
      var pageCanvasContext = pageCanvasManager.getPage(page.number);

      var x = (page.x * gpr);
      var y = (page.y * gpr);
      var width = (page.width * gpr) ;
      var height = (page.height * gpr) ;

      ctx.translate(x, y);
      var tiles = pageCanvasContext.getTiles(page, context.scale, time);

      var cols = {};
      var rows = {};

      for (var t = 0, tlen = tiles.length; t < tlen; ++t)
      {
        var tile = tiles[t];
        var canvas = tile.canvas;
        var rect = tile.rect;
        
        var tx = cols[rect.x] = (rect.x * gpr);
        cols[rect.x + rect.w] = (tx + (rect.w * gpr));
        var ty = rows[rect.y] = (rect.y * gpr) ;
        rows[rect.y + rect.h] = (ty + (rect.h * gpr));
      }

      
      for (var t = 0, tlen = tiles.length; t < tlen; ++t)
      {
        var tile = tiles[t];
        var canvas = tile.canvas;
        var rect = tile.rect;
       var tx = cols[rect.x];
        var ty = rows[rect.y];
        var eX = cols[rect.x + rect.w];
        width = max(width, eX);
        var twidth = eX - tx;
        var eY = rows[rect.y + rect.h];
        height= max(height, eY);
        var theight =  eY- ty;
/*
        this.setImageSmoothing(ctx, (rect.w*gpr+0.5|0) !== canvas.width);
        ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height, rect.x*gpr, rect.y*gpr, rect.w*gpr, rect.h*gpr);*/
        
        this.setImageSmoothing(ctx, ((rect.w * gpr + 0.5) | 0) !== canvas.width);
        ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height, rect.x*gpr, rect.y*gpr, rect.w*gpr, rect.h*gpr);
      }
      ctx.translate(-x, -y);

      ctx.beginPath();
      ctx.rect(x+0.5, y+0.5, width-1, height-1);
      if (tiles.length === 0)
      {
        ctx.fill();
      }
      ctx.stroke();
    }
    ctx.restore();
    
    pageCanvasManager.resetDirtyLayers(pages);

    this.renderScrollbarsState(ctx,  gpr);
    this.afterFrameSynchronizedTasks.execute();
  };
  
  P.renderScrollbarsState = function(ctx, gpr)
  {
    ctx.fillStyle = "DarkGray";
    var scrollableViewport = this.scrollableViewport;
    var hs = scrollableViewport.hScroll;
    var vs = scrollableViewport.vScroll;
    var sb = (scrollableViewport.barThickness*gpr+0.5)|0;
    if (hs.visible)
    {
      var handleSize = (hs.handleSize*gpr + 0.5 )|0;
      var handlePosition =  (hs.handlePosition*gpr + 0.5 )|0;
      
      ctx.fillRect(handlePosition, ((scrollableViewport.viewport.height*gpr+0.5)|0) - sb, handleSize, sb);
    }
    
    if (vs.visible)
    {
      var handleSize = (vs.handleSize*gpr + 0.5 )|0;
      var handlePosition =  (vs.handlePosition*gpr + 0.5 )|0;
      
      ctx.fillRect((scrollableViewport.viewport.innerWidth*gpr + 0.5)|0, handlePosition, sb, handleSize);
    }
  }
    
}(
vitrium.viewer, 
vitrium.ui, 
_, 
__globals__));

// script:viewer/tools-controller.js
/// <reference path="~/build.html" />

(function (exports, ui, i18n, $, _, Backbone, fs, io, viewer, globals) {
   "use strict";
   var _T = i18n._T;

   var MENU_REFRESH_REQUESTED = "menuRefreshRequested";
   exports.ToolsController = ToolsController;

   function ToolsController(model, context)
   {
      this.model = model;
      this.context = context;

      model.on("action:delete", this.onDocumentDelete, this);
      model.on("action:save", this.onDocumentSave, this);
      model.on("action:manage", this.onOpenStoredDocuments, this);
      model.on("action:about", this.onAbout, this);

   }

   
   ToolsController.prototype.registerHideBoxLoading = function(box)
   {
      var model = this.model;
      model.on("change:refreshing", function onMenuUpdated(model, val) {
         //console.log("refreshing changed");
         if (!val) {
            box.hideLoading();

            box.hide();

            model.off("change:refreshing", onMenuUpdated);
         }
      });

   };

   ToolsController.prototype.onDocumentDelete = function () {
      var viewer = this.context.viewer;
      var view = this.context.view;
      var ctx = this.context.document.getContext();
      var cache = ctx.cacheManager;

      var self = this;
      
         var box = vitrium.viewer.showDismissBox(viewer, "",
         _T("delete-current-document-title"),
          _T("delete-current-document-question"),
         {
            view: view,
            buttons:
            [
                { id: "close", title: _T("fs-cancel") },
                { id: "do-delete", title: _T("fs-action-item-delete-title"), cssClass: "btn-primary btn-danger" }
            ]
         });

         box.on("button:do-delete", function (evt) {
            evt.preventDefault();
            box.showLoading();
            
            self.registerHideBoxLoading(box);

            cache.forceInvalidate(ctx.url, function () {
               self.model.trigger(MENU_REFRESH_REQUESTED);
            },
            function (error) {
               virtrium.log.error(error);
               box.hideLoading();
               box.displayMessages("fs-action-failed");
            });
         });
   };


   ToolsController.prototype.onAbout = function () {
      var ABOUT_BOX_TEMPLATE = _.template('<p><strong>Version</strong>: <%=version%></p>\
                                         <p><strong>Network status</strong>: <%=networkStatus%></p>\
                                         <p><strong>User agent</strong>: <%=userAgent%></p>\
                                         <% if (lastError) { %><p><strong>Last error</strong>: <%=lastError%></p><%}%>\
                                        ');
      
      var version =vitrium.viewer.version;
      var buttons;
      var feedbackUrl = this.context.options.feedbackUrl;
      if (_.isEmpty(feedbackUrl))
      {
         buttons = [ 
           {id :"close", cssClass: "btn-primary", title:_T("fs-close")}
         ];
      }
      else
      {
         buttons = [ 
           {id :"feedback", title:_T("about-send-feedback-button")},
           {id :"close", cssClass: "btn-primary", title:_T("fs-close")}
         ];
      }
      
      
      var logErrorCapture = vitrium.log.getCapture(function (logmsg) { return logmsg.level >= 3; });
      var lastError = null;
      if (logErrorCapture.length !== 0)
      {
         lastError = logErrorCapture[logErrorCapture.length - 1].message.toString();
      }
      
      var content = ABOUT_BOX_TEMPLATE({
         _T : vitrium.i18n._T,
         version : version.toString(),
         lastError : lastError,
         userAgent: window.navigator.userAgent,
         networkStatus : window.navigator.onLine ? "online" : "offline"				
      });
      
      var viewer = this.context.viewer;
      var view = this.context.view;
      var box = vitrium.viewer.showDismissBox(viewer, "", 
      vitrium.i18n._T("about-title"), 
      content,
      {
         view : view,
         buttons : buttons
      });
      
      box.on("button:feedback", function(event)
      {
         setTimeout(function(){  
            var model = new SuggestionFormModel();
            var form = new vitrium.ui.Form(model, {
               manualSync : true,
               fields : [
                 {	
                    id : "feedback", 
                    type: "textarea",
                    label : _T("send-feedback-feedback-label") 
                 }, 
                 {	
                    id : "email", 
                    type: "text", 
                    label : _T("send-feedback-email-label"), 
                    placeholder : _T("send-feedback-email-placeholder") 
                 }
               ]
            });
          
        
            var box = vitrium.viewer.showDismissBox(viewer, "", 
            vitrium.i18n._T("send-feedback-title"), 
            form.el,
            {
               view : view,
               buttons : [	
                 {id :"close", title:_T("fs-close")}, 
                 {id :"feedback", title:_T("about-send-feedback-button"), cssClass:"btn-primary no-key"}
               ]
            });
            form.focus("feedback");
            //	var textarea = box.el.find("textarea");
          
            box.on("button:feedback", function(evt) {	
               form.sync();
               var formValues = model.toJSON();
               if (formValues["feedback"].length === 0)
               {
                  form.displayMessages({ "feedback" : { type : "error" , text : "fs-action-err-empty"}});
                  form.focus("feedback");
                  evt.preventDefault();
                  return;
               }
          
        
               if (feedbackUrl.indexOf("mailto:") === 0)
               {			
                  var url = feedbackUrl;
                  var to =  null;
                  if (feedbackUrl.indexOf("?") !== -1)
                  {
                     url+= "&subject=";
                     to = feedbackUrl.substring("mailto:".length, feedbackUrl.indexOf("?"));
                  }
                  else
                  {
                     url+= "?subject=";
                     to = feedbackUrl.substring("mailto:".length, feedbackUrl.length);
                  }
            
                  url += encodeURIComponent(_T("send-feedback-subject"));
                            
                  var body = generateHumanMessage();
                  url+="&body="+encodeURIComponent(body);
      
                  displayProblemBox(vitrium.i18n._T("send-feedback-problem-text", [to]), body);						
                  // trigger mailto 
                  window.location = url;
               }
               else
               {
            
              
                  var data = _.extend({ 
                     "log" : vitrium.log.getCapture(),
                     "userAgent" :window.navigator.userAgent,
                     "url" : window.location.toString()
                  }, formValues);
                  var origin = window.location.origin;
              
                  if (feedbackUrl.indexOf("http") === 0 && feedbackUrl.indexOf(origin) !== 0)
                  {
                     vitrium.utils.loadDataCORS({ 
                        url : feedbackUrl, 
                        method : "POST", 
                        data : JSON.stringify(data), 
                        headers : [["Content-Type", "application/json"]],
                        success : handleSuccess,
                        error : handleError
                     });
                  }
                  else
                  {
                     $.ajax({ 
                        url : feedbackUrl, 
                        method : "POST", 
                        data : JSON.stringify(data), 
                        contentType:  "application/json",
                        success :handleSuccess,
                        error : handleError,
                        dataType : "text"
                     });
                  }
              
                  box.showLoading();
                  evt.preventDefault();
               }
            
            
               function handleError()
               {
                  box.hideLoading();
                  box.hide();
                  form.destroy();
              
                  displayProblemBox(_T("send-feedback-connection-error"));
               }
            
               function handleSuccess()
               {
                  box.hideLoading();
                  box.hide();
                  form.destroy();
               }
            
               function generateHumanMessage()
               {
                  var logCapture =  vitrium.log.getCapture();
                  var messages = [];
                  var levels = ["d", "i", "w", "e"];
                  for (var i = 0, len=logCapture.length; i < len; ++i)
                  {
                     var level = levels[logCapture[i].level];
                     if (!level)
                     {
                        level = "unknown";
                     }
                
                     messages.push("["+level+"] " + logCapture[i].message);
                  }								
              
                  var body = _T("send-feedback-problem-description")+"\n" 
                  +formValues["feedback"]
                  +"\nEmail:"+formValues["email"]+"\n\n"
                  +_T("send-feedback-system-information")
                  +"\nURL:"+window.location.toString()
                  +"\nUser Agent:"+window.navigator.userAgent
                  +"\nNetwork Status: "+(window.navigator.onLine ? "online":"offline")
                  +"\n\nLog:\n"+messages.join("\n");
            
                  return body;
               }
            
               function displayProblemBox(message, body)
               {
                  setTimeout(function(){
                     body = body || generateHumanMessage();
                     var box = vitrium.viewer.showDismissBox(viewer, "", 
                       vitrium.i18n._T("send-feedback-title"), 
                       message+ "<pre>"+body+"</pre>");							
                  
                     if (!vitrium.is_mobile)
                     {
                        vitrium.viewer.selectText(box.el.find("pre")[0]);
                     }
                  },0);
               }
            });
         }, 0);
        
      });
   };

   ToolsController.prototype.onDocumentSave = function()
   {
      if (this.context.document !== null)
      {
         var self = this;
         var dViewer = this.context.viewer;

         var defaultButtons = [ { "id": "cancel" , "title" : i18n._T("ui-tools-downloading-cancel")}];
         //TODO refactor MenuItemsModel into different class, it is more generic, just reuse
         var model = new viewer.MenuItemsModel({
            "title" :  i18n._T("ui-tools-downloading"), 
            "progress" : 0, 
            "buttons" : defaultButtons
         });
        
         var view = this.context.view;
         var progressDialog = vitrium.viewer.showProgressScreen(dViewer, model, {view : view});
         var task = this.context.document.downloadToOfflineStorage().whenProgress(function (progress)
         {
            model.set("progress", progress);
         })
         .then(function(){
            model.set({
               "title": i18n._T("ui-tools-download-completed"),
               "progress": "done",
               "buttons": [
                 { "id": "close", "title": i18n._T("ui-tools-download-close") }
               ]
            });
            progressDialog.el.find(".modal-body").prepend($("<div class='alert alert-success'>" + i18n._T("message-download-successful") + "</div>"));

            self.model.trigger(MENU_REFRESH_REQUESTED);

         })
         .catchError(function (e)
         {
            model.set({
               "title": i18n._T("ui-tools-download-failed"),
               "progress": "done",
               "buttons": [
                 { "id": "close", "title": i18n._T("ui-tools-download-close") }
               ]
            });
            progressDialog.el.find(".modal-body").prepend($("<div class='alert alert-error'>" + i18n._T("ui-tools-download-failed-message") + "</div>"));
         }).whenComplete(function ()
         {
            dViewer.currentStorageAction = null;
         });

         dViewer.currentStorageAction = {
            cancel: function ()
            {
               progressDialog.hide();
            }
         };         

//         self.registerHideBoxLoading(progressDialog);

         var self = this
         progressDialog.on("button:close", function(evt)
         {
            evt.preventDefault();
            progressDialog.hide();
         });
          
         progressDialog.on("button:cancel", function()
         {
            task.cancel();
         });
          
         progressDialog.on("view:show",function(visible)
         {
            if (!visible)
            {
               task.cancel();
               dViewer.currentStorageAction = null;
            }
         });
          
         model.on("closed", function()
         {
            task.cancel();
         });   
      }
   };

   ToolsController.prototype.onOpenStoredDocuments = function () {
      var model = new fs.BrowserModel();
      model.set("mode", "edit");
      var controller = new fs.BrowserController(model);
      var currentDocumentDialog = null;
      var currentDocumentId = null;

      model.on("node:pushed", function (model, node) {
         node.on("invalidate", onInvalidate);

      });
      model.on("node:popped", function (model, node) {
         node.off("invalidate", onInvalidate);
      });

      function onInvalidate(id) {
         controller.pop(id);
      }



      var inlineActions = [
                        { id: "item-delete", icon: "fa fa-trash-o", cssClass: "btn-danger" }//,
                        /*{   id : "item-move", icon : "icon-share-alt"	},
                        {   id : "item-rename", icon : "icon-edit"	}*/
      ];

      var root = [
            new fs.ContainerRenderer("fs-top", [
                new fs.NameView(model, controller)//,
                //new fs.EditModeButton(model, new fs.ActionView(model, controller,{ /*"create-folder" : "icon-plus"*/ }))
            ]),
            new fs.ContainerRenderer("fs-cb", []),
            new fs.ListView(model, controller, {
               "folder": "fa fa-folder-open"
            },
            inlineActions
            )
      ];

      var folders = [
            new fs.ContainerRenderer("fs-top", [
                new fs.NameView(model, controller)//,
                //new fs.EditModeButton(model, new fs.ActionView(model, controller,{ /*"create-folder" : "icon-plus"*/}))
            ]),
            new fs.ContainerRenderer("fs-cb", []),
            new fs.ListView(model, controller, {
               "folder": "fa fa-folder-open"
            },
            inlineActions
            )
      ];

      /*var documents = [
          new fs.ContainerRenderer("fs-top", [
              new fs.NameView(model, controller)
          ]),
          new fs.ContainerRenderer("fs-cb", []),
          new fs.ContainerRenderer("vitrium-fs-document-view", [
            new DocumentView()
          ])
      ];*/
      $(globals).on("storage", refreshAll);

      function refreshAll() {
         if (currentDocumentDialog !== null) {
            fsStorage.loadDocument(function (document) {
               // do nothing
            },
            function error() {
               if (currentDocumentDialog !== null) {
                  currentDocumentDialog.triggerButtonAction("close");
                  currentDocumentDialog = null;
               }
            }, currentDocumentId);
         }

         controller.refreshAll();
      }

      var view = this.context.view;
      var dialog = new fs.Dialog(view, {
         cssClass: "fs-file-dialog",
         title: _T("ui-tools-saved-documents-title"),
         body: "",
         buttons: [
           { id: "close", title: _T("fs-close") }
         ]
      });

      var self = this;
      dialog.on("button:close", function (evt) {
         evt.preventDefault();
         $(globals).off("storage", refreshAll);

         self.model.trigger(MENU_REFRESH_REQUESTED);

         dialog.hide();
      });

      this.context.viewer.on("document:detached", function () {
         view.destroyAll();
      });

      new fs.FSBrowserView(dialog.el.find(".modal-body"), model, {
         "root": root,
         "folder": folders
      },
        0.5
      );

      new fs.CreateFolderActionView(model, view, controller);
      new fs.RenameActionView(model, view, controller);
      new fs.DeleteActionView(model, view, controller);
      new fs.MoveActionView(model, view, controller);

      var fsStorage = io.CachableFileSystemContext.getCacheManager().getFSStorage();
      var fsService = new fs.SimpleFSService(fsStorage, { fsNodesClass: NodesCreator });
      fsService.getRoot(function (node) {
         controller.push(node);
      });

      model.on("action-success", function (action) {
          dialog.displayMessages([{ type: "success", text: "fs-action-" + action + "-success" }]);
      });

      model.on("node:pushed", function () {
         dialog.clearMessages();
      });

      model.on("node:popped", function () {
         dialog.clearMessages();
      });

      model.on("action:open-document", function (controller, id, current) {
         dialog.showLoading();

         fsStorage.loadDocument(function (document) {
            dialog.hideLoading();

            currentDocumentId = id;
            var d = currentDocumentDialog = new fs.Dialog(view, {
               cssClass: "vitrium-document-dialog",
               title: document.title,
               body: DOCUMENT_DIALOG_TEMPLATE({ _T: i18n._T, document: document, formatSize: globals.formatSize, formatDateTime: formatDateTime }),
               buttons: [
                 { id: "close", title: _T("btn-cancel") },
                 { id: "open", title: _T("ui-tools-open"), cssClass: "btn-primary" }
               ]
            });

            d.on("button:open", onOpen);
            d.on("button:close", onClose);

            d.show();

            function onOpen(evt) {
               onClose();

               if (globals.location == document.location) {
                  globals.location.reload();
               }
               else {
                  globals.location = document.location;
               }

               view.destroyAll();
            }

            function onClose(evt) {
               d.off();

               currentDocumentDialog = null;
               currentDocumentId = null;
            }


         },
         function (error) {
            dialog.hideLoading();
         }, id);
      });


      dialog.show();
   };

   function formatDateTime(timestamp) {
      var d = new Date(timestamp);
      var month = d.getMonth();
      month += 1;
      if (month < 10) {
         month = "0" + month;
      }
      var day = d.getDate();
      if (day < 10) {
         day = "0" + day;
      }

      var hour = d.getHours();
      if (hour < 10) {
         hour = "0" + hour;
      }

      var minute = d.getMinutes();
      if (minute < 10) {
         minute = "0" + minute;
      }


      return d.getFullYear() + "-" + month + "-" + day + "&nbsp;" + hour + ":" + minute;

   }

   var DOCUMENT_DIALOG_TEMPLATE = _.template('<div class="vitrium-document-thumbnail"><img src="<%=document.thumb||""%>" class="img-polaroid" /></div>\
    <div class="vitrium-document-info">\
    <h4><%=document.title%></h4>\
    <% if (document.author && document.author.length > 0) { %>\
    <p>\
      <strong><%=_T("document-author-label")%>:</strong> <%=document.author%>\
    </p>\
    <%}%>\
      <p><strong><%=_T("document-pages-label")%>:</strong> <%=document.pages%></p>\
      <p><strong><%=_T("document-size-label")%>:</strong> <%=formatSize(document.info.length, true) || "unknown"%></p>\
      <p><strong><%=_T("document-saved-label")%>:</strong> <%=formatDateTime(document.info.stateChanged) || "unknown"%></p></div>');

   function NodesCreator() {
      fs.FSNodes.apply(this, arguments);
   }
   _.extend(NodesCreator.prototype, fs.FSNodes.prototype);
   _.extend(NodesCreator.prototype, {
      createModelItem: function () {
         var result = fs.FSNodes.prototype.createModelItem.apply(this, arguments);

         if (result.type === "document") {
            result.action = "open-document";
         }

         return result;
      }
   });



   var SuggestionFormModel = Backbone.Model.extend({
      defaults: {
         email: "",
         feedback: ""
      }
   });

}
(vitrium.viewer,
vitrium.ui,
vitrium.i18n,
jQuery,
_,
Backbone,
vitrium.fs,
vitrium.io,
vitrium.viewer,
__globals__));

// script:viewer/tools-ui.js
/// <reference path="~/build.html" />

(function (exports, ui, i18n, $, _, Backbone, fs, io, geometry, globals)
{
  "use strict";
  var _T = i18n._T;
  var viewer = exports;
  var STATES =viewer.STATES;
  var ST_LOCKED = STATES.get("LOCKED");
  var ST_READY = STATES.get("READY");
  var ST_NOT_READY = STATES.get("NOT_READY");
  var ST_RENDERING_PAUSED = STATES.get("RENDERING_PAUSED");

  var OFFLINE_ST_SUPPORTED = "supported";
  var OFFLINE_ST_NOT_SUPPORTED = "notsupported";
  var OFFLINE_ST_DOWNLOADED = "downloaded";
  var OFFLINE_ST_DISABLED = "disabled";
  

  exports.ToolsControl = ToolsControl;
  
  function ToolsControl(_viewer, toolsMenuModel, options)
  {
    ui.ContainerWidget.call(this);
    this.layoutManager = new ui.BoxLayout(this);
    this.layoutManager.align = ui.DIRECTION.RIGHT;
    this.layoutManager.center = true;

    this.viewer = _viewer;
    this.view = new  viewer.FSDialogViewAdapter(this.viewer);
    this.options = options || {};
    this._renderedButtons = [];
    this._size = 0;

    $(this._containerEl).addClass("btn-group");
    
   
   // this.$el.on("tap click", "button", _.bind(this.showToolsMenu, this));
    
    this.onStorageChanged = _.bind(this.__onStorageChanged, this);
    
    _viewer.on("document:attached", this.documentAttached, this);
    _viewer.on("document:detached", this.documentDetached, this);
    _viewer.on("change:state", this.onStateChanged, this);

        
    //_viewer.on("document:offline-invalidated", this.onStorageChanged);
    
    
    vitrium.i18n.on("language:changed", this.languageChanged, this);
    
    this.document = null;
        
    this.languageChanged(vitrium.i18n);
    this.onStateChanged(_viewer.state.current(), _viewer.state);
    

    $(globals).on("storage", this.onStorageChanged);

    this.toolsMenuModel = toolsMenuModel;
    this.toolsMenuScreen = null;
    
    
    this.updateMenutItemsCallback = null;

    this.events.on("action:DownloadCurrentDocument", this.onDocumentSave);
    this.events.on("action:ShowToolsMenu", this.showToolsMenu);
    this.events.on("action:HideToolsMenu", this.hideToolsMenu);

    toolsMenuModel.on("change:refreshing", this.onRefreshingChanged, this);
    toolsMenuModel.on("chnage:offlineState", this.onOfflineStateChanged, this);
    toolsMenuModel.on("change:choices", this.onChoicesChanged, this);
    toolsMenuModel.on("change:defaultChoices", this.refreshToolsMenuItems, this);
    toolsMenuModel.on("menuRefreshRequested", this.refreshToolsMenuItems, this);

    this.refreshToolsMenuItems();

    this.refreshAgain = false;
    this.sortedWidgets = [];
  }
  

  ToolsControl.prototype = _.extend(Object.create(ui.ContainerWidget.prototype), {
     onRefreshingChanged : function(model, val)
     {
        if (this.toolsMenuScreen)
        {
           if (val)
           {
              this.toolsMenuScreen.showLoading();

           }        
           else
           {
              this.toolsMenuScreen.hideLoading();
           }
        }     
     },
     onOfflineStateChanged: function()
     {
        if (this.toolsMenuScreen)
        {
           var val = this.toolsMenuModel.get("offlineState");
           var body = this.toolsMenuScreen.el.find(".modal-body");
           if (val === OFFLINE_ST_NOT_SUPPORTED)
           {
              body.prepend("<div class='alert alert-info'>" + _T("message-cache-is-disabled") + "</div>");
           }
           else
           {
              body.find(".alert.alert-info").remove();
           }
        }
     },
     onActivate: function()
     {
        ui.ContainerWidget.prototype.onActivate.call(this);
        this.listen($(this.el), "tap click", "button", _.bind(this.onButtonClicked, this));

     },
     onButtonClicked: function(evt)
     {
        var action = $(evt.currentTarget).attr("data-id");
        if (action === "tools")
           this.showToolsMenu();
        else
           this.toolsMenuModel.trigger("action:" + action);

        evt.preventDefault();

     },
     close : function()
     {
        if (this.view)this.view.destroyAll();
     },
     documentAttached : function (document)
     {
        this.document = document;
      
        this.onCloseButtonChanged();
        var self = this;
        var ctx = document.getContext();
        var c = 2;

        ctx.on("file-system-initialized", function onFileSystemInitialized() {
           ctx.off("file-system-initialized", onFileSystemInitialized);
           --c;
            if (c == 0)
               self.onStorageChanged();
        });

        document.on("info:loaded", function onInfoLoaded() {
           document.off("info:loaded", onInfoLoaded);
           --c;
           if (c == 0)
              self.onStorageChanged();

        });

      document.on("offline-invalidated", this.refreshToolsMenuItems, this);
    },
    documentDetached: function (document)
    {
      this.document = null;
      document.off("offline-invalidated", this.refreshToolsMenuItems, this);

      $(globals).off("storage", this.onStorageChanged);
      
      this.onCloseButtonChanged();
      this.refreshToolsMenuItems();
    },
    onStateChanged: function (current, state)
    {
      var buttons = $(this.el).find("button");
      if (current === ST_LOCKED)
      {
        buttons.attr("disabled", "disabled");
      }
      else
      {
        buttons.removeAttr("disabled");
      }
      
    },
    hideToolsMenu : function()
    {
      if (this.toolsMenuScreen)
      {
        this.toolsMenuScreen.hide();
      }

       //FIXME nothing is intented to be global
       $("body").css({
         "overflow": "hidden"
       });
    },
    languageChanged : function (i18n)
    {
      //this.$el.attr("title", i18n._T("ui-tools-menu-title"));
    },
    showToolsMenu : function (e)
    {
      //FIXME nothing is intented to be global
      $("body").css({
        "overflow" : "visible"
      });
          
      this.toolsMenuScreen = vitrium.viewer.showMenuScreen(this.viewer, this.toolsMenuModel, { view : this.view});
      this.toolsMenuScreen.on("button:close", this.onToolsMenuVisibilityChanged, this);
         
      this.refreshToolsMenuItems();
      
      this.onCloseButtonChanged();

    }, 
    onCloseButtonChanged : function()
    {
      if (this.toolsMenuScreen)
      {
        if (!this.document)
        {	
          this.toolsMenuScreen.el.find("button[data-action='close']").hide();
        }
        else
        {
          this.toolsMenuScreen.el.find("button[data-action='close']").show();
        }
      }
    },
    onToolsMenuVisibilityChanged: function()
    {
      this.toolsMenuScreen.off("button:close", this.onToolsMenuVisibilityChanged, this);
      this.toolsMenuScreen = null;
      
      //FIXME nothing is intented to be global
      $("body").css({
        "overflow" : "hidden"
      });
 
      // HACK I should figure out a cleaner way
      this.viewer.parent.layoutManager.top.layoutManager.refresh();

    //  if (this.viewer.documentRenderer)this.viewer.documentRenderer.onResize();
      /*//ST_RENDERING_PAUSED
      if (this.viewer.state.has(ST_RENDERING_PAUSED))
      {
        this.viewer.state.pop(); 
      }*/
    },
    getDownloadState : function(result, url)
    {
       var downloadState = OFFLINE_ST_NOT_SUPPORTED;
       
       if (result.offlineStorageSupported)
       {
          downloadState = OFFLINE_ST_SUPPORTED;
                         
          var canDisplayDocumentSpecificInfo = url !== null && self.document !== null;
          if (canDisplayDocumentSpecificInfo)
          {
             if (result.isCurrentDocumentDownloaded)
             {
                downloadState = OFFLINE_ST_DOWNLOADED;
             }
             else if (!this.document.getContext().offlineStorage)
             {
                downloadState = OFFLINE_ST_DISABLED;
             }
          }
       }

       if (!isAppCacheManifestInstalled() && downloadState !== OFFLINE_ST_DOWNLOADED)
       {
          downloadState = OFFLINE_ST_DISABLED;
       }

       return downloadState;    

    },
    refreshToolsMenuItems : function()
    {
       var model = this.toolsMenuModel;
       if (!model.get("refreshing"))
       {
          model.set("refreshing", true);
          var self = this;

          var url = this.document !== null ? this.document.getContext().url : null;
          io.CachableFileSystemContext.getCacheManager().loadStorageInfo(url, 
             function (result) 
             {
                 if (self.refreshAgain)
                 {
                     self.refreshAgain = false;
                     model.set("refreshing", false);
                     self.refreshToolsMenuItems();
                     return;
                 }
             
                var choices = [];
                _.each(model.get("defaultChoices"), function (choice) { choices.push(choice); });

                if (self.document) {
                   var downloadState = self.getDownloadState(result, url);
                   if (downloadState === OFFLINE_ST_DOWNLOADED) {
                      choices.push({
                         title: i18n._T("ui-tools-document-is-offline"),
                         id: "delete",
                         icon: '<i class="fa fa-trash-o"></i>',
                         priority: -1
                      });
                   }
                   else if (downloadState === OFFLINE_ST_SUPPORTED && self.document.fileSystem.initialized) {
                      choices.push({
                         title: i18n._T("ui-tools-save-document-offline", [formatSize(calculateDocumentSize(self.document), true)]),
                         id: "save",
                         icon: "<i class='fa fa-download'></i>",
                         priority: -1
                      });
                   }
                }

                if (result.isAnyDocumentDownloaded) 
                {
                   choices.push({ title: i18n._T("ui-tools-manage-saved-documents"), id: "manage", toolHidden: 1 });
                }

                self.broadcastEvent("ToolsMenuChange", choices, model);

                choices.push({ title: i18n._T("ui-tools-menu-title"), id: "tools", icon: "<i class='fa fa-bars'>", toolHidden: 2 })
                choices.push({ title: i18n._T("ui-tools-about"), id: "about", toolHidden: 1 });

                model.set("title", i18n._T("ui-tools-menu-title"));
                model.set("choices", choices);
                model.set("offlineState", OFFLINE_ST_DISABLED);
                model.set("refreshing", false);

                
          });
       }
       else 
       {
           this.refreshAgain = true;
       }
    },
    __onStorageChanged : function()
    {
      this.refreshToolsMenuItems();
      
    },
    onChoicesChanged: function(model, choices)
    {
        this._removeButtons();
        this._createButtonsForChoices(choices);
    },
    _removeButtons: function()
    {

        var widgets = this._widgets;
        for (var i = 0, len = widgets.length ; i !== len; ++i)
        {
            var w = widgets[i];
            this.remove(w);
            this.layoutManager.removeWidget(w);
        }
    },
    _createButtonsForChoices: function (choices)
    {
        var sum = 0;
        for (var i = 0, len = choices.length; i !== len; ++i)
        {
           var choice = choices[i];
           
           if ((choice.toolHidden & 1) === 0)
           {
              var toolButton = choice.widget || new ToolButton(choice.id, choice.title, choice.icon || "<i class='icon icon-star-empty'></i>", choice.priority || 0);

              this.add(this.layoutManager.add(toolButton));
              sum += toolButton.dim.w;
           }
        }

        this.layoutManager.add(new Spacer());

      
        this.setWidth(sum);

        this.sortedWidgets = this.getPrioritySortedWidgets();
        this._size = 0;
    },
    setWidth: function(width)
    {
       var dim = this.getDim();
       dim.w = width;
       this.setDim(dim);

       this.parent.layoutManager.refresh();
    },
    resetToDefaultSize: function () {
       for (var i = 0; i !== this._size; ++i)
          this.sortedWidgets[i].resetToDefaultSize();

       this.setWidth(this.sumWidth());
      // this.layoutManager.refresh();
    },
    getPrioritySortedWidgets: function(){
       var widgets = _.clone(this._widgets);
       widgets.sort(function (elemA, elemB) {
          var a= elemA.priority;
          var b = elemB.priority;
          if (a < b) return -1;
          if (a === b) return 0;
          return 1;
       });
       
       return widgets;
       
    },
    makeSmallerIfPosible: function () {
       var beginIdx = null;
       var idx = this._size;
       var smaller = false;

      
       var widgets = this.sortedWidgets;
      // console.log(_.pluck(widgets, "id").join(","));
     //  console.log(idx);

       while(!smaller && idx !== beginIdx)
       {
          if (beginIdx === null) beginIdx = idx;
          smaller = widgets[idx].makeSmallerIfPosible();

          idx = (idx + 1) % widgets.length;
       }

       this._size = idx;
       this.setWidth(this.sumWidth());
     
       return smaller;       
    },
    makeBiggerIfPosible: function () {
       var beginIdx = null;
       var idx = this._size;
       var bigger = false;
       var widgets = this.sortedWidgets;

       while (!bigger && idx !== beginIdx) {
          if (beginIdx === null) beginIdx = idx;
          
          bigger = widgets[idx].makeBiggerIfPosible();
          idx--;
          if (idx === -1)
             idx = widgets.length - 1;

       }

       this._size = idx;
       this.setWidth(this.sumWidth());

   //    this.layoutManager.refresh();
       return bigger;
    },
    sumWidth: function()
    {
       var widgets = this._widgets;
       var sum = 0;
       for (var i = 0, len = widgets.length; i !== len; ++i)
       {
          var dim = widgets[i].dim;
        
          if (widgets[i].size !== 1)
             sum += dim.w;
       }
       
       return sum;
    }
  });
  
  
 


  function isAppCacheManifestInstalled()
  {
    var html = document.getElementsByTagName("html")[0];
    var res = html.attributes.getNamedItem("manifest") !== null;
    //

    return res;
  };

  function calculateDocumentSize(document)
  {
    var entries = document.fileSystem.entries;
    var files = document.fileProvider().listFilesForDownload();

    var sum = 0;
    _.each(entries, function (entry)
    {
      if (files.indexOf(entry.filename) !== -1)
      {
        sum += entry.uncompressedSize;
      }
    });

    return sum;
  }

  function ToolButton(id, label, icon, priority)
  {
     ui.DomSizedWidget.call(this, document.createElement("button"));
     this.id = id;
     this.priority = priority;
     // this.$el = $(this.el)
     this.$el
      .append(icon)
      .attr("data-id", id)
      .attr("title", label)
      .attr("type", "button")
      .addClass("btn")
      .addClass("toolbtn");

     if (id !== "tools")
      this.maxSize = 1;

      
    
  }
  ToolButton.prototype = Object.create(ui.DomSizedWidget.prototype);

  function Spacer()
  {
     this.dim = new geometry.Rectangle(0, 0, 5, 5, 0);
  }
  

}(
vitrium.viewer,
vitrium.ui,
vitrium.i18n,
jQuery,
_,
Backbone,
vitrium.fs,
vitrium.io,
vitrium.geometry2,
__globals__));

// script:viewer/paging-controls-ui.js
/// <reference path="~/build.html" />
(function (exports, ui, vitrium, _, Backbone, $, document)
{
  "use strict";
  
  var CTRLS_TMPL = '<button class="btn prev-page" type="button"><i class="fa fa-arrow-up"></i></button>\
    <button class="btn next-page" type="button"><i class="fa fa-arrow-down"></i></button>\
    <input type="text" class="input-mini current-page" >\
    <span class="add-on pages-total">of</span>';
  
  var STATES = exports.STATES;
  var ST_READY = STATES.get("READY");
  var ST_LOCKED =  STATES.get("LOCKED");
  var ST_NOT_READY =  STATES.get("NOT_READY");
  
  exports.PagingControls = PagingControls;
  function PagingControls(viewer)
  {
    ui.DomSizedWidget.call(this, document.createElement("div"));
    this.el.className = "vitrium-paging-controls input-prepend input-append";
   
    $(CTRLS_TMPL).appendTo(this.el);
    this.currentPageInput = this.$el.find(".current-page").val("-");
    this.viewer = viewer;

    viewer.on("change:currentPage", this.onPageChanged, this);
    viewer.on("change:state", this.onStateChanged, this);
    viewer.on("change:pageCount", this.onPageCountChanged, this);
    
    
    
    this.$el.on("keyup", "input.current-page", _.bind(this.keyUp, this));
    this.$el.on("focus", "input.current-page", _.bind(this.focusIn, this));
    this.$el.on("focusout", "input.current-page", _.bind(this.focusOut, this));
    this.$el.on("tap click", ".next-page", _.bind(this.nextPage, this));
    this.$el.on("tap click", ".prev-page", _.bind(this.prevPage, this));
    this.$el.on("mouseup", "button", _.bind(this.onMouseUp, this));
        
    this.page = null;
    this.limit = 0;
    this.onStateChanged(viewer.state.current(), viewer.state);
    this.onLanguageChanged(vitrium.i18n);
    vitrium.i18n.on("language:changed", this.onLanguageChanged, this);
    this.locked = false;

    this.maxSize = 3;
  }
  
  
  PagingControls.prototype = _.extend(Object.create(ui.DomSizedWidget.prototype), {
    constructor: PagingControls,
    onMouseUp : function()
    {
      this.viewer.focus();
    },	
    onLanguageChanged : function(i18n)
    { 
      var c = this.$el;
      c.find(".next-page").attr("title", i18n._T("ui-next-page"));
      c.find(".prev-page").attr("title", i18n._T("ui-previous-page"));
      c.find(".pages-total").html(i18n._T("ui-page-count", [this.limit === 0 ? "-" : this.limit]));
    },
    onPageChanged : function(page)
    {
      if (this.page !== page)
      {
        this.page = page;
        this.refresh();
      }
    },
    onRender : function()
    {
      if (this.page === null)
      {
        this.currentPageInput.val("-");
      }
      else
      {
        this.currentPageInput.val(this.page + 1);
      }
    },
    focusOut  : function()
    {
       if (vitrium.is_mobile)
       {
          this.keyUp({ which: 13, preventDefault: function () { } });
       }
       else
       {
          this.refresh();
       }
      
    },
    focusIn : function(e)
    {
      setTimeout(_.bind(function()
      {
        this.$el.find("input.current-page").select();
      },this), 1);
    },
    onStateChanged : function(current,  state)
    {
      if (current === ST_LOCKED || !state.has(ST_READY))
      {
        this.$el.find("button, input").attr("disabled", "disabled");
        this.$el.find("input").attr("type", "text");
      }
      else
      {
        this.$el.find("button, input").removeAttr("disabled");
        if (!vitrium.is_mobile)
        {
          this.$el.find("input").attr("type", "text");
        }
        else
        {
          this.$el.find("input").attr("type", "number");
        }
        
      }
      
      if (state.has(ST_NOT_READY))
      {
        this.currentPageInput.val("-");
        this.onPageCountChanged(0);
      }
    },	
    onPageCountChanged : function(pageCount)
    {
      this.limit = pageCount;
      this.$el.find(".pages-total").html(vitrium.i18n._T("ui-page-count", [pageCount === 0 ? "-" : pageCount]));
    },
    nextPage : function()
    {
      if (this.page !== null)	this.viewer.scrollTo(Math.min(this.page +1, this.limit));
    }, 
    prevPage : function()
    {
      if (this.page !== null)	this.viewer.scrollTo(Math.max(this.page -1,0));
    },
    keyUp : function(e)
    {
      switch (e.which) {
         case 13:
            e.preventDefault();
            var val = this.currentPageInput.val();


            if (/^\d+$/.test(val)) {
               //restore an original state
               var newPage = parseInt(val, 10);
               this.viewer.scrollTo(newPage - 1);
            }
            else {
               this.refresh();
            }

            return false;
            break;
         case 27:
            e.preventDefault();
            this.refresh();
            return false;
            break;
         case 38: //up
            e.preventDefault();
            this.prevPage();
            return false;
            break;
         case 40: //down
            e.preventDefault();
            this.nextPage();
            return false;
            break;
      }

      return true;       
    }
  });
  
}(
vitrium.viewer,
vitrium.ui,
vitrium, 
_, 
Backbone, 
jQuery,
document));
// script:viewer/scale-controls-ui.js
/// <reference path="~/build.html" />

(function (exports, ui, vitrium, _, Backbone, $, document)
{
  "use strict";
  
  var CTRLS_TMPL = 
  '<button class="btn plus" type="button"><i class="fa fa-plus"></i></button>\
    <button class="btn minus" type="button"><i class="fa fa-minus"></i></button>\
    <input type="number" class="input-mini current-scale" value="100">\
    <span class="add-on">%</span>\
    <button class="btn lock" type="button"><i class="fa fa-arrows-h"></i></button>';
  
  var STATES = exports.STATES;
  var ST_READY = STATES.get("READY");
  var ST_LOCKED =  STATES.get("LOCKED");
  
  exports.ScaleControls = ScaleControls;
  function ScaleControls(viewer)
  {
    ui.DomSizedWidget.call(this, document.createElement("div"));
    this.viewer = viewer;
    this.el.className = "vitrium-scale-controls input-prepend input-append";

    var controlEl = this.controls = $(CTRLS_TMPL).appendTo(this.el);
    this.$el.on("tap click", "button.lock", _.bind(this.lockClicked, this));
    this.$el.on("tap click", "button.plus", _.bind(this.plusClicked, this));
    this.$el.on("tap click", "button.minus", _.bind(this.minusClicked, this));
    this.$el.on("mouseup", "button", _.bind(this.onMouseUp, this));
    
    this.scaleInput = this.$el.find("input.current-scale");
    this.scaleInput.focusout(_.bind(this.focusOut, this)).focus(_.bind(this.focusIn, this));
    this.scaleInput.keyup(_.bind(this.keyUp, this));
    
    viewer.on("change:resizeMode", this.onModeChanged, this);
    viewer.on("change:scale", this.onScaleChanged, this);
    viewer.on("change:state", this.onStateChanged, this);
    this.modeChanged = false;
    this.scaleChanged = false;
    
    this.scale = 1;
    this.onModeChanged(viewer.resizeMode);		
    this.onLanguageChanged(vitrium.i18n);
    this.onStateChanged(viewer.state.current(), viewer.state);
    vitrium.i18n.on("language:changed", this.onLanguageChanged, this);

    this.maxSize = 3;
  }
  
  ScaleControls.prototype = _.extend(Object.create(ui.DomSizedWidget.prototype), {
    constructor: ScaleControls,
    onMouseUp : function()
    {
      this.viewer.focus();
    },
    onLanguageChanged : function(i18n)	
    {
      var c = this.$el;
      c.find("button.plus").attr("title", i18n._T("ui-zoom-in"));
      c.find("button.minus").attr("title", i18n._T("ui-zoom-out"));
      c.find("button.lock").attr("title", i18n._T("ui-zoom-fit-to-window"));
    },
    focusOut : function()
    {
       if (vitrium.is_mobile)
       {
          this.keyUp({ which: 13, preventDefault: function () { } });
       }
       else
       {
          this.onScaleChanged(this.scale);
       }
    },
    focusIn : function(e)
    {
      setTimeout(function(){$(e.target).select();},0);
    },
    onScaleChanged : function(scale)
    {
      this.scaleChanged = true;
      this.scale = scale;
      this.refresh();
    },
    onModeChanged : function(mode)
    {
      this.modeChanged = true;
      this.refresh();
    },
    onRender : function()
    {
      if (this.scaleChanged)
      {
        this.scaleInput.val(""+Math.ceil(this.scale * 100));
        this.scaleChanged = false;
      }
      
      if (this.modeChanged)
      {
        var ResizeMode = vitrium.viewer.ResizeMode;
        if (this.viewer.resizeMode === ResizeMode.SCALE_CONTENT)
        {
          this.$el.find("button.lock").addClass("btn-primary");
        }
        else
        {
          this.$el.find("button.lock").removeClass("btn-primary");
        }

        this.modeChanged = false;
      }
    },
    plusClicked : function()
    {
      var scale = Math.ceil(this.scale * 100);
      var rest = scale % 25;
      
      scale += 25-rest;
      
      this.viewer.setScale(scale/100);
    },
    minusClicked : function()
    {
      var scale = Math.ceil(this.scale * 100);
      var rest = scale % 25;
      
      if (rest === 0)
      {
        rest = 25;
      }
      scale -= rest;
      
      this.viewer.setScale(scale/100);	
    },	
    lockClicked : function(e)
    {
      var ResizeMode = vitrium.viewer.ResizeMode;
      if (this.viewer.resizeMode === ResizeMode.SCALE_CONTENT)
      {
        this.viewer.setResizeMode(ResizeMode.FIXED_CONTENT);
      }
      else
      {
        this.viewer.setResizeMode(ResizeMode.SCALE_CONTENT);
      }
    }, 		
    onStateChanged : function(current, stateHolder)
    {
      if (!stateHolder.has(ST_READY) || current === ST_LOCKED)
      {
        this.controls.find("button, input").attr("disabled", "disabled");
      }
      else
      {
        this.controls.find("button, input").removeAttr("disabled");
      }
    },
    keyUp : function(e)
    {
      switch(e.which)
      {
        case 13:
          e.preventDefault();
          var val = this.scaleInput.val();

          if (/^\d+$/.test(val))
          {
            this.viewer.setScale(val/100);	
          }
          else
          {
            this.onScaleChanged(this.scale);
          }
          
          return false;
        break;
        case 27:
          e.preventDefault();
          this.onScaleChanged(this.scale);
          return false;
        break;
        case 38: //up
          e.preventDefault();
          this.plusClicked();
          return false;
        break;
        case 40: //down
          e.preventDefault();
          this.minusClicked();
          return false;
        break;
      }
      
      return true;
    }	
  });

}(
vitrium.viewer,
vitrium.ui,
vitrium, 
_,
Backbone, 
jQuery, 
document));
// script:viewer/viewer-toolbar-ui.js
/// <reference path="~/build.html" />

(function (exports,v, ui)
{
  "use strict";
  exports.Toolbar = Toolbar;

  function Toolbar(viewer, search, toolsModel)
  {
    ui.ContainerWidget.call(this);
    this.el.className = "vitrium-toolbar";
    this.layoutManager = new ui.BasicLayoutManager(this);
     
    var debugLoading = false;
      //
     
   


    var toolBar = new v.ToolsControl(viewer,toolsModel, viewer.options);
    var toolsController = new v.ToolsController(toolsModel, toolBar);

    this.layoutManager.left = this.add(new v.LoadingIndicator(viewer, debugLoading));
     //  this.layoutManager.right = this.add(toolBar);

   

    var main = this._mainView = this.layoutManager.center = this.add(new ui.ContainerWidget());
    main.layoutGuard = new ui.IntersectionLayoutGuard(main);
    main.layoutManager = new ui.HorizontalAlignLayout(main);

    //HACK to satisfy fullscreen button position request
    this.scaleControls = new v.ScaleControls(viewer)
    main.layoutManager.left = main.add(this.scaleControls);
    main.layoutManager.center = main.add(new v.PagingControls(viewer));
    main.layoutManager.right = main.add(toolBar);
    this.dim.h = 40;
    var dim = toolBar.dim;
    dim.h = 40;
    toolBar.dim = dim;
    //this.add(new vitrium.viewer.ScaleControls(dViewer));
    this._actionBar = null;
  }

  Toolbar.prototype = Object.create(ui.ContainerWidget.prototype);
  Toolbar.prototype.showActionBar = function (actionbar)
  {
    this._actionBar = actionbar;
    this.remove(this._mainView);
    this.layoutManager.center = this.add(actionbar);
  };
  
  Toolbar.prototype.showStatusView = function ()
  {
    this.remove(this._actionBar);
    this.layoutManager.center = this.add(this._mainView);
    this._actionBar = null;
  };

}
(vitrium.viewer,
vitrium.viewer,
vitrium.ui));

// script:viewer/text-search-ui.js
/// <reference path="~/build.html" />
(function (exports, ui, vitrium, _, Backbone, $, document)
{
  "use strict";
  
  var State = {
    OPEN : true,
    CLOSED: false
  };
  
  var STATES = exports.STATES;
  var ST_LOCKED = STATES.get("LOCKED");
  var ST_READY = STATES.get("READY");
  
  exports.SearchControls = SearchControls;
  exports.SearchControlsState = State;
  
  var SEARCH_CTRLS_TMPL = "<div class='afix' style='display:none; z-index:2;'><div class='input-prepend input-append'><button class='btn btn-danger vitrium-tool-margin close-search'  type='button' ><i class='fa fa-search'></i></button><input class='span2 search' type='text'/><div class='btn-group'><button type='button' class='btn prev' disabled type='button' >&nbsp;<i class='fa fa-chevron-left'></i>&nbsp;</button>	<button type='button' class='btn btn-primary next' disabled>&nbsp;<i class='fa fa-chevron-right'></i></button></div></div></div>";
  
  function SearchControls(controller, model, viewer)
  {
    ui.DomSizedWidget.call(this, document.createElement("div"));
    this.el.className = "vitrium-search-controls";
    this.$el.css({ position: "" });
    this.controller = controller;
    this.model = model;
    this.viewer = viewer;
    
    var searchControls = this.searchControls = $(SEARCH_CTRLS_TMPL).appendTo(this.el);
     
    
    searchControls.find("input.search").on("input", _.bind(this.inputChanged, this)).keyup(_.bind(this.searchKey, this));
    searchControls.on("tap click", "button.next",_.bind(this.next, this));
    searchControls.on("tap click", "button.prev", _.bind(this.prev, this));
    searchControls.on("tap click", "button.close-search", _.bind(this.searchClicked, this));
    
    this.stateChanged();
    model.on("change:ui-state", this.stateChanged, this);
    model.on("search:end-reached",this.searchFinished, this);
    model.on("search:completed",this.searchCompleted, this);
    model.on("change:longsearch", this.longSearchChanged, this);
    
    
    viewer.on("document:attached", this.documentAttached, this);
    viewer.on("document:detached", this.documentDetached, this);
    
    viewer.on("change:state" , this.updateControlsState, this);
    viewer.on("keydown",this.searchKey, this);
    
    $(document).keydown(_.bind(this.onDocumentKeyDown, this));
    
    this.lastVal  = null;
    this.languageChanged(vitrium.i18n);
    vitrium.i18n.on("language:changed", _.bind(this.languageChanged, this));
    
    this.searchInProgress = false;
        
    this.lastTop = 0;
    this.updateControlsState();
    this.maxSize = 2;
  }
  SearchControls.prototype = _.extend(Object.create(ui.DomSizedWidget.prototype),
  {
    constructor: SearchControls,
    setDim : function(val)
    {
      ui.DomSizedWidget.prototype.setDim.call(this, val);
      if (this.isUIOpen()) this.updatePosition();
    },
    onActivate: function()
    {
       ui.DomSizedWidget.prototype.onActivate.call(this);
     
    
    },
    getDim : function()
    {
      var dim = ui.DomSizedWidget.prototype.getDim.call(this);
      if (this.currentSize > 0 && this.isUIOpen())
      {
        var d = dim.clone()
        d.w = 1;
        //d.h = 0;
        return d;
      }
      else
      {
        return dim;
      }
    },
    updatePosition : function()
    {
    //  this.searchControls.css({ left: (-this.searchControls.innerWidth())+"px", top: "20px" });
    },
    isUIOpen : function()
    {
      var state = this.model.get("ui-state");
      return state === State.OPEN;
    },
    detachFromLayout : function()
    {
      this._detached = true;
    },
    onInfoLoaded : function(info)
    {
      this.setEnabled(true);
      this.model.set({"ui-state" : State.CLOSED});
      this.searchControls.find("input").val("");
    },	
    updateControlsState : function()
    {
      var els = this.searchControls.find("button, input");
      if (this.isSearchPosible())
      {
        els.removeAttr("disabled");
      }
      else
      {
        els.attr("disabled","disabled");
      }
    },
    longSearchChanged : function(model, val)
    {
      if (val)
      {
        this.longSearchBegin();
      }	
      else
      {
        this.longSearchEnd();
      }
    },	//longsearch:begin
    longSearchBegin : function()
    {
      if (!this.searchInProgress)
      {
        var box = this.searchInProgress = vitrium.viewer.showDismissBox(this.viewer, "info", 
          vitrium.i18n._T("ui-search-in-progress-title"),
          vitrium.i18n._T("ui-search-in-progress"), 
          { buttons : [ { id : "close", title : vitrium.i18n._T("ui-search-document-end-cancel-btn-label") }] }
        );
        box.on("button:close", this.cancelClicked, this);
      }		
    //$('<div class="vitrium-long-search-box"><button class="btn vitrium-cancel"><i class="icon-remove"></i></button>&nbsp;'+vitrium.i18n._T("ui-search-in-progress")+'</div>').appendTo(this.viewer.contentEl).find(".vitrium-cancel").click();
    },
    cancelClicked : function()
    {
      this.controller.abortLongSearch();
    },
    longSearchEnd : function()
    {
      var box = this.searchInProgress;
      if (box)
      {
        box.off("button:close", this.cancelClicked, this);
        box.hide();
        this.searchInProgress = null;
      }
        
      if (!vitrium.is_mobile)
      {
        this.searchControls.find("input.search").focus();
      }
      this.viewer.$el.find(".vitrium-long-search-box").remove();
    }, 
    searchCompleted : function()
    {
      if (this.searchInProgress) this.searchInProgress.hide();

      var searchControls = this.searchControls;
      var self = this;
      var box = this.searchInProgress = vitrium.viewer.showDismissBox(
      this.viewer, 
      "info", 
      vitrium.i18n._T("ui-search-completed-title"),
      vitrium.i18n._T("ui-search-completed"), 
      { buttons: [{ id : "close", title : vitrium.i18n._T("menu-close"), cssClass: "btn-primary" }]	});	
      
      box.on("view:show", function(visible)
      {	
        if (!visible)
        {
          if (!vitrium.is_mobile)
          {
            searchControls.find("input.search").focus().select();
          }
          self.searchInProgress = null;
        }
      });
    },
    languageChanged : function(i18n)
    {
      var s = this.searchControls;
      s.find("button.next").attr("title", i18n._T("ui-search-next"));
      s.find("button.prev").attr("title", i18n._T("ui-search-prev"));
      s.find("button.close-search").attr("title", i18n._T("ui-search-close"));
      s.find("input").attr("title", i18n._T("ui-search"));
    },
    searchFinished :  function()
    {
      var ctrl = this.controller;
      var startFromBeginning = false;
      var self = this;
      
      if (this.searchInProgress) this.searchInProgress.hide();
      this.searchInProgress = null;
      
      var directionMsg = this.model.get("mode") === vitrium.viewer.SearchMode.FORWARD ? "end" : "beg" ;
      
      var box = vitrium.viewer.showDismissBox(this.viewer, "success",
      vitrium.i18n._T("ui-search-document-"+directionMsg+"-reached-title"),
      vitrium.i18n._T("ui-search-document-"+directionMsg+"-reached"), 
      {
        buttons : [
          {
            "id" : "start",
            "title" : vitrium.i18n._T("ui-search-document-"+directionMsg+"-start-btn-title"),
            "label" : vitrium.i18n._T("ui-search-document-"+directionMsg+"-start-btn-label"),
            "cssClass" : "btn-primary"
          },
          {
            "id" : "close",
            "title" : vitrium.i18n._T("ui-search-document-"+directionMsg+"-cancel-btn-title"),
            "label" : vitrium.i18n._T("ui-search-document-"+directionMsg+"-cancel-btn-label")
          }
        ]
      });
      
      box.on("button:start", function(evt)
      {
        setTimeout(function()
        {
          self.longSearchBegin();
          ctrl.next();
        }, 0);
      });
      
      box.on("button:close", function(evt)
      {
        setTimeout(function()
        {
        self.cancelClicked();
        self.model.set({"ui-state" : State.CLOSED});
        }, 0);
      });
    }, 
    stateChanged : function()
    {
      var state = this.model.get("ui-state");
      var self = this;
      if (state === State.OPEN)
      {
        this.priority = -1;
        var searchControls = this.searchControls;
        vitrium.viewer.$fadeIn(searchControls[0]);
        searchControls.css({"display":"block"}).removeClass("closed").addClass("opened").find("input.search").focus().select();
        this.inputChanged();

      }
      else
      {
        this.priority = 0;
        this.lastVal = null;
        var searchControls = this.searchControls;
        searchControls.removeClass("opened").addClass("closed");
        searchControls.css({ "display": "none" });

        var cursor = this.model.get("cursor");
        this.model.set(_.extend({}, this.model.defaults));
        if (cursor)
        {
          this.model.trigger("changed", [cursor.page]);
        }
        
        this.viewer.focus();
        this._detached = false;

      }
      this.trigger("size:change");
    }, 
    searchClicked : function()
    {
    //  if (e.type === "click") e.preventDefault();
      if (this.model.get("ui-state"))
      {	
        this.model.set({"ui-state" : State.CLOSED});
      }
      else
      {
        this.model.set({"ui-state" : State.OPEN});
      }
    //  return false;
    },	
    inputChanged : function()
    {
      if (this.searchInProgress) return true;
    
      var val = this.searchControls.find("input.search").val();
      if (!_.isEmpty(val))
      {
        this.searchControls.find("button.next, button.prev").removeAttr("disabled");
      }
      else
      {
        this.searchControls.find("button.next, button.prev").attr("disabled", "disabled");
      }
    },	
    searchKey : function(e)
    {			
      if (this.searchInProgress || this.viewer.controlsLock) return true;
      var state = this.model.get("ui-state");
      
      if (state === State.OPEN)
      {
        this.inputChanged();
      
        if (e.which === 13)
        {
          e.preventDefault();
          var val = this.searchControls.find("input.search").val();
          if (!_.isEmpty(val))
          {
            if (e.ctrlKey)
            {
              this.prev();
            }
            else
            {
              this.next();
            }
          }
          return false;
        }
        else if (e.which === 27)
        {
          e.preventDefault();
          this.model.set({"ui-state" : State.CLOSED});
          return false;
        }
        return true;
      }
    },	
    next :  function()
    {
      if (this.searchInProgress) return;
      this.model.set({ "mode" : vitrium.viewer.SearchMode.FORWARD});
      this.search();
    },	
    search : function()
    {		
      if (this.searchInProgress) return;
      var val = this.searchControls.find("input.search").val();
      if (val !== this.lastVal)
      {
        this.controller.search(val);
      }		
      else
      {
        this.controller.next();
      }
      this.lastVal = val;
    },	
    prev :  function()
    {		
      if (this.searchInProgress) return;
    
      this.model.set({ "mode" : vitrium.viewer.SearchMode.BACKWARD});
      this.search();
    },
    onDocumentKeyDown : function(e)
    {		
      if (e.ctrlKey && e.which === 70 && this.isSearchPosible() )
      {
        this.model.set({"ui-state" : State.OPEN});
        this.searchControls.find("input.search").focus().select();
        e.preventDefault();
        return false;
      }
      return true;
    },
    isSearchPosible : function()
    {
      var state = this.viewer.state;
      return state.current() !== ST_LOCKED && state.has(ST_READY);
    }
  });

  _.extend(SearchControls.prototype, Backbone.Events);
  
}(
vitrium.viewer,
vitrium.ui,
vitrium, 
_, 
Backbone, 
jQuery, 
document));
// script:viewer/highlight-panel-ui.js
/// <reference path="~/build.html" />

(function (exports, ui, _, Backbone, i18n)
{
  "use strict";
    //ui.icon("null-tool")

  exports.HighlightPanel = HighlightPanel;
  function HighlightPanel(annotationController, annotationControllerModel)
  {
    ui.LabeledSidePanel.call(this, ui.icon("pencil"), "highlight-panel-title");
    this.originalIcon = this.icon;
    this.textHighlightIcon = ui.icon("highlight-text");
    this.eraserIcon = ui.icon("eraser");

    this.layoutManager.center = this.add(new HighlightPanelContent(annotationController, annotationControllerModel));
    this.annotationControllerModel = annotationControllerModel;

    annotationControllerModel.on("change:activatedAction", this.onActivatedActionChanged, this);
    annotationControllerModel.get("colorSelectorModel").on("change:colorSelection", this.updateIconColor, this);
  }
  HighlightPanel.prototype = Object.create(ui.LabeledSidePanel.prototype);
  HighlightPanel.prototype.onActivatedActionChanged = function (model, action)
  {
    
    if (action === "texthighlight" && this.lastOpened)
    {
      if (this.icon !== this.textHighlightIcon)
      {
        this.setIcon(this.textHighlightIcon);
      }
    }
    else if (action === "eraser" && this.lastOpened)
    {
      if (this.icon !== this.textHighlightIcon)
      {
        this.setIcon(this.eraserIcon);
      }
    }
    else if (this.icon !== this.originalIcon)
    {
      this.setIcon(this.originalIcon);
    }

    this.updateIconColor();
    this.onLanguageChanged();
  };

  HighlightPanel.prototype.onLanguageChanged = function ()
  {
      ui.LabeledSidePanel.prototype.onLanguageChanged.call(this);
      if (!this.annotationControllerModel) return;

      var action = this.annotationControllerModel.get("activatedAction");
      var tools = this.annotationControllerModel.get("toolSelectorModel").get("toolSelectionList");
      
      if (action !== null && tools.indexOf(action) !==-1)
      {
          this.setIconLabel(i18n._T("selected-tool-" + action));
      }
  };

  HighlightPanel.prototype.updateIconColor = function ()
  {
    var action = this.annotationControllerModel.get("activatedAction");
    var $icon = $(this.icon.el).find("i");
    $(this.icon.el).removeClass("active");
    var $svgicon = $(this.icon.el).find("path");
    if (this.lastOpened && (action === "freehighlight" || action === "texthighlight"))
    {
      var color = this.annotationControllerModel.get("colorSelectorModel").getSelectedColor();
      $icon.css("color", color);
      $svgicon.css("fill", color);
      $(this.icon.el).addClass("active");

    }
    else
    {
      $icon.css("color", "");
      $svgicon.css("fill", "");
    }

    if (action === "eraser" && this.lastOpened)
    {
      $(this.icon.el).addClass("active");

    }
  };

  function HighlightPanelContent(annotationController, annotationControllerModel)
  {
    ui.ContainerWidget.call(this);
    this.layoutManager = new ui.BoxLayout(this);
    this.layoutManager.align = ui.DIRECTION.TOP;

    var toolModel = this.toolSelectorModel = annotationControllerModel.get("toolSelectorModel");
   
    var iconCache = new ui.IconCache();

    var toolSelector = this.toolSelector = new ui.ChoiceSelector(toolModel, function ($el, tool, idx)
    {
      $el.attr("title", i18n._T("tool-" + tool));

      var icon = null;
      if (tool === null)
      {
          icon = iconCache.icon("null-tool");
      }
      else if (tool === "freehighlight")
      {
          icon = iconCache.icon("pencil");
      }
      else if (tool === "eraser")
      {
          icon = iconCache.icon("eraser");
      }
      else if (tool === "texthighlight")
      {
          icon = iconCache.icon("highlight-text");
      }

      $el.append(icon.el);
      $el.attr("tool", tool);
    },
     "toolSelection", function onRenderCallback()
     {
       cssLinearGradient(this.$el.find("[tool='freehighlight'] .icon"), model.getSelectedColor());
       cssLinearGradient(this.$el.find("[tool='texthighlight'] .icon"), model.getSelectedColor());
     });

    this.layoutManager.add(this.add(toolSelector));

    var model = this.colorSelectorModel = annotationControllerModel.get("colorSelectorModel");


    var colorSelector = new ui.ChoiceSelector(model, function ($el, color, idx)
    {
      $el.css("background-color", color);
    }, "colorSelection");
    colorSelector.$el.addClass("vitrium-color-selector");

    this.layoutManager.add(this.add(colorSelector));

  }
  HighlightPanelContent.prototype = Object.create(ui.ContainerWidget.prototype);
  HighlightPanelContent.prototype.onActivate = function ()
  {
      this.listen(this.colorSelectorModel, "change:colorSelection", this.toolSelector.refresh, this.toolSelector);
  };


  function cssLinearGradient($el, color)
  {
    $el.css("background", color)
    .css("background", '-webkit-linear-gradient(' + color + ', white)')
    .css("background", '-o-linear-gradient(' + color + ', white)')
    .css("background", '-moz-linear-gradient(' + color + ', white)')
    .css("background", 'linear-gradient(' + color + ', white)');
  }

}
(vitrium.viewer,
vitrium.ui,
_,
Backbone,
vitrium.i18n));

// script:viewer/history-controls-ui.js
/// <reference path="~/build.html" />

(function (exports, ui, i18n)
{
  "use strict";

  exports.HistoryControls = HistoryControls;

  function HistoryControls(historyModel)
  {
    ui.DomSizedWidget.call(this, document.createElement("div"));
    this.$el.addClass("vitrium-history-controls");
    this.historyModel = historyModel;
    this.$el.append("<button type='button' class='btn' data-action='repeat'><i class='fa fa-repeat'></i></button><button type='button' class='btn' data-action='undo'><i class='fa fa-undo'></i></button>");
    this.$el.on("tap click", "button", _.bind(this.onButtonClicked, this));
  }
  HistoryControls.prototype = Object.create(ui.DomSizedWidget.prototype);
  HistoryControls.prototype.onActivate = function ()
  {
    this.listen(this.historyModel, "history:changed", this.onHistoryChanged, this);
    this.listen(i18n, "language:changed", this.onLanguageChanged, this);

    this.onLanguageChanged();
    this.historyModel.triggerHistoryChange();
  };

  HistoryControls.prototype.onLanguageChanged = function ()
  {
    this.$el.find("button[data-action='undo']").attr("title", i18n._T("tool-undo"));
    this.$el.find("button[data-action='repeat']").attr("title", i18n._T("tool-repeat"));
  };
  HistoryControls.prototype.onButtonClicked = function (evt)
  {
    var action = $(evt.currentTarget).attr("data-action");
    if (action === "undo")
    {
      this.historyModel.undo();
    }
    else if (action === "repeat")
    {
      this.historyModel.redo();
    }

  };
  HistoryControls.prototype.setDim = function (dim)
  {
    this.$el.css({ left: 0, bottom: 0 });
  };

  HistoryControls.prototype.onHistoryChanged = function (model, canUndo, canRepeat)
  {
    var $undoButton = this.$el.find("button[data-action='undo']");
    var $repeatButton = this.$el.find("button[data-action='repeat']");
    if (canUndo)
    {
      $undoButton.removeAttr("disabled");
    }
    else
    {
      $undoButton.attr("disabled", "disbled");
    }

    if (canRepeat)
    {
      $repeatButton.removeAttr("disabled");
    }
    else
    {
      $repeatButton.attr("disabled", "disbled");
    }

  };


}
(
vitrium.viewer,
vitrium.ui,
vitrium.i18n));

// script:viewer/notes-panel-ui.js
/// <reference path="~/build.html" />

(function (exports, ui, i18n, _)
{
  "use strict";

  exports.NotesPanel = NotesPanel;
  function NotesPanel(annotationsController, annotationControllerModel, model, notesSelectionModel)
  {
    ui.LabeledSidePanel.call(this, ui.icon("comment-o"), "notes-panel-title");
    this.annotationControllerModel = annotationControllerModel;
    this.originalIcon = this.icon;
    this.eraserIcon = ui.icon("eraser");

    this.layoutManager.center = this.add(new NotesPanelContent(annotationsController, annotationControllerModel, model, notesSelectionModel));

    
    this.annotationControllerModel.on("change:activatedAction", this.onActivatedActionChanged, this);
  }
  NotesPanel.prototype = Object.create(ui.LabeledSidePanel.prototype);


  NotesPanel.prototype.onLanguageChanged = function ()
  {
      ui.LabeledSidePanel.prototype.onLanguageChanged.call(this);
      if (!this.annotationControllerModel) return;

      var action = this.annotationControllerModel.get("activatedAction");
      var tools = this.annotationControllerModel.get("noteSelectorModel").get("toolSelectionList");

      if (action !== null && tools.indexOf(action) !== -1)
      {
          this.setIconLabel(i18n._T("selected-tool-" + action));
      }
  };
 
  NotesPanel.prototype.onActivatedActionChanged = function (model, action)
  {
    $(this.icon.el).removeClass("active");
   if (action === "eraser" && this.lastOpened)
    {
      if (this.icon !== this.textHighlightIcon)
      {
        this.setIcon(this.eraserIcon);
      }
      
    }
    else if (this.icon !== this.originalIcon)
    {
      this.setIcon(this.originalIcon);
    }

   if (this.lastOpened && (action === "eraser" || action=== "note"))
   {
     $(this.icon.el).addClass("active");
   }
   this.onLanguageChanged();
  };
  

  function NotesPanelContent(annotationController, annotationControllerModel, model, notesSelectionModel)
  {
    ui.ContainerWidget.call(this);
    this.layoutManager = new ui.BasicLayoutManager(this);
    
    var iconCache = new ui.IconCache();

    var toolSelector = new ui.ChoiceSelector(annotationControllerModel.get("noteSelectorModel"), function ($el, tool, idx)
    {
        $el.attr("title", i18n._T("tool-" + tool));

      var icon = null;
      if (tool === null)
      {
          icon = iconCache.icon("null-tool");
      }
      else if (tool === "eraser")
      {
          icon = iconCache.icon("eraser");
      }
      else if (tool === "note")
      {
          icon = iconCache.icon("comment-o");
      }

      $el.append(icon.el);
      $el.attr("tool", tool);
    }, "toolSelection");

    this.layoutManager.top = new ui.LayoutMarginProxy(this.add(toolSelector), { bottom: 10 });
    this.listView = this.layoutManager.center = this.add(new ui.ListView(new AnnotationsListViewModel(model), function ($el, note, idx)
    {
      var page = document.createElement("div");
      page.className = "vitrium-note-page";
      page.innerHTML = i18n._T("note-page") + "&nbsp;" + (note.page+1);

      $el.append(page);

      $("<div class='vitrium-note-content'>").text(note.toString()).appendTo($el);
      
      
      if (notesSelectionModel.isSelected(note))
      {
        $el.addClass("selected");
        $el.prepend("<button class='btn vitrium-note-edit' type='button' data-action='note-edit'><i class='fa fa-pencil-square-o'></i></button><button class='btn vitrium-note-delete' type='button' data-action='note-delete'><i class='fa fa-trash-o'></i></button>");
      }
      else
      {
        $el.removeClass("selected");
      }
    }));

  
    
    this.noteSelectionModel = notesSelectionModel;
    this.annotationController = annotationController;
  }
  NotesPanelContent.prototype = Object.create(ui.ContainerWidget.prototype);
  NotesPanelContent.prototype.onActivate = function ()
  {
      this
      .listen(this.listView, "item:clicked", this.onListItemClick, this)
      .listen(this.listView, "item:doubleclicked", this.onListItemDoubleClick, this)
      .listen(this.listView, "action:note-edit", this.onNoteEditClicked, this)
      .listen(this.listView, "action:note-delete", this.onNoteDeleteClicked, this)
      .listen(this.noteSelectionModel, "change:selected", this.listView.refresh, this.listView);
  };

  NotesPanelContent.prototype.onListItemClick = function(note, idx)
  {
    this.noteSelectionModel.select(note);
    this.annotationController.showAnnotation(note);
  };

  NotesPanelContent.prototype.onNoteEditClicked = function (note, idx, button)
  {
    this.annotationController.editNote(note);
  };

  NotesPanelContent.prototype.onNoteDeleteClicked = function (note, idx, button)
  {
    this.annotationController.deleteAnnotation(note);
  };


  NotesPanelContent.prototype.onListItemDoubleClick = function (note, idx)
  {
    this.onListItemClick(note, idx);
    this.broadcastEvent("action:ClosePanelIfDetached");
  };


  function AnnotationsListViewModel(model)
  {
    this.model = model;
    this.filtered = null;

    this.on = _.bind(model.on, model);
    this.off = _.bind(model.off, model);
  }
  
  AnnotationsListViewModel.prototype.getLength = function ()
  {
    this.filtered = this.model.getCurrentState().state.getAllNotes();
    return this.filtered.length;
  };

  AnnotationsListViewModel.prototype.getItem = function (i)
  {    
    return this.filtered[i];
  };

}
(vitrium.viewer,
vitrium.ui,
vitrium.i18n,
_));

// script:viewer/notes-dialog-ui.js
/// <reference path="~/build.html" />

(function (exports,v, i18n, ui, Backbone, _)
{
  "use strict";

  exports.NoteFormModel = Backbone.Model.extend({
     defaults: {
        id: null,
      cid : null,
      text: "",
      page: null,
      position: null
    }
  });

  exports.showNoteFormDialog = function (viewer, model, callback, isNew)
  {
    var form = new ui.Form(model, {
      manualSync: true,
      fields: [
        {
          id: "text",
          type: "textarea",
          label: i18n._T("note-text-label")
        }
      ]
    });

    
    form.el.addClass("vitrium-note-form");
     
    var box = v.showDismissBox(viewer, null, i18n._T("note-form-title-" + (isNew ? "new" : "edit")), form.el, {
      buttons: [
        { id: "close", title: i18n._T("note-cancel-label") },
        { id: "save", title: i18n._T("note-save-label"), cssClass: "btn-primary no-key" }
      ]
    });
    
    if (vitrium.is_mobile && $.browser.safari)
    {
      // HACK for mobile safari (it fixes weird scrolling when element lost its focus)
      form.el.find("textarea").focusout(function () { $(window).scrollTop(0); });
    }

    form.focus("text");
    box.on("button:save", function (evt)
    {
      form.sync();
      if (_.isEmpty(model.get("text")))
      {
        form.displayMessages({ "text": { type: "error", text: "note-form-validation-empty-note" } });
        form.focus("text");
        evt.preventDefault();
        return;
      }

      form.destroy();
      callback(true, model);
    });
    box.on("button:close", function () { callback(false, model); });

  };

}
(
vitrium.viewer,
vitrium.viewer,
vitrium.i18n,
vitrium.ui,
Backbone,
_
));

// script:viewer/bookmarks-panel-ui.js
/// <reference path="~/build.html" />

(function (exports, ui, _, Backbone)
{
  "use strict";

  exports.BookmarksPanel = BookmarksPanel;
  exports.BookmarksListModel = BookmarksListModel;

  var KEY_LEFT = 37;
  var KEY_UP = 38;
  var KEY_RIGHT = 39;
  var KEY_DOWN = 40;
  var KEY_ENTER = 13;

  function BookmarksPanel(model)
  {
    ui.LabeledSidePanel.call(this, ui.icon("bookmark"), "bookmarks-panel-title");

    this.model = model;
    this.bookmarksView = this.layoutManager.center = this.add(new ui.ListView(model, function ($el, bookmark, idx)
    {
      $el.css("paddingLeft", bookmark.level + "em");

      var content = document.createElement("div");
      content.className = "vitrium-bookmark-content";
      var $content = $(content).text(bookmark.title);

      if (bookmark.documentVisible)
      {
        $el.addClass("vitrium-bookmark-visible");
      }

      if (bookmark.selected)
      {
        $el.addClass("vitrium-bookmark-selected");
      }

      if (bookmark.nullOperation)
      {
        $el.addClass("vitrium-bookmark-null");
      }

      if (bookmark.bold) $content.addClass("vitrium-bookmark-bold");
      if (bookmark.italic) $content.addClass("vitrium-bookmark-italic");
      if (bookmark.color && !bookmark.selected) $content.css("color", bookmark.color);

      if (bookmark.children)
      {
        if (bookmark.opened)
        {
          $("<span class='vitrium-bookmark-tree-node vitrium-bookmark-close' data-action='node-close'><i class = 'fa fa-minus-square-o'></i></span>").appendTo($el);
        }
        else
        {
          $("<span class='vitrium-bookmark-tree-node vitrium-bookmark-open' data-action='node-open'><i class = 'fa fa-plus-square-o'></i></span>").appendTo($el);
        }
      }

      $el.append(content);
    }));

    this.bookmarksView.$el.attr("tabindex", 0);
    this.lastActionTime = 0;
    this.selectionChanged = false;
    this.keyHandled = false;
    model.on("selection-changed", function ()
    {
      this.selectionChanged = true;
      this.refresh();
    }, this)
  }
  BookmarksPanel.prototype = Object.create(ui.LabeledSidePanel.prototype);
  BookmarksPanel.prototype.onActivate = function ()
  {
    this
     .listen(this.bookmarksView, "item:clicked", this.onBookmarkItemClicked, this)
     .listen(this.bookmarksView, "item:doubleclicked", this.onBookmarkItemDoubleClicked, this)
     .listen(this.bookmarksView, "action:node-close", this.onNodeClose, this)
     .listen(this.bookmarksView, "action:node-open", this.onNodeOpen, this)
     .listen(this.bookmarksView.$el, "keydown", _.bind(this.onKeyDown, this));



    setTimeout(_.bind(function scrollToActivatedElement()
    {
       this.scrollTo($(this.bookmarksView.el).find(".vitrium-bookmark-visible"));
    }, this), 50);
    
    this.refresh();
  };

  BookmarksPanel.prototype.onRender = function ()
  {
    if (this.selectionChanged)
      
    {
      var $oldSelection = this.bookmarksView.$el.find(".vitrium-bookmark-selected");
      $oldSelection.removeClass("vitrium-bookmark-selected");

      var oldSelectionIdx = parseInt($oldSelection.attr("idx"), 10);

      var item = this.model.getItem(oldSelectionIdx);
      if (item && item.color)
      {
        $oldSelection.find(".vitrium-bookmark-content").css("color", item.color);
      }

     var $current = this.bookmarksView.$el.find("[idx='" + this.model.selectedIdx + "']").addClass("vitrium-bookmark-selected");
      item = this.model.getItem(this.model.selectedIdx);
      if (item && item.color)
      {
        $current.find(".vitrium-bookmark-content").css("color", "white");
      }

      this.selectionChanged = false;
    }

    if (this.keyHandled)
    {
      this.scrollTo(this.bookmarksView.$el.find(".vitrium-bookmark-selected"));
     
      this.keyHandled = false;
    }
    
  };

  BookmarksPanel.prototype.scrollTo = function (visible)
  {
    if (visible.length > 0)
    {
      var scrollPos = this.bookmarksView.$el.scrollTop();
      var top = this.bookmarksView.$el.offset().top;
      var selectedTop = visible.offset().top;
      var selectedHeight = visible.height();

      var listHeight = this.bookmarksView.dim.h;
      var listPos = selectedTop - top;
      if (listPos - (selectedHeight * 2) < 0)
      {
        this.bookmarksView.$el.scrollTop(scrollPos + listPos - (selectedHeight * 2));
      }
      else if (listPos + selectedHeight + (selectedHeight * 2) > listHeight)
      {
        this.bookmarksView.$el.scrollTop(scrollPos + (listPos + selectedHeight - listHeight) + (selectedHeight * 2));
      }


    }
  };
  BookmarksPanel.prototype.onKeyDown = function (evt)
  {
    var key = evt.which;
    var model = this.model;
    var handled = false;
    switch (key)
    {
      case KEY_UP:
        model.selectPrev();
        this.refresh();
        handled = true;
        break;
      case KEY_DOWN:
        model.selectNext();
        this.refresh();
        handled = true;

        break;
      case KEY_LEFT:
        model.closeSelected();
        handled = true;
        this.refresh();
        break;
      case KEY_RIGHT:
        model.openSelected();
        handled = true;
        this.refresh();
        break;
      case KEY_ENTER:
        if (model.selected !== null)
        {
          this.broadcastEvent("action:openBookmark", model.selected._data);
          handled = true;
        }
        break;
    };
    if (handled)
    {
      this.keyHandled = true;
      evt.preventDefault();
    }
    
  };

  BookmarksPanel.prototype.onBookmarkItemClicked = function (node, idx, listview, touch)
  {
    listview.$el.focus();
    this.model.select(idx);
    this.broadcastEvent("action:openBookmark", node._data);
    if (touch && this.notIgnored())
    {
      if (!node.opened)
      {
        this.model.openNode(idx);
      }
      else
      {
        this.model.closeNode(idx);
      }
    }
      
  };

  BookmarksPanel.prototype.onBookmarkItemDoubleClicked = function (node, idx, listview, touch)
  {
    if (!touch && this.notIgnored())
    {
      if (node.opened)
      {
        this.model.closeNode(idx);
      }
      else
      {
        this.model.openNode(idx);
      }
    }

    if (touch)
    {
      this.broadcastEvent("action:ClosePanelIfDetached");
    }
  };

  BookmarksPanel.prototype.onNodeOpen = function (node, idx)
  {
    if (!node.opened && this.notIgnored())
    {
      this.model.openNode(idx);
    }
  };

  BookmarksPanel.prototype.onNodeClose = function (node, idx)
  {
    if (node.opened && this.notIgnored())
    {
      this.model.closeNode(idx);
    }
  };

  BookmarksPanel.prototype.notIgnored = function ()
  {    
    var time = Date.now();
    if (time - this.lastActionTime > 500)
    {

      this.lastActionTime = time;
      return true;
    }
    return false;
  };




  function BookmarksListModel(data)
  {
    this.flatNodeList = [];
    this.nodes = [];

    this._buildNodes(data);
    
    
    this.currentNodes = null;
    this.nodesChanged = true;

    this.currentVisibleNode = null;

    this.selected = null;
    this.selectedIdx = null;

    this.timer = null;
    this.currentViewport = null;
  }

  BookmarksListModel.prototype = {
    getLength : function()
    {
      if (this.nodesChanged)
      {
        this.currentNodes = this._prepareNodes(this.nodes);
        this.markVisible(this.currentVisibleNode);
        this.selectedIdx = this.currentNodes.indexOf(this.selected);
        if (this.selectedIdx === -1) this.selectedIdx = null;

        this.nodesChanged = false;
      }
      return this.currentNodes.length;
    },
    getItem : function(idx)
    {
      return this.currentNodes[idx];
    },
    openNode : function(idx)
    {
      var node = this.currentNodes[idx];
      if (node.children !== null)
      {
        node.opened = true;
        this.triggerChange();
      }
    },
    closeNode : function(idx)
    {
      var node = this.currentNodes[idx];
      if (node.children !== null)
      {
        node.opened = false;

        if (this._isChildOf(node, this.selected))
        {
          this.selected = node;
        }
        this.triggerChange();
      }
    },
    select : function(idx)
    {
      if (idx < 0)
      {
        idx = this.currentNodes.length -1;
        //console.log(idx);
        this.select(idx);
      }
      else
      {
        this.selected = this.currentNodes[idx];
        this.selectedIdx = idx;

        this.trigger("selection-changed", this);
      }
    },
    selectNext : function()
    {
      if (this.selectedIdx === null)
      {
        this.select(0);
      }
      else
      {
        this.select((this.selectedIdx + 1) % this.currentNodes.length);
      }
    },
    selectPrev: function()
    {
      if (this.selectedIdx === null)
      {
        this.select(-1);
      }
      else
      {
        this.select(this.selectedIdx + -1);
      }
    },
    openSelected: function()
    {
      if (this.selectedIdx !== null) this.openNode(this.selectedIdx);
    },
    closeSelected: function()
    {
      if (this.selectedIdx !== null)
      {
        if (this.selected.opened)
        {
          this.closeNode(this.selectedIdx);
        }
        else 
        {
          var c = this.selected.parent;
          while(c !== null)
          {
            if (c.opened)
            {
              var idx = this.currentNodes.indexOf(c);
              if (idx !== -1)
              {
                this.closeNode(idx);
              }

              break;
            }
            c = c.parent;
          }
            
        }
      }
    },
    _isChildOf : function(node, queryChild)
    {
      var r = node.children !== null && node.children.indexOf(queryChild) !== -1;

      for (var i = 0, len = node.children === null ? 0 :node.children.length; i < len && !r; ++i)
      {
        r = this._isChildOf(node.children[i], queryChild);
      }
      return r;
    },
    _prepareNodes : function(nodes)
    {
      var prepared = [];
      this._traverseForPreparation(prepared, nodes);
      return prepared;
    },
    _traverseForPreparation : function(prepared, nodes)
    {
      for (var i = 0, len = nodes.length; i < len; ++i)
      {
        var node = nodes[i];
        
        prepared.push(node);
        if (node.opened)
        {
          this._traverseForPreparation(prepared, node.children);
        }
      }
    },
    _buildNodes : function(data)
    {
      var nodes = this.nodes;
      for (var i = 0, len=data.length; i < len;++i)
      {
        nodes.push(this._createNode(data[i], 0, null));
      }
      
    },
    _createNode : function(current, level, parent)
    {
      var myChildren = null;
      var children = current.Children;
      if (children.length > 0)
      {
        myChildren = [];
      }

      var n = {
        _model: this,
        _data: current,
        parent: parent,
        level: level,
        children: myChildren,
        documentVisible: false,
        opened: false,
        get title()
        {
          return this._data.Title;
        },
        get pageIdx()
        {
          return this._data.Operation.PageIdx;
        },
        get nullOperation()
        {
          return _.isEmpty(this._data.Operation);
        },
        get bold()
        {
          return !!this._data.Bold;
        },
        get italic()
        {
          return !!this._data.Italic;
        },
        get color()
        {
          return this._data.Color;
        },
        get verticalPosition()
        {
          var op = this._data.Operation;
          if ("Y" in op)
          {
            return op.Y;
          }
          else
          {
            return 0;
          }
        },
        get selected ()
        {
          return this._model.selected === this;
        }
      };

      for (var i = 0, len = children.length; i < len; ++i)
      {
        myChildren.push(this._createNode(children[i], level + 1, n));
      }

     

      this.flatNodeList.push(n);
      return n;
    },
    triggerChange: function()
    {
      this.nodesChanged = true;
      this.trigger("changed", this);
    },
    setVisiblePages : function(pages)
    {
      this.currentViewport = pages;
      var self = this;
      if (this.timer === null)
      {
        this.timer = setTimeout(function ()
        {
          self.computeActiveBookmark(self.currentViewport);
          self.triggerChange();
          self.timer = null;
        }, 500);
      }     
    },
    computeActiveBookmark: function(pages)
    {
      var pageNumbers = _.pluck(pages, "number");
      var beg = Math.min.apply(Math, pageNumbers);
      var pagesArrayIdx = -1;

      var previousBookmark = null;
      var visibleBookmarks = [];


      var flatNodes = this.flatNodeList;
      for (var i = 0, len = flatNodes.length; i < len; ++i)
      {
        var node = flatNodes[i];
        if (node.nullOperation) { node.documentVisible = false; continue; };

        var currentPageIdx = node.pageIdx;
        node.documentVisible = false;
        

        if (currentPageIdx < beg)
        {
          if (previousBookmark !== null)
          {
            if (currentPageIdx > previousBookmark.pageIdx)
            {
              previousBookmark = node;
            }
            else if (currentPageIdx === previousBookmark.pageIdx && node.verticalPosition >= previousBookmark.verticalPosition)
            {
              previousBookmark = node;
            }
          }
          else
          {
            previousBookmark = node;
          }
        }
        else if ((pagesArrayIdx = pageNumbers.indexOf(currentPageIdx)) !== -1)
        {
          var vPos = pages[pagesArrayIdx].duY + node.verticalPosition ;
          visibleBookmarks.push({ node: node, vert: vPos });
        }
      }

      visibleBookmarks.sort(function (a, b) { return a.vert - b.vert; });

      var mark = previousBookmark;
      var greaterThanZero = null;

      for (var i = 0; i < visibleBookmarks.length; ++i)
      {
        var distance = visibleBookmarks[i];

        // if it is offscreen we replace it
        if (distance.vert < 120)
        {
          mark = distance.node;
        }
        if (greaterThanZero == null && distance.vert > 0 && distance.vert < 120)
        {
          greaterThanZero = distance.node;
        }
      }
      
      if (greaterThanZero !== null)
      {
        mark = greaterThanZero;
      }          

     this.markVisible(mark);
    },
    markVisible : function(node)
    {
      this.currentVisibleNode = node;

      var chain = [];
      var c = node;
      while(c !== null)
      {
        c.documentVisible = false;
        chain.unshift(c);
        c = c.parent;
      } 

      for (var i = 0, len = chain.length; i < len; ++i)
      {
        var n = chain[i];
        if (!n.opened || i + 1 === len)
        {
          n.documentVisible = true;
          break;
        }
        
      }
    }
  };

  _.extend(BookmarksListModel.prototype, Backbone.Events);


}
(vitrium.viewer,
vitrium.ui,
_,
Backbone));

// script:viewer/thumbnails-panel-ui.js
/// <reference path="~/build.html" />

(function (exports, ui, _)
{
  "use strict";

  exports.ThumbnailsPanel = ThumbnailsPanel;
  function ThumbnailsPanel()
  {
    ui.LabeledSidePanel.call(this, ui.icon("th"), "thumbnails-panel-title");

  }
  ThumbnailsPanel.prototype = Object.create(ui.LabeledSidePanel.prototype);

}
(vitrium.viewer,
vitrium.ui,
_));

// script:viewer/text-selection-action-bar-ui.js
/// <reference path="~/build.html" />

(function (exports, ui, i18n, Backbone, _)
{
  "use strict";

  exports.SelectedTextActionBar = SelectedTextActionBar;
  function SelectedTextActionBar() 
  {
    ui.ContainerWidget.call(this);
    this.layoutManager = new ui.HorizontalAlignLayout(this);
    this.layoutManager.left = this.add(new Button("text-selection-done", ui.icon("check")));
    this.layoutManager.right = this.add(new Button("text-selection-highlight", ui.icon("pencil")));

    $(this.el).on("tap click", ".btn", _.bind(this.onButtonClicked, this));
  }

  SelectedTextActionBar.prototype = Object.create(ui.ContainerWidget.prototype);
  SelectedTextActionBar.prototype.onButtonClicked = function (evt)
  {
    if (evt.type === "click") evt.preventDefault();
    this.broadcastEvent("action:"+$(evt.currentTarget).attr("data-action"));
  };

  function Button(label, icon)
  {
    ui.DomSizedWidget.call(this, document.createElement("div"));
    this.$el.append($("<button>")
      .attr("data-action", label)
      .attr("type", "button")
      .attr("class", "btn")
      .text(i18n._T(label)).prepend(icon.el.firstChild));
  }

  Button.prototype = Object.create(ui.DomSizedWidget.prototype);


}
(
vitrium.viewer,
vitrium.ui,
vitrium.i18n,
Backbone,
_));

// script:viewer/loading-indicator-ui.js
/// <reference path="~/build.html" />

(function (exports, ui, _,Backbone, $, global, vitrium)
{
  "use strict";
  
	global.formatSize = formatSize;
	exports.LoadingIndicator = LoadingIndicator;
	function LoadingIndicator(viewer, showIO)
	{
	  ui.DomWidget.call(this, document.createElement("div"));
	  this.el.className = "vitrium-loading-indicator";
	  var dim = this.dim;
	  dim.w = 52;
	  //dim.h = 64;
	  this.dim = dim;

	  var image = new Image();
	  image.src = vitrium.utils.Pool.resourceUrl(vitrium.base_path + "ajax-loader.gif");

	  this.el.appendChild(image);
		
		viewer.on("document:attached", _.bind(this.documentAttached, this));
		viewer.on("document:detached", _.bind(this.documentDetached, this));
		
		this.onLoadingBegin = _.bind(this.loadingBegin, this);
		this.onLoadingEnd = _.bind(this.loadingEnd, this);
		
	
		this.showIO = showIO;
		
		if (showIO)
		{
			var iostatsButton = $("<button type='button' class='btn btn-mini vitrium-io-stats-button'><i class='icon-signal'></i></button>");
			iostatsButton.appendTo($("body"));
			
			this.iostats = $("<div class='vitrium-io-stats'>");
			
			var self = this;
			var handler = function()
			{
				if(self.statsOn)
				{
					self.iostats.remove();
				}
				else
				{
					self.iostats.appendTo($("body"));
				}
				
				self.statsOn = !self.statsOn;
			};
			
			this.iostats.click(handler);
			iostatsButton.click(handler);
			
			this.statsOn = false;
			this.stats = { requestedTotal : 0, downloadedTotal: 0, unzipedTotal: 0};
			this.statsTmpl = _.template("<table> \
			<tr><th>Requested total:</th><td><%= formatSize(requestedTotal, true) %></td></tr>\
			<tr><th>Downloaded total:</th><td><%= formatSize(downloadedTotal, true) %></td></tr>\
			<tr><th>Unzipped total:</th><td><%= formatSize(unzipedTotal, true) %></td></tr>\
			</table>");
			this.iostats.html(this.statsTmpl(this.stats));


			this.isLoading = false;
			this.statsInvalid = false;
		}
	};

	LoadingIndicator.prototype = _.extend(Object.create(ui.DomWidget.prototype), Backbone.Events);
	var LIP = LoadingIndicator.prototype;
	LIP.setDim = function (dim)
	{
	  ui.DomWidget.prototype.setDim.call(this, dim);
	  this.el.style.lineHeight = ((dim.h+0.5)|0) + "px";

	};
	LIP.documentAttached = function(document)
	{	
		document.on("loading:begin", this.onLoadingBegin);
		document.on("loading:end", this.onLoadingEnd);
		
		if (this.showIO) {
			// TODO refactor tight bound
			this.stats = { requestedTotal : 0, downloadedTotal: 0, unzipedTotal: 0};

			document.getContext().on("fileSystem:remoteRead", this.onRemoteRead, this);
		}
	};
	
	LIP.documentDetached = function(document)
	{
		document.off("loading:begin", this.onLoadingBegin);
		document.off("loading:end", this.onLoadingEnd);
		document.getContext().off("fileSystem:remoteRead", this.onRemoteRead, this);
	};
	
	LIP.loadingBegin = function()
	{	
	  this.isLoading = true;
	  this.refresh();
	};
	
	LIP.loadingEnd = function()
	{
	  this.isLoading = false;
	  this.refresh();  
	};

	LIP.onRender = function ()
  {
	  this.el.style.display = this.isLoading ? "block" : "none";
	  if (this.statsInvalid)
	  {
	    this.iostats.html(this.statsTmpl(this.stats));
	    this.statsInvalid = false;
	  }
	};
	
	LIP.onRemoteRead = function (type, compressedSize, uncompressedSize)
	{
	  var stats = this.stats;
	  if (type === "requested")
	  {
	    stats.requestedTotal += compressedSize;
	  }
	  else if (type === "finished")
	  {
	    stats.downloadedTotal += compressedSize;
	    stats.unzipedTotal += uncompressedSize;
	  }

	  this.refreshStats(stats);
	};

	
	LIP.refreshStats = function(stats)
	{
	  this.statsInvalid = true;
	  this.refresh();
	};
	
	function formatSize(bytes, si) {
		var thresh = si ? 1000 : 1024;
		if(bytes < thresh) return bytes + ' B';
		var units = si ? ['KB','MB','GB','TB','PB','EB','ZB','YB'] : ['KiB','MiB','GiB','TiB','PiB','EiB','ZiB','YiB'];
		var u = -1;
		do {
			bytes /= thresh;
			++u;
		} while(bytes >= thresh);
		return bytes.toFixed(1)+' '+units[u];
	};
	

}
(
vitrium.viewer,
vitrium.ui,
_, 
Backbone, 
jQuery, 
__globals__,
vitrium));
// script:viewer/fonts-manager.js
/// <reference path="~/build.html" />

(function (exports, fontsLoader) {
   "use strict";
   
   exports.FontsManager = FontsManager;
   function FontsManager(fontsInitializedCallback)
   {
      this._fonts = {};
      this._readyPages = {};
      this._pages = {};

      this._loadedFontFiles = [];
      this._initializedFontFiles = [];

      this._fontsInitializedCallback = fontsInitializedCallback;
   }

   // Method is called from PageCanvas manager
   FontsManager.prototype.canRenderPage = function FontsManager__canRenderPage(page)
   {
      return !!this._readyPages[page];
   };

   FontsManager.prototype.initPageFonts = function FontsManager__initPageFonts(pageIndex, fontFiles)
   {
      if (!this._pages.hasOwnProperty(pageIndex))
         this._pages[pageIndex] = fontFiles;
      
      return _.difference(fontFiles, this._loadedFontFiles);
   };

   FontsManager.prototype.pushFonts = function FontsManager__pushFonts(fontFiles)
   {
      var fonts = [];
      var fontIdx = this._fonts;
      var loadedFontFiles = this._loadedFontFiles;
      var fontFilesToInitilize = [];
      for (var i = fontFiles.length; i--;)
      {
         var fontFile = fontFiles[i];
         if (loadedFontFiles.indexOf(fontFile) !== -1)
            continue;
         else
         {
            loadedFontFiles.push(fontFile);
            fontFilesToInitilize.push(fontFile);
         }

         var fontArray = fontFiles[i].data;
         fonts.push.apply(fonts, fontArray);

         for (var j = fontArray.length; j--;) {
            var f = fontArray[j];
            fontIdx[f.key] = f;
         }
      }

      var self = this;
      var loadedCallback = function ()
      {
         self._initializedFontFiles.push.apply(self._initializedFontFiles, fontFilesToInitilize);
         self._markPagesThatHaveFontsFullyLoaded();
      };

      fontsLoader.load({
         fonts : fonts, 
         success: loadedCallback,
         error: loadedCallback,
         timeout: 400
      });      
   };

   FontsManager.prototype._markPagesThatHaveFontsFullyLoaded = function FontsManager__markPagesThatHaveFontsFullyLoaded()
   {
      var initializedSome = false;
      var readyPages = this._readyPages;
      _.each(this._pages, function(fontFiles, key)
      {
         if (_.difference(fontFiles, this).length === 0)
         {
            readyPages[key] = true;
            initializedSome = true;
         }
      }, this._initializedFontFiles);
                  
      if (initializedSome)
         this._fontsInitializedCallback(this._pages);
   };
    

   FontsManager.prototype.glyphIdxToChar = function FontsManager__glyphIdxToChar(font, glyphIdx) {
      var f = this._fonts[font];
      if (f) {
         var ra = f.ranges;
         for (var i = ra.length; i--;) {
            var r = ra[i];
            if (r[0] <= glyphIdx && r[1] >= glyphIdx) {
               var charIdx = glyphIdx - r[2];
               if (charIdx < 0) {
                  charIdx += 0xffff + 1;
               }
               else if (charIdx > 0xffff) {
                  charIdx -= 0xffff + 1;
               }

               return String.fromCharCode(charIdx);
            }
         }

         if (ra.length == 0 && glyphIdx == 0) {
            return ' ';
         }

         ra = f.ucs4Ranges;
         for (var i = ra.length; i--;) {
            var r = ra[i];
            if (r[0] <= glyphIdx && r[1] >= glyphIdx) {
               var charIdx = glyphIdx + r[2];
               return fromUTF32(charIdx);
            }
         }
      }
      
      if (glyphIdx === 0) return "";
      return null;
   };

   function fromUTF32(C)
   {
      var H = Math.floor((C - 0x10000) / 0x400) + 0xD800;
      var L = (C - 0x10000) % 0x400 + 0xDC00;
      return String.fromCharCode(H) + String.fromCharCode(L);
   }

}
(vitrium.viewer,
 vitrium.fonts
));



// script:viewer/page-canvas-manager.js
/// <reference path="~/build.html" />

(function (exports, ui, geometry, vitrium,viewer,log, _, Backbone,$)
{
  "use strict";
  exports.PageCanvasManager = PageCanvasManager;
  var max = Math.max;
  var min = Math.min;

  function PageCanvasManager(uiLoop, pageInfos, canvasLayers, tryGetThumbnailFunct, fontsManager)
  {
    this.uiLoop = uiLoop;
    this.uiRenderVisiblePages = new ui.UISync(this.renderVisiblePages, this, 0);
    this.refreshAllPages = false;
    this.refresCalled = false;
    this.fontsManager = fontsManager;
    this.taskScheduler = new vitrium.TaskScheduler(this);
    

    var maxDim = null;
    if (vitrium.is_mobile && window.navigator.appVersion.indexOf("Trident") === -1)
    {
      maxDim = new geometry.Rectangle(0, 0, 1024, 1024, 0);
    }
    else
    {
      maxDim = new geometry.Rectangle(0, 0, 2048, 2048, 0);
    }

    this.tilesCalculator = new ui.TilesCalculator(function () { return maxDim; });
    var pageCount = pageInfos.length;
    var p = this.pages = new Array(pageCount);

    for (var i = 0, len = pageCount; i < len; ++i)
    {
      p[i] = new Page(pageInfos[i], tryGetThumbnailFunct, this);
    }

    this.dirtyLayers = {};

    this.layers = canvasLayers;
    for (var i = 0, len = canvasLayers.length; i < len; ++i)
    {
      canvasLayers[i].on("changed", this.onLayerChanged, this);
    }
  }

  PageCanvasManager.prototype = {
    destroy: function ()
    {
      var p = this.pages;
      for (var i = 0, len = p.length; i < len; ++i)
      {
        p[i].free();
      }
      p.length = 0;
      var canvasLayers = this.layers;
      for (var i = 0, len = canvasLayers.length; i < len; ++i)
      {
        canvasLayers[i].off("changed", this.onLayerChanged, this);
      }
      this.pause();
    },
    getPage: function (idx)
    {
      return this.pages[idx];
    },
    freePageRange: function (start, end)
    {
      var pages = this.pages;
      for (var i = start; i <= end; ++i)
      {
        pages[i].free();
       // vitrium.log.debug("page freed: "+i);
      }
    },
    addLayer: function (layer)
    {
      if (this.layers.indexOf(layer) === -1)
      {
        this.layers.push(layer);
      }

      layer.on("changed", this.onLayerChanged, this);
    },
    removeLayer : function(layer)
    {
     layer.off("changed", this.onLayerChanged, this);
     this.layers = _.without(this.layers, layer);
     this.onLayerChanged();
    },
    onLayerChanged: function (pageNumbers, silent)
    {
      var dl = this.dirtyLayers;
      if (!pageNumbers)
      {
        
        for (var i = 0, len = this.pages.length; i < len ; ++i)
        {
            dl[i] = true; 
        }
      }
      else
      {
        for (var i = 0, len = pageNumbers.length; i < len ; ++i)
        {
          var pageNumber = pageNumbers[i];
          dl[pageNumber] = true;
        }
      }

      if (!silent)
      {
        this.broadcastContentChanged();
      }
    },
    broadcastContentChanged : function()
    {
      this.uiLoop.trigger("PageCanvasManager:contentChanged", this);
    },
    resetDirtyLayers: function (pages)
    {
      if (!pages)
      {
        this.resetDirtyLayers = {};
      }

      for (var i = 0, len = pages.length; i < len; ++i)
      {
        delete this.dirtyLayers[pages[i].number];
      }
    },
    isLayerDirty: function (pageNumber)
    {
      return !!this.dirtyLayers[pageNumber];
    },
    hasLayerContent: function (pageNumber)
    {
      var result = false;
      var canvasLayers = this.layers;
      for (var i = 0, len = canvasLayers.length; !result && i < len; ++i)
      {
        result = canvasLayers[i].hasContent(pageNumber);
      }

      return result;
    },
    renderLayers: function(pageNumber, ctx, time, pageDim)
    {
      var layers = this.layers;
      for (var i = 0, len = layers.length; i < len; ++i)
      {
        var layer = layers[i];
        
        if (layer.hasContent(pageNumber))
        {
          ctx.save();
          layer.render(pageNumber, ctx, time, pageDim);
          ctx.restore();
        }
      }
    },
    refresh: function ()
    {
      this.refresCalled = true;
      this.uiLoop.runAsync(this.uiRenderVisiblePages);
    },
    refreshAll: function ()
    {
      this.refreshAllPages = true;
      this.refresh();
    },
    pause: function ()
    {
      //the task will be canceled unitl further resume
      this.uiRenderVisiblePages.cancel();
    },
    resume: function ()
    {
      if (this.uiRenderVisiblePages.resume())
      {
        //should be scheduled next frame
        this.uiLoop.runAsync(this.uiRenderVisiblePages);
      }
    },
    renderVisiblePages: function PageCanvasManager__renderVisiblePages(context)
    {      
        var taskScheduler = this.taskScheduler;
        taskScheduler.markFrame();
        //it allows to not deal with something that has not been changed yet
        if (this.refresCalled)
        {
          this.__refreshPages(context);
          this.refresCalled = false;
        }

        taskScheduler.execute();
        if (taskScheduler.delayed)
        {
          this.uiLoop.runAsync(this.uiRenderVisiblePages);
        }

        if (this.__shouldRefreshMainUI(context))
        {
          this.broadcastContentChanged();
        }
      /*}
      else if (this.refreshCalled)
      {
        this.broadcastContentChanged();
      }*/
    },
    __refreshPages: function (context)
    {
      var taskScheduler = this.taskScheduler;
      var pages = context.pages;
      var pageContexes = this.pages;

      var refreshAllPages = this.refreshAllPages;
      this.refreshAllPages = false;
      var tilesCalculator = this.tilesCalculator;
      var fontsManager = this.fontsManager;

      for (var i = 0, len = pages.length; i < len; ++i)
      {
         var page = pages[i];
         if (fontsManager.canRenderPage(page.number)) 
         {
            var pageContext = pageContexes[page.number];

            var tasks = pageContext.prepareVisiblePartRendering(page, tilesCalculator, context);
            for (var t = 0, tlen = tasks.length; t < tlen; ++t) {
               taskScheduler.addTask(tasks[t]);
            }
         }
      }
    },
    __shouldRefreshMainUI: function (context)
    {
      var pages = context.pages;

      var pageContexes = this.pages;
      var result = false;
      var fontsManager = this.fontsManager;

      for (var i = 0, len = pages.length; i < len; ++i)
      {
        /// <var type="viewer.PageInfo"></var>
        var page = pages[i];
        if (!fontsManager.canRenderPage(page.number))
           continue;

        // NOTE it may be necessary to free last scale version
        var pageCtx = pageContexes[page.number];

        var status = pageCtx.checkRenderingTasks(page.viewportRect);
        if (status === R_ALL_DONE)
        {
          result = true;
          if (pageCtx.oldTiles !== null)
          {
            pageCtx.oldTiles.free();
            pageCtx.oldTiles = null;
          }
          // I am not breaking here , have to check all pageContexes
        }
        else if (status === R_PARTIALY_DONE)
        {
          result = true;
        }
        else if (status === R_INITIAL_DONE)
        {
          result = true;
          this.refresh();
        }
      }
      return result;
    }
  };

  _.extend(PageCanvasManager.prototype, Backbone.Events);

  function Page(info, tryGetThumbnailFunct, manager)
  {
    /// <param name="manager" type="PageCanvasManager"></param>
    /// <field name="manager" type="PageCanvasManager"></field>

    this.info = info;
    this.contentState = 0;
    this.status = 0;
    this.renderer = null;
    this.data = null;
    this.manager = manager;

    this.tryGetThumbnailFunct = tryGetThumbnailFunct;
    this._thumbnail = null;
    this.thumbnailTile = new CanvasTileInfo(new geometry.Rectangle(0, 0, 0, 0, 0));
    this.currentTiles = null;
    this.oldTiles = null;
    this.layerTiles = null;

    this.initialRenderingTask = null;
  }

  Page.prototype = {
    free: function ()
    {
      this._thumbnail = null;
      this.thumbnailTile.canvas = null;

      if (this.contentState !== 0)
      {
        if (this.renderer) this.renderer.free();
       }

      if (this.currentTiles !== null) this.currentTiles.free();
      if (this.oldTiles !== null) this.oldTiles.free();
      if (this.layerTiles !== null) this.layerTiles.free();
      if (this.initialRenderingTask !== null)
      {
        //this is ugly
        var task = this.initialRenderingTask;
        task.interrupt();
        task.tile.task = null;
        task.tile.free();
        task.tile = null;
      }

      this.currentTiles = null;
      this.oldTiles = null;
      this.layerTiles = null;
      this.initialRenderingTask = null;
      this.status = this.contentState = 0;
      this.data = null;      
    },
    getTiles: function(pageDim, scale, time)
    {
      /// <param name="pageDim" type="viewer.PageInfo"></param>
      var pageRect = pageDim.baseRect;
      var viewportRect = pageDim.viewportRect;
      this.thumbnailTile.rect.assign(pageRect);

      var currentTiles = null;
      var oldTiles = null;
      var loadOldTiles = true;
      if (this.currentTiles !== null)
      {
        this.currentTiles.scaleTo(scale);
        var result = this.currentTiles.queryRenderedTilesForViewport(viewportRect);
        currentTiles = result.tiles;
        loadOldTiles = !result.predResult;
      }

      if (loadOldTiles && this.oldTiles !== null)
      {
        this.oldTiles.scaleTo(scale);
        var result = this.oldTiles.queryRenderedTilesForViewport(viewportRect);
        oldTiles = result.tiles;
        loadOldTiles = !result.predResult;
      }
      
      var result = [];
      if (loadOldTiles)
      {
        if (this._thumbnail === null)
        {
          // setter call
          this.thumbnail = this.tryGetThumbnailFunct(pageDim.number);
        }
        
        if (this._thumbnail !== null)
        {
          result.push(this.thumbnailTile);
        }
      }

      if (oldTiles !== null) result.push.apply(result, oldTiles);
      if (currentTiles !== null) result.push.apply(result, currentTiles);
      
      // now render layers
      this.renderLayers(result, pageDim, viewportRect, scale, time);
      

      return result;
    },
    renderLayers : function(result, pageDim, viewportRect, scale,  time)
    {
      var hasContent = this.manager.hasLayerContent(pageDim.number);
      var isDirty = this.manager.isLayerDirty(pageDim.number);

      if (!hasContent && this.layerTiles !== null)
      {
        this.layerTiles.free();
        this.layerTiles = null;
      }
      var baseTileMng = this.currentTiles !== null ? this.currentTiles : this.oldTiles !== null ? this.oldTiles : null;

      if (hasContent && (this.layerTiles === null || (this.layerTiles.independent && baseTileMng !== null)))
      {
        if (baseTileMng !== null)
        {
          this.layerTiles = baseTileMng.createDependendLayerManager();
        }
        else if (this._thumbnail !== null)
        {

          var rects = this.manager.tilesCalculator.calculateTiles(pageDim.baseRect, viewportRect);
          this.layerTiles = new PageTilesManager(scale);
          this.layerTiles.init(rects);
        }
      }

      if (this.layerTiles !== null)
      {
        this.layerTiles.scaleTo(scale);
      }

      var tiles = null;
      if (isDirty && this.layerTiles !== null)
      {
        tiles = this.layerTiles.queryTilesForViewport(viewportRect, function (r) { return true; }).tiles;
    
        var outsideTiles = this.layerTiles.queryNotIntersectedTilesForViewport(viewportRect, function (r) { return true; });
        for (var i = 0, len = outsideTiles.length; i < len ; ++i)
        {
          outsideTiles[i].free();
        }
      }
      else if (hasContent && this.layerTiles !== null)
      {
        tiles = this.layerTiles.queryNonRenderedAndNotAllocatedTilesForViewport(viewportRect).tiles;
      }

      

      if (tiles !== null && tiles.length > 0)
      {
        for (var i = 0, len = tiles.length; i < len ; ++i)
        {
          var tile = tiles[i];
          if (tile.canvas === null)
          {
            tile.allocate();
          }
          var canvas = tile.canvas;
          var rect = tile.rect;

          var ctx = canvas.getContext("2d");
          ctx.clearRect(rect.x, rect.y, rect.w, rect.h);
          ctx.save();
          ctx.scale(scale, scale);
          
          this.manager.renderLayers(pageDim.number, ctx, time, pageDim);
          tile.rendered = true;
          ctx.restore();
        }
      }

      if (this.layerTiles !== null)
      {
        tiles = this.layerTiles.queryRenderedTilesForViewport(viewportRect).tiles;
        if (tiles !== null) result.push.apply(result, tiles);
      }
    },
    prepareVisiblePartRendering: function (pageDim, calculator, context)
    {
      /// <param name="pageDim" type="viewer.PageInfo"></param>
      /// <param name="calculator" type="ui.TilesCalculator"></param>
      if (this.data === null || (this.initialRenderingTask !== null && !this.initialRenderingTask.done))
      {
        return [];
      }

      var pageRect = pageDim.baseRect;
      var viewportRect = pageDim.viewportRect;
      
      this.thumbnailTile.rect.assign(pageRect);

      if (this.currentTiles !== null
        && this.currentTiles.creationScale !== context.scale)
      {
        if (this.oldTiles  !== null) this.oldTiles.free();

        var oldTiles = this.oldTiles = this.currentTiles;
        // let's preserve only rendered ones
        if (oldTiles.tiles === null)
        {
          this.oldTiles = null;
        }
        else
        {
          oldTiles.freeNonRendered();
          oldTiles.scaleTo(context.scale);
          oldTiles.freeNotInViewport(viewportRect);
        }
        
        this.currentTiles = null;
      }
      
      if (this.currentTiles === null)
      {
        this.currentTiles = new PageTilesManager(context.scale);

      //  vitrium.log.debug("page: " + pageDim.number + " pageRect: " + pageRect + " viewportRect:" + viewportRect);
        this.currentTiles.init(calculator.calculateTiles(pageRect, viewportRect));
      }
      else
      {
        this.currentTiles.freeNotInViewportPreserve(viewportRect);
      }

      if (this.layerTiles !== null && this.layerTiles.creationScale !== context.scale)
      {
        this.layerTiles.free();
        this.layerTiles = null;
      }
      else if (this.layerTiles !== null)
      {
        this.layerTiles.freeNotInViewportPreserve(viewportRect);
      }

      var tilesInViewport = this.currentTiles.queryNonRenderedAndNotAllocatedTilesForViewport(viewportRect).tiles;
      var tasks = [];
      var createInitialRenderingTask = this.initialRenderingTask === null;
      if (createInitialRenderingTask)
      {
        if (tilesInViewport.length > 0)
        {
          var tile = tilesInViewport[0];
          var canvas = tile.allocate();

          var task = tile.task = this.renderer.createAsyncRenderer(canvas, context.scale, pageDim.number, this.info, this.data, true);
    //      vitrium.log.debug("intial render for page: " + pageDim.number);
          this.initialRenderingTask = task;
          task.number = pageDim.number;
          task.initial = true;
          task.tile = tile;
          tasks.push(task);
        }
  
      }
      else
      {
        for (var i = 0, len = tilesInViewport.length; i < len; ++i)
        {
          var tile = tilesInViewport[i];
          var canvas = tile.allocate();

          var task = tile.task = this.renderer.createAsyncRenderer(canvas, context.scale, pageDim.number, this.info, this.data, false);
          task.initial = false;
          tasks.push(task);
        }
      }


      return tasks;
    },
    checkRenderingTasks: function (viewport)
    {

      if (this.data === null) return R_NONE;
      if (this.initialRenderingTask !== null && this.initialRenderingTask.done && this.initialRenderingTask.done !== 2)
      {
        this.initialRenderingTask.done = 2;
        this.currentTiles.checkRenderingTasks(viewport);
        return R_INITIAL_DONE;
      }

      return this.currentTiles.checkRenderingTasks(viewport);
    }
  };

  Object.defineProperty(Page.prototype, "thumbnail", {
    get: function () { return this._thumbnail; },
    set: function (newValue) { this.thumbnailTile.canvas = newValue; return this._thumbnail = newValue; },
    enumerable: true,
    configurable: true
  });

  function CanvasTileInfo(rect)
  {
    /// <field name="rect" type="geometry.Rectangle"></field>
    this.rect = rect;
    this.canvas = null;
    this.task = null;
    this.rendered = false;
  }

  CanvasTileInfo.prototype = {
    allocate: function ()
    {
      var canvas = this.canvas = ui.CANVAS_POOL.getCanvas(this.rect.w, this.rect.h);
      var ctx = canvas.getContext("2d");
      ctx.save();
      ctx.translate(-this.rect.x, -this.rect.y);

      return canvas;
    },
    free: function ()
    {
      if (this.task === null || !this.task.initial)
      {
        if (this.canvas !== null)
        {
        //  ui.CANVAS_POOL.freeCanvas(this.canvas);
          this.canvas = null;
        }
        if (this.task !== null)
        {
          this.task.interrupt();
          this.task = null;
        }
        this.rendered = false;
      }
    }
  };

  function PageTilesManager(scale)
  {
    /// <field name="tiles" type="Array" elementType="CanvasTileInfo" mayBeNull="true"></field>

    this.tiles = null;
    this.scale = scale;
    this.creationScale = scale;
    this.independent = true;
  }

  var R_NONE = 0;
  var R_PARTIALY_DONE = 1;
  var R_ALL_DONE = 2;
  var R_INITIAL_DONE = 3;

  PageTilesManager.prototype =
  {
    init: function (tileRectangles)
    {
      /// <param name="tileRectangles" type="Array" elementType="geometry.Rectangle"></param>
      var tiles = this.tiles = new Array(tileRectangles.length);
      for (var i = 0, len = tileRectangles.length; i < len; ++i)
      {
        tiles[i] = new CanvasTileInfo(tileRectangles[i]);
      }
    },
    createDependendLayerManager : function()
    {
      var tiles = this.tiles;
      var rects = new Array(tiles.length);
      for (var i = 0, len = tiles.length; i < len; ++i)
      {
        rects[i] = tiles[i].rect;
      }

      var result = new PageTilesManager(this.scale);
      result.init(rects);
      result.independent = false;
      return result;
    },
    free: function ()
    {
      var tiles = this.tiles;
      for (var i = 0, len = tiles.length; i < len; ++i)
      {
        tiles[i].free();
      }
      this.tiles = null;
    },
    scaleTo : function(scale)
    {
      if (this.scale !== scale && this.independent)
      {
        var old = this.scale;
        this.scale = scale;
        var tiles = this.tiles;

        var cols = {};
        var rows = {};

        for (var i = 0, len = tiles.length; i < len; ++i)
        {
          var rect = tiles[i].rect;
      
          var x = rect.x / old;
          var y = rect.y / old;
          var w = rect.w / old;
          var h = rect.h / old;

          //  console.log(rect.x, rect.y, rect.w, rect.h);
          x = x * scale;
          y = y * scale;
          w = w * scale;
          h = h * scale;
          

          cols[rect.x] = x;
          cols[rect.x+rect.w] = x+w;
          rows[rect.y] = y;
          rows[rect.y+rect.h] = y+h;
        }
        for (var i = 0, len = tiles.length; i < len; ++i)
        {
          var rect = tiles[i].rect;

          var x = cols[rect.x];
          var y = rows[rect.y];
          var w = cols[rect.x + rect.w] - x;
          var h = rows[rect.y + rect.h] - y;

          rect.x = x;
          rect.y = y;
          rect.w = w;
          rect.h = h;
          
        }

     /*   for (var i = 0, len = tiles.length; i < len; ++i)
        {
          var rect = tiles[i].rect;
          rect.x = cols[rect.x + rect.w]

          var x = rect.x / old;
          var y = rect.y / old;
          var w = rect.w / old;
          var h = rect.h / old;
          
        //  console.log(rect.x, rect.y, rect.w, rect.h);
          rect.x = (x * scale + 0.5) | 0;
          rect.y = (y * scale+0.5) | 0;
          rect.w = (w * scale+0.5) | 0;
          rect.h = (h * scale + 0.5) | 0;
          
        }*/
      }
    },
    freeNonRendered : function()
    {
      var tiles = this.tiles;
      var newTiles = [];
      for (var i = 0, len = tiles.length; i < len; ++i)
      {
        var tile = tiles[i];
        if (!tile.rendered)
        {
          tile.free();
        }
        else
        {
          newTiles.push(tile);
        }
      }
      this.tiles = tiles;
    },
    freeNotInViewport : function(viewport)
    {
      /// <param name="viewport" type="geometry.Rectangle"></param>

      var tiles = this.tiles;
      var sin = Math.sin, cos = Math.cos;
      var newTiles = [];
      for (var i = 0, len = tiles.length; i < len; ++i)
      {
        var tile = tiles[i];
        if (viewport.isIntersectedFast(tile.rect, cos, sin))
        {
          newTiles.push(tile);
        }
        else
        {
          tile.free();
        }
      }

      this.tiles = newTiles;
    },
    freeNotInViewportPreserve : function(viewport)
    {
      /// <param name="viewport" type="geometry.Rectangle"></param>

      var tiles = this.tiles;
      var sin = Math.sin, cos = Math.cos;
      for (var i = 0, len = tiles.length; i < len; ++i)
      {
        var tile = tiles[i];
        if (!viewport.isIntersectedFast(tile.rect, cos, sin))
        {
          tile.free();
        }
      }      
    },
    checkRenderingTasks: function (viewport)
    {
      var tiles = this.queryTilesForViewport(viewport, function (t) { return true; }).tiles;
            
      var hasDone = false;
      var areAllDone = true;
      for (var i = 0, len = tiles.length; i < len; ++i)
      {
        var tile = tiles[i];
        if (tile.task !== null && tile.task.done || tile.rendered)
        {
          hasDone = true;
          tile.task = null;
          tile.rendered = true;
        }
        else
        {
          areAllDone = false;
        }
      }
      
      

      if (hasDone && areAllDone)
      {
        return R_ALL_DONE;
      }
      else if (hasDone)
      {
        return R_PARTIALY_DONE;
      }
      else
      {
        return R_NONE;
      }
    },
    queryTilesForViewport: function (viewport, predicateFunct)
    {
      /// <param name="viewport" type="geometry.Rectangle"></param>
      /// <param name="predicateFunct" type="Function"></param>
      /// <returns type="Array"></returns>


      var tiles = this.tiles;
      var result = [];
      var sin = Math.sin, cos = Math.cos;
      var predResult = true;
      for (var i = 0, len = tiles === null ? 0 : tiles.length; i < len; ++i)
      {
        var t = tiles[i];
        
        
        if (viewport.isIntersectedFast(t.rect,cos,sin))
        {
          var p = predicateFunct(t);
          predResult = predResult && p;

          if (p)
          {
            result.push(t);
          }
        }
      }

      return { tiles: result, predResult: predResult };
    },
    queryNotIntersectedTilesForViewport: function (viewport, predicateFunct)
    {
      /// <param name="viewport" type="geometry.Rectangle"></param>
      /// <param name="predicateFunct" type="Function"></param>
      /// <returns type="Array" elementType="CanvasTileInfo"></returns>


      var tiles = this.tiles;
      var result = [];
      var sin = Math.sin, cos = Math.cos;
      for (var i = 0, len = tiles === null ? 0 : tiles.length; i < len; ++i)
      {
        var t = tiles[i];
        if (predicateFunct(t) && !viewport.isIntersected(t.rect))
        {
          result.push(t);
        }
      }

      return result;
    },
    queryNonRenderedAndNotAllocatedTilesForViewport: function (viewport)
    {
      /// <param name="viewport" type="geometry.Rectangle"></param>
      /// <returns type="Array" ></returns>

      return this.queryTilesForViewport(viewport, function (t) { return !t.rendered && t.canvas === null; });
    },
    queryRenderedTilesForViewport: function (viewport)
    {
      /// <param name="viewport" type="geometry.Rectangle"></param>
      /// <returns type="Array"></returns>

      return this.queryTilesForViewport(viewport, function (t) { return t.rendered; });
    }

  };




}(
vitrium.viewer,
vitrium.ui,
vitrium.geometry2,
vitrium,
vitrium.viewer,
vitrium.log,
_,
Backbone,
jQuery
));
// script:viewer/viewer.js
/// <reference path="~/build.html" />

(function (exports, ui, utils, vitrium, _, $, Backbone,  Hammer, window) {
  
  "use strict";

  var viewer = exports;
  var EventPipeGroup = vitrium.utils.EventPipeGroup;
  var $EventPipe = viewer.$EventPipe;
  var $MouseWheelEventPipe = viewer.$MouseWheelEventPipe;
  
  var STATES = viewer.STATES;
  
  var ST_NOT_READY = STATES.declare("NOT_READY");
  var ST_READY = STATES.declare("READY");
  var ST_LOCKED = STATES.declare("LOCKED");
  var ST_RENDERING_PAUSED = STATES.declare("RENDERING_PAUSED");
    
  var ResizeMode = {
    NONE : 0,
    SCALE_CONTENT : 1,
    FIXED_CONTENT: 2
  };
  
  var PageContentState = {
    LOAD_FAILED : -2,
    NOT_LOADED : 0,
    NOT_LOADED_OFFLINE: -1,
    LOAD_REQUESTED : 1,
    LOADED : 2
  };
  
  exports.ResizeMode = ResizeMode;
  exports.DocumentViewer = DocumentViewer;
  exports.PageContentState = PageContentState;
  

  DocumentViewer.prototype = _.extend(Object.create(ui.ContainerWidget.prototype),{
    initUI: initUI,
    destroy : destroy,
    attachDocument : attachDocument,
    dettachDocument : dettachDocument,
    setResizeMode : setResizeMode,
    setScale : setScale,
    limitScale : limitScale,
    translateCoordinatesToPage: translateCoordinatesToPage,
    getPageNumberByCoordinates : getPageNumberByCoordinates,
    getPageInfo : getPageInfo,
    isBellowPage : isBellowPage,
    getCurrentPage: getCurrentPage,
    getNumberOfPages: getNumberOfPages,
    scrollTo : scrollTo,
    scrollToPoint: scrollToPoint,
    //private
    setScaleInternal : setScaleInternal,
    requestPagesInViewer: requestPagesInViewer,
    forceRequestPages: onAfterViewportChange,
    refresh: function () { if (this.uiLoopContext.pages) this.forceRequestPages(this.uiLoopContext.pages);},
    changeDocumentRenderer : changeDocumentRenderer,
    pauseRendering : pauseRendering,
    resumeRendering : resumeRendering,
    setControlsLock: setControlsLock,
    initDocumentRenderer : initDocumentRenderer,
    
    onStateChanged : onStateChanged,
    tryGetThumbnail: tryGetThumbnail,
    afterFrame : afterFrame,
    beforeFrame: beforeFrame,
    getPageIteratorBetweenDU : function(start, end)
    {
      return this.documentRenderer.getPageIteratorBetweenDU(start, end);
    },
    addCanvasLayer : function(layer)
    {
      this.canvasLayers.push(layer);
      if (this.pageCanvasManager !== null)
      {
        this.pageCanvasManager.addLayer(layer);
      }
    },
    removeCanvasLayer : function(layer)
    {
        if (this.pageCanvasManager !== null)
        {
            this.pageCanvasManager.removeLayer(layer);
        }
        else
        {
            this.canvasLayers = _.without(this.canvasLayers, layer);
        }
    },
    focus : function()
    {
      this.$el.focus();
      this.broadcastEvent("viewer:focused", this);
    },
    cancelCurrentStorageAction : function()
    {
      if (this.currentStorageAction) {
        this.currentStorageAction.cancel();
        return true;
      }
      return false;
    }
  });
  
  _.extend(DocumentViewer.prototype, ui.Events);
  _.extend(DocumentViewer.prototype, vitrium.events);
  Object.defineProperties(DocumentViewer.prototype, {
    uiLoopContext: {
      get: function ()
      {
        return this.uiLoop === null ? null : this.uiLoop.context;
      }
    }
  });

  function DocumentViewer(options)
  {
    ui.ContainerWidget.call(this);
    this.layoutManager = new ui.BasicLayoutManager(this);
    var $el = this.$el = $(this.el);
    this.options = options;    
    this.uiFreePages =  new ui.UISync(_.bind(freePages, this), -5);
    
    var hammer = this.hammer = new Hammer(this.el);
    hammer.options.prevent_default = true;
    hammer.options.prevent_mouseevents = true;

    this.lockOverlay = $("<div class='vitrium-lock-overlay'>");
    this.dialogParentEl = options.dialogParentEl || this.lockOverlay;
    /*
    if (options.toolbarEl)
    {
      var toolbarHammer = new Hammer($(options.toolbarEl)[0], {stop_browser_behavior: null});
      toolbarHammer.on("doubletap", function(evt)
      {
        evt.preventDefault();
      });
    }*/
    

    this.document = null;
    this.resizeMode = _.isUndefined(options.resizeMode) ? ResizeMode.SCALE_CONTENT : options.resizeMode;
    
    this.documentRendererClass = options.documentRendererClass || vitrium.viewer.ScrollMasterDocumentRenderer; //vitrium.viewer.DesktopDocumentRenderer;
    
    this.pageRenderClass = options.pageRendererClass || vitrium.viewer.PageRenderer;
    this.releasePagesNotVisiblePages = options.releasePagesNotVisiblePages || 1;
    this.renderAhead = options.renderAhead || 1;

    this.layers = options.layers || []; // factory functions for creating new layer
        
    this.onInfoLoaded = _.bind(onInfoLoaded, this);
    this.onPageLoaded = _.bind(onPageLoaded, this);
    this.onLoadingError = _.bind(onLoadingError, this);
    this.onFontsInitialized = _.bind(function () {
       if (this.pageCanvasManager)
         this.pageCanvasManager.refresh();
    }, this);

    this.currentOverlay = null;
  
    this.onConnectionChanged = _.bind(onConnectionChanged, this);
    
    this.resizeTimer = null;
    this.scrollTimer = null;
    
    this.scale = 0.1;
    
    this.uiInitialized = false;
    this.documentInfo = null;
    
        
    this.documentRenderer = null;
    
    
    this.controlsLock = false;
    this.initialPageLoadCompleter = new vitrium.async.Completer();
  //	this.on("change:resizeMode", this.onResizeModeChanged);
    
    this.isIE9 = navigator.userAgent.indexOf("MSIE 9.0") !== -1;
    this.isIOSMobile = navigator.userAgent.indexOf("iPhone") !== -1 || navigator.userAgent.indexOf("iPod") !== -1;
        
    this.maxScale = 0;
    this.online = true;
    
    this.state = new vitrium.State(viewer.STATES);
    vitrium.utils.pipeEvents(this.state, "change", this, "change:state");
    this.state.push(ST_NOT_READY);
    
    this.on("change:state", _.bind(this.onStateChanged, this));
    
    var $documentEl = $(window.document);
    this.eventPipes = new EventPipeGroup([
      new $EventPipe($el, "mousedown mouseleave click dblclick keydown keyup keypress focus focusout", this),
      new $MouseWheelEventPipe($el, this),
      new $EventPipe($documentEl, "mousemove mouseup", this),
      new $EventPipe(this.hammer, "ftouchstart ftouchend ftouchmove touch transformstart transform transformend rotate pinch pinchin pinchout tap touchmove doubletap dragstart drag dragend release hold", this)
    ]);
      
    this.pageCanvasManager = null;
    this.lastPagesStart = -1;
    this.lastPagesEnd = -1;
    
    this.freePagesIntervals = null;

    this.pageUnderMouse = null;
    
    
  
    this.canvasLayers = [];
    
    this.pagesRequestedDuringLock = 0;
    //this.renderingPaused = false;
    
    var autofocus = _.bind(function(evt, state){
      if (state.current() === ST_READY)
      {
        this.focus();
      }
    }, this);
    this.on("mousedown" , autofocus).on("tap", autofocus);
    $el.on("contextmenu", function(evt) {evt.preventDefault(); return false;});

     this.currentStorageAction = null;
     
     this.onAfterViewportChange = new ui.DelayTask(_.bind(onAfterViewportChange, this), options.renderDelay || 250, true);
     this.on("change:viewport", onViewportChanged, this);
     this.renderingPaused = false;

     this.events.on("action:openBookmark", openBookmark);
  }
  
    
  function onStateChanged(state, stateHolder)
  {
    if (stateHolder.has(ST_READY)) 
    {
      this.eventPipes.on();
      this.$el.attr("tabindex", "0");
      this.$el.focus();
    }
    else
    {
      this.eventPipes.off();
      this.$el.removeAttr("tabindex");
    }
        
    vitrium.log.debug("[state] "+ viewer.STATES.name(state));
  }	
  
  function setControlsLock(lock)
  {
    var current = this.state.current();
    if (lock && current !== ST_LOCKED)
    {
      this.lockOverlay.appendTo('body');
      this.hammer.options.prevent_default = false;
      this.hammer.options.prevent_mouseevents = false;

      this.state.push(ST_LOCKED);
      $('body').addClass("vitrium-locked");
    }
    else if ((!lock  && current === ST_LOCKED )|| (this.controlsLock && !lock))
    {		
      this.hammer.options.prevent_default = true;
      this.hammer.options.prevent_mouseevents = true;

      this.lockOverlay.remove();
      $('body').removeClass("vitrium-locked");
      if (current === ST_LOCKED)
      {
        this.broadcastEvent("RefreshLayout");
        this.state.pop();
      }
    }
    
    this.setProperty("controlsLock", lock);
  }
  
  function initUI()
  {
    this.$el.addClass("vitrium-document-viewer");			
    if (!vitrium.is_mobile)
    {
      this.$el.addClass("desktop");
    }
    this.$el.removeAttr("tabindex");
    
    this.uiInitialized = true;
    
    this.trigger("ui:initialized", this.$el, this);
  }
    
  function destroy()
  {
    if (this.parent !== null)
    {
      this.parent.remove(this);
    }

    this.dettachDocument();
    this.eventPipes.destroy();
    this.trigger("viewer:destroyed", this.$el, this);
    this.off();
  }
  
  function attachDocument(document)
  {
    if (!this.uiInitialized)
    {
      throw new Error("Error: you have to call initUI method first!");
    }
  
    if (this.document)
    {
      this.dettachDocument();
    }
    else if (this.documentRenderer)
    {
      this.remove(this.documentRenderer);
      this.documentRenderer.destroy();
            
      this.documentRenderer = null;
    }
    
    this.freePagesIntervals = new utils.IntIntervalGroup();
    
    document.on("info:loaded", this.onInfoLoaded);
    document.on("page-fonts:initialized", this.onFontsInitialized);
    document.on("page:loaded", this.onPageLoaded);
    document.on("loading:error", this.onLoadingError);
    document.on("connection:changed", this.onConnectionChanged);
    
    this.document = document;
    
    this.initDocumentRenderer();
    
    
    var self = this;
    document.on("page:loaded", function onTime() {
       self.initialPageLoadCompleter.complete();
       document.off("page:loaded", onTime);
    });
    
    this.trigger("document:attached", document, this);
  }
  
  function initDocumentRenderer()
  {
    this.documentRenderer = new this.documentRendererClass(this, this.options);
    this.layoutManager.center = this.prepend(this.documentRenderer);
    //this.documentRenderer = new vitrium.viewer.OnePageDocumentRenderer(this, this.options);
    
    this.trigger("change:controlsLock", this.controlsLock);
  }
  
  function dettachDocument()
  {		
    this.state.reset(ST_NOT_READY);
    
    var document = this.document;
    if (document)
    {
      document.off("info:loaded", this.onInfoLoaded);
      document.off("page-fonts:initialized", this.onFontsInitialized);
      document.off("page:loaded", this.onPageLoaded);
      document.off("loading:error", this.onLoadingError);
      document.off("connection:changed", this.onConnectionChanged);
     
      this.document = null;

      this.trigger("document:detached", document, this);
      this.initialPageLoadCompleter = new vitrium.async.Completer();
    }

    if (this.pageCanvasManager) 
    {
      this.pageCanvasManager.destroy();
      this.pageCanvasManager = null;
    }
    
    if (this.documentRenderer)
    {
      this.remove(this.documentRenderer);
      this.documentRenderer.destroy();
      this.documentRenderer = null;
    }
  
    
    if (this.documentInfo && this.documentInfo.pages)
    {
      var pagesInfo = this.documentInfo.pages;
      for (var i = 0,len=pagesInfo.length; i< len; ++i)
      {
        var p = pagesInfo[i];
        if (p.renderer)
        {
          p.renderer.releaseMemory();
        }
      }
      this.documentInfo = null;
    }
    
    this.freePagesIntervals = null;
    this.lastPagesStart = -1;
    this.lastPagesEnd = -1;
    //TODO support multiple documents on one page
    vitrium.fonts.free();
  }
  
  function changeDocumentRenderer(documentRendererClass)
  {
    if (documentRendererClass !== this.documentRendererClass)
    {
      this.documentRendererClass = documentRendererClass;
      var documentRenderer = this.documentRenderer;
      if (documentRenderer !== null)
      {
        var currentPage = null;
        var pages =  null;
        var documentInfo = this.documentInfo;
        
        if (documentInfo)
        {
          if (!_.isEmpty(documentInfo.pages))
          {
            pages = documentInfo.pages;
            currentPage = documentRenderer.getCurrentPage();
          }
        }
        
        this.remove(documentRenderer);
        documentRenderer.destroy();
        

        this.documentRenderer = documentRenderer = new documentRendererClass(this, this.options);
        this.layoutManager.center = this.prepend(documentRenderer);
        /*if (!documentRenderer.freePageEl)
        {
          documentRenderer.freePageEl = function(){};
        }*/
        documentRenderer.setPages(pages);
        setScaleInternal.call(this, documentRenderer.computeScale());
        
        if (currentPage !== null)
        {
          documentRenderer.scrollTo(currentPage);
        }
      }
    
    }
  
  }
  
  
  function onInfoLoaded(info)
  {
    this.documentInfo = info;	
    
    var pages = info.pages;
    this.pageCanvasManager = new viewer.PageCanvasManager(this.uiLoop,pages, this.canvasLayers, _.bind(this.tryGetThumbnail, this), this.document.fontsManager);
    

    this.maxScale = 4.0;
    info.maxScale = this.maxScale;
    
    var renderer = this.documentRenderer;
    renderer.setPages(pages);
    setScaleInternal.call(this, renderer.computeScale());
        
    vitrium.log.debug("info loaded");
    this.trigger("change:pageCount", pages.length);
    this.trigger("change:currentPage", 0);
    this.trigger("document:info-loaded");

    this.state.changeState(ST_NOT_READY, ST_READY);
  }
    
  function getPageInfo(idx)
  {
    var docInfo = this.documentInfo;
    var pageInfo = docInfo.pages[idx];
    
    return pageInfo;
  }
  var isIE9 = navigator.userAgent.indexOf("MSIE 9.0") !== -1;
  
  function onPageLoaded(idx, page, status)
  {
    var docInfo = this.documentInfo;
    var pageInfo = docInfo.pages[idx];
    var pageCanvasContext = this.pageCanvasManager.getPage(idx);
    
    if (pageCanvasContext.contentState === PageContentState.LOAD_REQUESTED || 
        pageCanvasContext.status <= status)
    {
      if (status === 2)
      {
        pageCanvasContext.thumbnail = page;	
        vitrium.log.debug("thumb loaded:" + idx);

        // just push thumbnail into view
        this.pageCanvasManager.broadcastContentChanged();
      }
      else
      {        
        pageCanvasContext.data = page;
        vitrium.log.debug("page data loaded:" + idx);
        // request page content rendering
        this.pageCanvasManager.refresh();
/*          pageCanvasContext.renderer.renderPage(canvas, scale, pageInfo, page, docInfo, status, this.pageLOADED);*/
      }
      
      pageCanvasContext.contentState = PageContentState.LOADED;
      pageCanvasContext.status = status;
      
    }
  }
  
  function tryGetThumbnail(idx)
  {
    return this.document.fileProvider().tryGetThumbnail(idx);
  }
  
  /*function pageLOADED(idx, status, canvas)
  {
    this.trigger("page-render:end", idx, status, canvas);			
    var pageCanvasContext = this.pageCanvasManager.getPage(idx);
    pageCanvasContext.onOffscreenRenderingDone();
    this.documentRenderer.refresh();
    
    vitrium.log.debug("page LOADED:"+idx);
    
  }	*/
  
  function onLoadingError(className, name)
  {
    
    if (className === 0)
    {
      var pageIdx = name;		
      var pageCanvasContext = this.pageCanvasManager.getPage(pageIdx);
      if (this.online)
      {
        pageCanvasContext.contentState = PageContentState.LOAD_FAILED;
      }
      else
      {
        pageCanvasContext.contentState = PageContentState.NOT_LOADED_OFFLINE;
      }
    
      // this displays an error message
      pageCanvasContext.data = {};
      this.pageCanvasManager.refresh();

      vitrium.log.error("page load failed:"+pageIdx);
      // TODO render loading error on that page
    }
  
  }
  
  function validateOptions(options)
  {
    if (!_.isObject(options))
    {
      throw new Error("Error: options must be an object");
    }
  
    if (!options.$el)
    {
      throw new Error("Error: $el must be specified!");
    }
    
  }
  
  function setResizeMode (resizeMode)
  {
    if (resizeMode < ResizeMode.NONE || resizeMode > ResizeMode.FIXED_CONTENT)
    {
      throw new Error("Error: resizeMode  must be value from vitrium.viewer.ResizeMode (NONE, SCALE_CONTENT, FIXED_CONTENT)");
    }
    
    this.setProperty("resizeMode", resizeMode);
    this.documentRenderer.dim = this.documentRenderer.dim;
   // this.documentRenderer.onResize();
  }
  
  function setScale(scale)
  {
    this.trigger("manualscale:begin");
    var oldScale = setScaleInternal.call(this, scale);
    this.documentRenderer.setScale(this.scale, oldScale);
    
   
    this.setResizeMode(ResizeMode.FIXED_CONTENT);
    
    this.trigger("manualscale:end");
  }
  
    function setScaleInternal(scale)
  {
    if (_.isNumber(scale))
    {
      var result = this.scale;
      scale = this.limitScale(scale);
      
      this.setProperty("scale", scale);
      
      var pageContexts = this.pageCanvasManager.pages;
      
      if (pageContexts && pageContexts.length > 0)
      {
        for (var i = Math.max(this.lastPagesStart,0), end =this.lastPagesEnd, len=pageContexts.length;  i < len && i <= end;++i)
        {
          pageContexts[i].contentState = PageContentState.NOT_LOADED;
        }
      }
      
      return result ;
    }
    else
    {
      throw new Error("Error: scale must be a number");
    }	
  }
  
  function limitScale(scale)
  {
    return Math.max(Math.min(scale, this.maxScale), 0.1);
  }
  

  function translateCoordinatesToPage(coordinates, pageNumber)
  {
    return this.documentRenderer.translateCoordinatesToPage(coordinates, pageNumber);
  }
  
  //TODO this method should be moved to desktop-browser-document-renderer
  function getPageNumberByCoordinates(x, y)
  {
    return this.documentRenderer.getPageNumberByCoordinates(x, y,1);
  }
  
  function scrollTo(pageIdx)
  {
    this.documentRenderer.scrollTo(Math.min(pageIdx, this.documentInfo.pages.length-1));
  }
  
  function scrollToPoint(pageIdx, point, op)
  {
    this.documentRenderer.scrollToPoint(Math.min(pageIdx, this.documentInfo.pages.length-1), point, op);
  }
  
  
  function getNumberOfPages()
  {
    return this.documentInfo.pages.length;
  }
  
  function getCurrentPage()
  {
    return this.documentRenderer.getCurrentPage();
  }
  
  function isBellowPage(pageIdx, point)
  {
    return this.documentRenderer.isBellowPage(pageIdx, point);
  }
  
  function onConnectionChanged(online)
  {
    var old = this.online;
    this.online = online;
    
    if (online && !old)
    {
      if (this.documentInfo !== null)
      {
        var self = this;
      
        setTimeout(function()
        {
          if (self.uiLoopContext && self.uiLoopContext.pages)
          {
            self.requestPagesInViewer(self.uiLoopContext.pages);
          }
        }, 1000);
      }
      else if (this.document !== null)
      {
        this.document.load();
      }
      
    }
  }

  function onViewportChanged(forceRendering, pagesInViewport)
  {
    this.pauseRendering();
    if (forceRendering)
    {
      this.pageCanvasManager.refreshAll();
    }
    else
    {
      this.pageCanvasManager.refresh();
    }

    this.onAfterViewportChange.execute(pagesInViewport);
  }

  function onAfterViewportChange(pagesInViewport)
  {
    this.resumeRendering();
    this.requestPagesInViewer(pagesInViewport);
    
    this.trigger("viewport:done");
  }
  
  function requestPagesInViewer(pagesInViewport)
  {		
    var documentRenderer = this.documentRenderer;
  //	var pages = documentRenderer.viewportPages();
    
    var pageCanvasManager = this.pageCanvasManager;
    var pageContexts = pageCanvasManager.pages;
    var pageCount = pageContexts.length;

    var PageRenderer = this.pageRenderClass;

    
    
    var lowerBound = pageCount -1;
    var upperBound = 0;
  
    
    var doc = this.document;
    var fileProvider = doc.fileProvider();
    
    var layers = this.layers;
    
    
    var self = this;
    var online = this.online;
    
    // to ensure that second page will be loaded as well
    /*if (pages.length === 1 && pages[0] === 0 && pageCount > 1)
    {
      pages.push(1);
    }*/

    for (var i = 0, len = pagesInViewport.length; i < len; ++i)
    {
      var reqIdx = pagesInViewport[i].number;
        
      lowerBound = Math.min(reqIdx, lowerBound);
      upperBound = Math.max(reqIdx, upperBound);
      
      var pageContext = pageContexts[reqIdx];
      var state = pageContext.contentState;
      if (state == PageContentState.NOT_LOADED || (state == PageContentState.NOT_LOADED_OFFLINE && online) || state == PageContentState.LOAD_FAILED)
      {
        var renderer = pageContext.renderer || (pageContext.renderer = new PageRenderer(doc, fileProvider, layers));
        
        if (state == PageContentState.LOAD_FAILED)
        {
          pageContext.free();
        }

        pageContext.contentState = PageContentState.LOAD_REQUESTED;
        
                    
        self.trigger("page:requested", reqIdx);
        doc.requestPage(reqIdx);				
        
        vitrium.log.debug("request loading: "+reqIdx);				
      }
    }
    
    
    if (lowerBound !== 0) lowerBound -= this.releasePagesNotVisiblePages;
    if (upperBound < pageCount-1) upperBound += this.releasePagesNotVisiblePages;
    
    
    var lastPagesStart = this.lastPagesStart; 
    var lastPagesEnd = this.lastPagesEnd;
    // free not visible pages
    if (lastPagesEnd !== -1 && (lastPagesStart !== lowerBound || lastPagesEnd !== upperBound))
    {	
      //<lastPagesStart, lastPagesEnd> - (lowerBound-1,upperBound+1)
      var toFreeIntervals = utils.intSubstract1D(lastPagesStart, lastPagesEnd, lowerBound-1,upperBound+1);
      var freePagesIntervals = this.freePagesIntervals;
      var len = toFreeIntervals ? toFreeIntervals.length : 0;
      for (var i = 0 ; i < len;++i)
      {
        freePagesIntervals.addInterval(toFreeIntervals[i]);
      }
    
      if (len > 0)
      {
        this.uiLoop.runAsync(this.uiFreePages);
      }
    //		vitrium.log.debug("pages to release: i<"+lowerBound+" ||  i > "+upperBound);
    //		this.document.freePageRange(lastPagesStart, lastPagesEnd, lowerBound, upperBound, pageCount);
    //		this.pageCanvasManager.freePageRange(lowerBound, upperBound);
    }
    
    this.lastPagesStart = lowerBound; 
    this.lastPagesEnd = upperBound;
    //this.trigger("page-render:freed", lowerBound, upperBound);
  }
  
  function freePages()
  {
    var freePagesIntervals = this.freePagesIntervals;
    
    freePagesIntervals.substract(this.lastPagesStart-1, this.lastPagesEnd+1);
    freePagesIntervals.compact();
    
    var intervals = freePagesIntervals.intervals;
    var document = this.document;
    var pageManager = this.pageCanvasManager;
    
    for (var i = 0, len = intervals.length; i < len;++i)
    {
      var interval = intervals[i];
      var s = interval.start;
      var e = interval.end;
      vitrium.log.debug("freeing pages:"+ interval.toString());
      document.freePageRange(s, e);
      pageManager.freePageRange(s, e);
    }		
    
    intervals.length = 0;
  }
  
  function pauseRendering()
  {		
    if (this.pageCanvasManager !== null) this.pageCanvasManager.pause();
    this.renderingPaused = true;
  }
  
  function resumeRendering()
  {
    if (this.pageCanvasManager !== null) this.pageCanvasManager.resume();
    this.renderingPaused = false;
  }
  
  function afterFrame(callback)
  {
    this.documentRenderer.afterFrame(callback);
  }
  
  function beforeFrame(callback)
  {
    this.documentRenderer.beforeFrame(callback);
  }
  
  
  function noop(){}
  
  function openBookmark(bookmark)
  {
    var operation = bookmark.Operation;
    if ("PageIdx" in operation)
    
    {
      var p = new vitrium.geometry.Point(operation.X, operation.Y);
      //TODO implement that according the specification
      if (!p.x) p.x = 0;
      if (!p.y) p.y = 0;


      this.scrollToPoint(operation.PageIdx, p, "top");
    }
    else if (operation.Type === "URI")
    {
      viewer.openLink(operation.Uri);
    }
  }
}(
vitrium.viewer, 
vitrium.ui,
vitrium.utils, 
vitrium, 
_, 
jQuery, 
Backbone,
Hammer,
__globals__
));
// script:viewer/page-saver.js
/// <reference path="~/build.html" />

(function (exports, log, _) {
   "use strict";

   exports.PageSaver = PageSaver;

   function PageSaver(viewer)
   {
      this._viewer = viewer;
      this._document = null;
      viewer.on("document:attached", this.onDocumentAttached, this);
      viewer.on("document:detached", this.onDocumentDettached, this);
      viewer.on("viewport:done", this.onPageChanged, this);
   }

   PageSaver.prototype.onDocumentAttached = function (doc) {
      this._document = doc;
      doc.on("info:loaded", this.onInfoLoaded, this);

   };

   PageSaver.prototype.onDocumentDettached = function (doc) {
      this._document.off("info:loaded", this.onInfoLoaded, this);
      this._document = null;
   };

   PageSaver.prototype.onInfoLoaded = function () {
      var self = this;
      this._document.context.openStorage().then(function (storage) {

         storage.loadInfo("||last-position||", function(info)
         {
            //log.debug("[PageSaver] info loaded", info);
            if (info && _.isNumber(info.position))
            {
               self._viewer.documentRenderer.setVScrollPos(info.position * self._viewer.scale);
            }
         });
      });
   };

   PageSaver.prototype.onPageChanged = function ()
   {
      if (this._document)
      {
         this._document.context.openStorage().then(_.bind(function (storage) {
            //log.debug("[PageSaver] info save");

            storage.storeInfo("||last-position||", {
               page: this._viewer.getCurrentPage(),
               position: this._viewer.documentRenderer.getDUViewportState().scrollY
            });
         }, this));
      }
   };

}
(vitrium.viewer,
vitrium.log,
_));

// script:viewer/dom-events/touch-scroll.js
/// <reference path="~/build.html" />

(function (exports, viewer, geometry, ui, _, globals)
{
	"use strict";
	exports["TouchScroll"] = TouchScroll;
	
	var STATES = viewer.STATES;
	var ST_READY = STATES.get("READY");
	var ST_TOUCH_SCROLL = STATES.declare("TOUCH_SCROLL");
	
	var isPerformanceNow = !!(globals.performance && globals.performance.now);
	function now()
	{
		if (isPerformanceNow)
		{
			return performance.now();
		}
		else
		{
			return Date.now();
		}
	}
	
	function TouchScroll(viewer)
	{
		this.viewer = viewer;
		
		viewer.on("dragstart", this.onDragStart, this)
				 .on("drag", this.onDrag, this)
				 .on("dragend", this.onDragEnd, this)
				 .on("touch", this.onTouch, this);
		
		this.documentRenderer = null;
		this.dragStart = new geometry.Point(0,0);
		this.currentPos = new geometry.Point(0,0);
		
		this.scroller = new ui.KineticScroller(1/ui.CANVAS_POOL.GLOBAL_PIXEL_RATIO, 0.2,  null, _.bind(this.getCurrentTime, this));
		this.velocityTracker = new ui.VelocityTracker();
		
		this.performScrolling = new ui.UISync(this.onPerformScrolling, this, -11);
		
		this.animationStart = 0;
		this.dragEnd = false;
		this.lastDeltaX = 0;
		this.lastDeltaY = 0;
	}
	
	TouchScroll.prototype = {
	  refresh : function()
	  {
	    this.viewer.uiLoop.runAsync(this.performScrolling);
	  },
		onTouch : function(evt, state)
		{
			if (state.current() === ST_TOUCH_SCROLL)
			{
			//	console.log("onTouch");
				if (!this.scroller.mFinished) this.scroller.abortAnimation();
 				this.dragEnd = false;
				state.pop();
			}
		},
		onDragStart : function(evt, state)
		{
			if (state.current() === ST_READY && evt.gesture.pointerType !== "mouse")
			{
				this.dragEnd = false;
				state.push(ST_TOUCH_SCROLL);
				
				this.animationStart = now();
				var dr = this.documentRenderer = this.viewer.documentRenderer;
				dr.fillScrollPosition(this.dragStart);
				this.lastDeltaX = 0;
				this.lastDeltaY = 0;
			}
		},
		onDragEnd : function(evt, state)
		{
			if (state.current() === ST_TOUCH_SCROLL)
			{
				var dr =this.documentRenderer;
				var ds = dr.fillScrollPosition(this.currentPos);
				var gevt = evt.gesture;		
			//	var dir = gevt.direction;
				var viewport = dr.scrollableViewport.viewport;
	
				var vt = this.velocityTracker;
        vt.addMovement(gevt.center.pageX, gevt.center.pageY, now());

				vt.computeCurrentVelocity(1000, 5000);

				var dir = this.velocityTracker.computeDirection();//gevt.direction;
				if (dir !== null)
				{
				  if (dir === ui.DIRECTION_VERTICAL)
					{
            //console.log(vt.mYVelocity);
						this.scroller.fling(ds.x, ds.y, 0, -vt.mYVelocity, 0, viewport.contentWidth, 0, viewport.contentHeight);
					}
					else
					{
						this.scroller.fling(ds.x, ds.y, -vt.mXVelocity, 0,0, viewport.contentWidth, 0, viewport.contentHeight);
					}
				}
				else
				{
					this.scroller.fling(ds.x, ds.y, -vt.mXVelocity, -vt.mYVelocity, 0, viewport.contentWidth, 0, viewport.contentHeight);
				}			
        this.dragEnd = true;
      //  console.log("dragEnd=true");
			//	console.log(vt.mXVelocity, vt.mYVelocity);
        this.refresh();			
			}
		},
		onDrag : function(evt, state)
		{
			if (state.current() === ST_TOUCH_SCROLL)
			{
				
				
				var ds = this.dragStart;
				var dr =this.documentRenderer;
				
				var gevt = evt.gesture;		
				this.velocityTracker.addMovement(gevt.center.pageX, gevt.center.pageY, now());
				
				gevt.preventDefault();
			
        
				var dir = this.velocityTracker.computeDirection();//gevt.direction;


				
			//	console.log(dir);
				if (dir !== null)
				{
					if (dir === ui.DIRECTION_HORIZONTAL)
					{
					  this.scroller.startScroll(ds.x, ds.y, -gevt.deltaX, -this.lastDeltaY);
					  this.lastDeltaX = gevt.deltaX;
					  
					}
					else
					{
					  this.scroller.startScroll(ds.x, ds.y, -this.lastDeltaX, -gevt.deltaY);
					  this.lastDeltaY = gevt.deltaY;
					}
				}
				else
				{
				  this.scroller.startScroll(ds.x, ds.y, -gevt.deltaX, -gevt.deltaY);
				  this.lastDeltaX = gevt.deltaX;
          this.lastDeltaY = gevt.deltaY;
				}

				//dr.setScrollPosition(pos);
				
				this.refresh();
				
			}
		},
		onPerformScrolling : function(context, time)
		{
			var scroller = this.scroller;
			if (!scroller.mFinished)
			{
				var more = scroller.computeScrollOffset();
				var pos = this.currentPos;
				pos.x = scroller.mCurrX;
				pos.y = scroller.mCurrY;
				
			//	console.log(more, pos.y);
				var dr = this.documentRenderer;
				dr.setScrollPosition(pos);
				
				if (more)
				{
				  this.refresh();
				}
				
				if (this.dragEnd)
				{
					this.viewer.state.pop();
					this.dragEnd = false;
       //   console.log("dragEnd=false");
				}
			}
			else if (this.dragEnd)
			{
				this.viewer.state.pop();
				this.dragEnd = false;
  //      console.log("dragEnd=false");
			}
		},
		getCurrentTime : function()
		{
			if (this.animationStart > 0)
			{
				var tmp =this.animationStart;
				this.animationStart = 0;
				return tmp;
			}
			else
			{
			  return this.viewer.uiLoop.lastFrameTime();
			}
		}
	};

}(
vitrium.viewer.events,
vitrium.viewer, 
vitrium.geometry, 
vitrium.ui, 
_,
__globals__
));



// script:viewer/dom-events/mouse-wheel-scroll.js
(function (exports, viewer, _)
{
	"use strict";
	exports["MouseWheelScroll"] = MouseWheelScroll;
	
	var STATES = viewer.STATES;
	var ST_READY = STATES.get("READY");
	
	function MouseWheelScroll(viewer)
	{
		this.viewer = viewer;
		viewer.on("mousewheel", this.onMouseWheel, this);
	}
	
	MouseWheelScroll.prototype = {
		onMouseWheel : function(evt, delta, deltaX, deltaY, state)
		{
			if (state.current() === ST_READY)
			{
				this.viewer.documentRenderer.scrollByStep(deltaX, deltaY);
				
				evt.preventDefault();
			}
		}
	};

}(
vitrium.viewer.events,
vitrium.viewer, 
_
));
// script:viewer/dom-events/mouse-scrollbar.js
(function (exports, viewer, ui, geometry, _)
{
	"use strict";
	exports["MouseScrollbar"] = MouseScrollbar;
	
	var STATES = viewer.STATES;
	var ST_READY = STATES.get("READY");
	var ST_MOUSE_SCROLLBAR = STATES.declare("MOUSE_SCROLLBAR");
	var ST_MOUSE_SCROLLBAR_AUTO = STATES.declare("MOUSE_SCROLLBAR_AUTO");
	var SCROLLBAR_MOUSE_TOLERANCE = 1;
	var Point = geometry["Point"];
	
	var SB_VERTICAL = 1;
	var SB_HORIZONTAL = 2;
	var SB_NONE = 0;
	
	function MouseScrollbar(viewer)
	{
		this.viewer = viewer;
		
		viewer
				 .on("mousedown", this.onMouseDown, this)
				 .on("mouseup", this.onMouseUp, this)
				 .on("mousemove", this.onMouseMove, this);
		
		this.documentRenderer = null;
		this.handle  = SB_NONE;
		this.dragStartValue = null;
		this.startPosition = null;
		
		this.mousePosition = new Point(0,0);
		this.performScroll = new ui.UISync(this.onPerformScroll, this, -11);
		
		this.startTime = 0;
		this.lastScrollTime = 0;
		this.timer = 0;
		this.startDirection = 0;
	}
	
	MouseScrollbar.prototype = {
		onMouseDown : function(evt, state)
		{
			if (state.current() === ST_READY)
			{
			  var dr = this.documentRenderer = this.viewer.documentRenderer;
			  var uiLoop = this.viewer.uiLoop;
				var handle = this.handle = dr.getScrollbarHandle(evt.pageX, evt.pageY, SCROLLBAR_MOUSE_TOLERANCE);
				this.dragStartValue =  dr.getScrollHandlePos(handle);
				
				
				if (handle === SB_NONE)
				{
					var handle = this.handle = dr.getScrollbarArea(evt.pageX, evt.pageY, SCROLLBAR_MOUSE_TOLERANCE);
					if (handle !== SB_NONE)
					{
						state.push(ST_MOUSE_SCROLLBAR_AUTO);
						
						this.lastScrollTime = 0;
						this.startTime = Date.now();
						
						var p = this.mousePosition ;
						p.x = evt.pageX;
						p.y = evt.pageY;
						
						this.startDirection = dr.getDirectionFromScrollbarHandle(handle, p.x, p.y);
						clearTimeout(this.timer);
						this.timer = setTimeout(_.bind(function(){
							uiLoop.runAsync(this.performScroll);
						}, this), 250);
					}
				}
				else
				{
					state.push(ST_MOUSE_SCROLLBAR);
				}
				
				if (handle === SB_VERTICAL)
				{
					this.startPosition = evt.pageY;
					evt.preventDefault();
				}		
				else if (handle === SB_HORIZONTAL)
				{
					this.startPosition = evt.pageX;
					evt.preventDefault();	
				}	
			}
		},
		onMouseUp : function(evt, state)
		{
			var current = state.current();
			if (current === ST_MOUSE_SCROLLBAR)
			{
				evt.preventDefault();
				this.handle = SB_NONE;
				state.pop();
			}
			else if (current === ST_MOUSE_SCROLLBAR_AUTO)
			{	
				state.pop();
				if (Date.now() -this.startTime< 500)
				{
					clearTimeout(this.timer);
					this.timer = 0;
					
					var dr = this.viewer.documentRenderer;
					
					var p = dr.tmpPoint;
					p.x = evt.pageX;
					p.y = evt.pageY;
					
					dr.translateToViewportFill(p, p);
					var area = dr.getScrollbarArea(evt.pageX, evt.pageY, SCROLLBAR_MOUSE_TOLERANCE);
					
					if (area === SB_VERTICAL)
					{
						dr.setVHandlePos(p.y);	
						evt.preventDefault();					
					}
					else if (area === SB_HORIZONTAL)
					{
						dr.setHHandlePos(p.x);	
						evt.preventDefault();
					}
				}
			}
		},
		onMouseMove : function(evt, state)
		{
			var current = state.current();
			if (current === ST_MOUSE_SCROLLBAR)
			{
				evt.preventDefault();
				
				if (this.handle === SB_VERTICAL)
				{		
					var scrollPos = this.dragStartValue +  evt.pageY -this.startPosition;
					this.documentRenderer.setVHandlePos(scrollPos);			
				}
				else
				{
					var scrollPos = this.dragStartValue + evt.pageX -this.startPosition;
					this.documentRenderer.setHHandlePos(scrollPos);					
				}
			}
			else if (current === ST_MOUSE_SCROLLBAR_AUTO)
			{
				evt.preventDefault();	
				var p = this.mousePosition ;
				p.x = evt.pageX;
				p.y = evt.pageY;
			}
		},
		onPerformScroll: function MouseScrollbar__onPerformScroll(context, time)
		{
			var current = this.viewer.state.current();
			if (current === ST_MOUSE_SCROLLBAR_AUTO)
			{
				var dr = this.viewer.documentRenderer;
				var uiLoop = this.viewer.uiLoop;

				var p = this.mousePosition;
				var direction = dr.getDirectionFromScrollbarHandle(this.handle, p.x, p.y);
				var timeDiff = (time - this.lastScrollTime);
				if (direction === 0)
				{
					this.viewer.state.pop();
				}
				else if (
					(this.lastScrollTime === 0 || timeDiff > 50) && 
					this.startDirection === direction && 
					dr.getScrollbarArea(p.x,p.y, SCROLLBAR_MOUSE_TOLERANCE) === this.handle)
				{


					dr.scrollViewportPage(direction);
					this.lastScrollTime = time;
				}
				
				uiLoop.runAsync(this.performScroll);
			}
		}
	};

}(
vitrium.viewer.events,
vitrium.viewer,
vitrium.ui,
vitrium.geometry, 
_
));
// script:viewer/dom-events/touch-scrollbar.js
(function (exports, viewer, _)
{
	"use strict";
	exports["TouchScrollbar"] = TouchScrollbar;
	
	var STATES = viewer.STATES;
	var ST_READY = STATES.get("READY");
	var ST_TOUCH_SCROLLBAR = STATES.declare("TOUCH_SCROLLBAR");
	var SCROLLBAR_TOUCH_TOLERANCE = TouchScrollbar["SCROLLBAR_TOUCH_TOLERANCE"]  = 30;
	
	var SB_VERTICAL = 1;
	var SB_HORIZONTAL = 2;
	var SB_NONE = 0;
	
	function TouchScrollbar(viewer)
	{
		this.viewer = viewer;
		
		viewer.on("dragstart", this.onDragStart, this)
				 .on("drag", this.onDrag, this)
				 .on("dragend", this.onDragEnd, this)
				 .on("tap", this.onTap, this);
		
		this.documentRenderer = null;
		this.handle  = SB_NONE;
		this.dragStartValue = null;

	}
	
	TouchScrollbar.prototype = {
		onDragStart : function(evt, state)
		{
			if (state.current() === ST_READY && evt.gesture.pointerType !== "mouse")
			{
			
				var gevt = evt.gesture;
				var center = gevt.center;
				var dr = this.documentRenderer = this.viewer.documentRenderer;
				//console.log(center.pageX, center.pageY);
				var handle = this.handle = dr.getScrollbarHandle(center.pageX, center.pageY, SCROLLBAR_TOUCH_TOLERANCE);
				this.dragStartValue =  dr.getScrollHandlePos(handle);
				
				switch(handle)
				{
					case SB_VERTICAL:
						
						state.push(ST_TOUCH_SCROLLBAR);
					break;
					case SB_HORIZONTAL:
						
						state.push(ST_TOUCH_SCROLLBAR);
					break;
					default:	break;				
				}
			}
		},
		onDragEnd : function(evt, state)
		{
			var current = state.current();
			if (current === ST_TOUCH_SCROLLBAR)
			{
				this.handle = SB_NONE;
				state.pop();
			}
		},
		onDrag : function(evt, state)
		{
			var current = state.current();
			if (current === ST_TOUCH_SCROLLBAR)
			{
				var gevt = evt.gesture;
				gevt.preventDefault();
				
				if (this.handle === SB_VERTICAL)
				{		
					this.documentRenderer.setVHandlePos(this.dragStartValue + gevt.deltaY);					
				}
				else
				{
					this.documentRenderer.setHHandlePos(this.dragStartValue + gevt.deltaX);					
				}
			}
		},
		onTap : function(evt, state)
		{
			if (state.current() === ST_READY)
			{	
				var gevt = evt.gesture;
				var touch = evt.gesture.touches[0];
				
				var dr = this.viewer.documentRenderer;
				if (dr.getScrollbarArea(touch.pageX, touch.pageY, SCROLLBAR_TOUCH_TOLERANCE) === SB_VERTICAL)
				{
					
					var p = dr.tmpPoint;
					p.x = touch.pageX;
					p.y = touch.pageY;
					
					dr.translateToViewportFill(p, p);
					
					dr.setVHandlePos(p.y);	
					gevt.preventDefault();					
				}
			}
		}
	};

}(
vitrium.viewer.events,
vitrium.viewer, 
_
));
// script:viewer/dom-events/key-scroll.js
(function (exports, viewer, _)
{
	"use strict";
	exports["KeyScroll"] = KeyScroll;
	
	var STATES = viewer.STATES;
	var ST_READY = STATES.get("READY");
	
	function KeyScroll(viewer)
	{
		this.viewer = viewer;
		viewer.on("keydown", this.onKeyDown, this);
	}
	
	KeyScroll.prototype = {
		onKeyDown : function(evt, state)
		{
			if (state.current() === ST_READY)
			{
				
				var dr = this.viewer.documentRenderer;
				var handled = false;
				switch(evt.which)
				{
					case 34: //page down
						dr.scrollViewportPage(1);
					handled = true;
					break;
					case 33: //page up
						dr.scrollViewportPage(-1);
					handled = true;
					break;
					case 38:
						dr.scrollByStep(0,1);
					handled = true;
					break;
					case 40:
						dr.scrollByStep(0,-1);
					handled  = true;
					break;
					case 39: //right
						dr.scrollByStep(-1,0);
					handled = true;
					break;
					case 37: //left
						dr.scrollByStep(1,0);
					handled = true;
					break;
					case 36: // home
						dr.scrollToBeginning();
					handled  = true;
					break;
					case 35: //end
						dr.scrollToEnd();
					handled = true;
					break;
				}
				
				if (handled)
				{
					evt.preventDefault();
				}
			}
		}
	};
}(
vitrium.viewer.events,
vitrium.viewer, 
_
));
// script:viewer/dom-events/joystick-scroll.js
(function (exports, viewer, ui,geometry, _)
{
	"use strict";
	exports["JoystickScroll"] = JoystickScroll;
	var GLOBAL_PIXEL_RATIO	= ui["CANVAS_POOL"]["GLOBAL_PIXEL_RATIO"];
	var STATES = viewer.STATES;
	var ST_READY = STATES.get("READY");
	var ST_JOYSTICK_SCROLL = STATES.declare("JOYSTICK_SCROLL");
	var SCROLLBAR_TOUCH_TOLERANCE = exports["TouchScrollbar"]["SCROLLBAR_TOUCH_TOLERANCE"];
	
	var Point = geometry["Point"];
		
	var SB_VERTICAL = 1;
	var SB_HORIZONTAL = 2;
	var SB_NONE = 0;
	
	
	function JoystickScroll(viewer)
	{
		this.viewer = viewer;
		
		viewer
				 .on("drag", this.onDrag, this)
				 .on("touchend", this.onTouchEnd, this)
				 .on("dragend", this.onTouchEnd, this)
				 .on("release", this.onTouchEnd, this)
				 .on("hold", this.onHold, this);
				 
		
		this.documentRenderer = null;
		this.handle  = SB_NONE;
		this.speed = 0;
		this.direction = 0;
		this.performScrolling = new ui.UISync(this.onPerformScrolling, this, -11);	
		this.renderState = new ui.UISync(this.onRenderState, this, 11);
		this.lastTime = null;
		this.beginTime = null;
		this.lastRequestTime = null;
		this.center  = new Point(0, 0);
		this.finger = new Point(0, 0);
		
		this.inRun = false;
	}
	
	JoystickScroll.prototype = {
		onHold : function(evt, state)
		{
			if (state.current() === ST_READY)
			{
				var dr = this.viewer.documentRenderer;
				var touch = evt.gesture.touches[0];
				if (evt.gesture.pointerType !== "mouse" && dr.getPageNumberByCoordinates(touch.pageX, touch.pageY, 2) === null)
				{
					state.push(ST_JOYSTICK_SCROLL);
					//evt.gesture.preventDefault();
					this.center.x = touch.pageX;
					this.center.y = touch.pageY;
					this.inRun = false;
					this.viewer.uiLoop.runAsync( this.performScrolling );
				}
			}		
		},
		onTouchEnd : function(evt, state)
		{
			//console.log("touchend");
			var current = state.current();
			if (current === ST_JOYSTICK_SCROLL)
			{
				
				this.speed = 0;
				this.direction = 0;
				this.lastTime = null;
				this.inRun = false;
				state.pop();
				this.viewer.documentRenderer.refresh();
			}
		},
		onDrag : function(evt, state)
		{
			var current = state.current();
			if (current === ST_JOYSTICK_SCROLL)
			{
				var gevt = evt.gesture;
				gevt.preventDefault();
				
				this.direction = gevt.deltaY > 0 ? -1 : 1;
				this.speed = Math.min(Math.abs(gevt.deltaY), 400)/400;
				
				this.finger.x = this.center.x + gevt.deltaX;
				this.finger.y = this.center.y + gevt.deltaY;
				
			}
		},
		onPerformScrolling: function (context, currentTime)
		{
			var v = this.viewer;
			var current = v.state.current();
			
			if (current === ST_JOYSTICK_SCROLL)
			{
			  var dr = v.documentRenderer;
			  dr.refresh();

				if (this.lastTime == null)
				{
				  this.lastRequestTime = this.beginTime = this.lastTime = currentTime;
				}
				else
				{			
					var time = currentTime;
					var duration =  time-this.lastTime ;
					
					var speed = this.speed;
					if (speed < 0.05)
					{
						speed = 0;
					}
					if (speed > 0)
					{
						this.inRun = true;
						var step = duration / (1000/60) * this.direction * speed;
						
						//console.log(step);
						dr.scrollByStep(0, step);
				
						if (speed < 0.25 && speed > 0)
						{
							if (time - this.lastRequestTime > 500)
							{
							  v.forceRequestPages(context.pages);

								this.lastRequestTime = time;
							}
						}

					}
				
					this.lastTime = time;
				}
			  

				this.viewer.uiLoop.runAsync(this.performScrolling);

				if (dr.el.getContext)
				{
				  this.viewer.uiLoop.runAsyncAsap(this.renderState);
				}
			}
		},
		onRenderState : function()
		{
			var v = this.viewer;
			var dr = v.documentRenderer;
			var current = v.state.current();
			if (current === ST_JOYSTICK_SCROLL)
			{
				
					var ctx=dr.el.getContext("2d");
					dr.setImageSmoothing(ctx, true);
					var gpr = GLOBAL_PIXEL_RATIO;
					
				
					ctx.strokeStyle = "#696969";
					ctx.fillStyle = "#696969";
					ctx.lineWidth = 1.5 *gpr;

					if (!this.inRun)
					{
					  var duration = (this.lastTime - this.beginTime) / 1000;


					  var pos = (duration % 2) / 2 +1;
					 // console.log("duration", pos);

						var r = 30 * pos *gpr;
						
						var center = this.center;	
					
						ctx.beginPath();
						ctx.arc(center.x*gpr,center.y*gpr - r,r,0,2*Math.PI);
						
						ctx.globalAlpha = pos*0.3; 
						ctx.fill();
						ctx.globalAlpha = 1; 
						ctx.stroke();			

					}
					else
					{
						var finger = this.finger;
						var center = this.center;
						
						var r =  30 * gpr;
						
						ctx.beginPath();
						var fingerX = finger.x*gpr;
						var fingerY = finger.y*gpr-r;
						var centerX = center.x*gpr;
						var centerY = center.y*gpr-r;
						
						ctx.arc(fingerX, fingerY,r,0,2*Math.PI);
						ctx.globalAlpha = 0.3; 
						ctx.fill();
						ctx.globalAlpha = 1; 
						ctx.stroke();
						
						ctx.beginPath();
						ctx.lineWidth = 1;
						ctx.moveTo(fingerX, fingerY);
						ctx.lineTo(centerX, centerY );
						ctx.stroke();
						
						ctx.beginPath();
						r =  50* gpr;
						
						ctx.arc(centerX,centerY,r,0,2*Math.PI);
						ctx.lineWidth = 1.5 *gpr;
						ctx.globalAlpha = 0.3; 
						ctx.fill();
						ctx.globalAlpha = 1; 
						ctx.stroke();
					}
					//console.log(pos);
					
			}
		}
	};

}(
vitrium.viewer.events,
vitrium.viewer, 
vitrium.ui, 
vitrium.geometry, 
_
));
// script:viewer/dom-events/pinch-to-zoom.js
(function (exports, viewer, geometry, _)
{
	"use strict";
	exports["PinchToZoom"] = PinchToZoom;
	
	var STATES = viewer.STATES;
	var ST_READY = STATES.get("READY");
	var ST_PINCH_TO_ZOOM = STATES.declare("ST_PINCH_TO_ZOOM");
	
	function PinchToZoom(viewer)
	{
		this.viewer = viewer;
		//console.log(viewer);
		viewer.on("transformstart", this.onTransformStart, this)
				 .on("pinch", this.onPinch, this)				 
				 .on("transformend", this.onTransfromEnd, this);
		this.center = new geometry.Point(0,0);
		this.scale = 0;
	}
	
	PinchToZoom.prototype = {
		onTransformStart : function(evt, state)
		{
			if (state.current() === ST_READY)
			{
				this.scale = this.viewer.scale;
				state.push(ST_PINCH_TO_ZOOM);
				evt.gesture.preventDefault();
			}
		},
		onPinch : function(evt, state)
		{
			if (state.current() === ST_PINCH_TO_ZOOM)
			{
			
				this.viewer.setScale(this.scale * evt.gesture.scale);
				evt.gesture.preventDefault();
			}
		},
		onTransfromEnd : function(evt, state)
		{
			if (state.current() === ST_PINCH_TO_ZOOM)
			{
				state.pop();
			}
		}
	};

}(
vitrium.viewer.events,
vitrium.viewer, 
vitrium.geometry, 
_
));
// script:viewer/dom-events/mouse-text-selection.js
(function (exports, viewer,ui, geometry, _)
{
  "use strict";
  exports.MouseTextSelection = MouseTextSelection;
  
  var STATES = viewer.STATES;
  var ST_READY = STATES.get("READY");
  var ST_MOUSE_TEXT_SELECTING = STATES.declare("MOUSE_TEXT_SELECTING");
  var MOUSE_TOLERANCE = 1;
  
  var Point = geometry.Point;
  
  var SB_VERTICAL = 1;
  var SB_HORIZONTAL = 2;
  var SB_NONE = 0;
  
  function MouseTextSelection(viewer, selectionController)
  {
    this.viewer = viewer;
    this.selectionController = selectionController;
    
    viewer
         .on("mousedown", this.onMouseDown, this)
         .on("mouseup", this.onMouseUp, this)
         .on("mousemove", this.onMouseMove, this)
         .on("dblclick", this.onDblClick, this);
    this.documentRenderer = null;
    this.handle  = SB_NONE;
        
    this.duSelectionStart = new Point(0,0);
    this.duSelectionEnd = new Point(0, 0);
    this.duScrollSpeed = new Point(0, 0);
    this.vpLastMousePosition = new Point(0, 0);
    
    this.performScroll = new ui.UISync(this.onPerformScroll, this, -11);
    this.lastScrollTime = 0;
    this.isMouseDown = false;
    this.pauseScrollingUntilPage = null;
  }
  
  MouseTextSelection.prototype = {
    onMouseDown : function(evt, state)
    {
      if (state.current() === ST_READY)
      {
        if (evt.which === 1)
        {			  
          var dr = this.documentRenderer = this.viewer.documentRenderer;
        
          if (dr.getPageNumberByCoordinates(evt.pageX , evt.pageY, MOUSE_TOLERANCE) !== null)
          {
            
            this.lastScrollTime  = 0;
            var selectionStart = this.duSelectionStart;
            var mousePosition = this.vpLastMousePosition;				

            mousePosition.x = selectionStart.x = evt.pageX;
            mousePosition.y = selectionStart.y = evt.pageY;
            // it is necessary to store in scale and viewport independent units
            dr.translateToViewportFill(selectionStart,selectionStart);
            dr.convertToDocumentUnitsFill(selectionStart, selectionStart);
          
            var viewport = dr.getDUViewportState();
            this.cleanFromViewport(selectionStart, viewport);

            this.pauseScrollingUntilPage = null;
            this.isMouseDown = true;
          
          }
        }
        
        this.selectionController.cancelSelection();
      }
    },
    onMouseUp : function(evt, state)
    {
      var current = state.current();
      var r = false;
      if (current === ST_MOUSE_TEXT_SELECTING)
      {	
        evt.preventDefault();
        state.pop();
        this.pauseScrollingUntilPage = null;
        this.selectionController.finish();
        r = true;
      }
      this.isMouseDown = false;
      return r;
    },
    onMouseMove : function(evt, state)
    {
      var current = state.current();
      if (this.isMouseDown)
      {
        var mousePosition = this.vpLastMousePosition;				
        if (mousePosition.x === evt.pageX && mousePosition.y === evt.pageY)
        {
          return;
        }

        if (current !==  ST_MOUSE_TEXT_SELECTING)
        {
          state.push(ST_MOUSE_TEXT_SELECTING);
        }
        evt.preventDefault();
        var dr = this.documentRenderer;
        var selectionEnd = this.duSelectionEnd;
        
        
        mousePosition.x = selectionEnd.x = evt.pageX;
        mousePosition.y = selectionEnd.y = evt.pageY;
        
        var viewport = dr.getDUViewportState();
        dr.translateToViewportFill(selectionEnd,selectionEnd);
        dr.convertToDocumentUnitsFill(selectionEnd, selectionEnd);
        
        var duScrollSpeed =this.duScrollSpeed;
        if (selectionEnd.y <= 0 )
        {
          duScrollSpeed.y = selectionEnd.y ;
        }
        else if (selectionEnd.y >= viewport.height)
        {
          duScrollSpeed.y = selectionEnd.y - viewport.height;
        }
        else
        {
          duScrollSpeed.y = 0;
        }
        
        if (selectionEnd.x <= 0 )
        {
          duScrollSpeed.x = selectionEnd.x ;
        }
        else if (selectionEnd.x >= viewport.width)
        {
          duScrollSpeed.x = selectionEnd.x - viewport.width;
        }
        else
        {
          duScrollSpeed.x = 0;
        }
        
        if (duScrollSpeed.x  !== 0 || duScrollSpeed.y !== 0)
        {
          this.viewer.uiLoop.runAsync( this.performScroll );
        }
        
        this.cleanFromViewport(selectionEnd, viewport);
        
    //		console.log(viewport.scrollY);
        //console.log(this.duSelectionStart.x, this.duSelectionStart.y, selectionEnd.x, selectionEnd.y);
        this.selectionController.setSelectionPoints(this.duSelectionStart, selectionEnd);
        /*var pagesIt = dr.getPageIteratorBetweenDU(this.duSelectionStart, selectionEnd);
        var ar = [];
        while(pagesIt.hasNext())
        {
          ar.push(pagesIt.next().number);
        }
        
        console.log(ar.join(","));*/
      }
    },
    onDblClick : function(evt)
    {
      var dr = this.viewer.documentRenderer;
      var pageNumber = dr.getPageNumberByCoordinates(evt.pageX, evt.pageY, 1);
      if (pageNumber !== null)
      {
        var pagePoint = new Point(evt.pageX, evt.pageY);
        dr.translateCoordinatesToPage(pagePoint, pageNumber);

        this.selectionController.selectWord(pageNumber, pagePoint);
        this.selectionController.finish();
      }

    },
    cleanFromViewport : function(point, viewport)
    {
      point.x += viewport.scrollX - viewport.centerHorizontalConstant;
      point.y += viewport.scrollY;
    },
    onRectanglesReady : function(pageNumber)
    {
      var current = this.viewer.state.current();
      if (current === ST_MOUSE_TEXT_SELECTING && this.pauseScrollingUntilPage === pageNumber)
      {
        var dr = this.viewer.documentRenderer;
        this.selectionController.rectangleStorage.off("finished", this.onRectanglesReady, this);
        this.viewer.uiLoop.runAsync( this.performScroll );
      }
    },
    onPerformScroll: function MouseTextSelection__onPerformScroll(context, time)
    {
      var current = this.viewer.state.current();
      var duScrollSpeed =this.duScrollSpeed;
      if (current === ST_MOUSE_TEXT_SELECTING && (duScrollSpeed.x !== 0  || duScrollSpeed.y !== 0))
      {
        var dr = this.viewer.documentRenderer;
        var  stepLength = (time  - this.lastScrollTime) / 1000;
    
    
        if (this.lastScrollTime !== 0)
        {
          dr.scrollByStep(-duScrollSpeed.x*stepLength, -duScrollSpeed.y*stepLength);			
          
          var mousePosition = this.vpLastMousePosition;
          var selectionEnd = this.duSelectionEnd;
          
          var viewport = dr.getDUViewportState();
          
          dr.translateToViewportFill(selectionEnd, mousePosition);
          dr.convertToDocumentUnitsFill(selectionEnd, selectionEnd);
          
          this.cleanFromViewport(selectionEnd, viewport);
                  
          this.selectionController.setSelectionPoints(this.duSelectionStart, selectionEnd);
        }
          
        this.lastScrollTime = time;
        if (this.selectionController.canScrollMore(duScrollSpeed.y))
        {
          this.viewer.uiLoop.runAsync(this.performScroll);
        }
        else
        {
          var viewportPages = dr.viewportPages();
          var nextScrollPage = 		this.pauseScrollingUntilPage =  this.selectionController.getNextPageForDirection(duScrollSpeed.y);
          if (viewportPages[viewportPages.length-1] !== nextScrollPage)
          {
            this.viewer.uiLoop.runAsync(this.performScroll);
          }
          else
          {
            this.lastScrollTime = 0;
            this.selectionController.rectangleStorage.on("finished", this.onRectanglesReady, this);
          }
        }				
      }
      else if (duScrollSpeed.x === 0  && duScrollSpeed.y === 0)
      {
        this.lastScrollTime =  0;
      }
    }
  };

}(
vitrium.viewer.events,
vitrium.viewer,
vitrium.ui,
vitrium.geometry, 
_
));
// script:viewer/dom-events/touch-text-selection.js
/// <reference path="~/build.html" />

(function (exports, viewer, geometry, geometry2)
{
  "use strict";
  var STATES = viewer.STATES;
  var ST_READY = STATES.get("READY");
  var ST_TOUCH_TEXT_SELECTING = STATES.declare("TOUCH_TEXT_SELECTING");

  var ST_NONE = 0;
  var ST_ACTIVE = 1;
  var ST_BEG_HANDLE_DRAG = 2;
  var ST_END_HANDLE_DRAG = 3;

  exports.TouchTextSelection = TouchTextSelection;
  function TouchTextSelection(viewer, selectionController, selectionModel, handleSize)
  {
    this.viewer = viewer;
    this.selectionController = selectionController;
    this.selectionModel = selectionModel;
    this.handleSize = handleSize;

    viewer
      .on("hold", this.onHold, this)
      .on("dragstart", this.onDragStart, this)
      .on("drag", this.onDrag, this)
      .on("dragend", this.onDragEnd, this)
      .on("tap", this.onTap, this)
      .on("mousedown", this.onMouseDown, this)
      .on("mouseup", this.onMouseUp, this)
      .on("mousemove", this.onMouseMove, this);

    this.state = ST_NONE;
    this.holding = false;
    this.tmpRect = new geometry2.Rectangle(0, 0, 1, 1, 0);
    this.tmpPosition = new geometry.Point(0, 0);
    this.startPoint = null;
    this.staticPoint = null;
    this.mouseDownPoint = null;
    this.activePageNumber = null;

    selectionModel.on("changed", this.onSelectionChanged, this);
  }

  TouchTextSelection.prototype = {
    onSelectionChanged : function(pages, enabled)
    {
      if (enabled && !this.selectionModel.get("selection").isEmpty())
      {
        if (this.holding)
        {
          this.state = ST_ACTIVE;
        }
      }
      else
      {
        this.state = ST_NONE;
        this.activePageNumber = null;
      }
      
    },
    onHold : function(evt, state)
    {
      if (state.current() === ST_READY)
      {
        this.holding = true;
        var point = this._getPosition(evt);
        var pageNumber = this._getPageNumber(point);

        if (pageNumber !== null)
        {
          this._translateToPage(pageNumber, point);
          this.activePageNumber = pageNumber;
          this.selectionController.selectWord(pageNumber, point);
          this.selectionModel.set("mode", this.selectionModel.MODE.TOUCH);
        }
        this.holding = false;
      }
    },
    onTap : function(evt, state)
    {
      if (this.state === ST_ACTIVE)
      {
        this.selectionController.cancelSelection();
        this.state = ST_NONE;
        this.activePageNumber = null;
        return true;
      }
    },
    onMouseDown : function(evt, state)
    {
      var point = this._getPositionMouse(evt);
      var t = point.clone();
      if (this.dragStart(point, state))
      {
        this.mouseDownPoint = t;
        evt.preventDefault();
        return true;
      }
      
    },
    onMouseUp : function(evt,state)
    {
      if (this.onDragEnd(evt, state))
      {
        this.mouseDownPoint = null;
        return true;
      }   
    },
    onMouseMove : function(evt)
    {
      if (this.mouseDownPoint !== null && this.state !== ST_NONE)
      {
        var point = this._getPositionMouse(evt);
        point.x -= this.mouseDownPoint.x;
        point.y -= this.mouseDownPoint.y;
       // console.log(point, this.mouseDownPoint);
        return this.drag(point);
      }
    },
    onDragStart : function(evt, state)
    {
      if (this.dragStart(this._getPosition(evt), state))
      {
        evt.gesture.preventDefault();
        return true;
      }
    },
    dragStart : function(point, state)
    {
      if (state.current() === ST_READY && this.state === ST_ACTIVE)
      {
        var pageNumber = this.activePageNumber;
        if (this._getPageNumber(point) === pageNumber)
        {
          this._translateToPage(pageNumber, point);

          var selection = this.selectionModel.get("selection")[pageNumber];
          var first = selection[0].clone();
          var last = selection[selection.length - 1].clone();

          
          var q = this.tmpRect;
          q.x = point.x;
          q.y = point.y;
          
          var qf = first.clone();

          var m = 6;

          qf.x -= this.handleSize*m;
          qf.y -= this.handleSize * m;
          qf.h += this.handleSize * m;
          qf.w += this.handleSize*m;

          if (qf.isIntersected(q))
          {
            this.startPoint = this._translateFromPageToDU(pageNumber, first.getCenterPoint());
            this.staticPoint = this._translateFromPageToDU(pageNumber,last.getCenterPoint());
            this.state = ST_BEG_HANDLE_DRAG;
            state.push(ST_TOUCH_TEXT_SELECTING);
            
            return true;
          }

          var lq = last.clone();
          //last.y -= this.handleSize*2;
          lq.h += this.handleSize*m;
          lq.w += this.handleSize*m;

          if (lq.isIntersected(q))
          {
            this.startPoint = this._translateFromPageToDU(pageNumber, last.getCenterPoint());
            this.staticPoint = this._translateFromPageToDU(pageNumber, first.getCenterPoint());
            
            this.state = ST_END_HANDLE_DRAG;
            state.push(ST_TOUCH_TEXT_SELECTING);
            
            return true;
          }
        }
      }
      return false;
    },
    onDragEnd : function(evt, state)
    {
      if (state.current() === ST_TOUCH_TEXT_SELECTING)
      {
        this.state = ST_ACTIVE;
        this.startPoint = null;
        state.pop();
        return true;
      }
    },
    drag : function(deltaPoint)
    { 
      this._convertToDU(deltaPoint);

      var sp = this.startPoint.clone();
      sp.add(deltaPoint);

      this.selectionController.setSelectionPoints(sp, this.staticPoint.clone());
      return true;
    },
    onDrag : function(evt, state)
    {
      if (state.current() === ST_TOUCH_TEXT_SELECTING && this.state !== ST_NONE)
      {
        var gs = evt.gesture;
        gs.preventDefault();
        var p = this.tmpPosition;
        p.x = gs.deltaX;
        p.y = gs.deltaY;
        
       return this.drag(p);
      }
    },
    _getPosition : function(evt)
    {
      var t = evt.gesture.touches[0];
      this.tmpPosition.x = t.pageX;
      this.tmpPosition.y = t.pageY;
      return this.tmpPosition;
    },
    _getPositionMouse: function(evt)
    {
      var t = evt;
      this.tmpPosition.x = t.pageX;
      this.tmpPosition.y = t.pageY;
      return this.tmpPosition;
    },
    _getPageNumber: function(position)
    {
      return this.viewer.documentRenderer.getPageNumberByCoordinates(position.x, position.y, 1);
    },
    _translateToPage: function(pageNumber, point)
    {
      return this.viewer.documentRenderer.translateCoordinatesToPage(point,pageNumber);
    },
    _translateFromPageToDU : function(pageNumber, point)
    {
      return this.viewer.documentRenderer.translateCoordiatesFromPageToDU(point, pageNumber);
    },
    _convertToDU : function(point)
    {
      return this.viewer.documentRenderer.convertToDocumentUnitsFill(point, point);
    }

  };



}
(vitrium.viewer.events,
vitrium.viewer,
vitrium.geometry,
vitrium.geometry2
));

// script:viewer/io/crc32.js
(function(exports, bin)
{
	"use strict";
	var global  = exports;
	
	function CRC32() {
		this.crc = -1;
	}	
	var CP = CRC32.prototype;
	CP.table = (function() {
		var i, j, t, table = [];
		for (i = 0; i < 256; i++) {
			t = i;
			for (j = 0; j < 8; j++)
				if (t & 1)
					t = (t >>> 1) ^ 0xEDB88320;
				else
					t = t >>> 1;
			table[i] = t;
		}
		return table;
	})();

	if (!!global.ArrayBuffer)
	{
		CP.append = function(data) {
				var offset, table = this.table;
				var crc = this.crc;
				for (offset = 0; offset < data.length; offset++)
					crc = table[(crc ^ data[offset]) & 0xFF] ^ (crc >>> 8);
				
				this.crc = crc;
		};
	}
	else
	{
		CP.append = function(data) {
				var offset, table = this.table;
				var crc = this.crc;
				if (data.readNumber)
				{			
					for (offset = 0; offset < data.length; offset++)
						crc = (crc >>> 8) ^ table[(crc ^ data.readNumber(1,offset)) & 0xFF];
				}
				else
				{
					for (offset = 0; offset < data.length; offset++)
						crc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];
				}				
				this.crc = crc;
		};
	
	}
	
	CP.get = function() {
			return ((~(this.crc)) >>> 0);
	};
	
	CP.equals = function(crc32)
	{
		return crc32 === this.get();
	};
	
	exports.CRC32 = CRC32;
}(
	__globals__, 
	vitrium.bin
));
// script:viewer/io/data-helper.js
(function(exports, global)
{
	var bin = exports;
	var getDataHelper;
	var isTypedArraysSupported =  !!global.ArrayBuffer;
	
	if (isTypedArraysSupported)
	{
		
		getDataHelper = function(byteLength, bytes) {
			var dataBuffer, dataArray;
			dataBuffer = new ArrayBuffer(byteLength);
			dataArray = new Uint8Array(dataBuffer);
			if (bytes)
				dataArray.set(bytes, 0);
			return {
				buffer : dataBuffer,
				array : dataArray,
				view : new DataView(dataBuffer)
			};
		};
	}
	else
	{
		getDataHelper = function(byteLength, bytes) {
			var dataBuffer, dataArray;
			dataBuffer = new bin.DataBufferView(bytes, 0, byteLength);
			dataArray = dataBuffer;
			
			return {
				buffer : dataBuffer,
				array : dataArray,
				view : dataBuffer
			};
		};
	}	
	
	exports["getDataHelper"] = getDataHelper;
}(vitrium.bin, __globals__));
// script:viewer/io/zip.js
/*
 Copyright (c) 2012 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

(function(zip, CRC32, bin, crypto, CryptoJS, globals) {

	var ERR_BAD_FORMAT = "File format is not recognized.";
	var ERR_ENCRYPTED = "File contains encrypted entry.";
	var ERR_ZIP64 = "File is using Zip64 (4gb+ file size).";
	var ERR_READ = "Error while reading zip file.";
	var ERR_WRITE = "Error while writing zip file.";
	var ERR_WRITE_DATA = "Error while writing file data.";
	var ERR_READ_DATA = "Error while reading file data.";
	var ERR_DUPLICATED_NAME = "File already exists.";
	var ERR_HTTP_RANGE = "HTTP Range not supported.";
	var ERR_AES_HEADER_MISSING = "AES header 0x9901 not found";
	var ERR_COMPRESION_METHOD = "Unknown compression method";
	var ERR_REQUIRED_AES_KEY = "Required AES key";
	var ERR_AES_UNKNOWN_STRENGTH = "Unknown strength value.";
	var ERR_AES_WRONG_PASSWORD = "Wrong password.";
		
	//JH added
	var isTypedArraysSupported = typeof globals.ArrayBuffer === "function" ||  typeof globals.ArrayBuffer === "object";
	var CHUNK_SIZE = isTypedArraysSupported ? 1000000 : 500000 ; 
	
	var getDataHelper = bin.getDataHelper;
	

	
	var launchProcess;
	if (isTypedArraysSupported)
	{
			launchProcess = function(process, reader, writer, offset, size, onappend, onprogress, onend, onreaderror, onwriteerror) {
			var chunkIndex = 0, index, outputSize = 0;
			var abort = new AbortHandler();
			
			function step() {
				var outputData;
				index = chunkIndex * CHUNK_SIZE;
				if (index < size)
					abort.req = reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(inputData) {
						var outputData = process.append(inputData, function() {
							if (onprogress)
								onprogress(offset + index, size);
						});
						
						if (outputData === -1)
						{
							chunkIndex++;
							step();
						}
						outputSize += outputData.length;
						onappend(true, inputData);
						writer.writeUint8Array(outputData, function() {
							onappend(false, outputData);
							chunkIndex++;
							step();
							//setTimeout(step, 1);
													
						}, onwriteerror);
						if (onprogress)
							onprogress(index, size);
					}, onreaderror);
				else {
					outputData = process.flush();
					if (outputData) {
						outputSize += outputData.length;
						writer.writeUint8Array(outputData, function() {
							onappend(false, outputData);
							onend(outputSize);
						}, onwriteerror);
					} else
						onend(outputSize);
				}
			}

			step();
			
			return abort;
		};
	
	}
	else
	{
	launchProcess = function(process, reader, writer, offset, size, onappend, onprogress, onend, onreaderror, onwriteerror) {
			var chunkIndex = 0, index, outputSize = 0;
			var abort = new AbortHandler();
			
			function step() {
				var outputData;
				index = chunkIndex * CHUNK_SIZE;
				if (index < size)
					abort.req = reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(inputData) {
						var suboffset = 0;
						var rem = inputData.length;
						function substep()
						{
							if (rem > 0)
							{
				
									var lastoffset = suboffset + Math.min(rem, 1024);
									var chunk;
									if (offset == 0 && lastoffset === rem)
									{
										chunk = inputData;
									}
									else
									{
										chunk = inputData.subarray(suboffset, lastoffset);
									}
									var chsize = lastoffset - suboffset;
									suboffset += chsize;
									rem -= chsize;
									
									var outputData = process.append(chunk, function() {
										if (onprogress)
											onprogress(offset + suboffset, size);
									});
									
									onappend(true, inputData);
									if (outputData === -1)
									{
										var t = setTimeout(substep, 1);
										abort.req = { abort : function(){ clearTimeout(t);}};
									}
									else
									{
										outputSize += outputData.length;
										writer.writeUint8Array(outputData, function() {
											onappend(false, outputData);
											var t = setTimeout(substep, 1);
											abort.req = { abort : function(){ clearTimeout(t);}};
										}, onwriteerror);
									}
									
								if (onprogress)
									onprogress(index, size);
							}
							else
							{
								chunkIndex++;
								step();
							}
						}
						substep();
						
					}, onreaderror);
				else {
					outputData = process.flush();
					if (outputData) {
						outputSize += outputData.length;
						writer.writeUint8Array(outputData, function() {
							onappend(false, outputData);
							onend(outputSize);
						}, onwriteerror);
					} else
						onend(outputSize);
				}
			}

			step();
			
			return abort;
		};
	
	}
	
		

	function inflate(reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror, name) {
		var worker, crc32 = new CRC32();
		var abort = new AbortHandler();
		
		function oninflateappend(sending, array) {
			if (computeCrc32 && !sending)
				crc32.append(array);
		}

		function oninflateend(outputSize) {
			onend(outputSize, crc32.get());
		}
	
		var inflater = new zip.Inflater();
		abort.req = launchProcess(inflater, reader, writer, offset, size, oninflateappend, onprogress, oninflateend, onreaderror, onwriteerror);
		
		return abort;
	}

	function copy(reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
		var chunkIndex = 0, crc32 = new CRC32();
		var abort = new AbortHandler();
		
		function step() {
			var index = chunkIndex * CHUNK_SIZE;
			if (index < size)
				abort.req = reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(array) {
					if (computeCrc32)
						crc32.append(array);
					if (onprogress)
						onprogress(index, size, array);
					writer.writeUint8Array([array], function() {
						chunkIndex++;
						step();
					}, onwriteerror);
				}, onreaderror);
			else
				onend(size, crc32.get());
		}

		step();
		
		return abort;
	}
	
	function aesHashEq(hmac, hmacChksum)
	{
		hash = CryptoJS.enc.u8array.stringify({ words : hmac.hasher.hash, sigBytes: 20});
				
		if (hmacChksum.readByteAt)
		{
		
			for (var i = 0; i < 10; ++i)
			{
				if (hash[i] != hmacChksum.readByteAt(i))
				{
					return false;
				}
			}
		}
		else
		{
			for (var i = 0; i < 10; ++i)
			{
				if (hash[i] != hmacChksum[i])
				{
					return false;
				}
			}
		}
		
		return true;
	}
	
	function aesCopy(reader, writer, offset, size, onend, onprogress, onreaderror, onwriteerror, aesDecryptor, hmac, hmacChksum, onbadpassword) {
		var chunkIndex = 0;
		var abort = new AbortHandler();

		function step() {
			var index = chunkIndex * CHUNK_SIZE;
			if (index < size)
			{
				abort.req = reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(array) {
					var wordArray = CryptoJS.enc.u8array.parse(array);
					hmac.update(wordArray);
					
					var deryptedChuck = aesDecryptor.process(wordArray);
					
					if (onprogress)
						onprogress(index, size, array);
					
					if (deryptedChuck.sigBytes > 0)
					{										
						var dBytes = CryptoJS.enc.u8array.stringify(deryptedChuck);
						
						writer.writeUint8Array([dBytes], function() {
							chunkIndex++;
							step();
						}, onwriteerror);
					}
					else
					{
						chunkIndex++;
						step();
					}
				}, onreaderror);
			}
			else
			{
				hmac.finalize();
			
				
				if (aesHashEq(hmac, hmacChksum))
				{	
					var deryptedChuck = aesDecryptor.finalize();
					if (deryptedChuck.sigBytes > 0)
					{										
						var dBytes = CryptoJS.enc.u8array.stringify(deryptedChuck);	
						writer.writeUint8Array(dBytes, function() {
							onend(size);
						}, onwriteerror);
					}
					else
					{
						onend(size);
					}
				}
				else
				{
					onbadpassword();
				}
			}
		}

		step();
		
		return abort;
	}
	
	
	function aesInflate(reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror, aesDecryptor, hmac, hmacChksum, onbadpassword) 
	{
		var worker, crc32 = new CRC32();		
		var abort = new AbortHandler();

		function oninflateappend(sending, array) {
			if (computeCrc32 && !sending)
				crc32.append(array);
		}

		function oninflateend(outputSize) {
			onend(outputSize, crc32.get());
		}

		var inflater = new zip.Inflater();
		abort.req = aesLaunchProcess(inflater, reader, writer, offset, size, oninflateappend, onprogress, oninflateend, onreaderror, onwriteerror , aesDecryptor, hmac, hmacChksum, onbadpassword);
				
		return abort;
	}
	
	function convertCryptoArray(array)
	{
		if (!isTypedArraysSupported)
		{
			var buffer = new bin.DataBuffer();
			buffer.attachData(array);
			array = buffer;
		}
		return array;
	}
	
	function aesLaunchProcess(process, reader, writer, offset, size, onappend, onprogress, onend, onreaderror, onwriteerror, aesDecryptor, hmac, hmacChksum, onbadpassword) {
		var chunkIndex = 0, index, outputSize = 0;
		var aesFlushed = false;
		var abort = new AbortHandler();
		
		function step() {
			var outputData;
			index = chunkIndex * CHUNK_SIZE;
			
			if (aesFlushed)
			{
				outputData = process.flush();
				if (outputData) {
					outputSize += outputData.length;
					writer.writeUint8Array(outputData, function() {
						onappend(false, outputData);
						onend(outputSize);
					}, onwriteerror);
				} else
					onend(outputSize);
			}
			else if (index < size)
			{
				abort.req = reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(array) {
					var wordArray = CryptoJS.enc.u8array.parse(array);
					hmac.update(wordArray);
					
					var deryptedChuck = aesDecryptor.process(wordArray);
					chunkIndex++;
				
					if (onprogress)
						onprogress(offset + index, size);
						
					if (deryptedChuck.sigBytes > 0)
					{	
						var dBytes = convertCryptoArray(CryptoJS.enc.u8array.stringify(deryptedChuck));
										
						var outputData = process.append(dBytes, function() {});
						if (outputData === -1)
						{
							step();
						}
						
						outputSize += outputData.length;
						onappend(true, dBytes);
						
						writer.writeUint8Array(outputData, function() {
							onappend(false, outputData);
							step();													
						}, onwriteerror);
					}
					else
					{
						step();
					}
				}, onreaderror);
			}
			else {
				hmac.finalize();
				if (aesHashEq(hmac, hmacChksum))
				{	
					var deryptedChuck = aesDecryptor.finalize();
					aesFlushed = true;
					if (deryptedChuck.sigBytes > 0)
					{	
						var dBytes = convertCryptoArray(CryptoJS.enc.u8array.stringify(deryptedChuck));				
						var outputData = process.append(dBytes, function() {});
						
						outputSize += outputData.length;
						onappend(true, dBytes);
						
						writer.writeUint8Array(outputData, function() {
							onappend(false, outputData);
							step();
						}, onwriteerror);
					}
					else
					{
						step();
					}
				}
				else
				{
					onbadpassword();
				}
			}
		}

		step();
		
		return abort;
	}

	// ZipReader

	function decodeASCII(str) {
		var i, out = "", charCode, extendedASCII = [ '\u00C7', '\u00FC', '\u00E9', '\u00E2', '\u00E4', '\u00E0', '\u00E5', '\u00E7', '\u00EA', '\u00EB',
				'\u00E8', '\u00EF', '\u00EE', '\u00EC', '\u00C4', '\u00C5', '\u00C9', '\u00E6', '\u00C6', '\u00F4', '\u00F6', '\u00F2', '\u00FB', '\u00F9',
				'\u00FF', '\u00D6', '\u00DC', '\u00F8', '\u00A3', '\u00D8', '\u00D7', '\u0192', '\u00E1', '\u00ED', '\u00F3', '\u00FA', '\u00F1', '\u00D1',
				'\u00AA', '\u00BA', '\u00BF', '\u00AE', '\u00AC', '\u00BD', '\u00BC', '\u00A1', '\u00AB', '\u00BB', '_', '_', '_', '\u00A6', '\u00A6',
				'\u00C1', '\u00C2', '\u00C0', '\u00A9', '\u00A6', '\u00A6', '+', '+', '\u00A2', '\u00A5', '+', '+', '-', '-', '+', '-', '+', '\u00E3',
				'\u00C3', '+', '+', '-', '-', '\u00A6', '-', '+', '\u00A4', '\u00F0', '\u00D0', '\u00CA', '\u00CB', '\u00C8', 'i', '\u00CD', '\u00CE',
				'\u00CF', '+', '+', '_', '_', '\u00A6', '\u00CC', '_', '\u00D3', '\u00DF', '\u00D4', '\u00D2', '\u00F5', '\u00D5', '\u00B5', '\u00FE',
				'\u00DE', '\u00DA', '\u00DB', '\u00D9', '\u00FD', '\u00DD', '\u00AF', '\u00B4', '\u00AD', '\u00B1', '_', '\u00BE', '\u00B6', '\u00A7',
				'\u00F7', '\u00B8', '\u00B0', '\u00A8', '\u00B7', '\u00B9', '\u00B3', '\u00B2', '_', ' ' ];
		for (i = 0; i < str.length; i++) {
			charCode = str.charCodeAt(i) & 0xFF;
			if (charCode > 127)
				out += extendedASCII[charCode - 128];
			else
				out += String.fromCharCode(charCode);
		}
		return out;
	}

	function decodeUTF8(str_data) {
		var tmp_arr = [], i = 0, ac = 0, c1 = 0, c2 = 0, c3 = 0;

		str_data += '';

		while (i < str_data.length) {
			c1 = str_data.charCodeAt(i);
			if (c1 < 128) {
				tmp_arr[ac++] = String.fromCharCode(c1);
				i++;
			} else if (c1 > 191 && c1 < 224) {
				c2 = str_data.charCodeAt(i + 1);
				tmp_arr[ac++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
				i += 2;
			} else {
				c2 = str_data.charCodeAt(i + 1);
				c3 = str_data.charCodeAt(i + 2);
				tmp_arr[ac++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
				i += 3;
			}
		}

		return tmp_arr.join('');
	}


	 function getString(bytes) {
			var i, str = "";
			for (i = 0; i < bytes.length; i++)
				str += String.fromCharCode(bytes[i]);
			return str;
		};
	

	function getDate(timeRaw) {
		var date = (timeRaw & 0xffff0000) >> 16, time = timeRaw & 0x0000ffff;
		try {
			return new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5,
					(time & 0x001F) * 2, 0);
		} catch (e) {
		}
	}

	function readCommonHeader(entry, data, index, centralDirectory, onerror) 
	{
		entry.version = data.view.getUint16(index, true);
		entry.bitFlag = data.view.getUint16(index + 2, true);
		entry.compressionMethod = data.view.getUint16(index + 4, true);
		entry.lastModDateRaw = data.view.getUint32(index + 6, true);
		entry.lastModDate = getDate(entry.lastModDateRaw);
		/*if ((entry.bitFlag & 0x01) === 0x01) {
			onerror(ERR_ENCRYPTED);
			return;
		}*/
		if (centralDirectory || (entry.bitFlag & 0x0008) != 0x0008) {
			entry.crc32 = data.view.getUint32(index + 10, true);
			entry.compressedSize = data.view.getUint32(index + 14, true);
			entry.uncompressedSize = data.view.getUint32(index + 18, true);
		}
		if (entry.compressedSize === 0xFFFFFFFF || entry.uncompressedSize === 0xFFFFFFFF) {
			onerror(ERR_ZIP64);
			return;
		}
		entry.filenameLength = data.view.getUint16(index + 22, true);
		entry.extraFieldLength = data.view.getUint16(index + 24, true);
	}
	
	function parseEncryptionHeader(data, start, len)
	{
		var step = len;
		var result = null;
		var e = start + len;
		for ( var i = start; i < e; i+=step)
		{
			var id = data.view.getUint16(i, true);
			i += 2;
			var len = data.view.getUint16(i, true); 
			i += 2;
			
			if (id === 0x9901) // AES extra field http://www.winzip.com/aes_info.htm
			{
				var version = data.view.getUint16(i, true);
				i += 2;
				var vendorId = data.view.getUint16(i, true);
				i += 2;
				var strength = data.view.getUint8(i);
				i += 1;
				var method = data.view.getUint16(i, true);
				i += 2;
				
				result = {
					version : version,
					vendorId : vendorId,
					strength : strength,
					method : method
				};
			
				break;
			}
			else
			{
				step = len;
			}
		}
		
		
		
		return result;
	}
	
	function aesKeyLen(mode) {  return (8 * (mode & 3) + 8); }
	function aesSaltLen(mode) { return (4 * (mode & 3) + 4); }

	var AES_MAC_LEN = 10;
	
	function readEntry(reader, that /*entry json*/, options)
	{
			//vitrium.log.debug("zip get data: "+this.filename);
			var writer  = options.writer;
			var onend = options.onend || function(){};
			var onprogress = options.onprogress || function(){};
			var onerrorentry = options.onerror || function(){};
			var onrangerecieved = options.onrange || function(){};
			
			var checkCrc32 = options.checkCrc32;
			var password = options.password;
	
			var worker = null;
			
			function getdataerror()
			{
				onerrorentry.apply(that, arguments);
			}

			function terminate(callback, param) 
			{
				if (worker)
					worker.terminate();
					
				worker = null;
				try
				{
					if (callback)
					{
						if (arguments.length > 2)
						{
							var args = [];
							for (var i = 1, len =arguments.length; i < len; ++i)
							{
								args.push(arguments[i]);
							}
							
							callback.apply(null, args);
						}
						else
						{
							callback(param);
						}
					}
					
					
					if (writer && writer.free)
					{
					
						writer.free();
					}
					abort = null;
				}
				catch(e)
				{
					getdataerror(e);
				}
			}
			
			function testCrc32(crc32) {
				var dataCrc32 = getDataHelper(4);
				dataCrc32.view.setUint32(0, crc32);
				return that.crc32 == dataCrc32.view.getUint32(0);
			}

			function getWriterData(uncompressedSize, crc32) {
			
				if (checkCrc32 && !testCrc32(crc32))
					onreaderror();
				else
				{
					try
					{
						writer.getData(function(data) {
							terminate(onend, data);
						});
					}
					catch(e)
					{
						terminate(getdataerror, e);
					}
				}
			}

			function onreaderror(e1, e2) {
				terminate(getdataerror, ERR_READ_DATA, e1, e2);
			}

			function onwriteerror() {
				terminate(getdataerror, ERR_WRITE_DATA);
			}
			
			function wrongpassword()
			{
				terminate(getdataerror, ERR_AES_WRONG_PASSWORD);
			}
			
			var abort = new AbortHandler();
			abort.req = reader.readUint8Array(that.offset, 30, function(bytes) {
				var data = getDataHelper(bytes.length, bytes), dataOffset;
				if (data.view.getUint32(0) != 0x504b0304) {
					getdataerror(ERR_BAD_FORMAT);
					return;
				}
				
				var headerError = false;
				readCommonHeader(that, data, 4, false, function(error) {
					getdataerror(error);
					headerError = true;
				});
				
				if (headerError)
				{
					return;
				}
				
				dataOffset = that.offset + 30 + that.filenameLength + that.extraFieldLength;
				onrangerecieved(that.offset, dataOffset+that.compressedSize);
				
				writer.init(function() {
					if (that.compressionMethod === 0)
					{
						worker = copy(reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
					}
					else if ((that.bitFlag & 0x01) === 0x01 && that.compressionMethod === 99 && that.encryptionHeader && (that.encryptionHeader.method === 0 || that.encryptionHeader.method === 8))
					{
						if (!password)
						{
							getdataerror(ERR_REQUIRED_AES_KEY);	
						}
						else
						{	
							var mode = that.encryptionHeader.strength;
							var saltLen = aesSaltLen(mode); // http://www.winzip.com/aes_info.htm III. Encrypted file storage format
							var keyLen = aesKeyLen(mode);
													
							abort.req = reader.readUint8Array(dataOffset, saltLen + 2, function(bytes) {
								var data = getDataHelper(bytes.length, bytes);
								var salt = data.array.subarray(0, saltLen);
								
								var passwordVerificationValue = data.view.getUint16(saltLen, true); 
								
								var wordSalt = CryptoJS.enc.u8array.parse(salt);							
								var myKey = crypto.PBKDF2(CryptoJS.enc.Utf8.parse(password), wordSalt, ((2*keyLen)+2)/4, 1000);
								
								var keyBytes =  CryptoJS.enc.u8array.stringify(myKey);
								if (!isTypedArraysSupported)	// IE
								{
									var b = new bin.DataBuffer();
									b.attachData(keyBytes);
									keyBytes = b;
								}
																
								var computedPVV = getDataHelper(keyBytes.length, keyBytes).view.getUint16(keyLen*2,true);
								
								if (computedPVV === passwordVerificationValue) // password is probably correct ( 1/65556)
								{
									//console.log("password is probably correct");
									var aesKey = CryptoJS.enc.u8array.parse(keyBytes.subarray(0, keyLen));
									var hmacKey = CryptoJS.enc.u8array.parse(keyBytes.subarray(keyLen, keyLen+keyLen));
									
									var aesDecryptor = CryptoJS.algo.AES.createDecryptor(aesKey, 
									{ 
										iv :  CryptoJS.enc.u8array.parse([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]), 
										mode: CryptoJS.mode.CTRGladman, 
										padding: CryptoJS.pad.NoPadding
									});
									
									 var hmacHasher = new crypto.HMACSha1(hmacKey);
									 //var cmphmacHasher= CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA1, hmacKey);
									
									abort.req = reader.readUint8Array(dataOffset+that.compressedSize-10,  10, function(hmacChkSum)
									{
										if (that.encryptionHeader.method === 0)
										{
											worker = aesCopy(
												reader, writer, dataOffset+saltLen+2, that.compressedSize - 10 -saltLen-2, getWriterData, 
												onprogress, onreaderror, onwriteerror, aesDecryptor, hmacHasher, hmacChkSum, wrongpassword
												);
										}
										else // 8
										{
											worker = aesInflate(
												reader, writer, dataOffset+saltLen+2, that.compressedSize - 10 -saltLen-2, checkCrc32, getWriterData, 
												onprogress, onreaderror, onwriteerror, aesDecryptor, hmacHasher, hmacChkSum, wrongpassword
												);
										}	
									}, onreaderror);	
								}
								else
								{
									getdataerror(ERR_AES_WRONG_PASSWORD);
								}
								
							}, onreaderror);	
						}
					}
					else if (that.compressionMethod === 8)
					{
						worker = inflate(reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror, that.filename);
					}
					else
					{
						getdataerror(ERR_COMPRESION_METHOD);			
					}
				}, onwriteerror);
			}, onreaderror);
			worker = abort;
			
			
			return function()
			{
				//vitrium.log.debug("zip abort: "+that.filename);
				terminate();
			};
	}
	
	function seekEOCDR(reader, offset, entriesCallback, onerror) {

	   var abortHandle = new AbortHandler();
		abortHandle.req = reader.readUint8Array(reader.size - offset, offset, function(bytes) {
			var dataView = getDataHelper(bytes.length, bytes).view;
			if (dataView.getUint32(0) != 0x504b0506) {
			   abortHandle.req = seekEOCDR(reader, offset + 1, entriesCallback, onerror);
			} else {
				entriesCallback(dataView);
			}
		}, onerror);

		return abortHandle;
	}
	
	function ZipEntry()
	{
		this.filename = null;
		this.version = null;
		this.bitFlag = null;
		this.compressionMethod = null;
		this.lastModDateRaw = null;
		this.lastModDate = null;
		this.crc32 = null;
		this.compressedSize = null;
		this.uncompressedSize = null;
		this.filenameLength = null;
		this.extraFieldLength = null;
		this.directory = null;
		this.offset = null;
		this.comment = null;
		this.commentLength = null;
		this.encryptionHeader = null;
	};
	
	function readEntries(reader, callback, onerror) {
				if (!reader)
				{
					onerror("reader must be specified");
					return;
				}
	
				if (reader.size < 22) {
					onerror(ERR_BAD_FORMAT);
					return;
				}
	   // look for End of central directory record
      
				var abortHandle = seekEOCDR(reader, 22, function(dataView) {
					var datalength = dataView.getUint32(16, true);
					var fileslength = dataView.getUint16(8, true);
					
					abortHandle.req = reader.readUint8Array(datalength, reader.size - datalength, function(bytes) 
					{
						var len = fileslength;
						var i, index = 0, entries = new Array(len), entry, filename, comment, data = getDataHelper(bytes.length, bytes);
						for (var i = 0; i < len; ++i)
						{
							entry = new ZipEntry();
							if (data.view.getUint32(index) != 0x504b0102) {
								onerror(ERR_BAD_FORMAT);
								return;
							}
							readCommonHeader(entry, data, index + 6, true, function(error) {
								onerror(error);
								return;
							});
							entry.commentLength = data.view.getUint16(index + 32, true);
							entry.directory = ((data.view.getUint8(index + 38) & 0x10) == 0x10);
							entry.offset = data.view.getUint32(index + 42, true);
							filename = getString(data.array.subarray(index + 46, index + 46 + entry.filenameLength));
							entry.filename = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(filename) : decodeASCII(filename);
							if (entry.bitFlag & 0x01 === 0x01)
							{
								entry.encryptionHeader = parseEncryptionHeader(data, index + 46 + entry.filenameLength, entry.extraFieldLength);
								
								if (entry.encryptionHeader === null)
								{
									onerror(ERR_AES_HEADER_MISSING);
									return;
								}
							}
							
							
							if (!entry.directory && entry.filename.charAt(entry.filename.length - 1) == "/")
								entry.directory = true;
							comment = getString(data.array.subarray(index + 46 + entry.filenameLength + entry.extraFieldLength, index + 46
									+ entry.filenameLength + entry.extraFieldLength + entry.commentLength));
							entry.comment = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(comment) : decodeASCII(comment);
							entries[i] = entry;
							index += 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength;
						}
						callback(entries);
					},
					onerror);
				}, onerror);

				return abortHandle;
	}

	// ZipWriter

	function encodeUTF8(string) {
		var n, c1, enc, utftext = [], start = 0, end = 0, stringl = string.length;
		for (n = 0; n < stringl; n++) {
			c1 = string.charCodeAt(n);
			enc = null;
			if (c1 < 128)
				end++;
			else if (c1 > 127 && c1 < 2048)
				enc = String.fromCharCode((c1 >> 6) | 192) + String.fromCharCode((c1 & 63) | 128);
			else
				enc = String.fromCharCode((c1 >> 12) | 224) + String.fromCharCode(((c1 >> 6) & 63) | 128) + String.fromCharCode((c1 & 63) | 128);
			if (enc != null) {
				if (end > start)
					utftext += string.slice(start, end);
				utftext += enc;
				start = end = n + 1;
			}
		}
		if (end > start)
			utftext += string.slice(start, stringl);
		return utftext;
	}

	function getBytes(str) {
		var i, array = [];
		for (i = 0; i < str.length; i++)
			array.push(str.charCodeAt(i));
		return array;
	}

		
	function AbortHandler()
	{
		this.req = null;
		this.worker = null;
	}
	
	AbortHandler.prototype.terminate =  function()
	{
		if(this.req) this.req.abort();
		if(this.worker) this.worker.terminate();
	};
	AbortHandler.prototype.abort = AbortHandler.prototype.terminate; 

	zip.readEntries = readEntries;
  zip.readEntry = readEntry;
	zip.errors = {
      ERR_BAD_FORMAT:  ERR_BAD_FORMAT, 
      ERR_ENCRYPTED : ERR_ENCRYPTED,
      ERR_ZIP64 : ERR_ZIP64, 
      ERR_READ : ERR_READ, 
      ERR_WRITE : ERR_WRITE, 
      ERR_WRITE_DATA : ERR_WRITE_DATA,
      ERR_READ_DATA : ERR_READ_DATA, 
      ERR_DUPLICATED_NAME : ERR_DUPLICATED_NAME, 
      ERR_HTTP_RANGE : ERR_HTTP_RANGE, 
      ERR_AES_HEADER_MISSING : ERR_AES_HEADER_MISSING, 
      ERR_COMPRESION_METHOD : ERR_COMPRESION_METHOD, 
      ERR_REQUIRED_AES_KEY  : ERR_REQUIRED_AES_KEY, 
      ERR_AES_UNKNOWN_STRENGTH : ERR_AES_UNKNOWN_STRENGTH, 
      ERR_AES_WRONG_PASSWORD : ERR_AES_WRONG_PASSWORD
    };
}
(
vitrium.zip, 
CRC32, 
vitrium.bin,
vitrium.crypto,
CryptoJS,
__globals__
));



// script:viewer/io/inflate-old.js
/*
 Copyright (c) 2012 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.
 * JZlib is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */
 
(function(zip, globals) {

	var arrayTypeCreator;
	var int32arrayCreator;
	if (typeof globals.Uint8Array === "function" || typeof globals.Uint8Array === "object")
	{
		return;
	}
	else
	{
		arrayTypeCreator = function (argument) {
			var result;
			if (typeof argument == "number")
			{
				result = new Array(argument);
				for (var i = 0; i < argument; ++i)
				{
					result[i] = 0;
				}
			}
			else
			{
				result = new Array(argument.length);
				for(var i = 0; i < argument.length; ++i)
				{
					if (argument.readNumber)
					{
						result[i] = argument.readNumber(1,i);
					}
					else
					{
						result[i] = argument[i];
					}
				}
			}
			
			result.subarray = function(start, end)
			{
				if (arguments.length < 1) { start = 0; }
                if (arguments.length < 2) { end = this.length; } 
				
				
				return this.slice(start, end);
			};
			result.set = function(chunk, bufferIndex)
			{	
				if (!bufferIndex)
					bufferIndex = 0;
					
				var self = this;
				for(var i = 0; i < chunk.length; ++i)
				{
					self[i+bufferIndex] = chunk[i];
				}
				return this;
			};
			
			
			
			return result;
		};
		
		int32arrayCreator = arrayTypeCreator;
	}
	// Global
	var MAX_BITS = 15;

	var Z_OK = 0;
	var Z_STREAM_END = 1;
	var Z_NEED_DICT = 2;
	var Z_STREAM_ERROR = -2;
	var Z_DATA_ERROR = -3;
	var Z_MEM_ERROR = -4;
	var Z_BUF_ERROR = -5;

	var inflate_mask = [ 0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff,
			0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff ];

	var MANY = 1440;

	// JZlib version : "1.0.2"
	var Z_NO_FLUSH = 0;
	var Z_FINISH = 4;

	// InfTree
	var fixed_bl = 9;
	var fixed_bd = 5;

	var fixed_tl = [ 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0,
			0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40,
			0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13,
			0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60,
			0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7,
			35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8,
			26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80,
			7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0,
			8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0,
			8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97,
			0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210,
			81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117,
			0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154,
			84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83,
			0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230,
			80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139,
			0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174,
			0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111,
			0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9,
			193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8,
			120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8,
			227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8,
			92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9,
			249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8,
			130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9,
			181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8,
			102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9,
			221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0,
			8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9,
			147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8,
			85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9,
			235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8,
			141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9,
			167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8,
			107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9,
			207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8,
			127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255 ];
	var fixed_td = [ 80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5,
			8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5,
			24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577 ];

	// Tables for deflate from PKZIP's appnote.txt.
	var cplens = [ // Copy lengths for literal codes 257..285
	3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];

	// see note #13 above about 258
	var cplext = [ // Extra bits for literal codes 257..285
	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112 // 112==invalid
	];

	var cpdist = [ // Copy offsets for distance codes 0..29
	1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];

	var cpdext = [ // Extra bits for distance codes
	0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];

	// If BMAX needs to be larger than 16, then h and x[] should be uLong.
	var BMAX = 15; // maximum bit length of any code

	function InfTree() {
		var that = this;

		var hn; // hufts used in space
		var v; // work area for huft_build
		var c; // bit length count table
		var r; // table entry for structure assignment
		var u; // table stack
		var x; // bit offsets, then code stack

		function huft_build(b, // code lengths in bits (all assumed <=
		// BMAX)
		bindex, n, // number of codes (assumed <= 288)
		s, // number of simple-valued codes (0..s-1)
		d, // list of base values for non-simple codes
		e, // list of extra bits for non-simple codes
		t, // result: starting table
		m, // maximum lookup bits, returns actual
		hp,// space for trees
		hn,// hufts used in space
		v // working area: values in order of bit length
		) {
			// Given a list of code lengths and a maximum table size, make a set of
			// tables to decode that set of codes. Return Z_OK on success,
			// Z_BUF_ERROR
			// if the given code set is incomplete (the tables are still built in
			// this
			// case), Z_DATA_ERROR if the input is invalid (an over-subscribed set
			// of
			// lengths), or Z_MEM_ERROR if not enough memory.

			var a; // counter for codes of length k
			var f; // i repeats in table every f entries
			var g; // maximum code length
			var h; // table level
			var i; // counter, current code
			var j; // counter
			var k; // number of bits in current code
			var l; // bits per table (returned in m)
			var mask; // (1 << w) - 1, to avoid cc -O bug on HP
			var p; // pointer into c[], b[], or v[]
			var q; // points to current table
			var w; // bits before this table == (l * h)
			var xp; // pointer into x
			var y; // number of dummy codes added
			var z; // number of entries in current table

			// Generate counts for each bit length

			p = 0;
			i = n;
			do {
				c[b[bindex + p]]++;
				p++;
				i--; // assume all entries <= BMAX
			} while (i !== 0);

			if (c[0] == n) { // null input--all zero length codes
				t[0] = -1;
				m[0] = 0;
				return Z_OK;
			}

			// Find minimum and maximum length, bound *m by those
			l = m[0];
			for (j = 1; j <= BMAX; j++)
				if (c[j] !== 0)
					break;
			k = j; // minimum code length
			if (l < j) {
				l = j;
			}
			for (i = BMAX; i !== 0; i--) {
				if (c[i] !== 0)
					break;
			}
			g = i; // maximum code length
			if (l > i) {
				l = i;
			}
			m[0] = l;

			// Adjust last length count to fill out codes, if needed
			for (y = 1 << j; j < i; j++, y <<= 1) {
				if ((y -= c[j]) < 0) {
					return Z_DATA_ERROR;
				}
			}
			if ((y -= c[i]) < 0) {
				return Z_DATA_ERROR;
			}
			c[i] += y;

			// Generate starting offsets into the value table for each length
			x[1] = j = 0;
			p = 1;
			xp = 2;
			while (--i !== 0) { // note that i == g from above
				x[xp] = (j += c[p]);
				xp++;
				p++;
			}

			// Make a table of values in order of bit lengths
			i = 0;
			p = 0;
			do {
				if ((j = b[bindex + p]) !== 0) {
					v[x[j]++] = i;
				}
				p++;
			} while (++i < n);
			n = x[g]; // set n to length of v

			// Generate the Huffman codes and for each, make the table entries
			x[0] = i = 0; // first Huffman code is zero
			p = 0; // grab values in bit order
			h = -1; // no tables yet--level -1
			w = -l; // bits decoded == (l * h)
			u[0] = 0; // just to keep compilers happy
			q = 0; // ditto
			z = 0; // ditto

			// go through the bit lengths (k already is bits in shortest code)
			for (; k <= g; k++) {
				a = c[k];
				while (a-- !== 0) {
					// here i is the Huffman code of length k bits for value *p
					// make tables up to required level
					while (k > w + l) {
						h++;
						w += l; // previous table always l bits
						// compute minimum size table less than or equal to l bits
						z = g - w;
						z = (z > l) ? l : z; // table size upper limit
						if ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table
							// too few codes for
							// k-w bit table
							f -= a + 1; // deduct codes from patterns left
							xp = k;
							if (j < z) {
								while (++j < z) { // try smaller tables up to z bits
									if ((f <<= 1) <= c[++xp])
										break; // enough codes to use up j bits
									f -= c[xp]; // else deduct codes from patterns
								}
							}
						}
						z = 1 << j; // table entries for j-bit table

						// allocate new table
						if (hn[0] + z > MANY) { // (note: doesn't matter for fixed)
							return Z_DATA_ERROR; // overflow of MANY
						}
						u[h] = q = /* hp+ */hn[0]; // DEBUG
						hn[0] += z;

						// connect to last table, if there is one
						if (h !== 0) {
							x[h] = i; // save pattern for backing up
							r[0] = /* (byte) */j; // bits in this table
							r[1] = /* (byte) */l; // bits to dump before this table
							j = i >>> (w - l);
							r[2] = /* (int) */(q - u[h - 1] - j); // offset to this table
							hp.set(r, (u[h - 1] + j) * 3);
							// to
							// last
							// table
						} else {
							t[0] = q; // first table is returned result
						}
					}

					// set up table entry in r
					r[1] = /* (byte) */(k - w);
					if (p >= n) {
						r[0] = 128 + 64; // out of values--invalid code
					} else if (v[p] < s) {
						r[0] = /* (byte) */(v[p] < 256 ? 0 : 32 + 64); // 256 is
						// end-of-block
						r[2] = v[p++]; // simple code is just the value
					} else {
						r[0] = /* (byte) */(e[v[p] - s] + 16 + 64); // non-simple--look
						// up in lists
						r[2] = d[v[p++] - s];
					}

					// fill code-like entries with r
					f = 1 << (k - w);
					for (j = i >>> w; j < z; j += f) {
						hp.set(r, (q + j) * 3);
					}

					// backwards increment the k-bit code i
					for (j = 1 << (k - 1); (i & j) !== 0; j >>>= 1) {
						i ^= j;
					}
					i ^= j;

					// backup over finished tables
					mask = (1 << w) - 1; // needed on HP, cc -O bug
					while ((i & mask) != x[h]) {
						h--; // don't need to update q
						w -= l;
						mask = (1 << w) - 1;
					}
				}
			}
			// Return Z_BUF_ERROR if we were given an incomplete table
			return y !== 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
		}

		function initWorkArea(vsize) {
			var i;
			if (!hn) {
				hn = []; // []; //new Array(1);
				v = []; // new Array(vsize);
				c = int32arrayCreator(BMAX + 1); // new Array(BMAX + 1);
				r = []; // new Array(3);
				u = int32arrayCreator(BMAX); // new Array(BMAX);
				x = int32arrayCreator(BMAX + 1); // new Array(BMAX + 1);
			}
			if (v.length < vsize) {
				v = []; // new Array(vsize);
			}
			for (i = 0; i < vsize; i++) {
				v[i] = 0;
			}
			for (i = 0; i < BMAX + 1; i++) {
				c[i] = 0;
			}
			for (i = 0; i < 3; i++) {
				r[i] = 0;
			}
			// for(int i=0; i<BMAX; i++){u[i]=0;}
			u.set(c.subarray(0, BMAX), 0);
			// for(int i=0; i<BMAX+1; i++){x[i]=0;}
			x.set(c.subarray(0, BMAX + 1), 0);
		}

		that.inflate_trees_bits = function(c, // 19 code lengths
		bb, // bits tree desired/actual depth
		tb, // bits tree result
		hp, // space for trees
		z // for messages
		) {
			var result;
			initWorkArea(19);
			hn[0] = 0;
			result = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);

			if (result == Z_DATA_ERROR) {
				z.msg = "oversubscribed dynamic bit lengths tree";
			} else if (result == Z_BUF_ERROR || bb[0] === 0) {
				z.msg = "incomplete dynamic bit lengths tree";
				result = Z_DATA_ERROR;
			}
			return result;
		};

		that.inflate_trees_dynamic = function(nl, // number of literal/length codes
		nd, // number of distance codes
		c, // that many (total) code lengths
		bl, // literal desired/actual bit depth
		bd, // distance desired/actual bit depth
		tl, // literal/length tree result
		td, // distance tree result
		hp, // space for trees
		z // for messages
		) {
			var result;

			// build literal/length tree
			initWorkArea(288);
			hn[0] = 0;
			result = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);
			if (result != Z_OK || bl[0] === 0) {
				if (result == Z_DATA_ERROR) {
					z.msg = "oversubscribed literal/length tree";
				} else if (result != Z_MEM_ERROR) {
					z.msg = "incomplete literal/length tree";
					result = Z_DATA_ERROR;
				}
				return result;
			}

			// build distance tree
			initWorkArea(288);
			result = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);

			if (result != Z_OK || (bd[0] === 0 && nl > 257)) {
				if (result == Z_DATA_ERROR) {
					z.msg = "oversubscribed distance tree";
				} else if (result == Z_BUF_ERROR) {
					z.msg = "incomplete distance tree";
					result = Z_DATA_ERROR;
				} else if (result != Z_MEM_ERROR) {
					z.msg = "empty distance tree with lengths";
					result = Z_DATA_ERROR;
				}
				return result;
			}

			return Z_OK;
		};

	}

	InfTree.inflate_trees_fixed = function(bl, // literal desired/actual bit depth
	bd, // distance desired/actual bit depth
	tl,// literal/length tree result
	td// distance tree result
	) {
		bl[0] = fixed_bl;
		bd[0] = fixed_bd;
		tl[0] = fixed_tl;
		td[0] = fixed_td;
		return Z_OK;
	};

	// InfCodes

	// waiting for "i:"=input,
	// "o:"=output,
	// "x:"=nothing
	var START = 0; // x: set up for LEN
	var LEN = 1; // i: get length/literal/eob next
	var LENEXT = 2; // i: getting length extra (have base)
	var DIST = 3; // i: get distance next
	var DISTEXT = 4;// i: getting distance extra
	var COPY = 5; // o: copying bytes in window, waiting
	// for space
	var LIT = 6; // o: got literal, waiting for output
	// space
	var WASH = 7; // o: got eob, possibly still output
	// waiting
	var END = 8; // x: got eob and all data flushed
	var BADCODE = 9;// x: got error

	function InfCodes() {
		var that = this;

		var mode; // current inflate_codes mode

		// mode dependent information
		var len = 0;

		var tree; // pointer into tree
		var tree_index = 0;
		var need = 0; // bits needed

		var lit = 0;

		// if EXT or COPY, where and how much
		var get = 0; // bits to get for extra
		var dist = 0; // distance back to copy from

		var lbits = 0; // ltree bits decoded per branch
		var dbits = 0; // dtree bits decoder per branch
		var ltree; // literal/length/eob tree
		var ltree_index = 0; // literal/length/eob tree
		var dtree; // distance tree
		var dtree_index = 0; // distance tree

		// Called with number of bytes left to write in window at least 258
		// (the maximum string length) and number of input bytes available
		// at least ten. The ten bytes are six bytes for the longest length/
		// distance pair plus four bytes for overloading the bit buffer.

		function inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {
			var t; // temporary pointer
			var tp; // temporary pointer
			var tp_index; // temporary pointer
			var e; // extra bits or operation
			var b; // bit buffer
			var k; // bits in bit buffer
			var p; // input data pointer
			var n; // bytes available there
			var q; // output window write pointer
			var m; // bytes to end of window or read pointer
			var ml; // mask for literal/length tree
			var md; // mask for distance tree
			var c; // bytes to copy
			var d; // distance back to copy from
			var r; // copy source pointer

			var tp_index_t_3; // (tp_index+t)*3

			// load input, output, bit values
			p = z.next_in_index;
			n = z.avail_in;
			b = s.bitb;
			k = s.bitk;
			q = s.write;
			m = q < s.read ? s.read - q - 1 : s.end - q;

			// initialize masks
			ml = inflate_mask[bl];
			md = inflate_mask[bd];

			// do until not enough input or output space for fast loop
			do { // assume called with m >= 258 && n >= 10
				// get literal/length code
				while (k < (20)) { // max bits for literal/length code
					n--;
					b |= (z.read_byte(p++) & 0xff) << k;
					k += 8;
				}

				t = b & ml;
				tp = tl;
				tp_index = tl_index;
				tp_index_t_3 = (tp_index + t) * 3;
				if ((e = tp[tp_index_t_3]) === 0) {
					b >>= (tp[tp_index_t_3 + 1]);
					k -= (tp[tp_index_t_3 + 1]);

					s.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];
					m--;
					continue;
				}
				do {

					b >>= (tp[tp_index_t_3 + 1]);
					k -= (tp[tp_index_t_3 + 1]);

					if ((e & 16) !== 0) {
						e &= 15;
						c = tp[tp_index_t_3 + 2] + (/* (int) */b & inflate_mask[e]);

						b >>= e;
						k -= e;

						// decode distance base of block to copy
						while (k < (15)) { // max bits for distance code
							n--;
							b |= (z.read_byte(p++) & 0xff) << k;
							k += 8;
						}

						t = b & md;
						tp = td;
						tp_index = td_index;
						tp_index_t_3 = (tp_index + t) * 3;
						e = tp[tp_index_t_3];

						do {

							b >>= (tp[tp_index_t_3 + 1]);
							k -= (tp[tp_index_t_3 + 1]);

							if ((e & 16) !== 0) {
								// get extra bits to add to distance base
								e &= 15;
								while (k < (e)) { // get extra bits (up to 13)
									n--;
									b |= (z.read_byte(p++) & 0xff) << k;
									k += 8;
								}

								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);

								b >>= (e);
								k -= (e);

								// do the copy
								m -= c;
								if (q >= d) { // offset before dest
									// just copy
									r = q - d;
									if (q - r > 0 && 2 > (q - r)) {
										s.window[q++] = s.window[r++]; // minimum
										// count is
										// three,
										s.window[q++] = s.window[r++]; // so unroll
										// loop a
										// little
										c -= 2;
									} else {
										s.window.set(s.window.subarray(r, r + 2), q);
										q += 2;
										r += 2;
										c -= 2;
									}
								} else { // else offset after destination
									r = q - d;
									do {
										r += s.end; // force pointer in window
									} while (r < 0); // covers invalid distances
									e = s.end - r;
									if (c > e) { // if source crosses,
										c -= e; // wrapped copy
										if (q - r > 0 && e > (q - r)) {
											do {
												s.window[q++] = s.window[r++];
											} while (--e !== 0);
										} else {
											s.window.set(s.window.subarray(r, r + e), q);
											q += e;
											r += e;
											e = 0;
										}
										r = 0; // copy rest from start of window
									}

								}

								// copy all or what's left
								if (q - r > 0 && c > (q - r)) {
									do {
										s.window[q++] = s.window[r++];
									} while (--c !== 0);
								} else {
									s.window.set(s.window.subarray(r, r + c), q);
									q += c;
									r += c;
									c = 0;
								}
								break;
							} else if ((e & 64) === 0) {
								t += tp[tp_index_t_3 + 2];
								t += (b & inflate_mask[e]);
								tp_index_t_3 = (tp_index + t) * 3;
								e = tp[tp_index_t_3];
							} else {
								z.msg = "invalid distance code";

								c = z.avail_in - n;
								c = (k >> 3) < c ? k >> 3 : c;
								n += c;
								p -= c;
								k -= c << 3;

								s.bitb = b;
								s.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								s.write = q;

								return Z_DATA_ERROR;
							}
						} while (true);
						break;
					}

					if ((e & 64) === 0) {
						t += tp[tp_index_t_3 + 2];
						t += (b & inflate_mask[e]);
						tp_index_t_3 = (tp_index + t) * 3;
						if ((e = tp[tp_index_t_3]) === 0) {

							b >>= (tp[tp_index_t_3 + 1]);
							k -= (tp[tp_index_t_3 + 1]);

							s.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];
							m--;
							break;
						}
					} else if ((e & 32) !== 0) {

						c = z.avail_in - n;
						c = (k >> 3) < c ? k >> 3 : c;
						n += c;
						p -= c;
						k -= c << 3;

						s.bitb = b;
						s.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						s.write = q;

						return Z_STREAM_END;
					} else {
						z.msg = "invalid literal/length code";

						c = z.avail_in - n;
						c = (k >> 3) < c ? k >> 3 : c;
						n += c;
						p -= c;
						k -= c << 3;

						s.bitb = b;
						s.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						s.write = q;

						return Z_DATA_ERROR;
					}
				} while (true);
			} while (m >= 258 && n >= 10);

			// not enough input or output--restore pointers and return
			c = z.avail_in - n;
			c = (k >> 3) < c ? k >> 3 : c;
			n += c;
			p -= c;
			k -= c << 3;

			s.bitb = b;
			s.bitk = k;
			z.avail_in = n;
			z.total_in += p - z.next_in_index;
			z.next_in_index = p;
			s.write = q;

			return Z_OK;
		}

		that.init = function(bl, bd, tl, tl_index, td, td_index) {
			mode = START;
			lbits = /* (byte) */bl;
			dbits = /* (byte) */bd;
			ltree = tl;
			ltree_index = tl_index;
			dtree = td;
			dtree_index = td_index;
			tree = null;
		};

		that.proc = function(s, z, r) {
			var j; // temporary storage
			var tindex; // temporary pointer
			var e; // extra bits or operation
			var b = 0; // bit buffer
			var k = 0; // bits in bit buffer
			var p = 0; // input data pointer
			var n; // bytes available there
			var q; // output window write pointer
			var m; // bytes to end of window or read pointer
			var f; // pointer to copy strings from

			// copy input/output information to locals (UPDATE macro restores)
			p = z.next_in_index;
			n = z.avail_in;
			b = s.bitb;
			k = s.bitk;
			q = s.write;
			m = q < s.read ? s.read - q - 1 : s.end - q;

			// process input and output based on current state
			while (true) {
				switch (mode) {
				// waiting for "i:"=input, "o:"=output, "x:"=nothing
				case START: // x: set up for LEN
					if (m >= 258 && n >= 10) {

						s.bitb = b;
						s.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						s.write = q;
						r = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);

						p = z.next_in_index;
						n = z.avail_in;
						b = s.bitb;
						k = s.bitk;
						q = s.write;
						m = q < s.read ? s.read - q - 1 : s.end - q;

						if (r != Z_OK) {
							mode = r == Z_STREAM_END ? WASH : BADCODE;
							break;
						}
					}
					need = lbits;
					tree = ltree;
					tree_index = ltree_index;

					mode = LEN;
				case LEN: // i: get length/literal/eob next
					j = need;

					while (k < (j)) {
						if (n !== 0)
							r = Z_OK;
						else {

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;
							return s.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					tindex = (tree_index + (b & inflate_mask[j])) * 3;

					b >>>= (tree[tindex + 1]);
					k -= (tree[tindex + 1]);

					e = tree[tindex];

					if (e === 0) { // literal
						lit = tree[tindex + 2];
						mode = LIT;
						break;
					}
					if ((e & 16) !== 0) { // length
						get = e & 15;
						len = tree[tindex + 2];
						mode = LENEXT;
						break;
					}
					if ((e & 64) === 0) { // next table
						need = e;
						tree_index = tindex / 3 + tree[tindex + 2];
						break;
					}
					if ((e & 32) !== 0) { // end of block
						mode = WASH;
						break;
					}
					mode = BADCODE; // invalid code
					z.msg = "invalid literal/length code";
					r = Z_DATA_ERROR;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);

				case LENEXT: // i: getting length extra (have base)
					j = get;

					while (k < (j)) {
						if (n !== 0)
							r = Z_OK;
						else {

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;
							return s.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					len += (b & inflate_mask[j]);

					b >>= j;
					k -= j;

					need = dbits;
					tree = dtree;
					tree_index = dtree_index;
					mode = DIST;
				case DIST: // i: get distance next
					j = need;

					while (k < (j)) {
						if (n !== 0)
							r = Z_OK;
						else {

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;
							return s.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					tindex = (tree_index + (b & inflate_mask[j])) * 3;

					b >>= tree[tindex + 1];
					k -= tree[tindex + 1];

					e = (tree[tindex]);
					if ((e & 16) !== 0) { // distance
						get = e & 15;
						dist = tree[tindex + 2];
						mode = DISTEXT;
						break;
					}
					if ((e & 64) === 0) { // next table
						need = e;
						tree_index = tindex / 3 + tree[tindex + 2];
						break;
					}
					mode = BADCODE; // invalid code
					z.msg = "invalid distance code";
					r = Z_DATA_ERROR;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);

				case DISTEXT: // i: getting distance extra
					j = get;

					while (k < (j)) {
						if (n !== 0)
							r = Z_OK;
						else {

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;
							return s.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					dist += (b & inflate_mask[j]);

					b >>= j;
					k -= j;

					mode = COPY;
				case COPY: // o: copying bytes in window, waiting for space
					f = q - dist;
					while (f < 0) { // modulo window size-"while" instead
						f += s.end; // of "if" handles invalid distances
					}
					while (len !== 0) {

						if (m === 0) {
							if (q == s.end && s.read !== 0) {
								q = 0;
								m = q < s.read ? s.read - q - 1 : s.end - q;
							}
							if (m === 0) {
								s.write = q;
								r = s.inflate_flush(z, r);
								q = s.write;
								m = q < s.read ? s.read - q - 1 : s.end - q;

								if (q == s.end && s.read !== 0) {
									q = 0;
									m = q < s.read ? s.read - q - 1 : s.end - q;
								}

								if (m === 0) {
									s.bitb = b;
									s.bitk = k;
									z.avail_in = n;
									z.total_in += p - z.next_in_index;
									z.next_in_index = p;
									s.write = q;
									return s.inflate_flush(z, r);
								}
							}
						}

						s.window[q++] = s.window[f++];
						m--;

						if (f == s.end)
							f = 0;
						len--;
					}
					mode = START;
					break;
				case LIT: // o: got literal, waiting for output space
					if (m === 0) {
						if (q == s.end && s.read !== 0) {
							q = 0;
							m = q < s.read ? s.read - q - 1 : s.end - q;
						}
						if (m === 0) {
							s.write = q;
							r = s.inflate_flush(z, r);
							q = s.write;
							m = q < s.read ? s.read - q - 1 : s.end - q;

							if (q == s.end && s.read !== 0) {
								q = 0;
								m = q < s.read ? s.read - q - 1 : s.end - q;
							}
							if (m === 0) {
								s.bitb = b;
								s.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								s.write = q;
								return s.inflate_flush(z, r);
							}
						}
					}
					r = Z_OK;

					s.window[q++] = /* (byte) */lit;
					m--;

					mode = START;
					break;
				case WASH: // o: got eob, possibly more output
					if (k > 7) { // return unused byte, if any
						k -= 8;
						n++;
						p--; // can always return one
					}

					s.write = q;
					r = s.inflate_flush(z, r);
					q = s.write;
					m = q < s.read ? s.read - q - 1 : s.end - q;

					if (s.read != s.write) {
						s.bitb = b;
						s.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						s.write = q;
						return s.inflate_flush(z, r);
					}
					mode = END;
				case END:
					r = Z_STREAM_END;
					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);

				case BADCODE: // x: got error

					r = Z_DATA_ERROR;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);

				default:
					r = Z_STREAM_ERROR;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);
				}
			}
		};

		that.free = function() {
			// ZFREE(z, c);
		};

	}

	// InfBlocks

	// Table for deflate from PKZIP's appnote.txt.
	var border = [ // Order of the bit length code lengths
	16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];

	var TYPE = 0; // get type bits (3, including end bit)
	var LENS = 1; // get lengths for stored
	var STORED = 2;// processing stored block
	var TABLE = 3; // get table lengths
	var BTREE = 4; // get bit lengths tree for a dynamic
	// block
	var DTREE = 5; // get length, distance trees for a
	// dynamic block
	var CODES = 6; // processing fixed or dynamic block
	var DRY = 7; // output remaining window bytes
	var DONELOCKS = 8; // finished last block, done
	var BADBLOCKS = 9; // ot a data error--stuck here

	function InfBlocks(z, w) {
		var that = this;

		var mode = TYPE; // current inflate_block mode

		var left = 0; // if STORED, bytes left to copy

		var table = 0; // table lengths (14 bits)
		var index = 0; // index into blens (or border)
		var blens; // bit lengths of codes
		var bb = [ 0 ]; // bit length tree depth
		var tb = [ 0 ]; // bit length decoding tree

		var codes = new InfCodes(); // if CODES, current state

		var last = 0; // true if this block is the last block

		var hufts = int32arrayCreator(MANY * 3); // single malloc for tree space
		var check = 0; // check on output
		var inftree = new InfTree();

		that.bitk = 0; // bits in bit buffer
		that.bitb = 0; // bit buffer
		that.window = arrayTypeCreator(w); // sliding window
		that.end = w; // one byte after sliding window
		that.read = 0; // window read pointer
		that.write = 0; // window write pointer

		that.reset = function(z, c) {
			if (c)
				c[0] = check;
			// if (mode == BTREE || mode == DTREE) {
			// }
			if (mode == CODES) {
				codes.free(z);
			}
			mode = TYPE;
			that.bitk = 0;
			that.bitb = 0;
			that.read = that.write = 0;
		};

		that.reset(z, null);

		// copy as much as possible from the sliding window to the output area
		that.inflate_flush = function(z, r) {
			var n;
			var p;
			var q;

			// local copies of source and destination pointers
			p = z.next_out_index;
			q = that.read;

			// compute number of bytes to copy as far as end of window
			n = /* (int) */((q <= that.write ? that.write : that.end) - q);
			if (n > z.avail_out)
				n = z.avail_out;
			if (n !== 0 && r == Z_BUF_ERROR)
				r = Z_OK;

			// update counters
			z.avail_out -= n;
			z.total_out += n;

			// copy as far as end of window
			if (z.next_out.insert)
			{
				//JH this is because of opera
				z.next_out = z.next_out.insert(that.window.subarray(q, q + n), p);
			}
			else
			{
				z.next_out.set(that.window.subarray(q, q + n), p);
			}
			
			p += n;
			q += n;

			// see if more to copy at beginning of window
			if (q == that.end) {
				// wrap pointers
				q = 0;
				if (that.write == that.end)
					that.write = 0;

				// compute bytes to copy
				n = that.write - q;
				if (n > z.avail_out)
					n = z.avail_out;
				if (n !== 0 && r == Z_BUF_ERROR)
					r = Z_OK;

				// update counters
				z.avail_out -= n;
				z.total_out += n;

				// copy
				if (z.next_out.insert)
				{
					z.next_out = z.next_out.insert(that.window.subarray(q, q + n), p);
				}
				else
				{
					z.next_out.set(that.window.subarray(q, q + n), p);
				}
				p += n;
				q += n;
			}

			// update pointers
			z.next_out_index = p;
			that.read = q;

			// done
			return r;
		};

		that.proc = function(z, r) {
			var t; // temporary storage
			var b; // bit buffer
			var k; // bits in bit buffer
			var p; // input data pointer
			var n; // bytes available there
			var q; // output window write pointer
			var m; // bytes to end of window or read pointer

			var i;

			// copy input/output information to locals (UPDATE macro restores)
			// {
			p = z.next_in_index;
			n = z.avail_in;
			b = that.bitb;
			k = that.bitk;
			// }
			// {
			q = that.write;
			m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
			// }

			// process input based on current state
			// DEBUG dtree
			while (true) {
				switch (mode) {
				case TYPE:

					while (k < (3)) {
						if (n !== 0) {
							r = Z_OK;
						} else {
							that.bitb = b;
							that.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							that.write = q;
							return that.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}
					t = /* (int) */(b & 7);
					last = t & 1;

					switch (t >>> 1) {
					case 0: // stored
						// {
						b >>>= (3);
						k -= (3);
						// }
						t = k & 7; // go to byte boundary

						// {
						b >>>= (t);
						k -= (t);
						// }
						mode = LENS; // get length of stored block
						break;
					case 1: // fixed
						// {
						var bl = []; // new Array(1);
						var bd = []; // new Array(1);
						var tl = [ [] ]; // new Array(1);
						var td = [ [] ]; // new Array(1);

						InfTree.inflate_trees_fixed(bl, bd, tl, td);
						codes.init(bl[0], bd[0], tl[0], 0, td[0], 0);
						// }

						// {
						b >>>= (3);
						k -= (3);
						// }

						mode = CODES;
						break;
					case 2: // dynamic

						// {
						b >>>= (3);
						k -= (3);
						// }

						mode = TABLE;
						break;
					case 3: // illegal

						// {
						b >>>= (3);
						k -= (3);
						// }
						mode = BADBLOCKS;
						z.msg = "invalid block type";
						r = Z_DATA_ERROR;

						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}
					break;
				case LENS:

					while (k < (32)) {
						if (n !== 0) {
							r = Z_OK;
						} else {
							that.bitb = b;
							that.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							that.write = q;
							return that.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					if ((((~b) >>> 16) & 0xffff) != (b & 0xffff)) {
						mode = BADBLOCKS;
						z.msg = "invalid stored block lengths";
						r = Z_DATA_ERROR;

						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}
					left = (b & 0xffff);
					b = k = 0; // dump bits
					mode = left !== 0 ? STORED : (last !== 0 ? DRY : TYPE);
					break;
				case STORED:
					if (n === 0) {
						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}

					if (m === 0) {
						if (q == that.end && that.read !== 0) {
							q = 0;
							m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
						}
						if (m === 0) {
							that.write = q;
							r = that.inflate_flush(z, r);
							q = that.write;
							m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
							if (q == that.end && that.read !== 0) {
								q = 0;
								m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
							}
							if (m === 0) {
								that.bitb = b;
								that.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								that.write = q;
								return that.inflate_flush(z, r);
							}
						}
					}
					r = Z_OK;

					t = left;
					if (t > n)
						t = n;
					if (t > m)
						t = m;
					that.window.set(z.read_buf(p, t), q);
					p += t;
					n -= t;
					q += t;
					m -= t;
					if ((left -= t) !== 0)
						break;
					mode = last !== 0 ? DRY : TYPE;
					break;
				case TABLE:

					while (k < (14)) {
						if (n !== 0) {
							r = Z_OK;
						} else {
							that.bitb = b;
							that.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							that.write = q;
							return that.inflate_flush(z, r);
						}

						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					table = t = (b & 0x3fff);
					if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {
						mode = BADBLOCKS;
						z.msg = "too many length or distance symbols";
						r = Z_DATA_ERROR;

						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}
					t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
					if (!blens || blens.length < t) {
						blens = []; // new Array(t);
					} else {
						for (i = 0; i < t; i++) {
							blens[i] = 0;
						}
					}

					// {
					b >>>= (14);
					k -= (14);
					// }

					index = 0;
					mode = BTREE;
				case BTREE:
					while (index < 4 + (table >>> 10)) {
						while (k < (3)) {
							if (n !== 0) {
								r = Z_OK;
							} else {
								that.bitb = b;
								that.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								that.write = q;
								return that.inflate_flush(z, r);
							}
							n--;
							b |= (z.read_byte(p++) & 0xff) << k;
							k += 8;
						}

						blens[border[index++]] = b & 7;

						// {
						b >>>= (3);
						k -= (3);
						// }
					}

					while (index < 19) {
						blens[border[index++]] = 0;
					}

					bb[0] = 7;
					t = inftree.inflate_trees_bits(blens, bb, tb, hufts, z);
					if (t != Z_OK) {
						r = t;
						if (r == Z_DATA_ERROR) {
							blens = null;
							mode = BADBLOCKS;
						}

						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}

					index = 0;
					mode = DTREE;
				case DTREE:
					while (true) {
						t = table;
						if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {
							break;
						}

						var j, c;

						t = bb[0];

						while (k < (t)) {
							if (n !== 0) {
								r = Z_OK;
							} else {
								that.bitb = b;
								that.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								that.write = q;
								return that.inflate_flush(z, r);
							}
							n--;
							b |= (z.read_byte(p++) & 0xff) << k;
							k += 8;
						}

						// if (tb[0] == -1) {
						// System.err.println("null...");
						// }

						t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];
						c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];

						if (c < 16) {
							b >>>= (t);
							k -= (t);
							blens[index++] = c;
						} else { // c == 16..18
							i = c == 18 ? 7 : c - 14;
							j = c == 18 ? 11 : 3;

							while (k < (t + i)) {
								if (n !== 0) {
									r = Z_OK;
								} else {
									that.bitb = b;
									that.bitk = k;
									z.avail_in = n;
									z.total_in += p - z.next_in_index;
									z.next_in_index = p;
									that.write = q;
									return that.inflate_flush(z, r);
								}
								n--;
								b |= (z.read_byte(p++) & 0xff) << k;
								k += 8;
							}

							b >>>= (t);
							k -= (t);

							j += (b & inflate_mask[i]);

							b >>>= (i);
							k -= (i);

							i = index;
							t = table;
							if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {
								blens = null;
								mode = BADBLOCKS;
								z.msg = "invalid bit length repeat";
								r = Z_DATA_ERROR;

								that.bitb = b;
								that.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								that.write = q;
								return that.inflate_flush(z, r);
							}

							c = c == 16 ? blens[i - 1] : 0;
							do {
								blens[i++] = c;
							} while (--j !== 0);
							index = i;
						}
					}

					tb[0] = -1;
					// {
					var bl_ = []; // new Array(1);
					var bd_ = []; // new Array(1);
					var tl_ = []; // new Array(1);
					var td_ = []; // new Array(1);
					bl_[0] = 9; // must be <= 9 for lookahead assumptions
					bd_[0] = 6; // must be <= 9 for lookahead assumptions

					t = table;
					t = inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f), blens, bl_, bd_, tl_, td_, hufts, z);

					if (t != Z_OK) {
						if (t == Z_DATA_ERROR) {
							blens = null;
							mode = BADBLOCKS;
						}
						r = t;

						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}
					codes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);
					// }
					mode = CODES;
				case CODES:
					that.bitb = b;
					that.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					that.write = q;

					if ((r = codes.proc(that, z, r)) != Z_STREAM_END) {
						return that.inflate_flush(z, r);
					}
					r = Z_OK;
					codes.free(z);

					p = z.next_in_index;
					n = z.avail_in;
					b = that.bitb;
					k = that.bitk;
					q = that.write;
					m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);

					if (last === 0) {
						mode = TYPE;
						break;
					}
					mode = DRY;
				case DRY:
					that.write = q;
					r = that.inflate_flush(z, r);
					q = that.write;
					m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
					if (that.read != that.write) {
						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}
					mode = DONELOCKS;
				case DONELOCKS:
					r = Z_STREAM_END;

					that.bitb = b;
					that.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					that.write = q;
					return that.inflate_flush(z, r);
				case BADBLOCKS:
					r = Z_DATA_ERROR;

					that.bitb = b;
					that.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					that.write = q;
					return that.inflate_flush(z, r);

				default:
					r = Z_STREAM_ERROR;

					that.bitb = b;
					that.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					that.write = q;
					return that.inflate_flush(z, r);
				}
			}
		};

		that.free = function(z) {
			that.reset(z, null);
			that.window = null;
			hufts = null;
			// ZFREE(z, s);
		};

		that.set_dictionary = function(d, start, n) {
			that.window.set(d.subarray(start, start + n), 0);
			that.read = that.write = n;
		};

		// Returns true if inflate is currently at the end of a block generated
		// by Z_SYNC_FLUSH or Z_FULL_FLUSH.
		that.sync_point = function() {
			return mode == LENS ? 1 : 0;
		};

	}

	// Inflate

	// preset dictionary flag in zlib header
	var PRESET_DICT = 0x20;

	var Z_DEFLATED = 8;

	var METHOD = 0; // waiting for method byte
	var FLAG = 1; // waiting for flag byte
	var DICT4 = 2; // four dictionary check bytes to go
	var DICT3 = 3; // three dictionary check bytes to go
	var DICT2 = 4; // two dictionary check bytes to go
	var DICT1 = 5; // one dictionary check byte to go
	var DICT0 = 6; // waiting for inflateSetDictionary
	var BLOCKS = 7; // decompressing blocks
	var DONE = 12; // finished check, done
	var BAD = 13; // got an error--stay here

	var mark = [ 0, 0, 0xff, 0xff ];

	function Inflate() {
		var that = this;

		that.mode = 0; // current inflate mode

		// mode dependent information
		that.method = 0; // if FLAGS, method byte

		// if CHECK, check values to compare
		that.was = [ 0 ]; // new Array(1); // computed check value
		that.need = 0; // stream check value

		// if BAD, inflateSync's marker bytes count
		that.marker = 0;

		// mode independent information
		that.wbits = 0; // log2(window size) (8..15, defaults to 15)

		// this.blocks; // current inflate_blocks state

		function inflateReset(z) {
			if (!z || !z.istate)
				return Z_STREAM_ERROR;

			z.total_in = z.total_out = 0;
			z.msg = null;
			z.istate.mode = BLOCKS;
			z.istate.blocks.reset(z, null);
			return Z_OK;
		}

		that.inflateEnd = function(z) {
			if (that.blocks)
				that.blocks.free(z);
			that.blocks = null;
			// ZFREE(z, z->state);
			return Z_OK;
		};

		that.inflateInit = function(z, w) {
			z.msg = null;
			that.blocks = null;

			// set window size
			if (w < 8 || w > 15) {
				that.inflateEnd(z);
				return Z_STREAM_ERROR;
			}
			that.wbits = w;

			z.istate.blocks = new InfBlocks(z, 1 << w);

			// reset state
			inflateReset(z);
			return Z_OK;
		};

		that.inflate = function(z, f) {
			var r;
			var b;

			if (!z || !z.istate || !z.next_in)
				return Z_STREAM_ERROR;
			f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
			r = Z_BUF_ERROR;
			while (true) {
				// System.out.println("mode: "+z.istate.mode);
				switch (z.istate.mode) {
				case METHOD:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					if (((z.istate.method = z.read_byte(z.next_in_index++)) & 0xf) != Z_DEFLATED) {
						z.istate.mode = BAD;
						z.msg = "unknown compression method";
						z.istate.marker = 5; // can't try inflateSync
						break;
					}
					if ((z.istate.method >> 4) + 8 > z.istate.wbits) {
						z.istate.mode = BAD;
						z.msg = "invalid window size";
						z.istate.marker = 5; // can't try inflateSync
						break;
					}
					z.istate.mode = FLAG;
				case FLAG:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					b = (z.read_byte(z.next_in_index++)) & 0xff;

					if ((((z.istate.method << 8) + b) % 31) !== 0) {
						z.istate.mode = BAD;
						z.msg = "incorrect header check";
						z.istate.marker = 5; // can't try inflateSync
						break;
					}

					if ((b & PRESET_DICT) === 0) {
						z.istate.mode = BLOCKS;
						break;
					}
					z.istate.mode = DICT4;
				case DICT4:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					z.istate.need = ((z.read_byte(z.next_in_index++) & 0xff) << 24) & 0xff000000;
					z.istate.mode = DICT3;
				case DICT3:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					z.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 16) & 0xff0000;
					z.istate.mode = DICT2;
				case DICT2:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					z.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 8) & 0xff00;
					z.istate.mode = DICT1;
				case DICT1:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					z.istate.need += (z.read_byte(z.next_in_index++) & 0xff);
					z.istate.mode = DICT0;
					return Z_NEED_DICT;
				case DICT0:
					z.istate.mode = BAD;
					z.msg = "need dictionary";
					z.istate.marker = 0; // can try inflateSync
					return Z_STREAM_ERROR;
				case BLOCKS:

					r = z.istate.blocks.proc(z, r);
					if (r == Z_DATA_ERROR) {
						z.istate.mode = BAD;
						z.istate.marker = 0; // can try inflateSync
						break;
					}
					if (r == Z_OK) {
						r = f;
					}
					if (r != Z_STREAM_END) {
						return r;
					}
					r = f;
					z.istate.blocks.reset(z, z.istate.was);
					z.istate.mode = DONE;
				case DONE:
					return Z_STREAM_END;
				case BAD:
					return Z_DATA_ERROR;
				default:
					return Z_STREAM_ERROR;
				}
			}
		};

		that.inflateSetDictionary = function(z, dictionary, dictLength) {
			var index = 0;
			var length = dictLength;
			if (!z || !z.istate || z.istate.mode != DICT0)
				return Z_STREAM_ERROR;

			if (length >= (1 << z.istate.wbits)) {
				length = (1 << z.istate.wbits) - 1;
				index = dictLength - length;
			}
			z.istate.blocks.set_dictionary(dictionary, index, length);
			z.istate.mode = BLOCKS;
			return Z_OK;
		};

		that.inflateSync = function(z) {
			var n; // number of bytes to look at
			var p; // pointer to bytes
			var m; // number of marker bytes found in a row
			var r, w; // temporaries to save total_in and total_out

			// set up
			if (!z || !z.istate)
				return Z_STREAM_ERROR;
			if (z.istate.mode != BAD) {
				z.istate.mode = BAD;
				z.istate.marker = 0;
			}
			if ((n = z.avail_in) === 0)
				return Z_BUF_ERROR;
			p = z.next_in_index;
			m = z.istate.marker;

			// search
			while (n !== 0 && m < 4) {
				if (z.read_byte(p) == mark[m]) {
					m++;
				} else if (z.read_byte(p) !== 0) {
					m = 0;
				} else {
					m = 4 - m;
				}
				p++;
				n--;
			}

			// restore
			z.total_in += p - z.next_in_index;
			z.next_in_index = p;
			z.avail_in = n;
			z.istate.marker = m;

			// return no joy or set up to restart on a new block
			if (m != 4) {
				return Z_DATA_ERROR;
			}
			r = z.total_in;
			w = z.total_out;
			inflateReset(z);
			z.total_in = r;
			z.total_out = w;
			z.istate.mode = BLOCKS;
			return Z_OK;
		};

		// Returns true if inflate is currently at the end of a block generated
		// by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
		// implementation to provide an additional safety check. PPP uses
		// Z_SYNC_FLUSH
		// but removes the length bytes of the resulting empty stored block. When
		// decompressing, PPP checks that at the end of input packet, inflate is
		// waiting for these length bytes.
		that.inflateSyncPoint = function(z) {
			if (!z || !z.istate || !z.istate.blocks)
				return Z_STREAM_ERROR;
			return z.istate.blocks.sync_point();
		};
	}

	// ZStream

	function ZStream() {
	}

	ZStream.prototype = {
		inflateInit : function(bits) {
			var that = this;
			that.istate = new Inflate();
			if (!bits)
				bits = MAX_BITS;
			return that.istate.inflateInit(that, bits);
		},

		inflate : function(f) {
			var that = this;
			if (!that.istate)
				return Z_STREAM_ERROR;
			return that.istate.inflate(that, f);
		},

		inflateEnd : function() {
			var that = this;
			if (!that.istate)
				return Z_STREAM_ERROR;
			var ret = that.istate.inflateEnd(that);
			that.istate = null;
			return ret;
		},

		inflateSync : function() {
			var that = this;
			if (!that.istate)
				return Z_STREAM_ERROR;
			return that.istate.inflateSync(that);
		},
		inflateSetDictionary : function(dictionary, dictLength) {
			var that = this;
			if (!that.istate)
				return Z_STREAM_ERROR;
			return that.istate.inflateSetDictionary(that, dictionary, dictLength);
		},
		read_byte : function(start) {
			var that = this;
			if (that.next_in.readNumber)
			{
				return that.next_in.readNumber(1,start);
			}
			//return that.next_in.subarray(start, start + 1)[0];
			return that.next_in[start];
		},
		read_buf : function(start, size) {
			var that = this;
			return that.next_in.subarray(start, start + size);
		}
	};

	// Inflater

	function Inflater() {
		var that = this;
		var z = new ZStream();
		var bufsize = 512;
		var flush = Z_NO_FLUSH;
		var buf = arrayTypeCreator(bufsize);


		z.inflateInit();
		z.next_out = buf;

		that.append = function(data) {
			var err, buffers = [];
			if (data.length === 0)
				return;
			z.next_in_index = 0;
			z.next_in = data;
			z.avail_in = data.length;
			
			do {
				z.next_out_index = 0;
				z.avail_out = bufsize;
							
				err = z.inflate(flush);
				
						
				if (err != Z_OK && err != Z_STREAM_END  && err != Z_BUF_ERROR)
					throw "inflating: " + z.msg;
				
				if (z.next_out_index)
					if (z.next_out_index == bufsize)
						buffers.push(arrayTypeCreator(z.next_out));
					else
						buffers.push(arrayTypeCreator(z.next_out.subarray(0, z.next_out_index)));
			
//				console.log(z.avail_in +" "+ z.avail_out);
			
			} while (z.avail_out === 0);			

			
			return buffers;
		};
		that.flush = function() {
			z.inflateEnd();
		};
	}

	zip.Inflater = Inflater;

}
(vitrium.zip, __globals__));

// script:viewer/uri.js
(function(exports, globals)
{
  "use strict";
  
  exports.URI = URI;
  
  
/*
 * An URI datatype.  Based upon examples in RFC3986.
 * source : https://code.google.com/p/js-uri/
 * license : http://opensource.org/licenses/BSD-3-Clause
 * TODO %-escaping
 * TODO split apart authority
 * TODO split apart query_string (on demand, anyway)
 *
 * @(#) $Id$
 */
 
// Constructor for the URI object.  Parse a string into its components.
function URI(str) {
    if (!str) str = "";
    // Based on the regex in RFC2396 Appendix B.
    var parser = /^(?:([^:\/?\#]+):)?(?:\/\/([^\/?\#]*))?([^?\#]*)(?:\?([^\#]*))?(?:\#(.*))?/;
    var result = str.match(parser);
    this.scheme    = result[1] || null;
    this.authority = result[2] || null;
    this.path      = result[3] || null;
    this.query     = result[4] || null;
    this.fragment  = result[5] || null;
}

// Restore the URI to it's stringy glory.
URI.prototype.toString = function () {
    var str = "";
    if (this.scheme) {
        str += this.scheme + ":";
    }
    if (this.authority) {
        str += "//" + this.authority;
    }
    if (this.path) {
        str += this.path;
    }
    if (this.query) {
        str += "?" + this.query;
    }
    if (this.fragment) {
        str += "#" + this.fragment;
    }
    return str;
};

/**
  @author johnh@vitrium.com
*/
URI.prototype.isCrossDomain = function()
{
  if (this.authority === null)
  {
    return false;
  }
  else
  {    
    return this.authority !== globals.location.host;
  }
};

// Introduce a new scope to define some private helper functions.
(function () {
    // RFC3986 5.2.3 (Merge Paths)
    function merge(base, rel_path) {
        var dirname = /^(.*)\//;
        if (base.authority && !base.path) {
            return "/" + rel_path;
        }
        else {
            return base.path.match(dirname)[0] + rel_path;
        }
    }

    // Match two path segments, where the second is ".." and the first must
    // not be "..".
    var DoubleDot = /\/((?!\.\.\/)[^\/]*)\/\.\.\//;

    function remove_dot_segments(path) {
        if (!path) return "";
        // Remove any single dots
        var newpath = path.replace(/\/\.\//g, '/');
        // Remove any trailing single dots.
        newpath = newpath.replace(/\/\.$/, '/');
        // Remove any double dots and the path previous.  NB: We can't use
        // the "g", modifier because we are changing the string that we're
        // matching over.
        while (newpath.match(DoubleDot)) {
            newpath = newpath.replace(DoubleDot, '/');
        }
        // Remove any trailing double dots.
        newpath = newpath.replace(/\/([^\/]*)\/\.\.$/, '/');
        // If there are any remaining double dot bits, then they're wrong
        // and must be nuked.  Again, we can't use the g modifier.
        while (newpath.match(/\/\.\.\//)) {
            newpath = newpath.replace(/\/\.\.\//, '/');
        }
        return newpath;
    }

    // RFC3986 5.2.2. Transform References;
    URI.prototype.resolve = function (base) {
        var target = new URI();
        if (this.scheme) {
            target.scheme    = this.scheme;
            target.authority = this.authority;
            target.path      = remove_dot_segments(this.path);
            target.query     = this.query;
        }
        else {
            if (this.authority) {
                target.authority = this.authority;
                target.path      = remove_dot_segments(this.path);
                target.query     = this.query;
            }        
            else {
                // XXX Original spec says "if defined and empty";
                if (!this.path) {
                    target.path = base.path;
                    if (this.query) {
                        target.query = this.query;
                    }
                    else {
                        target.query = base.query;
                    }
                }
                else {
                    if (this.path.charAt(0) === '/') {
                        target.path = remove_dot_segments(this.path);
                    } else {
                        target.path = merge(base, this.path);
                        target.path = remove_dot_segments(target.path);
                    }
                    target.query = this.query;
                }
                target.authority = base.authority;
            }
            target.scheme = base.scheme;
        }

        target.fragment = this.fragment;

        return target;
    };
  })();
 
}
(
vitrium.utils, 
__globals__));
// script:viewer/io/binary.js
(function (exports, _, global) {
	"use strict";
	
	// if they are supported it safes lot of memory
	var isTypedArraysSupported = _.isFunction(global.ArrayBuffer) || _.isObject(global.ArrayBuffer);
	var EXTENSION_MATCHER = /^x-(.+)/;

	_.extend(exports, {
		DataBuffer : DataBuffer, 
		DataBufferView : DataBufferView,
		loadData : loadData,
		createBinaryStructure : createBinaryStructure,
		base64_encode: base64_encode,
	   appendToUrl: appendToUrl,
	   appendEncodedToUrl: appendEncodedToUrl,
      EXTENSION_MATCHER: EXTENSION_MATCHER
	});

	
	// this class partially implements https://developer.mozilla.org/en-US/docs/JavaScript_typed_arrays/DataView
	function DataBufferView(buffer, offset, length)
	{	
		if (length < 0)
			throw new Error("Error: length must be greater than zero!");
			
		if (buffer.length - offset < length)
			throw new Error("Error: offset+length must be less or equal of the original buffer size");
			
		this.buffer = buffer;
		this.offset = offset;
		this.length = length;
		
		
		var endpos = offset + length;
		
		function checkPosition(pos)
		{
			if (pos >= endpos || pos < offset)
			{
				throw new Error("Error: index out of bounds");
			}
		}
		
		this.getUint8 = function(byteOffset)
		{
			var pos = byteOffset + offset;
			checkPosition(pos);
			
			return buffer.readNumber(1, pos);
		};
		
		this.getUint16 = function(byteOffset, littleEndian)
		{
			var pos = byteOffset + offset;
			checkPosition(pos);
			
			if (littleEndian)
			{
				return buffer.readNumberLittleEndian(2, pos);
			}
			else
			{
				return buffer.readNumberBigEndian(2, pos);
			}
		};
		
		this.getUint32 = function(byteOffset, littleEndian)
		{
			var pos = byteOffset + offset;
			checkPosition(pos);
			
			if (littleEndian)
			{
				return buffer.readNumberLittleEndian(4, pos);
			}
			else
			{
				return buffer.readNumberBigEndian(4, pos);
			}
		};
		
		this.subarray = function(begin, end)
		{
			if (arguments.length < 2)
			{
				end = length;
			}
			
			if (end > length)
			{
				end = length;
			}
						
			var pos = begin + offset;
			checkPosition(pos);
			
			return buffer.subarray(pos, end);
		};
		
		this.subview = function(begin, end)
		{
			if (arguments.length < 2)
			{
				end = length;
			}
			else
			{
				end = end - begin;
			}
			
			return new DataBufferView(this, begin, end);
		};
	
		
		//methods for DataBuffer interface
		
		this.readNumber = function(numBytes, byteOffset)
		{
			if (arguments.length < 2)
			{
				byteOffset = 0;
			}
			var pos = byteOffset + offset;
			//checkPosition(pos);
			return buffer.readNumber(numBytes, pos);
		};

		this.readByteAt = function(byteOffset)
		{
			if (arguments.length < 1)
			{
				byteOffset = 0;
			}
			var pos = byteOffset + offset;
			checkPosition(pos);
			
			return buffer.readByteAt(pos);
		};
		
		this.readNumberLittleEndian = function(numBytes, byteOffset)
		{
			if (arguments.length < 2)
			{
				byteOffset = 0;
			}
			
			var pos = byteOffset + offset;
			checkPosition(pos);
			return buffer.readNumberLittleEndian(numBytes, pos);
		};
		
		this.readNumberBigEndian = function(numBytes, byteOffset)
		{
			if (arguments.length < 2)
			{
				byteOffset = 0;
			}
			
			var pos = byteOffset + offset;
			checkPosition(pos);
			return buffer.readNumberBigEndian(numBytes, pos);
		};
	
			
		this.writeNumberLittleEndian = function (numBytes, num, byteOffset)
		{
			if (arguments.length < 2)
			{
				byteOffset = 0;
			}
			
			var pos = byteOffset + offset;
			checkPosition(pos);
			buffer.writeNumberLittleEndian(numBytes,num, pos);
		};
		
		this.writeNumberBigEndian = function (numBytes, num, byteOffset)
		{
			if (arguments.length < 2)
			{
				byteOffset = 0;
			}
			
			var pos = byteOffset + offset;
			checkPosition(pos);
			buffer.writeNumberBigEndian(numBytes, num, pos);
		};
		
		this.writeDataBuffer = function(dataBufer, destPos, srcOffset, srcLen)
		{
			var pos = offset + destPos;
			checkPosition(pos);
			
			
			
			buffer.writeDataBuffer(dataBuffer, pos, srcOffset, srcLen);
		};
	}
	
	
	function DataBuffer(initialSize)
	{
		var _exception = {
			NotLoaded : 1,
			EOFReached	: 2,
			MustDefined : 3
		};
		


		var fileSize = -1;
		var fileContents;
		
		
		

		this.getFileContents = function(){
			checkIfLoaded();
			
			var contents = [];
			for(var i = 0; i < fileSize; i++) {
				contents.push(this.readByteAt(i))
			}
			return contents;
		}
		
		this.getFileSize = function(){
			return fileSize;
		}





		
		
		// reads little endian order
		this.readNumber = function(iNumBytes, iFrom){
			checkIfLoaded();
			
			iNumBytes = iNumBytes || 1;

			
			
		

			var result = 0;
			for(var i=iFrom + iNumBytes; i>iFrom; --i){
				result = result * 256 + this.readByteAt(i-1);
			}

			return result;
		};
		
		this.readNumberLittleEndian = this.readNumber;
		
		this.readNumberBigEndian = function(iNumBytes, iFrom){
			checkIfLoaded();
			
			iNumBytes = iNumBytes || 1;

			
			var iTo = iFrom + iNumBytes;
			

			var result = 0;
			for(var i=iFrom; i<iTo; ++i){
				result = result * 256 + this.readByteAt(i);
			}

			return result;
		};
		
		
		this.readString = function(iNumChars, iFrom){
			checkIfLoaded();
			
			iNumChars = iNumChars || 1;
		
			var result = "";
			var tmpTo = iFrom + iNumChars;
			for(var i=iFrom; i<tmpTo; i++){
				result += String.fromCharCode(this.readNumber(1));
			}

			return result;
		};

		this.readUnicodeString = function(iNumChars, iFrom){
			checkIfLoaded();
			
			iNumChars = iNumChars || 1;


			var result = "";
			var tmpTo = iFrom + iNumChars*2;
			for(var i=iFrom; i<tmpTo; i+=2){
				result += String.fromCharCode(this.readNumber(2));
			}

			return result;
		};
		

		

		
		
		this.attachData = function(data)
		{
			if (_.isString(data))
			{
				fileContents = data;
				fileSize = fileContents.length;
				this.readByteAt = readByteAtFromString;
			}
			else if (data)
			{
				fileContents = data;
				fileSize = fileContents.length;
				this.readByteAt = readByteAtFromArray;
			}
			else
			{
				throwException(_exception.MustDefined);
			}
			
			this.length = fileSize;
			
			return  this;
		};
		
		this.readByteAt = function()
		{
			//this throws an exception
			checkIfLoaded();
		};
		
		function readByteAtFromArray(i)
		{
			return fileContents[i];
		}
		
		function readByteAtFromString(i)
		{
			return fileContents.charCodeAt(i) & 0xff;
		}
		
		function checkIfLoaded()
		{
			if (fileSize < 0)
				throwException(_exception.NotLoaded);
		}

		function throwException(errorCode){
			switch(errorCode){
				case _exception.EOFReached:
					throw new Error("Error: EOF reached");
					break;
				case _exception.NotLoaded:
					throw new Error("Error: Data must be loaded first!");
					break;
				case _exception.MustDefined:
					throw new Error("Error: Arugment must be an array like object or string");
					break;
			}
		}
		
				// functions bellow are added to implement interface of zip library
		this.init = function(callback, onerror) {
			this.size = fileSize;
			callback();
		};
		
		this.writeByte = function(num, pos)
		{
			if (num < 0)
			{
				num = 0xFF + num + 1;
			}
			fileContents[pos] = num;
		};
		
		this.getArray = function()
		{
			return fileContents;
		};
		
		this.writeNumberBigEndian = function (numlen, num, pos)
		{
			if (Math.pow(2,numlen*8) <= num)
			{
				throw new Error("Number out of range!");
			}
			
			var shift = (numlen * 8)-8;
			var rest = num;
			
			for(var i=0; i < numlen; ++i)
			{
				var byteVal = rest >> shift;
				rest = ~(byteVal<<shift) & rest;
				this.writeByte(byteVal, pos + i);
				shift -= 8;
			}	
		};
		
		this.writeNumberLittleEndian = function (numlen, num, pos)
		{
			if (Math.pow(2,numlen*8) <= num)
			{
				throw new Error("Number out of range!");
			}
			
			var shift = (numlen * 8)-8;
			var rest = num;
			
			var cPos = pos+numlen - 1;
			for(var i=0; i < numlen; ++i)
			{
				var byteVal = rest >> shift;
				rest = ~(byteVal<<shift) & rest;
				this.writeByte(byteVal, cPos - i);
				shift -= 8;
			}	
		};
		
		
		
		this.cumulativeOffset = function()
		{
			return 0;
		};
		
		
		
		if (isTypedArraysSupported)
		{
			this.writeDataBuffer = function(srcDataBufer, destPos, srcOffset, srcLen)
			{	
				if (fileContents.slice)
				{
					for (var i = 0; i < srcLen; ++i)
					{
						this.writeByte(srcDataBufer.readByteAt(i+srcOffset), i+destPos);
					}
				}
				else
				{		
					// uint8 array optimization
					var realArray = srcDataBufer.subarray(srcOffset, srcOffset+srcLen);
					fileContents.set(realArray, destPos);
				}
			};
		
			this.getOriginalData = function()
			{
				return fileContents;
			};
	
			this.subarray = function(index, end)
			{
				if (!end && end !== 0)
				{
					length = fileContents.length;
				}
				
				if (!index)
				{
					index = 0;
				}
				
				if (fileContents.subarray)
				{
					return fileContents.subarray(index, end);
				}
				else
				{
					return new Uint8Array(fileContents.slice(index, end));
				}
			};

			this.readUint8Array = function(index, length, callback, onerror)
			{
			/*	try
				{*/
					checkIfLoaded();
					callback(new Uint8Array(fileContents.subarray(index, index + length)));	
				/*}
				catch(e)
				{
					if (_.isFunction(onerror)) onerror(e);
				}*/
			};
		}
		else
		{
			this.getOriginalData = function()
			{
				// old firefox
				if (_.isString(fileContents))
				{
					return this.getFileContents();
				}
				else
				{
					return fileContents;
				}
			};
			
			this.writeDataBuffer = function(srcDataBufer, destPos, srcOffset, srcLen)
			{	
				if (fileContents.slice)
				{
					for (var i = 0; i < srcLen; ++i)
					{
						this.writeByte(srcDataBufer.readByteAt(i+srcOffset), i+destPos);
					}
				}
			}
			
			this.subarray = function(offset, end)
			{
				if (!end && end !== 0)
				{
					end = fileContents.end;
				}
				
				if (!offset)
				{
					offset = 0;
				}
				
				return this.getOriginalData().slice(offset, end);
			};
			
			this.readUint8Array = function(index, length, callback, onerror)
			{
			/*	try
				{*/
					checkIfLoaded();
					callback(new DataBufferView(this, index, length));
					
				/*}
				catch(e)
				{
					if (_.isFunction(onerror)) onerror(e);
				}*/
			};
		}
		
		
		if (initialSize)
		{
			if (isTypedArraysSupported)
			{
				this.attachData(new Uint8Array(initialSize));
			}
			else
			{
				var array = new Array(initialSize);
				for (var i = 0; i < initialSize; ++i)
				{
					array[i] = 0;
				}
				
				this.attachData(array);
			}
		}
	}
	
	function XHRWraper(xhr)
	{
		this.xhr = xhr;
	}
	
	XHRWraper.prototype.abort = function()
	{
		var none = function(){};
		var xhr = this.xhr;
		xhr.onreadystatechange = none;
		xhr.onload = none;
		xhr.ontimeout = none;
		xhr.abort();
	};
	
	function loadData(options)
	{
		var url = options.url;
		var method = options.method || "GET";
		var success = options.success || function(){};
		var failed = options.error || function(){};
		var headers = options.headers || [];
		
		if (_.isFunction(url))
		{
			url = url();
		}
		
		if (!_.isString(url))
		{
			throw new Error("Error: url must be a string or function that returns a string");		
		}
		
		if (!_.isString(method))
		{
			throw new Error("Error: method must be a string");
		}
		
		if (!_.isFunction(success))
		{
			throw new Error("Error: success must be a function");
		}
		
		if (!_.isFunction(failed))
		{
			throw new Error("Error: error must be a function");
		}
		
		var xhr = new XMLHttpRequest();
		var headersCount = headers.length;

		for (var i = 0; i < headersCount; ++i) {
		   var v = headers[i];
		   if (v[0] === "Range")
		   {
		      url = appendEncodedToUrl(url, v[1]);
		   }
		   else if (EXTENSION_MATCHER.test(v[0]))
		   {
		      var parts = v[0].split(EXTENSION_MATCHER);
		      url = appendToUrl(url, parts[1].replace(/-/g,''), v[1]);
		   }
		}

		xhr.open(method, url, true);
      		
		for (var i = 0; i < headersCount; ++i) {
		   var v = headers[i];
		   xhr.setRequestHeader(v[0], v[1]);
		}

		if (isTypedArraysSupported)
		{	
			xhr.responseType = 'arraybuffer';
			xhr.onload = function(e) {
			  var status = this.status;
			  if (status >= 200 && status < 300 || status === 304) {
				var response = this.response;
				if (response)
				{
					var uInt8Array = new Uint8Array(response); 
					success(uInt8Array, this);
				}
				else
				{
					success(null, this);
				}
			  }
			  else
			  {
				failed(this.status, this);
			  }
			  this.onload = null;
			  this.ontimeout = null;
			};
			
			xhr.onerror = function (e)
			{
				failed(this.status);
			};
		}
		else
		{			
			if (xhr.overrideMimeType)
				xhr.overrideMimeType("text/plain; charset=x-user-defined");
				
			xhr.onreadystatechange = function(e) {
				
				if (this.readyState === 4)
				{	
					var status = this.status;
					if (status >= 200 && status < 300 || status === 304)
					{
						var data;
						if (this.overrideMimeType || options.directDecode) {
							data = this.responseText; // this should be a byte buffer
							if (!data)
							{
								data = null;
							}
						}
						else
						{
							var body = xhr.responseBody; //body is VBArray
							//IE way
							data = body.toArray();
							
							
							if (!data)
							{
								data = null;
							}
						}
						success(data, this);
					}
					else
					{
						failed(this.status, this);
					}
					
					this.onreadystatechange = null;
					this.ontimeout = null;
				}	
			};
		}

		xhr.ontimeout = function () {
		   failed(this.status, this);
		};

		xhr.send(null);
		
		return new XHRWraper(xhr);
	}
	
	function base64_encode (data) {
	// based on http://kevin.vanzonneveld.net
		var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
		var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
		ac = 0,
		enc = "";


		if (!data)
			return data;

		var dlen = data.length;
	
		var tmp_arr = new Array(dlen);
		
		do {
			o1 = data[i++] //data.charCodeAt(i++);
			o2 = data[i++]; //data.charCodeAt(i++)
			o3 = data[i++]; //data.charCodeAt(i++)

			bits = o1 << 16 | o2 << 8 | o3;

			h1 = bits >> 18 & 0x3f;
			h2 = bits >> 12 & 0x3f;
			h3 = bits >> 6 & 0x3f;
			h4 = bits & 0x3f;

			// use hexets to index into b64, and append result to encoded string
			tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
		} while (i < dlen);

		enc = tmp_arr.join('');
		var r = dlen % 3;
		return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);
	}
	
	function appendEncodedToUrl(url, value)
	{
	   if (url.indexOf("?") === -1)
	   {
	      url += "?";
	   }
	   else
	   {
	      url += "&";
	   }
	   url += value;
	   return url;
	}

	function appendToUrl(url, name, value)
	{
	   return appendEncodedToUrl(url, name + "=" + encodeURIComponent(value));
	}


	
	function createBinaryStructure(littleEndian, atributes)
	{
		var Structure = function (buffer)
		{
			this.buffer = buffer;
		};
		
		var declare;
		if (littleEndian)
		{
			declare = function(attr, cOffset)
			{
				return function(num)
				{
						if (arguments.length == 0)
						{
							return this.buffer.readNumberLittleEndian(attr[1],cOffset);
						}
						else
						{
							this.buffer.writeNumberLittleEndian(attr[1], num, cOffset);
						}	
				};
			};
		}
		else
		{
			declare = function(attr, cOffset)
			{
				return function(num)
				{
						if (arguments.length == 0)
						{
							return this.buffer.readNumberBigEndian(attr[1],cOffset);
						}
						else
						{
							this.buffer.writeNumberBigEndian(attr[1], num, cOffset);
						}	
				};
			};		
		}
		
		var result = {};
		var offset = 0;
		for (var i = 0; i < atributes.length; ++i)
		{
			var attr = atributes[i];
			result[attr[0]] = declare(attr, offset);
			offset += attr[1];
		}
				
		result.__size_of = function()
		{
			return offset;
		};
		
		result._ref_in_array = function(idx)
		{
			return new Structure(new DataBufferView(this.buffer, offset*idx, this.buffer.length - (offset*idx)));	
		};
		
		_.extend(Structure.prototype, result);
		
		return Structure;
	}
}(
vitrium.bin,
_,
__globals__));
// script:viewer/io/cors.js
(function (exports, utils, globals) {
	"use strict";

	exports.loadDataCORS = loadData;
	function createCORSRequest(method, url) {
		var xhr = new XMLHttpRequest();
		if ("withCredentials" in xhr) {

			// Check if the XMLHttpRequest object has a "withCredentials" property.
			// "withCredentials" only exists on XMLHTTPRequest2 objects.
			xhr.open(method, url, true);

		} else if (typeof XDomainRequest != "undefined") {

			// Otherwise, check if XDomainRequest.
			// XDomainRequest only exists in IE, and is IE's way of making CORS requests.
			xhr = new XDomainRequest();
			xhr.open(method, url);

		} else {

			// Otherwise, CORS is not supported by the browser.
			xhr = null;

		}
		return xhr;
	}

	function createRequest(method, url) {
		var xhr = new XMLHttpRequest();
		xhr.open(method, url, true);

		return xhr;
	}

	function isCORS(url) {
    var uri = new utils.URI(url);
    return uri.isCrossDomain();    
  }

	function loadData(options) {
		var url = options.url;
		var method = options.method || "GET";
		var success = options.success || function () {};
		var failed = options.error || function () {};
		var headers = options.headers || [];
		var data = options.data ? options.data : null;
    
    if (_.isFunction(url)) 
    {
			url = url();
		}
    
		var xhr = null;
    if (isCORS(url))
    {
      xhr = createCORSRequest(method, url);
    }
    else
    {
      xhr = createRequest(method, url);
    }
      
		if (!xhr) {
			failed.call(options, "CORS not supported");
			return null;
		} else {
			if (!_.isString(url)) {
				throw new Error("Error: url must be a string or function that returns a string");
			}

			if (!_.isString(method)) {
				throw new Error("Error: method must be a string");
			}

			if (!!xhr.setRequestHeader) //IE 9 does not support that
			{
				var len = headers.length;
				for (var i = 0; i < len; ++i) {
					var v = headers[i];
					xhr.setRequestHeader(v[0], v[1]);
				}

				xhr.onload = function (e) {
					var status = this.status;
					if (status >= 200 && status < 300 || status === 304) {
						var response = this.responseText;
						if (response) {
							success.call(options, response, this);
						} else {
							success.call(options, null, this);
						}
					} else {
						failed.call(options, this.status, this);
					}
					this.onload = null;
					this.ontimeout = null;
					this.onerror = null;
				};

				xhr.onerror = function (e) {
					failed.call(options, this.status);
				};
			} else {
				xhr.onload = function (e) {
					success.call(options, this.responseText, this);
					this.onload = null;
					this.ontimeout = null;
					this.onerror = null;
				};

				xhr.onerror = function (e) {
					failed.call(options, 0);
				};
			}

			xhr.ontimeout = function () {
				failed.call(options, 0, this);
			};
			xhr.send(data);

			return xhr;
		}
	}

}
	(
		vitrium.utils,
		vitrium.utils,
		__globals__));
// script:viewer/io/blob-api.js
(function(exports, global)
{
  "use strict";
  
	var blobObject = !!global["Blob"];
	var URL = global.webkitURL || global.mozURL || global.msURL ||  global.URL || {};
	
	var createObjectURL = !!URL.createObjectURL;
	var level = 0;
	var is_safari = false;
	
	if (global.navigator && global.navigator.userAgent)
	{
		var userAgent = global.navigator.userAgent.toLowerCase();

		is_safari =  userAgent.indexOf('safari/') > -1 && !userAgent.indexOf('chrome/');
	}
	
	if (is_safari)
	{
		//mac sucks
		level = 0;
	}
	else	if (blobObject && createObjectURL)
	{
		level = 2;
	}
	else if (blobObject)
	{
		level = 1;
	}
	
	exports.Blob = {
		level : level,
		URL : URL
	};	

}(
vitrium.features, 
__globals__));	
// script:viewer/io/io-scheduler.js
(function(exports, bin, vitrium, _, globals)
{
	"use strict";
	var isDomReady = !!globals.document;
	exports.IOScheduler = IOScheduler;
	
	function IOScheduler(limit, loader)
	{
		this.limit = limit;
		this.numRequest = 0;
		this.queue = [];
		
		this.loader = loader || bin;
	}
	
	var IOSP = IOScheduler.prototype; 
	IOSP.loadData = function(options)
	{
		//vitrium.log.debug("load data: "+options.url);
		var req = new IORequest(this, options);
		this.queue.push(req);
		this.execute();
		
		return req;
	};
	
	IOSP.abort = function (request)
	{
		this.queue = _.without(this.queue, request);
	};
	
	IOSP.release = function (request)
	{
		if (isDomReady)
		{
			var self = this;
			setTimeout(function(){
				--self.numRequest;
				self.execute();
			},0);
		}
		else
		{
			--this.numRequest;
			this.execute();
		}
	};
	
	IOSP.execute = function ()
	{
		var reqs = this.queue;
		var execute = Math.min(this.limit - this.numRequest, reqs.length);
		for (var i =  execute; i--;)
		{
			var r = reqs.shift();
			r.xhr = this.loader.loadData(r.request);
		}
		
		this.numRequest += execute;		
	};
	
	function IORequest(scheduler, options)
	{
		this.scheduler = scheduler;
		var request = this.request = _.clone(options);
		
		this.success = options.success || noop;
		this.error = options.error || noop;
		this.xhr = null;
		
		request.success = _.bind(onSuccess, this);
		request.error =  _.bind(onError, this);
	}
	
	IORequest.prototype.abort = function()
	{
		if (this.xhr)
		{
			this.xhr.abort();
			this.xhr = null;
		}
		
		if (this.scheduler)
		{
			this.scheduler.abort(this);
			this.scheduler.release(this);
			
			this.scheduler = null;
		}
	};
	
	
	var lastResult = 0;
	
	function onSuccess()
	{
		this.success.apply(this, arguments);		
		this.xhr = null;
		
		releaseRequest.call(this);
	}
	
	function onError()
	{
		releaseRequest.call(this);
		
		this.error.apply(this, arguments);		
		this.xhr = null;
		
		
	}
	
	function releaseRequest()
	{
		if (this.scheduler)
		{
			this.scheduler.release(this);
			this.scheduler = null;
		}
	}
	
	
	function noop(){};
	
}(
vitrium.bin, 
vitrium.bin,
vitrium,
_,
__globals__));
// script:viewer/io/direct-decode.js
(function (exports, bin)
{
	exports.DirectDecodeDataLoader = 
	{
		loadData: function (options)
		{
			var url = options.url;
			var method = options.method || "GET";
			var success = options.success || function(){};
			var failed = options.error || function(){};
			var headers = options.headers || [];
					
			var xhr = new XMLHttpRequest();

			var headersCount = headers.length;

			for (var i = 0; i < headersCount; ++i) {
			   var v = headers[i];
			   if (v[0] === "Range") {
			      url = bin.appendEncodedToUrl(url, v[1]);
			   }
			   else if (bin.EXTENSION_MATCHER.test(v[0])) {
			      var parts = v[0].split(bin.EXTENSION_MATCHER);
			      url = bin.appendToUrl(url, parts[1].replace(/-/g, ''), v[1]);
			   }
			}

			xhr.open(method, url, true);
			
			var len = headers.length;
			for (var i = 0; i < len; ++i)
			{
				var v = headers[i];
				xhr.setRequestHeader(v[0], v[1]);
			}
			
			xhr.onreadystatechange = function(e) {
				
				if (this.readyState === 4)
				{	
					var status = this.status;
					if (status >= 200 && status < 300 || status === 304)
					{
							var data = this.responseText; 
							if (!data)
							{
								data = null;
							}
							success(data, this);
					}
					else
					{
						failed(this.status, this);
					}
					
					this.onreadystatechange = null;
					this.ontimeout = null;
				}	
			};
			xhr.send(null);	
			return xhr;
		}
	};
	
	

}(vitrium.bin, vitrium.bin));


// script:viewer/io/remote-file.js
(function (exports, bin) {
	"use strict";

	var ERR_ETAG_CHANGED = 0xFFFF;

	exports.RemoteFile = RemoteFile;

	function RemoteFile(url, loader) {
		this.url = url;
		this.loader = loader || bin;
		this.etag = null;
		this.size = null;
	}

	var ETAG_RE = /.*["](.+)["]/;

	RemoteFile.prototype = {
		init : function (success, error, endbyte) {
			if (typeof endbyte === "undefined") {
				endbyte = 2;
			}

			var self = this;

			var url = this.url;

			if (url.indexOf("?") === -1) {
				url += "?";
			} else {
				url += "&";
			}

			url += "_ts=" + Date.now().toString(16);
         
			return this.loader.loadData({
				url : url,
				headers : [
                    ["Cache-Control", "no-cache"],
                    ["Range", "bytes=0-" + endbyte],
                    ["x-dd-enabled", "true"]
                  ],
				method : "GET",

				success : function (data, xhr) {
					var contentRange = xhr.getResponseHeader("Content-Range");

					var contentLen = 0;
					if (contentRange) {
						var idx = contentRange.indexOf("/");
						if (idx !== -1 && (idx + 1) < contentRange.length) {
							contentLen = contentRange.substring(idx + 1, contentRange.length);
						}
					}

					var etag = xhr.getResponseHeader("ETag");
					if (etag) {
						var etagM = etag.match(ETAG_RE);
						if (etagM && etagM.length == 2) {
							etag = etagM[1];
						}

					} else {
						etag = null;
					}
					self.etag = etag;

					if (contentLen > 0) {
						self.size = parseInt(contentLen, 10);
						success(self.size, self.etag, data, xhr.getResponseHeader("x-supports-dd"));
					} else {
						error();
					}
				},
				error : error
			});
		},
		checkETag : function (success, error) {
			var url = this.url;
			if (url.indexOf("?") == -1) {
				url += "?";
			} else {
				url += "&";
			}
			url += "_ts=" + Date.now().toString(16);

			var self = this;
			this.loader.loadData({
				url : url,
				headers : [["Cache-Control", "no-cache"],
					["Range", "bytes=0-1"]
				],
				method : "GET",
				success : function (data, xhr) {
					var contentRange = xhr.getResponseHeader("Content-Range");
					var etag = xhr.getResponseHeader("ETag");
					if (etag) {
						var etagM = etag.match(ETAG_RE);
						if (etagM && etagM.length == 2) {
							etag = etagM[1];
						}

					} else {
						etag = null;
					}

					success(self.etag === etag);
				},
				error : error
			});

		},
		readAndDecode : function (index, length, callback, onerror, encoding, contentType) {
			if (!index) {
				index = 0;
			}

			if (!contentType) {
				contentType = "text/plain; charset=utf-8";
			}

			//vitrium.log.debug("read: "+index+ " len:"+length);

			var len = this.size;

			if (len > 0) {
				var start = index;
				var end = (index + length) - 1;
				var url = this.url;
				if (url.indexOf("?") == -1) {
					url += "?";
				} else {
					url += "&";
				}

				var blockId = "_ts=" + Date.now().toString(16);

				url += blockId;

				if (start < len && end < len) {
					var self = this;
					return this.loader.loadData({
					   method: "GET",
                  directDecode: true,
						url : url,
						headers : [
							["Range", "bytes=" + start + "-" + end],
							["Cache-Control", "no-cache"],
							["x-dd-enabled", "true"],
							["x-dd", encoding + "|" + contentType]
						],
						success : function (data, xhr) {
							var etag = xhr.getResponseHeader("ETag");
							if (etag) {
								var etagM = etag.match(ETAG_RE);
								if (etagM && etagM.length == 2) {
									etag = etagM[1];
								}
							} else {
								etag = null;
							}

							if (etag !== self.etag) {
								onerror(ERR_ETAG_CHANGED, xhr);
							} else {
								callback(data);
							}
						},
						error : function (err, xhr) {
							var h = false;
							if (err === 416) {
								var etag = xhr.getResponseHeader("ETag");
								if (!etag) {
									etag = null;
								}

								if (etag !== self.etag) {
									onerror(ERR_ETAG_CHANGED, xhr);
									h = true;
								}
							}

							if (!h) {
								onerror(err, xhr);
							}
						}
					});
				} else {
					onerror("The requested range of bytes is out of range: fileLen:" + len + " start:" + start + " end:" + end);
				}
			} else {
				onerror("The file is empty or must be initialized first");
			}

			return null;
		},
		readUint8Array : function (index, length, callback, onerror) {

			if (!index) {
				index = 0;
			}

			//vitrium.log.debug("read: "+index+ " len:"+length);

			var len = this.size;

			if (len > 0) {
				var start = index;
				var end = (index + length) - 1;
				var url = this.url;
				if (url.indexOf("?") == -1) {
					url += "?";
				} else {
					url += "&";
				}

				//var blockId = "_rfStart="+start+"&_rfEnd="+end+"&_ts="+new Date().getTime().toString(16);
				var blockId = "_ts=" + Date.now().toString(16);
				/*var blocks = this.blocks;
				var buffer = blocks[blockId];
				if (buffer){
				buffer.readUint8Array(0, length, callback, onerror);
				}*/

				url += blockId;

				if (start < len && end < len) {
					var self = this;
					return this.loader.loadData({
						method : "GET",
						url : url,
						headers : [
							["Range", "bytes=" + start + "-" + end],
							["Cache-Control", "no-cache"]
						],
						success : function (data, xhr) {
							var buffer = new bin.DataBuffer();
							buffer.attachData(data);

							var etag = xhr.getResponseHeader("ETag");
							if (etag) {
								var etagM = etag.match(ETAG_RE);
								if (etagM && etagM.length == 2) {
									etag = etagM[1];
								}
							} else {
								etag = null;
							}

							if (etag !== self.etag) {
								onerror(ERR_ETAG_CHANGED, xhr);
							} else {
								buffer.readUint8Array(0, length, callback, onerror);
							}
						},
						error : function (err, xhr) {
							var h = false;
							if (err === 416) {
								var etag = xhr.getResponseHeader("ETag");
								if (!etag) {
									etag = null;
								}

								if (etag !== self.etag) {
									onerror(ERR_ETAG_CHANGED, xhr);
									h = true;
								}
							}

							if (!h) {
								onerror(err, xhr);
							}
						}
					});
				} else {
					onerror("The requested range of bytes is out of range: fileLen:" + len + " start:" + start + " end:" + end);
				}
			} else {
				onerror("The file is empty or must be initialized first");
			}

			return null;
		}

	};

}(
vitrium.bin, 
vitrium.bin));
// script:viewer/io/worker-pool.js
(function(exports, vitrium, log, Backbone, _, global)
{
  "use strict";
  exports.Pool = Pool;
  Pool.workerPath = workerPath;
  Pool.resourceUrl = resourceUrl;

  var CMD_INIT = 0x0001;
  var CMD_INITIALIZED = 0x0002;
  var CMD_JOB_MSG = 0x0003;
  var CMD_TERMINATE = 0x0004;
  var CMD_TERMINATED = 0x0005;
  var CMD_ERROR = 0x0006;
  
  function Pool(count, script, onready)
  {			
    
    this.script = script;
    
    this.jobsCounter = 0;
    this.count = count;
  
    this.readyCount = 0;
    this.workers = new Array(count);
    this.onready = onready || noop;
  
    
    this.onDispatchMessage = null;
    this.onErrorMessage = null;
    
    this.jobs = {};
  }
  
  var PoolP = Pool.prototype;
  
  PoolP.start = function(data)
  {
    
    this.onDispatchMessage = _.bind(onDispatchMessage, this);
    this.onErrorMessage = _.bind(onErrorMessage, this);
    var workers = this.workers;
    var script = this.script;
    log.debug("[Pool] WebWorker start src=" + script + " n=" + workers.length);
    for (var i = workers.length; i--;)
    {
      var worker = workers[i] = new Worker(script);
      worker.onmessage = this.onDispatchMessage;
      worker.onerror = this.onErrorMessage;
      worker.postMessage({ cmd : CMD_INIT, id: i, data : data});
    }
  };
  
  PoolP.stop = function()
  {

    var workers = this.workers;
    var script = this.script;
    log.debug("[Pool] WebWorker stop src=" + script);

    this.readyCount = 0;
    this.jobsCounter = 0;
    
    for (var i = workers.length; i--;)
    {
      var w = workers[i];
      if (w)
      {
        w.onmessage = null;
        w.terminate();
      }
    }
    
    _.each(this.jobs, function(job)
    {
      job.trigger("terminated", job);
    });
    
    this.jobs = {};
    this.onDispatchMessage = null;
    this.onErrorMessage = null;
  };
    
  PoolP.createJob = function(name)
  {
    if (this.readyCount === this.count)
    {
      var id =  this.jobsCounter++;
      
      //vitrium.log.debug("create job "+id +" name "+name);
      
      return this.jobs[id] = new Job(this, id, name);
    }
    else
    {
      throw new Error("Pool is not ready yet!");
    }
  };
  
  PoolP.postMessage = function(id, message)
  {
    //console.log("postMessage to job: "+id, message);
    var worker = this.workers[id % this.count];
    worker.postMessage({ cmd :  CMD_JOB_MSG, id : id, data : message});
  };
  
  PoolP.terminate = function (id)
  {
    //vitrium.log.debug("terminate job "+id);
    var worker = this.workers[id % this.count];
    worker.postMessage({ cmd :  CMD_TERMINATE, id : id});
  };
  
  function onErrorMessage(error)
  {
     vitrium.log.error("[Pool]", this.script);
     vitrium.log.error(error.message);
     var stack = error.stack;
     if (stack)
     {
        vitrium.log.error(stack);
     }
     else
     {
        vitrium.log.error(error);
     }

    error.preventDefault();
  }
  
  function onDispatchMessage(event)
  {
    var msg = event.data;
    var id = msg.id;
    var cmd = msg.cmd;
    
    switch(cmd)
    {
      case CMD_JOB_MSG:
        var job = this.jobs[id];
        if (job)
        {
          job.trigger("message", msg);
        }
        else
        {
          vitrium.log.error("job "+id+" not exists");
        }				
      break;
      case CMD_TERMINATED:
        var job = this.jobs[id];
        if (job)
        {
          job.trigger("terminated", job);
          
          var job = this.jobs[id];
          job.pool = null;
          job.terminating = true;
          
          delete this.jobs[id];
        }
        else
        {
          vitrium.log.error("job "+id+" not exists");
        }	
      break;
       case CMD_INITIALIZED:
          log.debug("[Pool] response from WebWorker "+this.script+" CMD_INITIALIZED");

         var count = ++this.readyCount;
        if (count === this.count)
        {
           log.debug("[Pool] all workers are ready");
          this.onready(count);
        }
      break;
      case CMD_ERROR:
        
        var job = this.jobs[id];
        if (job)
        {
          vitrium.log.error("jobId:"+id+" name: "+job.name+" error: "+msg.data);
          job.trigger("error", msg);
        }
      break;
    }
  };	
  
  function Job(pool, id, name)
  {
    this.pool = pool;
    this.id = id;
    this.terminating = false;
    this.name = name;
  }
  
  var JobP = Job.prototype;
  _.extend(JobP, Backbone.Events);
  JobP.addEventListener = JobP.on;
  JobP.removeEventListener = JobP.off;
  JobP.postMessage = function (message)
  {
    if (!this.terminating)
    {
      this.pool.postMessage(this.id, message);
      return true;
    }
    else
    {
      return false;		//throw new Error("Cannot send the message, job "+this.id+" was terminated"); 
    }
  };

  
  JobP.terminate = function()
  {
    if (!this.terminating)
    {
      this.terminating = true;
      this.pool.terminate(this.id);
    }
  };	
  
  JobP.abort = JobP.terminate;

  function noop() { }

  function workerPath(requestedPath)
  {
    var path = global.ZIP_WORKER_PATH;
    if (!path)
    {
      path = vitrium.base_path;
    }

    if (requestedPath)
    {
      path = path + requestedPath;
    }

    return resourceUrl(path);
  }

  function resourceUrl(url) {
     var version = $("meta[name='resources-version']").attr("content");
     if (version && version.length > 0) {
        return url + "?version=" + version;
     }
     return url;
  }
  
}(
vitrium.utils,
vitrium,
vitrium.log,
Backbone,  
_,
__globals__));
// script:viewer/io/g4s-format.js
(function(exports, bin, global)
{
	"use strict";
	
	var Utf8Decoder = bin.SimpleUTF8Decoder;
	var isTypedArraysSupported = !!global.ArrayBuffer;
	
	
	var INT_LIMIT = new BigInteger(Math.pow(2,53).toString());
	
	var UINT8 = 1;
	var UINT16 = 2;
	var UINT32 = 4;
	var INT64 = 8;
	
	function Header(magic, version, globalFlags, numberOfEntries, directoryOffset, directoryLen,directoryCRC32)
	{
		this.magic = magic;
		this.version = version;
		this.globalFlags = globalFlags;
		this.numberOfEntries = numberOfEntries;
		this.directoryOffset = directoryOffset;
		this.directoryLen = directoryLen;
		this.directoryCRC32 = directoryCRC32;
	}
	
	Header.parse = function (data, offset)
	{
		if (!offset) offset = 0;
		var view = data.view;
		var i = offset;
		
		var magic = view.getUint16(i, true);
		i += UINT16;	
		
		var version = view.getUint16(i, true);
		i += UINT16;	
		var globalFlags = view.getUint16(i, true);
		i += UINT16;
		var numberOfEntries = view.getUint16(i, true);
		i += UINT16;
		var directoryOffset =  positiveInt64ToNumberSafe(parsePositiveInt64LE(view, i));
		i += INT64;
		var directoryLen = view.getUint32(i , true);
		i +=  UINT32;
		var directoryCRC32 = view.getUint32(i , true);
		i += UINT32;
				
		return new Header(magic, version, globalFlags, numberOfEntries, directoryOffset, directoryLen, directoryCRC32);
	};
	
	Header.SIZE = UINT16 + UINT16 + UINT16 + UINT16 + INT64 + UINT32 + UINT32;
	Header.prototype.isValid= function()
	{	
		return this.directoryOffset > 0 && this.magic === 0x5334;	
	};
	
	
	function FileEntry(flags, offset, compressedSize, uncompressedSize, crc32, filename, metadata, size)
	{
		this.flags = flags;
		this.offset = offset; 
		this.compressedSize = compressedSize;
		this.uncompressedSize = uncompressedSize;
		this.crc32 = crc32;
		this.filename = filename;
		this.metadata = metadata;
		this.size = size;
		
		//AES related fields
		this.hmacChecksum = null;
		this.aesSalt = null;
		this.aesPV = null;
		this.aesMode = null;
		this.aesDerivedKey = null;
		this.hmacKey = null;
	}
	
	FileEntry.SIZE = UINT16 + INT64+INT64 + INT64 +UINT32 + UINT16+ UINT16;
	
	FileEntry.parse = function(data, offset)
	{
		var view = data.view;
		var i = offset;
		var flags = view.getUint16(i, true);
		i += UINT16;
		var offset =  positiveInt64ToNumberSafe(parsePositiveInt64LE(view, i));
		i += INT64;
		var compressedSize =  positiveInt64ToNumberSafe(parsePositiveInt64LE(view, i));
		i += INT64;
		var uncompressedSize =  positiveInt64ToNumberSafe(parsePositiveInt64LE(view, i));
		i += INT64;
		var crc32 =  view.getUint32(i, true);
		i += UINT32;
		var fileNameLen = view.getUint16(i, true);
		i += UINT16;
		var extraMetadataLen = view.getUint16(i, true);
		i += UINT16;
		
		var fileName = parseUTF8String(data.array, i, fileNameLen);
		i += fileNameLen;
		
		var metadata =  extraMetadataLen > 0 ? data.array.subarray(i, i+extraMetadataLen) : null;
		if (metadata !== null && !isTypedArraysSupported)
		{	
			var tmp = new bin.DataBuffer();
			tmp.attachData(metadata);
			metadata = tmp;		
		}
		
		return new FileEntry(flags, offset, compressedSize, uncompressedSize, crc32 , fileName, metadata, FileEntry.SIZE + fileNameLen + extraMetadataLen);
	};
	
	FileEntry.prototype.isValid = function()
	{
		return this.offset >= Header.SIZE && this.compressedSize > 0 && this.uncompressedSize > 0;
	};
	
	
	
	
	function parsePositiveInt64LE(dataView, offset)
	{
		var hi = dataView.getUint8(offset+7);
	
		if (hi > 0x7F)
		{
			throw new Error("Value is negative!");
		}
		
		var buffer = [
			hi.toString(16),
			dataView.getUint8(offset+6).toString(16),
			dataView.getUint8(offset+5).toString(16),
			dataView.getUint8(offset+4).toString(16),
			dataView.getUint8(offset+3).toString(16),
			dataView.getUint8(offset+2).toString(16),
			dataView.getUint8(offset+1).toString(16),
			dataView.getUint8(offset+0).toString(16)
			];
			
		if (buffer[0].length === 1) buffer[0] = "0"+buffer[0];
		if (buffer[1].length === 1) buffer[1] = "0"+buffer[1];
		if (buffer[2].length === 1) buffer[2] = "0"+buffer[2];
		if (buffer[3].length === 1) buffer[3] = "0"+buffer[3];
		if (buffer[4].length === 1) buffer[4] = "0"+buffer[4];
		if (buffer[5].length === 1) buffer[5] = "0"+buffer[5];
		if (buffer[6].length === 1) buffer[6] = "0"+buffer[6];
		if (buffer[7].length === 1) buffer[7] = "0"+buffer[7];
		
		return new BigInteger(buffer.join(''),16);		
	}
	
	function positiveInt64ToNumberSafe(int64)
	{
		var r;
		if (int64.compareTo(INT_LIMIT) <= 0)
		{
			r = int64.intValue();
		}
		else
		{
			r = -1;
		}
		return r;
	}
	
	function parseUTF8String(dataArray, offset, len)
	{
		//string is end with ZERO
		len -= 1; 
		var dec =  new Utf8Decoder(len);
		dec.init(noop);
		
		dec.decodeUTF8(dataArray.subarray(offset, offset+ len));
		
		var str = null;
		dec.getData(function(_str){ str = _str; });
		
		return str;
	}
	
	exports["FileEntry"] = FileEntry;
	exports["Header"] = Header;
	
	var noop = function(){};
	
}(
vitrium.g4s,
vitrium.bin,
__globals__
));
// script:viewer/io/g4s-io-chunk-processors.js
(function(exports, utils, bin, globals, CRC32, zip, CryptoJS)
{

	"use strict";
	
	var isTypedArraysSupported = !!globals.ArrayBuffer;
	var CHUNK_SIZE = isTypedArraysSupported ? 1000000 : 500000 ; 
	
	
	var getDataHelper = bin.getDataHelper;

	var launchProcess;
	if (isTypedArraysSupported)
	{
			launchProcess = function(process, reader, writer, offset, size, onappend, onprogress, onend, onreaderror, onwriteerror) {
			var chunkIndex = 0, index, outputSize = 0;
			var abort = new AbortHandler();
			
			function step() {
				var outputData;
				index = chunkIndex * CHUNK_SIZE;
				if (index < size)
					abort.req = reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(inputData) {
						var outputData = process.append(inputData, function() {
							if (onprogress)
								onprogress(offset + index, size);
						});
						
						if (outputData === -1)
						{
							chunkIndex++;
							step();
						}
						outputSize += outputData.length;
						onappend(true, inputData);
						writer.writeUint8Array(outputData, function() {
							onappend(false, outputData);
							chunkIndex++;
							step();
							//setTimeout(step, 1);
													
						}, onwriteerror);
						if (onprogress)
							onprogress(index, size);
					}, onreaderror);
				else {
					outputData = process.flush();
					if (outputData) {
						outputSize += outputData.length;
						writer.writeUint8Array(outputData, function() {
							onappend(false, outputData);
							onend(outputSize);
						}, onwriteerror);
					} else
						onend(outputSize);
				}
			}

			step();
			
			return abort;
		};
	
	}
	else
	{
	launchProcess = function(process, reader, writer, offset, size, onappend, onprogress, onend, onreaderror, onwriteerror) {
			var chunkIndex = 0, index, outputSize = 0;
			var abort = new AbortHandler();
			
			function step() {
				var outputData;
				index = chunkIndex * CHUNK_SIZE;
				if (index < size)
					abort.req = reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(inputData) {
						var suboffset = 0;
						var rem = inputData.length;
						function substep()
						{
							if (rem > 0)
							{
				
									var lastoffset = suboffset + Math.min(rem, 1024);
									var chunk;
									if (offset == 0 && lastoffset === rem)
									{
										chunk = inputData;
									}
									else
									{
										chunk = inputData.subarray(suboffset, lastoffset);
									}
									var chsize = lastoffset - suboffset;
									suboffset += chsize;
									rem -= chsize;
									
									var outputData = process.append(chunk, function() {
										if (onprogress)
											onprogress(offset + suboffset, size);
									});
									
									onappend(true, inputData);
									if (outputData === -1)
									{
										var t = setTimeout(substep, 1);
										abort.req = { abort : function(){ clearTimeout(t);}};
									}
									else
									{
										outputSize += outputData.length;
										writer.writeUint8Array(outputData, function() {
											onappend(false, outputData);
											var t = setTimeout(substep, 1);
											abort.req = { abort : function(){ clearTimeout(t);}};
										}, onwriteerror);
									}
									
								if (onprogress)
									onprogress(index, size);
							}
							else
							{
								chunkIndex++;
								step();
							}
						}
						substep();
						
					}, onreaderror);
				else {
					outputData = process.flush();
					if (outputData) {
						outputSize += outputData.length;
						writer.writeUint8Array(outputData, function() {
							onappend(false, outputData);
							onend(outputSize);
						}, onwriteerror);
					} else
						onend(outputSize);
				}
			}

			step();
			
			return abort;
		};
	
	}
	
		

	function inflate(reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
		var worker, crc32 = new CRC32();
		var abort = new AbortHandler();
		
		function oninflateappend(sending, array) {
			if (computeCrc32 && !sending)
				crc32.append(array);
		}

		function oninflateend(outputSize) {
			onend(outputSize, crc32.get());
		}
	
		var inflater = new zip.Inflater();
		abort.req = launchProcess(inflater, reader, writer, offset, size, oninflateappend, onprogress, oninflateend, onreaderror, onwriteerror);
		
		return abort;
	}

	function copy(reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
		var chunkIndex = 0, crc32 = new CRC32();
		var abort = new AbortHandler();
		
		function step() {
			var index = chunkIndex * CHUNK_SIZE;
			if (index < size)
				abort.req = reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(array) {
					if (computeCrc32)
						crc32.append(array);
					if (onprogress)
						onprogress(index, size, array);
					writer.writeUint8Array([array], function() {
						chunkIndex++;
						step();
					}, onwriteerror);
				}, onreaderror);
			else
				onend(size, crc32.get());
		}

		step();
		
		return abort;
	}
	
	function aesHashEq(hmac, hmacChksum)
	{
		var hash = utils.u8array.stringify({ words : hmac.hasher.hash, sigBytes: 20});
				
		if (hmacChksum.readByteAt)
		{
		
			for (var i = 0; i < 10; ++i)
			{
				if (hash[i] != hmacChksum.readByteAt(i))
				{
					return false;
				}
			}
		}
		else
		{
			for (var i = 0; i < 10; ++i)
			{
				if (hash[i] != hmacChksum[i])
				{
					return false;
				}
			}
		}
		
		return true;
	}
	
	function aesCopy(reader, writer, offset, size, onend, onprogress, onreaderror, onwriteerror, aesDecryptor, hmac, hmacChksum, onbadpassword) {
		var chunkIndex = 0;
		var abort = new AbortHandler();

		function step() {
			var index = chunkIndex * CHUNK_SIZE;
			if (index < size)
			{
				abort.req = reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(array) {
					var wordArray = utils.u8array.parse(array);
					hmac.update(wordArray);
					
					var deryptedChuck = aesDecryptor.process(wordArray);
					
					if (onprogress)
						onprogress(index, size, array);
					
					if (deryptedChuck.sigBytes > 0)
					{										
						var dBytes = utils.u8array.stringify(deryptedChuck);
						
						writer.writeUint8Array([dBytes], function() {
							chunkIndex++;
							step();
						}, onwriteerror);
					}
					else
					{
						chunkIndex++;
						step();
					}
				}, onreaderror);
			}
			else
			{
				hmac.finalize();
			
				
				if (aesHashEq(hmac, hmacChksum))
				{	
					var deryptedChuck = aesDecryptor.finalize();
					if (deryptedChuck.sigBytes > 0)
					{										
						var dBytes = utils.u8array.stringify(deryptedChuck);	
						writer.writeUint8Array(dBytes, function() {
							onend(size);
						}, onwriteerror);
					}
					else
					{
						onend(size);
					}
				}
				else
				{
					onbadpassword();
				}
			}
		}

		step();
		
		return abort;
	}
	
	
	function aesInflate(reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror, aesDecryptor, hmac, hmacChksum, onbadpassword) 
	{
		var worker, crc32 = new CRC32();		
		var abort = new AbortHandler();

		function oninflateappend(sending, array) {
			if (computeCrc32 && !sending)
				crc32.append(array);
		}

		function oninflateend(outputSize) {
			onend(outputSize, crc32.get());
		}

		var inflater = new zip.Inflater();
		abort.req = aesLaunchProcess(inflater, reader, writer, offset, size, oninflateappend, onprogress, oninflateend, onreaderror, onwriteerror , aesDecryptor, hmac, hmacChksum, onbadpassword);
				
		return abort;
	}
	
	function convertCryptoArray(array)
	{
		if (!isTypedArraysSupported)
		{
			var buffer = new bin.DataBuffer();
			buffer.attachData(array);
			array = buffer;
		}
		return array;
	}
	
	var aesLaunchProcess;
	if (isTypedArraysSupported)
	{
		aesLaunchProcess = function(process, reader, writer, offset, size, onappend, onprogress, onend, onreaderror, onwriteerror, aesDecryptor, hmac, hmacChksum, onbadpassword) 
		{
		var chunkIndex = 0, index, outputSize = 0;
		var aesFlushed = false;
		var abort = new AbortHandler();
		
		function step() {
			var outputData;
			index = chunkIndex * CHUNK_SIZE;
			
			if (aesFlushed)
			{
				outputData = process.flush();
				if (outputData) {
					outputSize += outputData.length;
					writer.writeUint8Array(outputData, function() {
						onappend(false, outputData);
						onend(outputSize);
					}, onwriteerror);
				} else
					onend(outputSize);
			}
			else if (index < size)
			{
				abort.req = reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(array) {
					var wordArray = utils.u8array.parse(array);
					hmac.update(wordArray);
					
					var deryptedChuck = aesDecryptor.process(wordArray);
					chunkIndex++;
				
					if (onprogress)
						onprogress(offset + index, size);
						
					if (deryptedChuck.sigBytes > 0)
					{	
						var dBytes = convertCryptoArray(utils.u8array.stringify(deryptedChuck));
										
						var outputData = process.append(dBytes, function() {});
						if (outputData === -1)
						{
							step();
						}
						
						outputSize += outputData.length;
						onappend(true, dBytes);
						
						writer.writeUint8Array(outputData, function() {
							onappend(false, outputData);
							step();													
						}, onwriteerror);
					}
					else
					{
						step();
					}
				}, onreaderror);
			}
			else {
				hmac.finalize();
				if (aesHashEq(hmac, hmacChksum))
				{	
					var deryptedChuck = aesDecryptor.finalize();
					aesFlushed = true;
					if (deryptedChuck.sigBytes > 0)
					{	
						var dBytes = convertCryptoArray(utils.u8array.stringify(deryptedChuck));				
						var outputData = process.append(dBytes, function() {});
						
						outputSize += outputData.length;
						onappend(true, dBytes);
						
						writer.writeUint8Array(outputData, function() {
							onappend(false, outputData);
							step();
						}, onwriteerror);
					}
					else
					{
						step();
					}
				}
				else
				{
					onbadpassword();
				}
			}
		}

		step();
		
		return abort;
		}
	}
	else
	{
		aesLaunchProcess = function(process, reader, writer, offset, size, onappend, onprogress, onend, onreaderror, onwriteerror, aesDecryptor, hmac, hmacChksum, onbadpassword) 
		{
		var chunkIndex = 0, index, outputSize = 0;
		var aesFlushed = false;
		var abort = new AbortHandler();
		
		function step() {
			var outputData;
			index = chunkIndex * CHUNK_SIZE;
			
			if (aesFlushed)
			{
				outputData = process.flush();
				if (outputData) {
					outputSize += outputData.length;
					writer.writeUint8Array(outputData, function() {
						onappend(false, outputData);
						onend(outputSize);
					}, onwriteerror);
				} else
					onend(outputSize);
			}
			else if (index < size)
			{
				
				abort.req = reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(array) {
					var rem = array.length;
					var suboffset = 0;
					function substep()
					{
						if (rem > 0)
						{
								var lastoffset = suboffset + Math.min(rem, 1024);
								var chunk;
								if (offset == 0 && lastoffset === rem)
								{
									chunk = array;
								}
								else
								{
									chunk = array.subarray(suboffset, lastoffset);
								}
								var chsize = lastoffset - suboffset;
								suboffset += chsize;
								rem -= chsize;
						
							var wordArray = utils.u8array.parse(chunk);
							hmac.update(wordArray);
							
							var deryptedChuck = aesDecryptor.process(wordArray);
							chunkIndex++;
						
							if (onprogress)
								onprogress(offset + index, size);
								
							if (deryptedChuck.sigBytes > 0)
							{	
								var dBytes = convertCryptoArray(utils.u8array.stringify(deryptedChuck));
												
								var outputData = process.append(dBytes, function() {});
								if (outputData === -1)
								{
									var t = setTimeout(substep, 1);
									abort.req = { abort : function(){ clearTimeout(t);}};
								}
								else
								{
									outputSize += outputData.length;
									writer.writeUint8Array(outputData, function() {
										onappend(false, outputData);
										var t = setTimeout(substep, 1);
										abort.req = { abort : function(){ clearTimeout(t);}};
									}, onwriteerror);
								}
							}
							else
							{
								chunkIndex++;
								step();
							}
						}
						else
						{
								chunkIndex++;
								step();
						}
					}
					
					substep();
				}, onreaderror);
				
			}
			else {
				hmac.finalize();
				if (aesHashEq(hmac, hmacChksum))
				{	
					var deryptedChuck = aesDecryptor.finalize();
					aesFlushed = true;
					if (deryptedChuck.sigBytes > 0)
					{	
						var dBytes = convertCryptoArray(utils.u8array.stringify(deryptedChuck));				
						var outputData = process.append(dBytes, function() {});
						
						outputSize += outputData.length;
						onappend(true, dBytes);
						
						writer.writeUint8Array(outputData, function() {
							onappend(false, outputData);
							step();
						}, onwriteerror);
					}
					else
					{
						step();
					}
				}
				else
				{
					onbadpassword();
				}
			}
		}

		step();
		
		return abort;
		}
	
	
	
	
	
	
	}
	
	function AbortHandler()
	{
		this.req = null;
		this.worker = null;
	}
	
	AbortHandler.prototype.terminate =  function()
	{
		if(this.req) this.req.abort();
		if(this.worker) this.worker.terminate();
	};
	AbortHandler.prototype.abort = AbortHandler.prototype.terminate; 

	
	exports.inflate = inflate;
	exports.copy = copy;	
	exports.aesCopy = aesCopy;
	exports.aesInflate = aesInflate;
	
}(
vitrium.g4s,
vitrium.utils,
vitrium.bin,
__globals__,
CRC32,
vitrium.zip,
CryptoJS));
// script:viewer/io/g4s.js
(function(exports, bin, global, crypto, utils, AES)
{
	"use strict";
	var ERR_TOO_SMALL = "file is too small to hold G4S format";
	var ERR_INVALID_HEADER = "invalid G4S header";
	var ERR_INVALID_DIRECTORY_CHECKSUM = "invalid G4S directory checksum";
	
	var ERR_READ = "Error while reading zip file.";
	var ERR_WRITE = "Error while writing zip file.";
	var ERR_WRITE_DATA = "Error while writing file data.";
	var ERR_READ_DATA = "Error while reading file data.";
	var ERR_AES_HEADER_MISSING = "AES header 0x9901 not found";
	var ERR_COMPRESION_METHOD = "Unknown compression method";
	var ERR_REQUIRED_AES_KEY = "Required AES key";
	var ERR_AES_UNKNOWN_STRENGTH = "Unknown strength value.";
	var ERR_AES_WRONG_PASSWORD = "Wrong password.";
	var ERR_AES_GLOBAL_METADATA = "Missing global AES metadata";
	var ERR_AES_METADATA = "Missing AES metadata";
	
	var Header = exports.Header;
	var FileEntry = exports.FileEntry;
	var inflate = exports.inflate;
	var copy = exports.copy;
	var aesInflate = exports.aesInflate;
	var aesCopy = exports.aesCopy;
	
	var CRC32 = global.CRC32;
	var isTypedArraysSupported = !!global.ArrayBuffer;
	
	exports.readEntries = function (reader, callback, onerror, headerBytes)
	{
		if (!reader)
		{
			onerror("reader must be specified");
			return;
		}
		
		if (reader.size < Header.SIZE)
		{
			onerror(ERR_TOO_SMALL);
			return;
		}
		
		var abortHandle = new AbortHandle();
		if (!headerBytes)
		{
			abortHandle.req = reader.readUint8Array(0, Header.SIZE, onHeaderReturned, onerror);
		}
		else
		{
			if (!isTypedArraysSupported)
			{
				var buffer = new bin.DataBuffer();
				buffer.attachData(headerBytes);
				
				onHeaderReturned(buffer);
			}
			else
			{
				onHeaderReturned(headerBytes);
			}
		}
		
		function onHeaderReturned(bytes) 
		{	
			if (bytes.length < Header.SIZE) { onerror(ERR_TOO_SMALL); return;}
		
			var helper = bin.getDataHelper(bytes.length, bytes);
			var header = Header.parse(helper);
			if (header.isValid())
			{
				abortHandle.req = reader.readUint8Array(header.directoryOffset, header.directoryLen, function(bytes)
				{
					var checksum = new CRC32();
					checksum.append(bytes);
					
					if (checksum.equals(header.directoryCRC32))
					{
						var helper = bin.getDataHelper(bytes.length, bytes);
						var entries = [];
						var offset = 0;
						for (var i = 0, len = header.numberOfEntries; i < len;++i)
						{
							var entry = FileEntry.parse(helper, offset);
							if (entry.isValid())
							{
								entries.push(entry);
							}
							
							offset += entry.size;
						}

						
						if ((header.globalFlags & (1|2)))	
						{
							
							//GF_SINGLE_PWD_SINGLE_KEY_AES|GF_SINGLE_PWD_MULTIPLE_KEYS_AES
							var aesGlobalSalt = null;
							var aesGlobalPV = null;
							var aesGlobalMode = null;
							if ((header.globalFlags & 1) === 1)
							{
								if (helper.array.length  - offset  > 0)
								{
									var view = helper.view;
									aesGlobalMode = view.getUint8(offset);
									var aesDataLen = offset + 1+2+(4*(aesGlobalMode&3) +4);
									// aes metadata are located after entries
									if (helper.array.length < aesDataLen)
									{
										onerror(ERR_AES_GLOBAL_METADATA);
										return;
									}
									
									/* global metadata contains
												1 byte	mode <1,3> (currently just 3=>AES256)
												2 bytes	password verification
												(4 * (mode & 3) + 4) bytes	salt											
									*/
									
									aesGlobalPV = view.getUint16(offset + 1, true);								
									aesGlobalSalt = helper.array.subarray(offset + 3, aesDataLen);
								}
								else
								{
										onerror(ERR_AES_GLOBAL_METADATA);
										return;
								}
							}
								
							for (var i = 0, len=entries.length; i < len; ++i)
							{
								var entry = entries[i];
								var fl = entry.flags;
								
								if ((fl & 2) === 2 && aesGlobalSalt !== null)
								{
										entry.hmacChecksum = entry.metadata;
										entry.aesSalt = aesGlobalSalt;
										entry.aesPV = aesGlobalPV;
										entry.aesMode = aesGlobalMode;
								}
								else if ((fl & 4) === 4 && entry.metadata.length > 0)
								{								
										var eHelper = bin.getDataHelper(entry.metadata.length, entry.metadata);
										var view = eHelper.view;
										var mode = entry.aesMode = view.getUint8(0);
										var saltLen = (4*(mode&3) +4);
										if (entry.metadata.length === 1+2+saltLen+10)
										{
											entry.aesPV = view.getUint16(1, true);
											entry.aesSalt =  entry.metadata.subarray(1+2, 1+2+saltLen);
											entry.hmacChecksum = entry.metadata.subarray(1+2+saltLen,1+2+saltLen+10);
										}
										else
										{
											onerror(ERR_AES_METADATA );
											return;
										}
								}
								else if ((fl & (2|4)) !== 0)
								{
									onerror(ERR_AES_METADATA);
									return;
								}
							}
						}
						
						callback(entries, header.globalFlags);
					}
					else
					{
						onerror(ERR_INVALID_DIRECTORY_CHECKSUM);
					}									
				}, onerror);
			}
			else
			{
				onerror(ERR_INVALID_HEADER);				
			}
		}
		
		return abortHandle;
	};
	
	exports.readEntry = function(reader, entry, options)
	{
			var ddSupport = options.ddSupport;
			var writer  = options.writer;
			var onend = options.onend || function(){};
			var onprogress = options.onprogress || function(){};
			var onerrorentry = options.onerror || function(){};
			var onrangerecieved = options.onrange || function(){};
			
			var checkCrc32 = !!options.checkCrc32;
			var password = options.password;
	
			var worker = null;
			
			function getdataerror()
			{
				onerrorentry.apply(entry, arguments);
			}

			function terminate(callback, param) 
			{
				if (worker)
					worker.terminate();
					
				worker = null;
				try
				{
					if (callback)
					{
						if (arguments.length > 2)
						{
							var args = [];
							for (var i = 1, len =arguments.length; i < len; ++i)
							{
								args.push(arguments[i]);
							}
							
							callback.apply(null, args);
						}
						else
						{
							callback(param);
						}
					}
					
					
					if (writer && writer.free)
					{
					
						writer.free();
					}
					
				}
				catch(e)
				{
					getdataerror(e);
				}
			}
						
			function getWriterData(uncompressedSize, crc32) {
			
				if (checkCrc32 && crc32.equals(entry.crc32))
					onreaderror();
				else
				{
					try
					{
						writer.getData(function(data) {
							terminate(onend, data);
						});
					}
					catch(e)
					{
						terminate(getdataerror, e);
					}
				}
			}
			
			function onreaderror(e1, e2) {
				terminate(getdataerror, ERR_READ_DATA, e1, e2);
			}

			function onwriteerror() {
				terminate(getdataerror, ERR_WRITE_DATA);
			}
			
			function wrongpassword()
			{
				terminate(getdataerror, ERR_AES_WRONG_PASSWORD);
			}
			
			writer.init(function()
			{
				if (entry.flags & (2|4))
				{
					var aesKey = utils.u8array.parse(entry.aesDerivedKey);
					var hmacKey = utils.u8array.parse(entry.hmacKey);
					var hmacChecksum = entry.hmacChecksum;
					
					var aesDecryptor = AES.createDecryptor(aesKey, 
					{ 
						iv :  utils.u8array.parse([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]), 
						mode: CryptoJS.mode.CTRGladman, 
						padding: CryptoJS.pad.NoPadding
					});
					 
					var hmacHasher = new crypto.HMACSha1(hmacKey);
					
					if (entry.flags & 0x0001 === 0x0001)
					{
						worker = aesInflate(reader, writer, entry.offset, entry.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror, aesDecryptor, hmacHasher, hmacChecksum, wrongpassword);
					}
					else
					{
						worker = aesCopy(reader, writer, entry.offset, entry.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror, aesDecryptor, hmacHasher, hmacChecksum, wrongpassword);
					}
				}
				else if (ddSupport)
				{
					var req = null;
					if (entry.flags & 0x0001 === 0x0001)
					{
						req = reader.readAndDecode(entry.offset, entry.compressedSize, function(data) {	terminate(onend, data);	},onreaderror, "deflate");
					}
					else
					{
						req = reader.readAndDecode(entry.offset, entry.compressedSize, function(data) {	terminate(onend, data);	},onreaderror, "");
					}
					
					worker = {
							terminate :function()
							{
								req.abort();
							}
					};
				}
				else
				{
					if (entry.flags & 0x0001 === 0x0001)
					{
						worker = inflate(reader, writer, entry.offset, entry.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
					}
					else
					{
						worker = copy(reader, writer, entry.offset, entry.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
					}
				}
			}, onwriteerror);
			
			return 	function(){worker.terminate();};
	};
	
	function AbortHandle()
	{
		this.req = null;
	}
	AbortHandle.prototype.terminate =  function()
	{
		if(this.req) this.req.abort();
	};
	AbortHandle.prototype.abort = AbortHandle.prototype.terminate; 
	
}(
vitrium.g4s,
vitrium.bin,
__globals__,
vitrium.crypto,
vitrium.utils,
CryptoJS.algo.AES
));
// script:viewer/io/file-system-algorithms.js
(function (exports, _) 
{
	"use strict";
  
  exports.findFileById = findFileById;
  exports.findFileByIdAndUrl = findFileByIdAndUrl;
  exports.findFileByIdAndNotUrl = findFileByIdAndNotUrl;
  exports.findFileByUrl = findFileByUrl;
  
  exports.makeIdSafe = makeIdSafe; 
  
  function findFileById(fileList, id)
  {
    return _.find(fileList, function(file) { return file.id === id; });
  }
  
  function findFileByUrl(fileList, url)
  {
    return _.find(fileList, function(file) { return file.url === url; });
  }
  
  function findFileByIdAndNotUrl(fileList, id, url)
  {
    return _.find(fileList, function(file) { return file.id === id && file.url !== url; });
  }
 
 
  function findFileByIdAndUrl(fileList, id, url)
  {
    return _.find(fileList, function(file) { return file.id === id && file.url === url; });
  } 
  
  function makeIdSafe(fileList, id, url)
  {
    id = id.replace(/\//g,"-");

    var currentId = id;
    var i = 1;
    while (findFileByIdAndNotUrl(fileList, currentId, url))
    {
      currentId = id + " ("+(i++)+")";
    }
    return currentId;
  }
  

}
(vitrium.fs, 
 _
));
// script:viewer/io/asyncStorage-tx.js
(function (exports, log, globals)
{
	"use strict";
	var tableName = "asyncStorage_data";
	var valueName = "asyncStorage_value";
	var keyName = "asyncStorage_key";
	
	exports.TxStorage = TxStorage;
	
	var backends = {
		"WebSQL" : WebSQLBackend,
		"IndexedDB": IndexedDBBackend
	};
	
	function TxStorage(db)
	{
		this.db = db;
	}

	TxStorage.prototype = {
		transaction : function(callback, error)
		{
			var BackendClass = backends[this.db.type];
			if (typeof BackendClass === "undefined")
			{
				log.error("transactions are not supported on this type: "+this.db.type);
				if (error) error("transactions are not supported on this type: "+this.db.type);				
			}
			else
			{
				new BackendClass(this.db.name, this.db._db, callback, error, false);
			}
		},
		readTransaction : function(callback, error)
		{
			var BackendClass = backends[this.db.type];
			if (typeof BackendClass === "undefined")
			{
				log.error("transactions are not supported on this type: "+this.db.type);
				if (error) error("transactions are not supported on this type: "+this.db.type);				
			}
			else
			{
				new BackendClass(this.db.name, this.db._db, callback, error, true);
			}
		}
	};
	

	function WebSQLBackend(name, db, callback, error, read)
	{
		this.name = name;
		this.tx = null;
		var self = this;
		if (read)
		{
			db.readTransaction(function(tx)
			{
				self.tx = tx;
				callback(self);
			}, error);
		}
		else
		{
			db.transaction(function(tx)
			{
				self.tx = tx;
				callback(self);
			}, error);
		}
	}
	function WebSQLInTx(name, tx)
	{
		this.name = name;
		this.tx = tx;
	}
	
	WebSQLInTx.prototype = WebSQLBackend.prototype = {
		abort : function()
		{
			this.tx.executeSql('ABORT', [], null, function(){ return true;});
		},
		setItem : function(key, value, callback, error)
		{
			//var self = this;
			var name = this.name;
			this.tx.executeSql("UPDATE "+name +" SET "+valueName+"=? WHERE "+keyName+"=?", [value, key], function(tx, rs)
			{
				if (rs.rowsAffected === 0)
				{
					tx.executeSql("INSERT INTO "+name +" ("+keyName+", "+valueName+") VALUES (?,?)", [key, value], function(tx, rs)
					{
						if (callback) callback(new WebSQLInTx(name, tx), value, key);
					}, handleError);
				}
				else
				{
					if (callback) callback(new WebSQLInTx(name, tx), value, key);
				}
			}, handleError);
			
			function handleError(e)
			{
				if (error) error(e);
			}
		},
		getItem : function(key, callback, error)
		{
			var name = this.name;
			//var self = this;
			this.tx.executeSql("SELECT * FROM "+name +" WHERE "+keyName+"=?", [key], function(tx, rs)
			{
				if (callback)
				{
					if (rs.rows.length === 0)
					{
						callback(new WebSQLInTx(name, tx), null, key);
					}
					else
					{
						callback(new WebSQLInTx(name, tx), rs.rows.item(0)[valueName], key);
					}
				}
			}, 	
			function(e)
			{
				if (error) error(e);
			});
		},
		listItems: function(callback, error)
		{
		  this.tx.executeSql("SELECT " + keyName + " FROM " + this.name, [], function (tx, rs)
		  {
		    var items = [];
		    for (var i = 0, len = rs.rows.length; i < len; ++i)
		    {
		      items.push(rs.rows.item(i)[keyName]);
		    }
		    callback(items);
		  },
      function (e)
		  {
        if (error) error(e);
		  });
		},
		removeItem: function(key, callback, error)
		{
			//var self = this;
			var name = this.name;
			this.tx.executeSql("DELETE FROM "+name +" WHERE "+keyName+"=?", [key], function(tx, rs)
			{
				if (callback) callback(new WebSQLInTx(name, tx));
			},
			function(e)
			{
				if (error) error(e);
			});
		},
		clear : function(callback, error)
		{
			var self = this;
			var name = this.name;
			this.tx.executeSql("DELETE FROM "+name,[], function(tx, rs)
			{
				if (callback) callback(new WebSQLInTx(name, tx));
			},
			function(e)
			{
				if (error) error(e);
			});
		}
	};
	var READ_ONLY = globals.IDBTransaction?(IDBTransaction.READ_ONLY || "readonly") : "readonly";
	var READ_WRITE= globals.IDBTransaction?(IDBTransaction.READ_WRITE || "readwrite") : "readwrite";
	
	function IndexedDBBackend(name, db, callback, error, readonly)
	{
		this.name = name;
		this.db = db;
		this.tx = db.transaction([tableName], (readonly? READ_ONLY: READ_WRITE));
		callback(this);
		var self =this;
		this.tx.onerror = function(e){
			if (error) error(e);
		};
	}
	
	IndexedDBBackend.prototype = {
		abort : function()
		{
			this.tx.abort();
		},
		setItem : function(key, value, callback, error)
		{
			var self = this;
			var objectStore = this.tx.objectStore(tableName);
			var request =  objectStore.put({ "asyncStorage_key" : this.name+"|-|"+key, "asyncStorage_value" : value, store: this.name});
			request.onsuccess = function(evt)
			{
				if (callback) callback(self, value, key);
			};
			request.onerror = function(e)
			{
				if (error) error(e);
			};
		},
		getItem : function(key, callback, error)
		{
			var self = this;
			var objectStore = this.tx.objectStore(tableName);
			var request =  objectStore.get(this.name+"|-|"+key);
			request.onsuccess = function()
			{
				if (callback) 
				{
					var record = request.result;
					if (typeof record === 'undefined') {
						callback(self, null, key);
					}
					else
					{
						callback(self, request.result.asyncStorage_value, key);
					}
				}
			};
			request.onerror = function(e)
			{
				if (error) error(e);
			};
		},
		removeItem :  function(key, callback, error)
		{
			var self = this;
			var objectStore = this.tx.objectStore(tableName);
			var request =  objectStore["delete"](this.name+"|-|"+key);
			request.onsuccess = function()
			{
				if (callback) 
				{
					callback(self, key);
				}
			};
			request.onerror = function(e)
			{
				if (error) error(e);
			};
		},
		listItems : function(callback, error)
		{
		  var self = this;
		  var objectStore = this.tx.objectStore(tableName);
		  var request = objectStore.index("by_store").openCursor(IDBKeyRange.only(this.name));

		  var items = [];
		  request.onsuccess = function (evt)
		  {
		    var result = evt.target.result;
		    if (result)
		    {
		      try
		      {
		        var itemKey = result.primaryKey.substring(self.name.length + 3, result.primaryKey.length);
		        items.push(itemKey);
		      }
		      catch(e)
		      {
            // just ignore invalid keys
		      }

		      result["continue"]();
		    }
		    else
		    {
		      callback(items);
		    }
		  };
		  request.onerror = error;
     
		},
		clear : function(callback, error)
		{
			var self = this;
			var objectStore = this.tx.objectStore(tableName);
			var request =  objectStore.index("by_store").openCursor(IDBKeyRange.only(this.name));
			

			var errorEvt = null;
			
			request.onsuccess = function(e)
			{
				var result = e.target.result;
				
				if (errorEvt !== null)
				{
					if (error) error(errorEvt);
				}
				
				if(!result)	{
					if (callback) callback();
					return;
				}
					
				var delreq = result["delete"]();
				
				delreq.onerror= deleteFailed;
				
				result["continue"]();
			};
			
			request.onerror = function(e)
			{
				if (error) error(e);
			};
			
			function deleteFailed(e)
			{
				errorEvt = e;
			}
		}
	};
}(vitrium.utils, vitrium.log, __globals__));
// script:viewer/io/asyncStorage.js
(function(exports, utils,async, _, globals)
{
  "use strict";
  
  exports.create = create;
  exports.eraseLocalData = eraseLocalData;
  
  var indexedDB = globals.indexedDB ||  globals.webkitIndexedDB || globals.mozIndexedDB || globals.msIndexedDB;
   
  var storageName = "asyncStorage_data";
  var keyFieldName = "asyncStorage_key";
  var valFieldName = "asyncStorage_value";
  
  
  var errorEvent = "error";
  
  function pickBackendClass()
  {
   if (indexedDB)
    {
      return IndexedDBBackend;
    }
    else if ("openDatabase" in globals)
    {
      return WebSQLBackend;
    }
    else
    {
      return null;
    }  
  }
    
  function create(name, callback, errorback)
  { 
    var BackendClass = pickBackendClass();
    if (BackendClass !== null)
    {
      return new BackendClass(name, callback, errorback);
    }
    else
    {
      async.run(function ()
      {
        errorback(ERR_666); //an older browser 
      });
    }
  }
    
  function eraseLocalData(eraseId, callback, errorback)
  {
      var BackendClass = pickBackendClass();
      if (BackendClass === null)
      {
        async.run(function ()
        {
          errorback(ERR_666); //an older browser 
        });
      }
      else
      {
        BackendClass.erase(eraseId, function(){
          globals.localStorage.setItem("fire", "er,"+Date.now()); // notify all other windows
          callback();          
        }, errorback);
      }
  }
    
  function WebSQLBackend(name, callback, errorback)
  {
    this.type = "WebSQL";
    var tname = this.name = "\""+name+"\"";
    this._db = null;
    try
    { 
      var db = this._db = globals.openDatabase("asyncStorage", "1.0", "", null);
      
      db.transaction(_.bind(function(tx)
      {
        tx.executeSql("CREATE TABLE IF NOT EXISTS schema_info (table_name TEXT NOT NULL PRIMARY KEY) ");
        tx.executeSql("CREATE TABLE IF NOT EXISTS schema_erase_id (erase_id INTEGER NOT NULL PRIMARY KEY) ");
        tx.executeSql("SELECT table_name FROM schema_info WHERE table_name=?", [tname], function(tx, rs)
        {
          if (rs.rows.length === 0)
          {
            tx.executeSql("INSERT INTO schema_info  ( table_name) VALUES (?)", [tname]);
          }
        });
        
        tx.executeSql("CREATE TABLE IF NOT EXISTS "+tname
        +" ("
        + valFieldName + " TEXT NOT NULL, "
        + keyFieldName +" TEXT NOT NULL PRIMARY KEY )", null, _.bind(function(){
          this.st = new utils.TxStorage(this);
          if (callback) callback(this);
        }, this), errorback || noop);
      }, this), errorback || noop);
    }
    catch(e)
    {
      if (errorback)
      {
        async.run(function ()
        {
          errorback(e); //an older browser 
        });
      }
    }
  
  }
  
  WebSQLBackend.erase = function (eraseId, callback, errorback)
  {
    try
    {
      var db = globals.openDatabase("asyncStorage", "1.0", "", null);
      db.transaction(function(tx)
      {
        tx.executeSql ("SELECT erase_id as eraseId FROM schema_erase_id", null, function(tx, rs)
        {
              var idRowsLen = rs.rows.length;
              var currentId =  idRowsLen !== 0 ? rs.rows.item(0).eraseId : 0;
              
              if (currentId < eraseId)
              {
                tx.executeSql("SELECT table_name FROM schema_info", null, function(tx, rs)
                {
                    var len = rs.rows.length;
                    if ( len !== 0)
                    {
                      var tables = [];
                      for (var i = 0; i < len; ++i)
                      {
                        tables.push(rs.rows.item(i).table_name);
                      }
                      
                      for (var i = 0; i < len; ++i)
                      {
                        tx.executeSql("DELETE FROM "+tables[i]);
                      }
                    
                      if (idRowsLen === 0)
                      {
                        tx.executeSql("INSERT INTO schema_erase_id VALUES(?)", [eraseId]);
                      }
                      else
                      {
                        tx.executeSql("UPDATE schema_erase_id SET erase_id = ?", [eraseId]);
                      }
                    // tx.executeSql("DELETE FROM schema_info");
                  } 
                }, 
                function()
                {
                  //no schema table
                  errorback();
                }); 
          }
        }, 
        function(){
          //no erase id table
          errorback();
        });
      }, 
      function(e)
      {
        // tx failed
        errorback(e);
      },
      function()
      {
        // transaction succeed
        callback();
      });
      }
      catch(e)
      {
        async.run(function ()
        {
          errorback(e);
        });

      }
  };
    
  function IndexedDBBackend(name, callback, errorback, version)
  {
    this.type = "IndexedDB";
    this.name = name;
    this._db = null;
    try
    {
      var r = indexedDB.open(storageName, version || 1);
    
      r.addEventListener("upgradeneeded", _.bind(this.onUpgradeNeeded, this));
      r.addEventListener("success", _.bind(function(evt){
          var db = this._db = evt.target.result;
          
          var stores = db.objectStoreNames;
          var found = false;
          for (var i = 0, len = stores.length; i < len && !found; ++i)
          {
            found = stores[i] === storageName;
          }
          
          if (!found)
          {
            setTimeout(_.bind(function()
            {
              var v = db.version;
              ++v;
              IndexedDBBackend.call(this, name, callback, errorback, v);
            }, this), 0);
          }
          else
          {
            this.st = new utils.TxStorage(this);
            if (callback) callback(this);
          }
      }, this));
      if (errorback) r.addEventListener("error", errorback);
      
      
    } 
    catch(e)
    {
      if (errorback)
      {
        async.run(function () { errorback(e); });
      }

    }
  }
  
  IndexedDBBackend.erase = function (eraseId, callback, errorback)
  {
    create("erase_id", function(db)
    {
      db.st.transaction(function(tx)
      {
        tx.getItem("erase_id", function(tx, val)
        {
          var lastEraseId = val === null? 0 : parseInt(val, 10);
          if (lastEraseId < eraseId)
          {
            var objectStore =  tx.tx.objectStore(storageName);
            var r = objectStore.clear();
            r.onsuccess=  function()
            {
              tx.setItem("erase_id", eraseId.toString(), callback, errorback);
            };
            r.onerror = errorback;
          }
          else
          {
            callback();
          }
        }, errorback);
      }, errorback);      
    }, errorback);
  };
  
  IndexedDBBackend.prototype = {
    onUpgradeNeeded : function(evt)
    {
      evt.target.result.createObjectStore(
      storageName, {
          keyPath: keyFieldName,
          autoIncrement: false
      }).createIndex(
        "by_store",
        "store",
        {unique: false}
      );
    }
  };

  var universal = {
    setItem : function(key, val, callback, errorback)
    {
      this.st.transaction(function(tx)
      {
        tx.setItem(key, val, function(tx, value, key){
          if (callback) callback(value, key);
        }, errorback || noop);
      }, errorback || noop);
    },
    getItem : function(key, callback, errorback)
    {
      this.st.readTransaction(function(tx)
      {
        tx.getItem(key, function(tx, value, key){
          if (callback) callback(value, key);
        }, errorback || noop);
      },errorback || noop);
    },
    removeItem : function(key, callback, errorback)
    {
      this.st.transaction(function(tx)
      {
        tx.removeItem(key, function(tx, key){
          if (callback) callback(key);
        }, errorback || noop);
      }, errorback || noop);
    },
    clear : function(callback, errorback)
    {
       this.st.transaction(function(tx)
      {
        tx.clear(callback || noop, errorback || noop);
      }, errorback || noop);
    },
    listItems : function(callback, errorback)
    {
      this.st.readTransaction(function (tx)
      {
        tx.listItems(callback, errorback||noop);
      }, errorback|| noop);
    }
  };

  _.extend(WebSQLBackend.prototype, universal);
  _.extend(IndexedDBBackend.prototype, universal);
  
  var ERR_666 = "Unable to initialize an offline storage.";
  function noop(){}
  
}
(
vitrium.utils.asyncStorage, 
vitrium.utils,
vitrium.async,
_,
__globals__));
// script:viewer/io/object-database.js
/// <reference path="~/build.html" />

(function (exports, async, _, globals) {
   "use strict";

   var indexedDB = globals.indexedDB ||  globals.webkitIndexedDB || globals.mozIndexedDB || globals.msIndexedDB;
     
   function pickBackendFunction()
   {
      if (indexedDB && !globals.disableIndexedDb)
      {
         return idbOpen;
      }
      else if ("openDatabase" in globals)
      {
         return webSqlOpen;
      }
      else
      {
         return function () {
            var completer = new async.Completer();

            _.defer(function () {
               completer.fail();
            });
            return completer.future;
         };
      }  
   }

   exports.ObjectDatabase = {
      open: function (name) {
         var opener = pickBackendFunction();
         return opener(name);
      }
   };

   function IDB(db, name)
   {
      this._db = db;
      this._name = name;
   }

   IDB.prototype.transaction = function (callback) {
      var tx = this._db.transaction([this._name], "readwrite");
      
      callback(new IDB_RWTransaction(tx, this._name));
   };
  
   IDB.prototype.readTransaction = function (callback, error) {
      var tx = this._db.transaction([this._name], "readonly");

      callback(new IDB_RTransaction(tx, this._name));
   };

   function IDB_TransactionBase(tx, name)
   {
      ///<param name="tx" type="IDBTransaction" />
      var completer = new async.Completer();
      ///<field name="tx" type="IDBTransaction" />
      this.tx = tx;
      this.objectStore = tx.objectStore(name);
      this.future = completer.future;

      tx.oncomplete = function () {
         completer.complete();
      };

      tx.onerror = function () {
         completer.fail(tx.error || tx.errorCode);
      };      
   }


   function IDB_RTransaction(tx, name) {
      IDB_TransactionBase.call(this, tx, name);
   }
   IDB_RTransaction.prototype = Object.create(IDB_TransactionBase.prototype);
   IDB_RTransaction.prototype.getById = function (id) {
      var completer = new async.Completer();
      var req = this.objectStore.get(id);
      req.onsuccess = function () {
         completer.complete(req.result);
      };

      req.onerror = function () {
         completer.fail(req.error || req.errorCode);
      };

      return completer.future;
   };

   IDB_RTransaction.prototype.getAll = function () {
      var completer = new async.Completer();

      var data = [];
      var req = this.objectStore.openCursor();
      req.onsuccess = function () {
         if (req.result)
         {
            data.push(req.result.value);
            req.result["continue"]();
         }
         else
         {
            completer.complete(data);
         }
      };

      req.onerror = function () {
         completer.fail(req.error || req.errorCode);
      };

      return completer.future;
   };

   IDB_RTransaction.prototype.getFirst = function () {
      var completer = new async.Completer();


      var req = this.objectStore.openCursor();
      req.onsuccess = function () {
         if (req.result)
         {
            completer.complete(req.result.value);
         }
         else {
            completer.complete(null);
         }
      };

      req.onerror = function () {
         completer.fail(req.error || req.errorCode);
      };

      return completer.future;
   };

   function IDB_RWTransaction(tx, name)
   {     
      IDB_RTransaction.call(this, tx, name);
   }

   IDB_RWTransaction.prototype = Object.create(IDB_RTransaction.prototype);
   IDB_RWTransaction.prototype.put = function (record) {
      var completer = new async.Completer();

      var req = this.objectStore.put(record);
      req.onsuccess = function () {
         completer.complete(req.result);
      };

      req.onerror = function () {
         completer.fail(req.error || req.errorCode);
      };

      return completer.future;
   };

   IDB_RWTransaction.prototype.remove = function (id) {
      var completer = new async.Completer();

      var req = this.objectStore["delete"](id);
      req.onsuccess = function () {
         completer.complete(id);
      };

      req.onerror = function () {
         completer.fail(req.error || req.errorCode);
      };

      return completer.future;
   };

   IDB_RWTransaction.prototype.clearAll = function () {
      var completer = new async.Completer();

      var req = this.objectStore.openCursor();
      req.onsuccess = function () {
         if (req.result) {
            req.result["delete"]();
            req.result["continue"]();
         }
         else {
            completer.complete();
         }
      };

      req.onerror = function () {
         completer.fail(req.error || req.errorCode);
      };

      return completer.future;
   };

   function idbOpen(name, version) {
      var completer = new async.Completer();
      version = version || 1;
      var request = indexedDB.open(name, version || 1);
      request.onsuccess = function (evt) {
         var db = request.result;
         completer.complete(new IDB(db, name));
      };
      request.onupgradeneeded = function (evt) {
         if (!request.result.objectStoreNames.contains(name)) {
            request.result.createObjectStore(
            name, {
               keyPath: "rowid",
               autoIncrement: true
            });
         }
      };

      request.onerror = function (evt) {
         var ec = request.error || request.errorCode;
         completer.fail(ec);
      };

      return completer.future;
   };


   function webSqlOpen(name, version)
   {
      var completer = new async.Completer();

      try
      {
         var db = globals.openDatabase(name, version, "", null);

         db.transaction(function (tx){
            tx.executeSql("CREATE TABLE IF NOT EXISTS objects (rowid INTEGER PRIMARY KEY AUTOINCREMENT, object TEXT NOT NULL)", null, function () {
               _.defer(function(){ completer.complete(new WebSQLDB(db)); });
            }, fail);
         }, fail);
      }
      catch(e)
      {
         _.defer(function(){
            completer.fail(e);
         });
      }

      function fail(e)
      {
         completer.fail(e);
      }

      return completer.future;
   }

   function WebSQLDB(db)
   {
      this._db = db;
   }

   WebSQLDB.prototype.transaction = function (callback) {
      var called = false;

      var completer = new async.Completer();

      this._db.transaction(function (tx) {
         called = true;
         callback(new WSQL_RWTransaction(tx, completer.future));
      },
      function (t, e) {
         if (!called)
            callback(null);
         else
            completer.fail(e);
      },
      function () {
         completer.complete();
      });
   };

   WebSQLDB.prototype.readTransaction = function (callback) {
      var called = false;

      var completer = new async.Completer();

      this._db.transaction(function (tx) {
         called = true;
         callback(new WSQL_RTransaction(tx, completer.future));
      },
      function (t, e) {
         if (!called)
            callback(null);
         else
            completer.fail(e);
      },
      function () {
         completer.complete();
      });
   };

   function WSQL_RTransaction(tx, future)
   {
      this._tx = tx;
      this.future = future;
   }

   WSQL_RTransaction.prototype.getById = function (id)
   {
      var completer = new async.Completer();
      
      this._tx.executeSql("SELECT rowid, object FROM objects WHERE rowid=?", [id], function (tx, rs) {
         if (rs.rows.length === 0)
            completer.complete(null);
         else {
            completer.complete(WSQL_parseRow(rs.rows.item(0)));
         }
      },
      function (e) {
         completer.fail(e);
      });

      return completer.future;
   };

   WSQL_RTransaction.prototype.getFirst = function ()
   {
      var completer = new async.Completer();

      this._tx.executeSql("SELECT rowid, object FROM objects ORDER BY rowid ASC LIMIT 1", null, function (tx, rs) {
         if (rs.rows.length === 0)
            completer.complete(null);
         else {
            completer.complete(WSQL_parseRow(rs.rows.item(0)));
         }
      },
      function (e) {
         completer.fail(e);
      });

      return completer.future;
   };

   WSQL_RTransaction.prototype.getAll = function ()
   {
      var completer = new async.Completer();

      this._tx.executeSql("SELECT rowid, object FROM objects ORDER BY rowid ASC", null, function (tx, rs) {
         if (rs.rows.length === 0)
            completer.complete(null);
         else {
            var len = rs.rows.length;
            var rows = [];
            for (var i = 0; i !== len; ++i)
            {
               rows.push(WSQL_parseRow(rs.rows.item(i)));
            }
            completer.complete(rows);
         }
      },
      function (e) {
         completer.fail(e);
      });

      return completer.future;
   };

   function WSQL_RWTransaction(tx, future) {
      WSQL_RTransaction.call(this, tx, future);
   }
   WSQL_RWTransaction.prototype = Object.create(WSQL_RTransaction.prototype);

   WSQL_RWTransaction.prototype.put = function (row) {
      var completer = new async.Completer();
      var tx = this._tx;
      var rowid = row.rowid;
      var object = JSON.stringify(row);

      if (!rowid && rowid !== 0) {
         rowid = null;
         insert();
      }
      else {
         tx.executeSql("UPDATE objects SET object=? WHERE rowid=?", [object, row.rowid], function (tx, rs) {
            if (rs.rowsAffected === 0) {
               insert();
            }
            else
            {
               completer.complete(rowid);
            }
         }, handleError);
      }

      function insert()
      {
         tx.executeSql("INSERT INTO objects (rowid, object) VALUES (?, ?)", [rowid, object], function (tx, rs) {
            completer.complete(rs.insertId);
         }, handleError);
      }

      function handleError(e)
      {
         completer.fail(e);
      }

      return completer.future;
   };

   WSQL_RWTransaction.prototype.remove = function (id) {
      var completer = new async.Completer();

      this._tx.executeSql("DELETE FROM objects WHERE rowid=?", [id], function (tx, rs) {
            completer.complete();
      },
      function (e) {
         completer.fail(e);
      });

      return completer.future;
   };

   WSQL_RWTransaction.prototype.clearAll = function () {
      var completer = new async.Completer();

      this._tx.executeSql("DELETE FROM objects", null, function (tx, rs) {
         completer.complete();
      },
      function (e) {
         completer.fail(e);
      });

      return completer.future;
   };

   function WSQL_parseRow(item)
   {
      var row = JSON.parse(item["object"]);
      row.rowid = item["rowid"];
      return row;
   }

}
(vitrium.utils,
vitrium.async,
_,
__globals__));

// script:viewer/io/persistent-queue.js
/// <reference path="~/build.html" />

(function (exports, utils, async, _) {
   "use strict";

   exports.openPersistentQueue = function openPersistentQueue(name, errorHandler) {
      var completer = new async.Completer();

      utils.ObjectDatabase.open(name).then(function (db) {
         completer.complete(new PersistentQueue(db), errorHandler);
      })
      .chainError(completer);

      completer.future.catchError(errorHandler);

      return completer.future;
   };

   exports.DefferedQueue = DefferedQueue;

   function PersistentQueue(db, globalErrorHandler) {
      this._db = db;
      this._globalErrorHandler = globalErrorHandler;
      this.onItemDeleted = function () { };
   }

   PersistentQueue.prototype._bindErrorHandler = function(completer)
   {
      if (this._globalErrorHandler !== null)
         completer.future.catchError(this._globalErrorHandler);
   };

   PersistentQueue.prototype.all = function () {
      var completer = new async.Completer();
      var self = this;
      this._db.readTransaction(function (tx) {
         tx.getAll()
         .chainSuccess(completer)
         .chainError(completer);
      });

      this._bindErrorHandler(completer);

      return completer.future;
   };

   PersistentQueue.prototype.top = function () {
      var completer = new async.Completer();
      var self = this;
      this._db.readTransaction(function (tx) {
         tx.getFirst()
         .chainSuccess(completer)
         .chainError(completer);
      });

      this._bindErrorHandler(completer);

      return completer.future;
   };

   PersistentQueue.prototype.deleteItem = function (row) {
      var completer = new async.Completer();
      var self = this;

      this._db.transaction(function (tx) {
         tx.remove(row.rowid)
            .then(function () { self.onItemDeleted(row); })
            .chainSuccess(completer)
            .chainError(completer);
      });

      this._bindErrorHandler(completer);

      return completer.future;
   };

   PersistentQueue.prototype.transaction = function(callback)
   {
      var self = this;
      this._db.transaction(function (tx) {
         callback(new PersistentQueueTransaction(tx, self));
      });
   }
      
   PersistentQueue.prototype.deleteAll = function () {
      var completer = new async.Completer();
      var self = this;

      this._db.transaction(function (tx) {
         tx.clearAll()
         .then(function () { self.onItemDeleted(null); })
         .chainSuccess(completer)
         .chainError(completer);
      });

      this._bindErrorHandler(completer);

      return completer.future;
   };

   PersistentQueue.prototype.push = function (cmd) {
      var completer = new async.Completer();
      var self = this;
      this._db.transaction(function (tx) {
         tx.put(cmd)
         .chainSuccess(completer)
         .chainError(completer);
      });

      this._bindErrorHandler(completer);

      return completer.future;
   };


   function PersistentQueueTransaction(tx, parent)
   {
      this._tx = tx;
      this._parent = parent;
      this.future = tx.future;
   }
   PersistentQueueTransaction.prototype.all = function () {
      return this._bindErrorHandler(this._tx.getAll());
   };

   PersistentQueueTransaction.prototype.top = function () {
      return this._bindErrorHandler(this._tx.getFirst());
   };

   PersistentQueueTransaction.prototype.push = function (cmd) {
      return this._bindErrorHandler(this._tx.put(cmd));
   };

   PersistentQueueTransaction.prototype.deleteAll = function () {
      var self = this;
      return this._bindErrorHandler(this._tx.clearAll()).then(function(){
         self._parent.onItemDeleted(null);
      });
   };

   PersistentQueueTransaction.prototype.deleteItem = function (cmd) {
      var self = this;
      return this._bindErrorHandler(this._tx.remove(cmd.rowid)).then(function () {
         self._parent.onItemDeleted(cmd);
      });
   };

   PersistentQueueTransaction.prototype._bindErrorHandler = function (future) {
      if (this._parent._globalErrorHandler)
         future.catchError(this._parent._globalErrorHandler);

      return future;
   };



   function DefferedQueue()
   {
      this._queue = [];
      this._rowIdCounter = 0;
      this.onItemDeleted = function () { };
   }

   DefferedQueue.prototype.all = function () {
      var completer = new async.Completer();
      
      _.defer(_.bind(function () {
         completer.complete(_.clone(this._queue));
      }, this));

      return completer.future;
   };

   DefferedQueue.prototype.top = function () {
      var completer = new async.Completer();


      _.defer(_.bind(function () {
         if (this._queue.length !== 0)
            completer.complete(this._queue[0]);
         else
            completer.complete();
      }, this));

      return completer.future;
   };

   DefferedQueue.prototype.deleteItem = function (row) {
      var completer = new async.Completer();
      _.defer(_.bind(function () {
         var i = this._queue.indexOf(row);
         if (i !== -1)
         {
            this._queue.splice(i, 1);
            this.onItemDeleted(row);
         }
         
         completer.complete();
      }, this));
      return completer.future;
   };

   DefferedQueue.prototype.deleteAll = function () {
      var completer = new async.Completer();

      _.defer(_.bind(function () {
         this._queue.length = 0;
         this.onItemDeleted(null);
         completer.complete();
      }, this));

      return completer.future;
   };

   DefferedQueue.prototype.push = function (e) {
      var completer = new async.Completer();
      
      _.defer(_.bind(function () {
         var rowid = e.rowid = ++this._rowIdCounter;
         this._queue.push(e);
         completer.complete(rowid);
      }, this));

      return completer.future;
   };

   DefferedQueue.prototype.transaction = function (callback) {
      callback(this);
   };

}
(vitrium.utils,
vitrium.utils,
vitrium.async,
_
));

// script:viewer/io/verifiable-storage.js
(function(exports, utils, crypto, CryptoJS)
{
  "use strict";
  
  exports.VerifiableStorage = VerifiableStorage;
  
  function VerifiableStorage(db) 
  {
     this.storage = new utils.TxStorage(db);
  }
  
  VerifiableStorage.prototype = {
    transaction : function(callback, error)
		{
      this.storage.transaction(function(tx){
        callback(new VerifiableTransactionProxy(tx));
      }, error);
    },
    readTransaction : function(callback, error)
		{
      this.storage.readTransaction(function(tx){
          callback(new VerifiableTransactionProxy(tx));
        }, error);
    }
  };
  
  function VerifiableTransactionProxy(tx)
  {
    this.tx = tx;
    this.valSuffix = "-val";
    this.chksumSuffix = "-chk";
  }
  
  VerifiableTransactionProxy.prototype = {
    abort : function() { this.tx.abort(); },
    clear : function(callback, error) { this.tx.clear(callback, error); },
    setItem : function(key, val, callback, error)
    {
       callback = callback || noop;
       error = callback || noop;
       
       var valKey = key+this.valSuffix;
       this.tx.setItem(key+this.chksumSuffix, checksum(val+valKey), function(tx)
       {
         tx.setItem(valKey, val, function(tx, val, _key) { callback(tx, val, key); }, error);
       }, error);
    },
    getItem : function(key, callback, error)
		{
       callback = callback || noop;
       error = callback || noop;
    
       var valKey = key+this.valSuffix;
       var chkKey = key+this.chksumSuffix;
       this.tx.getItem(chkKey, function(tx, chkval)
       {
          tx.getItem(valKey, function(tx, val) {
            if (val === null)
            {
               callback(tx, val, key);
            }
            else if (checksum(val+valKey) !== chkval)
            {
              // we act that like there is no value 
               callback(tx, null, key);
            }
            else
            {
               callback(tx, val, key);
            }
          }, error);
       }, error);
    },
    removeItem: function(key, callback, error)
		{
      callback = callback || noop;
      error = callback || noop;
      
      var valKey = key+this.valSuffix;
      var chkKey = key+this.chksumSuffix;
      this.tx.removeItem(chkKey, function(tx)
      {
        tx.removeItem(valKey, function(tx, _key) { callback(tx, key); }, error);
      },error);
    }
  };
  
  var Utf8Encoding = CryptoJS.enc.Utf8;
  var Hex = CryptoJS.enc.Hex;
  function checksum(text)
  {
    var hasher = new crypto.Sha1();
    var bytes = Utf8Encoding.parse(text);
    hasher.update(bytes);
        
    return Hex.stringify(hasher.finalize());
  }
  
  function noop(){}
  
}
(vitrium.utils,
vitrium.utils,
vitrium.crypto,
CryptoJS
));
// script:viewer/io/persistent-object.js
(function(exports, _)
{
	"use strict";
	
	exports.PersistentObjectManager = PersistentObjectManager;
	exports.PrefixedPersistentObjectManager = PrefixedPersistentObjectManager;
		
	function PersistentObjectManager(name, defaultValue, preSave, postSave)
	{
		this.name = name;
		this.defaultValue = defaultValue;
		this.preSave = preSave ? preSave  : null;
		this.postSave = postSave ? postSave : null;
	}
	
	PersistentObjectManager.prototype = 
	{
		load : function(tx, success, error)
		{
			tx.getItem(this.name, _.bind(function(tx, val){
				if (val !== null)
				{
					val = JSON.parse(val);
				}
				else
				{
					var def = this.defaultValue;
					if (_.isFunction(def))
					{
						def = def();
					}
					else if (def)
					{
						def = _.clone(def);
					}
					else
					{
						def = {};
					}
					
					val = def;
				}
				success(tx, val);
			}, this), error||noop);
		},
		save : function(tx, value, success, error)
		{
			if (this.preSave) { value = this.preSave(value); }
			if (this.postSave)
			{
				var postSave = this.postSave;
				tx.setItem(this.name, JSON.stringify(value), function(){
					postSave.apply(null, arguments);
					if (success) success.apply(null, arguments);
				}, error|| noop);		
			}
			else
			{
				tx.setItem(this.name, JSON.stringify(value), success|| noop, error|| noop);		
			}
		}
	};
	
	function PrefixedPersistentObjectManager(prefix, defaultValue, preSave)
	{
		this.prefix = prefix;
		this.defaultValue = defaultValue;
		this.preSave = preSave ? preSave  : null;
	}
	
	PrefixedPersistentObjectManager.prototype =
	{
		load : function(tx, name, success, error)
		{
			tx.getItem(this.prefix+":"+name, _.bind(function(tx, val){
				if (val !== null)
				{
					val = JSON.parse(val);
				}
				else
				{
					var def = this.defaultValue;
					if (_.isFunction(def))
					{
						def = def();
					}
					else if (def)
					{
						def = _.clone(def);
					}
					else
					{
						def = {};
					}
					
					val = def;
				}
				success(tx, val);
			}, this), error||noop);
		},
		save : function(tx, name, value, success, error)
		{
			if (this.preSave) { value = this.preSave(value); }
			tx.setItem(this.prefix+":"+name, JSON.stringify(value), success|| noop, error|| noop);		
		}
	};

	
	function noop(){}
	
}(vitrium.utils, _));
// script:viewer/io/cache-access/cache-manager.js
/// <reference path="~/build.html" />

(function (exports, cache, utils, asyncStorage, documents, async, fs, log, _, Backbone)
{
  "use strict";
  
  var ST_CAN_FREE = 0;
  var ST_DOWNLOADING = 1;
  var ST_DOWNLOADED = 2;

  exports.CACHE_STATE = {
    CAN_FREE: ST_CAN_FREE,
    DOWNLOADING: ST_DOWNLOADING,
    DOWNLOADED: ST_DOWNLOADED
  };

  var C_FRESH = 0;
  var C_INITIALIZING = 1;
  var C_INITIALIZED = 2;
  var C_FAIL = 3;

  var MAX_DOWNLOAD_TIME = 3 * 60 * 1000;

  exports.CacheManager = CacheManager;
  function CacheManager()
  {
    this.db = null;
  
    this.limit = 5000000;
    this.q = [];
    this.gcInProgress = false;


    this.fileListManager = new utils.PrefixedPersistentObjectManager("list", []);
    this.statsManager = new utils.PersistentObjectManager("stats", function () { return { "files": {} }; });
    this.fileSystemManager = new utils.PersistentObjectManager("fileSystem", [], function (fileList)
    {
      fileList.sort(function (a, b)
      {
        if (a.id < b.id)
        {
          return -1;
        }
        else if (a.id > b.id)
        {
          return 1;
        }
        else
        {
          return 0;
        }
      });

      return fileList;
    }, _.bind(this.fireFsChanged, this));

    this._cacheRegistry = new CacheRegistry(this);

    this._initFuture = null;
    this._initFailed = false;
  }
  
  CacheManager.prototype = {
    fireFsChanged: function ()
    {
      this.fireChanged("fs", null, true);
    },
    init: function ()
    {
      var self = this;
      if (this._initFuture === null && this.db === null && !this._initFailed)
      {
        var completer = new async.Completer();
        var errorHandler = _.bind(completer.fail, completer);

        asyncStorage.create("||global||", function (db)
        {
          var txDb = new utils.TxStorage(db);
          txDb.transaction(function (tx)
          {
            self.db = txDb;
            completer.complete(self);
          }, errorHandler);
        }, errorHandler);
  
        var future = this._initFuture = completer.future;
        future.catchError(function ()
        {
          self._initFailed = true;
        })
        .completed(function ()
        {
          self._initFuture = null;
        });
        
        return future;
      }
      else if (this._initFuture !== null)
      {
        return this._initFuture;
      }
      else if (this.db !== null)
      {
        var completer = new async.Completer();
        async.asyncSuccess(completer, this);
        
        return completer.future;
      }
      else
      {
        var completer = new async.Completer();
        async.asyncError(completer, "init failed");

        return completer.future;
      }
    },
    openCache : function(url, success, error, cipher)
    {
      
      var cacheHolder = this._cacheRegistry.getCache(url, cipher? cipher: null);

      if (this.db === null)
      {
        this.init().then(_.bind(doOpenCache, this)).catchError(error);
      }
      else
      {
        doOpenCache.call(this);
      }

      function doOpenCache()
      {
        var task = cacheHolder.initTask;

        if (cacheHolder.state === C_FRESH)
        {
          cacheHolder.instance.init(
          _.bind(task.complete, task),
          _.bind(task.fail, task));

          cacheHolder.state = C_INITIALIZING;
          task.future.then(function ()
          {
            cacheHolder.state = C_INITIALIZED;
          }).
          catchError(function ()
          {
            cacheHolder.state = C_FAIL;
          });
        }

        if (cacheHolder.state === C_INITIALIZING)
        {
          task.future.then(success).catchError(error);
        }
        else if (cacheHolder.state === C_INITIALIZED)
        {
          async.run(function () { success(cacheHolder.instance); });
        }
        else if (cacheHolder.state === C_FAIL)
        {
          async.run(error);
        }
        else
        {
          throw new Error("[CacheManager] the document cache is in invalid state");
        }
      }
      return cacheHolder.instance;
    },
    getFSStorage: function ()
    {
      return new documents.StoredDocumentsCacheAdapter(this.db, this.fileSystemManager, this);
    },
    prepare: function (requested, callback, error)
    {
      this.q.push({ callback: callback, error: error, requested: requested });
      this.executeGC();
    },
    executeGC: function ()
    {
      var q = this.q;
      if (q.length === 0 || this.gcInProgress)
      {
        return;
      }

      this.gcInProgress = true;

      var requested = 0;
      var limit = this.limit;


      var execute = [];
      var r = 0;
      for (var rlen = q.length; r < rlen; ++r)
      {
        var req = q[r];
        req.requested = Math.min(req.requested, limit);
        /*
          if (req.requested > limit)
          {
           req.error("file is too big to cache");
          }
          else*/if (requested + req.requested > limit)
          {
            break;
          }
          else
          {
            requested += req.requested;
            execute.push(req);
          }
      }

      q.splice(0, r);

      var self = this;
      if (requested === 0)
      {
        log.debug("[cache] zero request");
        callback();
        return;
      }
      if (requested < limit)
      {
        log.debug("[cache] request: " + requested);

        self.db.transaction(function (tx)
        {
          self.loadStats(tx, function (tx, stats)
          {
            var files = stats.files;
            var size = 0;
            var documents = [];
            var time = Date.now();


            for (var k in files)
            {
              var f = files[k];
              if (f.downloaded === ST_CAN_FREE)
              {
                f.url = k;
                size += f.length;
                documents.push(f);
              }
              else if (f.downloaded === ST_DOWNLOADING && time - f.stateChanged > MAX_DOWNLOAD_TIME)
              {
                // this case means that download was not successfull for some reason and now is the time to invalidate it
                f.downloaded = ST_CAN_FREE;

                f.url = k;
                size += f.length;
                documents.push(f);
              }
            }

            log.debug("[cache] current size: " + size);

            if (self.limit < size)
            {
              // cache is full, sort  desc by last load
              documents.sort(function (a, b)
              {
                var aL = a.lastLoad;
                var bL = b.lastLoad;
                if (aL == bL)
                {
                  return 0;
                }
                else if (aL < bL)
                {
                  return -1;
                }
                else
                {
                  return 1;
                }
              });

              var rest = requested + size - self.limit;

              log.debug("[cache] schedule to free: " + rest);
              var i = 0, dlen = documents.length;
              var changed = false;
              var step = function ()
              {
                var doc = documents[i++];
                if (doc.length < rest)
                {
                  rest -= doc.length;
                  asyncStorage.create(doc.url, function (db)
                  {
                    db.clear();
                  });

                  delete files[doc.url];
                  log.debug("[cache] invalidate: " + doc.url + " rem:" + rest);
                  changed = true;
                  if (i < dlen)
                  {
                    step();
                  }

                }
                else if (rest > 0)
                {
                  self.loadFileList(tx, doc.url, function (tx, list)
                  {
                    list.sort(function (a, b)
                    {
                      var aL = a.time;
                      var bL = b.time;
                      if (aL == bL)
                      {
                        return 0;
                      }
                      else if (aL < bL)
                      {
                        return -1;
                      }
                      else
                      {
                        return 1;
                      }
                    });

                    var toRemove = [];
                    var _list = list, j = 0, len = _list.length;
                    for (; j < len && rest > 0; ++j)
                    {
                      var f = _list[j];
                      rest -= f.length;
                      doc.length -= f.length;
                      log.debug("[cache] invalidate: " + doc.url + "/" + f.name + " rem:" + rest);
                      toRemove.push(f.name);
                    }
                    _list.splice(0, j);

                    if (_list.length === 0)
                    {
                      asyncStorage.create(doc.url, function (db)
                      {
                        db.clear();
                      });
                    }
                    else
                    {
                      asyncStorage.create(doc.url, function (db)
                      {
                        var _rem = toRemove;
                        for (var i = 0, len = _rem.length; i < len; ++i)
                        {
                          db.removeItem(_rem[i]);
                        }

                      }, errorHandler);
                    }

                    self.saveFileList(tx, doc.url, _list, function (tx)
                    {
                      self.saveStats(tx, stats, callback, errorHandler);
                    }, errorHandler);
                  }, errorHandler);
                }
                else if (changed)
                {
                  self.saveFileList(tx, doc.url, _list, function (tx)
                  {
                    self.saveStats(tx, stats, callback, errorHandler);
                  }, errorHandler);
                }
              };

              step();
            }
            else
            {
              callback();
            }
          }, errorHandler);
        }, errorHandler);
      }
      else
      {
        errorHandler("unable to fit file to cache");
      }

      function errorHandler(err)
      {
        var e = execute;
        for (var i = 0, len = e.length; i < len; ++i)
        {
          var error = e[i].error;
          if (error) error(err);
        }

        self.gcInProgress = false;
        setTimeout(_.bind(self.executeGC, self), 20);
      }

      function callback()
      {
        var e = execute;
        for (var i = 0, len = e.length; i < len; ++i)
        {
          var cb = e[i].callback;
          if (cb) cb();
        }

        self.gcInProgress = false;
        setTimeout(_.bind(self.executeGC, self), 20);
      }
    },
    loadFileList: function (tx, url, success, error)
    {
      this.fileListManager.load(tx, url, success, error);
    },
    saveFileList: function (tx, url, list, success, error)
    {
      this.fileListManager.save(tx, url, list, success, error);
    },
    storeFileCachedInfo: function (tx, url, name, length, callback)
    {
      var self = this;
      this.loadFileList(tx, url, function (tx, list)
      {
        list.push({ name: name, length: length, time: Date.now(), cached: Date.now() });
        self.saveFileList(tx, url, list, callback);
      });
    },
    getOfflineDownloadedDocumentsCount : function(success, error)
    {
      var self = this;
      this.db.readTransaction(function (tx)
      {
        self.loadStats(tx, function (tx, stats)
        {
          var c = 0;
          _.each(stats.files, function (val, key)
          {
            if (val.downloaded === 2)
            {
              ++c;
            }
          });

          success(c);
        }, error);
      }, error);
    },
    loadStats: function (tx, success, error)
    {
      this.statsManager.load(tx, success, error);
    },
    getDownloadState: function (url, success, error)
    {
      var self = this;
      this.db.readTransaction(function (tx)
      {
        self.loadStats(tx, function (tx, stats)
        {
          var counter = self.getStatsCounter(stats, url);
          success(counter.downloaded);
        }, error);
      }, error);
    },
    fireChanged: function (type, data, globalEmit)
    {
      if (globalEmit)
      {
        localStorage.setItem("fire", type + "," + Date.now());
      }
    },
    increment: function (url, name, length)
    {
      var self = this;
      this.db.transaction(function (tx)
      {
        self.loadStats(tx, function (tx, stats)
        {
          var counter = self.getStatsCounter(stats, url);
          counter.length += length;
          counter.lastLoad = Date.now();

          self.storeFileCachedInfo(tx, url, name, length, function (tx)
          {
            self.saveStats(tx, stats);
          });
        });
      });
    },
    updateLastLoad: function (url, name)
    {
      var self = this;
      this.db.transaction(function (tx)
      {
        self.loadStats(tx, function (tx, stats)
        {
          var counter = self.getStatsCounter(stats, url);
          counter.lastLoad = Date.now();

          self.loadFileList(tx, url, function (tx, list)
          {
            for (var i = 0, len = list.length; i < len; ++i)
            {
              var file = list[i];
              if (file.name === name)
              {
                file.time = counter.lastLoad;
                break;
              }
            }

            self.saveFileList(tx, url, list, function (tx)
            {
              self.saveStats(tx, stats);
            });
          });
        });
      });
    },
    saveStats: function (tx, stats, callback, errorHandler)
    {
      var self = this;
      this.statsManager.save(tx, stats, function (tx)
      {
        //self.fireChanged("stats", stats, true);
        if (callback) callback(tx);
      }, errorHandler);
    },
    getStatsCounter: function (stats, url)
    {
      var counter = stats.files[url];

      if (!counter)
      {
        var time = Date.now();
        counter = { "length": 0, "downloaded": ST_CAN_FREE, "stateChanged": time, "lastLoad": time };
        stats.files[url] = counter;
      }
      return counter;
    },
    setDownloadingState: function (url, state, callback, error, extendedData)
    {
      var self = this;
      this.db.transaction(update, error); 

      function update(tx)
      {
        self.loadStats(tx, function (tx, stats)
        {
          var counter = self.getStatsCounter(stats, url);
          counter.downloaded = state;
          counter.stateChanged = new Date().getTime();

          if (extendedData)
          {
            if ("size" in extendedData)
            {
              counter.length = extendedData.size;
            }

            self.loadExtendedData(tx, function (tx, data)
            {
              data[url] = extendedData.documentInfo;
              self.saveExtendedData(tx, data, function ()
              {
                self.saveStats(tx, stats, finish, error);
              }, error);
            }, error);
          }
          else
          {
            self.saveStats(tx, stats, finish, error);
          }
        }, error);
      }

      function finish(tx)
      {
        if (state === ST_DOWNLOADED)
        {
          //DOWNLOADED document can be only forced to invalidate, there is no reason to keep this list
          tx.removeItem("list:" + url);

          self.fileSystemManager.load(tx, function (tx, fileList)
          {
            var documentTitle = extendedData.documentInfo.title || url;
            //TODO replace with document name
            var id = fs.makeIdSafe(fileList, documentTitle, url);

            if (!fs.findFileById(fileList, id))
            {
              fileList.push({ id: id, type: "document", url: url });
              self.fileSystemManager.save(tx, fileList, function ()
              {
                callback();
              }, error);
            }
            else if (callback)
            {
              callback();
            };

          }, error);
        }
        else
        {
          self.fireChanged("stats", null, true);
          if (callback) { callback(); };
        }
      }
    },
    loadExtendedUIModel: function (success)
    {
      var self = this;
      this.db.readTransaction(function (tx)
      {
        self.loadExtendedData(tx, function (tx, data) { success(data); }, errorHandler);
      }, errorHandler);

      function errorHandler(error)
      {
        log.error(error);

        success({});
      }
    },
    loadExtendedData: function (tx, success, error)
    {
      var self = this;
      tx.getItem("extended", function (tx, val)
      {
        if (val === null)
        {
          success(tx, {});
        }
        else
        {
          success(tx, JSON.parse(val));
        }
      }, error);
    },
    saveExtendedData: function (tx, extended, success, error)
    {
      tx.setItem("extended", JSON.stringify(extended), success, error);
    },
    loadStorageInfo: function (url, success)
    {
      var self = this;
      this.init().then(function ()
      {
        self.db.readTransaction(function (tx)
        {
          self.loadStats(tx, function (tx, stats)
          {
            var isCurrentDocumentDownloaded = false;
            if (url)
            {
              isCurrentDocumentDownloaded = self.getStatsCounter(stats, url).downloaded === ST_DOWNLOADED;
            }
            
            var isAnyDocumentDownloaded = !!_.find(stats.files, function (doc) { return doc.downloaded === ST_DOWNLOADED; });

            success({
              offlineStorageSupported: true,
              isCurrentDocumentDownloaded: isCurrentDocumentDownloaded,
              isAnyDocumentDownloaded : isAnyDocumentDownloaded
            });
          }, errorHandler);
        }, errorHandler);

        
      })
      .catchError(errorHandler);

      function errorHandler()
      {
        success({ offlineStorageSupported : false });
      }
    },
    forceInvalidate: function (url, _success, error, statusCallback)
    {
      var self = this;

      log.debug("[cache] forceInvalidate: " + url);

      function success()
      {
        var cache = self._cacheRegistry.findCache(url);
        if (cache !== null)
        {
          cache.downloadState = ST_CAN_FREE;
        }

        _success.apply(null, arguments);
      }

      asyncStorage.create(url, function (db)
      {
        // delete whole cached content
        db.clear(function ()
        {
          self.db.transaction(function (tx)
          {
            // delete list of cached files from that document
            tx.removeItem("list:" + url);

            self.loadStats(tx, function (tx, stats)
            {
              // status retrieval is important to choose right UI behavior
              if (statusCallback) statusCallback(self.getStatsCounter(stats, url).downloaded);

              self.loadExtendedData(tx, function (tx, data)
              {
                // delete extened data 
                delete data[url];
                self.saveExtendedData(tx, data, function ()
                {
                  // remove referece from stats counter
                  delete stats.files[url];

                  // remove node from file system
                  self.fileSystemManager.load(tx, function (tx, fileList)
                  {
                    var node = null;
                    for (var i = 0, len = fileList.length; i < len; ++i)
                    {
                      node = fileList[i];
                      if (node.url === url)
                      {
                        break;
                      }
                      else
                      {
                        node = null;
                      }
                    }

                    if (node)
                    {
                      fileList = _.without(fileList, node);
                      self.fileSystemManager.save(tx, fileList, function ()
                      {
                        self.saveStats(tx, stats, success, error);
                      }, error);
                    }
                    else
                    {
                      //last step
                      self.saveStats(tx, stats, success, error);
                    }
                  }, error);
                }, error);
              }, error);
            }, error);
          }, error);
        }, error);
      }, error);

      Backbone.Events.trigger("storage:erased", url);
    },
    storeGlobalDocumentInfo: function (url, documentInfo)
    {
      var self = this;
      // just ignore it when storage is not available
      if (!this.db) return;

      this.db.transaction(function (tx)
      {
        self.loadExtendedData(tx, function (tx, data)
        {
          var current = data[url];
          if (_.isObject(current))
          {
            _.extend(current, documentInfo);
            self.saveExtendedData(tx, data, function ()
            {
              log.debug("extended data updated");
            }, error);
          }
        });

        self.fileSystemManager.load(tx, function (tx, fileList)
        {
          var documentTitle = documentInfo.title;
          var id = fs.makeIdSafe(fileList, documentTitle, url);
          var file = fs.findFileByUrl(fileList, url);

          if (file && file.id !== id)
          {
            file.id = id;
            self.fileSystemManager.save(tx, fileList, function ()
            {
              log.debug("fs data updated");
            }, error);
          }
        }, error);

      }, error);

      function error()
      {
        log.error("Error during documentInfo updating.");
      }
    }
  };

  function CacheRegistry(cacheManager)
  {
    this._cacheManager = cacheManager;
    this._caches = {};
  }
  CacheRegistry.prototype =
  {
    getCache : function(url, cipher)
    {
      var cacheHolder = null;
      if (!(url in this._caches))
      {
        cacheHolder = this._caches[url] = {
          instance: new cache.DocumentCacheManager(this._cacheManager, url, cipher),
          initTask: new async.Completer(),
          state : C_FRESH,
        };

      }
      else
      {
        cacheHolder = this._caches[url];
      }

      return cacheHolder;
    },
    findCache : function(url)
    {
      if (url in this._caches)
      {
        return this._caches[url].instance
      }
      return null;
    }


  };

}
(vitrium.io,
vitrium.io.cache,
vitrium.utils,
vitrium.utils.asyncStorage,
vitrium.io.documents,
vitrium.async,
vitrium.fs,
vitrium.log,
_,
Backbone
));

// script:viewer/io/cache-access/document-cache-manager.js
/// <reference path="~/build.html" />

(function (exports, io, cacheUtils, asyncStorage, log, _)
{
  "use strict";

  var FILE_SYSTEM_INFO_KEY = "||info||";


  exports.DocumentCacheManager = DocumentCacheManager;

  function DocumentCacheManager(cacheManager, url, cipher)
  {
    this._cacheManager = cacheManager;
    this._url = url;
    this._cipher = cipher;
    this._db = null;

    this.downloadState = io.CACHE_STATE.CAN_FREE;
    this._invalidating = false;
    this._queue = [];
  }

  DocumentCacheManager.prototype = {
    init: function (success, error)
    {
      var self = this;
      asyncStorage.create(this._url, function (db)
      {
        self._db = db;
        self.refreshStatus(function ()
        {
          success(self);
          self._executeQueue();
        }, handleError);
      }, handleError);

      function handleError()
      {
        self._db = null;
        error(arguments);
      }
    },
    erase: function ()
    {
      this._invalidating = true;
      var self = this;
      this._cacheManager.forceInvalidate(this._url, done, done);

      function done()
      {
        self.downloadState = io.CACHE_STATE.CAN_FREE;
        self._invalidating = false;
        self._executeQueue();
      }
    },
    _executeQueue: function()
    {
      var q = this._queue;
      this._queue = [];
      _.each(q, function (c) { c(); });
    },
    cacheFile: function (path, data)
    {
       if (this._cipher !== null) {
          var self = this;
          this._cipher.encrypt(data).then(function (data) {
             var args = [path, data];
             self._execute("_doCacheFile", args);
          }).catchError(function (e) {
             log.error("Unable to encrypt: " + path + " -> ", e);
          });
       }
       else {
          var args = [path, data];
          this._execute("_doCacheFile", args);
       }
    },
    storeFile: function(path, data, success, error)
    {
       if (this._cipher !== null) {
          var self = this;
          this._cipher.encrypt(data).then(function (data) {
             var args = [path, data, success, error];
             self._execute("_doStoreFile", args);
          }).catchError(function (e) {
             log.error("Unable to encrypt: " + path + " -> ", e);
             error(e);
          });
       }
       else {
          var args = [path, data, success, error];
          this._execute("_doStoreFile", args);
       }
    },
    readFile: function (path, success, error)
    {
       var args;
       if (this._cipher !== null)
       {
          var self = this;
          args = [path, function (data) {
             self._cipher.decrypt(data).then(function (data) {
                success(data);
             })
             .catchError(function(e){
                log.error("Unable to decrypt: " + path + " -> " + JSON.stringify(e));
                error(e);
             });
          }, error];
       }
       else
       {
          args = [path, success, error];
       }

       this._execute("_doReadFile", args);
    },
    deleteInfo: function (key, success, error)
    {
       var args = [key, success, error];
       this._execute("_doDeleteInfo", args);
    },
    storeInfo: function (key, info, success, error)
    {
      var args = [key, info, success, error];
      this._execute("_doStoreInfo", args);
    },
    loadInfo: function (key, success, error)
    {
      var args = [key, success, error];
      this._execute("_doLoadInfo", args);
    },
    setDownloadState : function(state, success, error, data)
    {
      var args = [state, success, error, data];
      this._execute("_doSetDownloadState", args);
    },
    listStoredItems : function(success, error)
    {
      var args = [success, error];
      this._execute("_doListStoredItems", args);
    },
    storeFileSystemInfo : function(fileSystemInfo, success, error)
    {
      this.storeInfo(FILE_SYSTEM_INFO_KEY, JSON.stringify(cacheUtils.serializeFileSystemInfo(fileSystemInfo)), success, error);
    },
    loadFileSystemInfo : function (success, error)
    {
      this.loadInfo(FILE_SYSTEM_INFO_KEY, function (info)
      {
        try
        {
          if (info === null)
          {
            success(null);
          }
          else
          {
            success(cacheUtils.deserializeFileSystemInfo(JSON.parse(info)));
          }
        }
        catch(e)
        {
          log.warn("[DocumentCacheManager] unable to parse fileSystemInfo");
          // just ignore it
          success(null);
        }
      }, error);
    },
    storeGlobalDocumentInfo : function(documentInfo)
    {
      var args = [documentInfo];
      this._execute("_doStoreGlobalDocumentInfo", args);
    },
    refreshStatus: function (success, error)
    {
      this._cacheManager.getDownloadState(this._url, _.bind(function (state)
      {
        this.downloadState = state;
        success();
      }, this),
      function ()
      {
        error();
        log.error("[DocumentCacheManager] unable to retrive the download state");
      })
    },
    _doCacheFile: function (path, data)
    {
      var self = this;
      this._cacheManager.prepare(data.length, function ()
      {
        self._db.setItem(path, data, function ()
        {
          self._cacheManager.increment(self._url, path, data.length);
        },
        function (e)
        {
          log.error("[LocalCacheFS] file cache failed");
          log.error(e);
        });
      });
    },
    _doStoreFile : function(path, data, success, error)
    {
      this._db.setItem(path, data, success, error);
    },
    _doReadFile: function (path, success, error)
    {
      var self = this;
      this._db.getItem(path, function (data)
      {
        if (data === null)
        {
          error(1404);
        }
        else
        {
          success(data);
          self._cacheManager.updateLastLoad(self._url, path);
        }
      }, error);
    },
    _doStoreInfo: function (key, info, success, error)
    {
      this._db.setItem(key, info, success, error);
    },
    _doLoadInfo: function (key, success, error)
    {
      this._db.getItem(key, success, error);
    },
    _doDeleteInfo: function(key, success, error)
    {
       this._db.removeItem(key, success, error);
    },
    _doListStoredItems : function(success, error)
    {
      this._db.listItems(success, error);
    },
    _doStoreGlobalDocumentInfo : function(documentInfo)
    {
      this._cacheManager.storeGlobalDocumentInfo(this._url, documentInfo);
    },
    _doSetDownloadState : function(state, success, error, data)
    {
      var self = this;
      this._cacheManager.setDownloadingState(this._url, state, function ()
      {
        self.downloadState = state;
        success();
      }, error, data);
    },
    _execute: function (action, args)
    {
      if (this._invalidating || this._db === null)
      {
        this._queue.push(_.bind(function () { this._execute(action, args); }, this));
      }
      else
      {
        this[action].apply(this, args);
      }
    }
  };
}
(
vitrium.io.cache,
vitrium.io,
vitrium.io.cache,
vitrium.utils.asyncStorage,
vitrium.log,
_));

// script:viewer/io/cache-access/local-cache-fs-serialization.js
/// <reference path="~/build.html" />

(function (exports, _)
{
  "use strict";

  exports.deserializeFileSystemInfo = deserializeFileSystemInfo;
  exports.serializeFileSystemInfo = serializeFileSystemInfo;

  function deserializeFileSystemInfo(cacheInfoObj)
  {
    if (cacheInfoObj.globalFlags & (1|2))
    {
      var len = cacheInfoObj.entries.length;
      var entries = cacheInfoObj.entries;

      for (var i = 0; i < len; ++i)
      {
        var entry = entries[i];

        entry.hmacChecksum = convertToUInt8Array(entry.hmacChecksum);
        entry.aesSalt = convertToUInt8Array(entry.aesSalt);
      }
    }

    return cacheInfoObj;
  }

  function serializeFileSystemInfo(fileSystemInfo)
  {
    if (fileSystemInfo.globalFlags & (1 | 2))
    {
      var serializableInfo = _.clone(fileSystemInfo);
      var entries = fileSystemInfo.entries;
      var newEntries = serializableInfo.entries = [];
      for (var i = 0,len=entries.length; i  < len; ++i)
      {
        var entry = entries[i];
        newEntries.push(serializeEntry(entry));
      }

      return serializableInfo;
    }

    return fileSystemInfo;
  }


  function serializeEntry(entry)
  {
    var metadata = entry.metadata;
    var hmacChecksum = entry.hmacChecksum;
    var aesSalt = entry.aesSalt;
    var aesDerivedKey = entry.aesDerivedKey;
    var hmacKey = entry.hmacKey;

    entry.metadata = null;
    entry.hmacChecksum = null;
    entry.aesSalt = null;
    entry.aesDerivedKey = null;
    entry.hmacKey = null;

    var newEntry = _.clone(entry);
    newEntry.hmacChecksum = convertToArray(hmacChecksum);
    newEntry.aesSalt = convertToArray(aesSalt);

    entry.metadata = metadata;
    entry.hmacChecksum = hmacChecksum;
    entry.aesSalt = aesSalt;
    entry.aesDerivedKey = aesDerivedKey;
    entry.hmacKey = hmacKey;

    return newEntry;
  }

  function convertToUInt8Array(orig)
  {
    if (orig !== null)
    {
      var len = orig.length;
      var res = new Uint8Array(len);

      for (var i = 0; i < len; ++i)
      {
        res[i] = orig[i];
      }

      return res;
    }
    return null;
  }

  function convertToArray(uint8array)
  {
    if (uint8array !== null)
    {
      var len = uint8array.length;
      var res = new Array(len);

      for (var i = 0; i < len; ++i)
      {
        res[i] = uint8array[i];
      }


      return res;
    }
    return null;
  }

}
(
vitrium.io.cache,
_
));

// script:viewer/io/cache-access/lazy-cipher.js
/// <reference path="~/build.html" />

(function (exports, async) {
   "use strict";

   exports.LazyCipher = LazyCipher;
   function LazyCipher()
   {
      this._cipher = null;
      this._queue = [];
   }

   LazyCipher.prototype.encrypt = function (data) {
      if (this._cipher !== null)
         return this._cipher.encrypt(data);

      var task = new _Task(true, data);

      this._queue.push(task);

      return task.completer.future;
   };

   LazyCipher.prototype.decrypt = function (data) {
      if (this._cipher !== null)
         return this._cipher.decrypt(data);

      var task = new _Task(false, data);

      this._queue.push(task);

      return task.completer.future;
   };

   LazyCipher.prototype.reset = function () {
      this._cipher = null;
   };
   LazyCipher.prototype.initCipher = function (cipher) {
      this._cipher = cipher;

      var q = this._queue;
      for(var i =0, len=q.length; i !== len;++i)
      {
         var t = q[i];
         var f;
         if (t.encryption)
            f = cipher.encrypt(t.data);
         else
            f = cipher.decrypt(t.data);

         f.chainSuccess(t.completer);
         f.chainError(t.completer);
      }

      this._queue = [];
   };


   function _Task(encryption, data)
   {
      this.encryption = encryption;
      this.data = data;
      this.completer = new async.Completer();
   }

}
(vitrium.io, vitrium.async));

// script:viewer/io/cache-access/local-cache-fs.js
/// <reference path="~/build.html" />

(function (exports, io, async, cacheUtils, asyncStorage, utils, log, crypto, _)
{
  "use strict";

  exports.LocalCacheFS = LocalCacheFS;
  var ST_FRESH = 0;
  var ST_INITIALIZING = 1;
  var ST_INITIALIZED = 2;
  // Note: I am not sure with this state
  var ST_BROKEN = 3;


  function LocalCacheFS(fileSystemContext)
  {
     /// <field name="_lazyCipher" type="io.LazyCipher" />

    this._context = fileSystemContext;
    this._cacheManager = fileSystemContext.cacheManager;
    this._cache = null;    
    this._lazyCipher = null;

    this._state = ST_FRESH;
    this._info = null;

     

    this.on("fileSystem:changed", this.onFileSystemChanged);
  }

  LocalCacheFS.prototype =
  {
    isCacheEnabled : function()
    {
      if ("cacheEnabled" in this._context)
      {
        return this._context.cacheEnabled;
      }
      else
      {
        return true;
      }
    },
    on : function(evt, callback)
    {
      if ("on" in this._context) this._context.on(evt, callback, this);
    },
    off : function(evt, callback)
    {
      if ("off" in this._context) this._context.off(evt, callback, this);
    },
    onFileSystemChanged : function()
    {
      if (this._cache !== null) 
      {
        log.debug("[LocalCacheFS] onFileSystemChanged");

        this._cache.erase();
        this._info = null;
      }        
    },
    init : function()
    {
      if (this._state === ST_FRESH)
      {
         var isEncryptionEnabled = !!this._context.encryptionKey;
         if (isEncryptionEnabled)
            this._lazyCipher = new io.LazyCipher();

        var cancelable = new async.Cancelable();
        var completer = new async.Completer(cancelable.cancelCallback);
    
        this._state = ST_INITIALIZING;
        var url = this._context.url;
        var self = this;

        var initializationErrorHandler = function (e) {
           self._state = ST_FRESH;
           if (cancelable.canceled) { return; }
           log.error("[LocalCacheFS] cache initializiation has failed");
           if (e) {
              log.error(e);
           }

           completer.fail(e);
        };

         self._cache = self._cacheManager.openCache(url, function (cache) {
            if (cancelable.canceled) { self._state = ST_FRESH; return; }

            cache.loadFileSystemInfo(function (info) {
               if (cancelable.canceled) {
                  self._state = ST_FRESH;
                  return;
               }

                 
               if (info !== null && ((isEncryptionEnabled && !info.storageEncryption) || (!isEncryptionEnabled && info.storageEncryption)))
               {
                  self._cache.erase();
                  log.warn("[LocalCacheFS] data were erased because of encryption method has changed");
                  info = null;
               }
               else if (isEncryptionEnabled && info !== null && crypto.calcKeyHash(self._context.encryptionKey) !== info.storageEncryption)
               {
                  self._cache.erase();
                  log.warn("[LocalCacheFS] data were erased because encryption key has changed");
                  info = null;
               }

               if (isEncryptionEnabled && info !== null)
               {
                  self.initEncryptionFromInfo(info);
               }
               else
               {
                  log.info("[LocalCacheFS] RAW storage used.");
               }

               self._state = ST_INITIALIZED;
               self._info = info;
               completer.complete();

            }, initializationErrorHandler);
         }, initializationErrorHandler, self._lazyCipher);
              

         return completer.future;
      }
      else
      {
        throw new Error("[LocalCacheFS] needs to be fresh!");
      }
    },
    initEncryptionFromInfo : function (info)
    {
       var self = this;
       var authKeyStored = false;
       if (info.globalFlags & (1 | 2))
       {
          var pwd = this._context.passwordProvider.password;
          this._context.passwordProvider.on("passwordEntered", _deriveKey);
          this._context.passwordProvider.on("invalidPassword", function () {
             if (authKeyStored)
             {
                self._lazyCipher.reset();
                self._cache.deleteInfo("||auth||", function () {
                   log.debug("[LocalCacheFS] auth info deleted");
                }, 
                function (e) {
                   log.debug("[LocalCacheFS] unable to delete auth info " + (e ? (e.message ? e.message : e) : ""));
                   self._cache.erase();
                });
             }
          });

          if (!_.isEmpty(pwd))
          {
             _deriveKey(pwd);
          }

          log.info("[LocalCacheFS] AES storage with document password used.");
       }
       else
       {
          log.info("[LocalCacheFS] AES storage used.");
          _initCipher(self._context.encryptionKey);
       }

       function _deriveKey(pwd)
       {
          log.debug("[LocalCacheFS] _deriveKey");
          var utf8pwd = CryptoJS.enc.Utf8.parse(pwd);

          var keyWordsLen = self._context.encryptionKey.length / 4;
          var derivedKey = utils.u8array.stringify(crypto.PBKDF2(utf8pwd, self._context.encryptionKey, keyWordsLen*2, 1000));
          
          var aesKey = derivedKey.subarray(0, self._context.encryptionKey.length);
          var authKeyBase = utils.u8array.parse(derivedKey.subarray(self._context.encryptionKey.length, derivedKey.length));

          var hasher = new crypto.Sha1();
          var authKey =  CryptoJS.enc.Hex.stringify(hasher.finalize(authKeyBase));
        
          self._cache.loadInfo("||auth||", function (info) {
             if (info === null)
             {
                authKeyStored = true;

                self._cache.storeInfo("||auth||", authKey, function () {
                   log.debug("[LocalCacheFS] auth info saved");
                }, function (err) {
                   log.error("[LocalCacheFS] auth info saving failed");
                });

                _initCipher(aesKey);
             }
             else if (info === authKey)
             {
                log.debug("[LocalCacheFS] auth info verified");
                _initCipher(aesKey);
             }
             else
             {
                log.warn("[LocalCacheFS] an incorrect password entered");
             }
          },
          function (err) {
             log.error("[LocalCacheFS] unable to get auth info");
             _initCipher(aesKey);            
          });
       }
      
       function _initCipher(key) {
          log.debug("[LocalCacheFS] _initCipher");
          var cipher = new crypto.AesStringWorkerClient(new crypto.AesCbcAlgorithmSettings());
          cipher.init(self._context.encryptionKey).then(function () {
             self._lazyCipher.initCipher(cipher);
          })
          .catchError(function (e) {
             log.error("[LocalCacheFS] AES encryption initialization failed!");
             initializationErrorHandler(e);
          });
       }
    },
    tryToGetDownloadedState : function()
    {
      if (this._state === ST_INITIALIZED)
      {
        return this._cache.downloadState;
      }
      return false;
    },
    destroy : function()
    {
      this.off("fileSystem:changed", this.onFileSystemChanged);
    },
    verifyCache : function(etag)
    {
      this._throwIfNotIntialized();
      if (this._info !== null)
      {
        if (this._info.etag === etag)
        {
          log.debug("[LocalCacheFS] verifyCache ok");
          return true;
        }
        else
        {
          log.debug("[LocalCacheFS] verifyCache fileSystem:changed");

          if ("trigger" in this._context)
          {
            // this will call _onFileSystemChanged too
            this._context.trigger("fileSystem:changed", "cache-verification");
          }
          else
          {
            this._onFileSystemChanged();
          }
          
          return false;
        }
      }
      else
      {
        log.debug("[LocalCacheFS] verifyCache this._info === null");
        return false;
      }
    },
    cacheFile : function(path, options, data)
    {
      this._throwIfNotIntialized();
      if (this.isCacheEnabled())
            this._doCacheFile(path, options, data);     
    },
    loadFileSystemInfo : function()
    {
      this._throwIfNotIntialized();

      var completer = new async.Completer();

      if (this._info !== null)
      {
        async.asyncSuccess(completer, this._info);
      }
      else
      {
        async.asyncError(completer);
      }

      return completer.future;
    },
    attachFileSystemInfo : function(fileSystemInfo)
    {
       log.debug("[LocalCacheFS] attachFileSystemInfo");

       fileSystemInfo.storageEncryption = this._context.encryptionKey ? crypto.calcKeyHash(this._context.encryptionKey) : null;
            
      if (this._checkInitialized())
      {
        if (this._info !== null && this._info.etag !== fileSystemInfo.etag) throw new Error("[LocalCacheFS] this should never happen (this._info.etag !== fileSystemInfo.etag)");

        if (this._info === null)
        {
           if (this._lazyCipher !== null) {
              this.initEncryptionFromInfo(fileSystemInfo);
           }

          this._info = fileSystemInfo;
          if (this.isCacheEnabled())   this._doStoreFileSystemInfo(fileSystemInfo);
        }

      }
      else
      {
        log.warn("[LocalCacheFS] attachFileSystemInfo (is not initialized)");
      }
    },
    list : function()
    {
      this._throwIfNotIntialized();
      var completer = new async.Completer();

      if (this._info !== null)
      {
        async.asyncSuccess(completer, _.clone(this._info.entries));
      }
      else
      {
        async.asyncError(completer);
      }

      return completer.future;
    },
    listPaths : function()
    {
      this._throwIfNotIntialized();
      var completer = new async.Completer();

      if (this._info !== null)
      {
        async.asyncSuccess(completer, _.pluck(this._info.entries, "filename"));
      }
      else
      {
        async.asyncError(completer);
      }

      return comleter.future;
    },
    read : function(path, options)
    {
      this._throwIfNotIntialized();
      var cancelable = new async.Cancelable();
      var completer = new async.Completer(cancelable.cancelCallback);
      var cipher = this._cipher;

      this._cache.readFile(path, function (data)
      {
        if (!cancelable.canceled)
        {
            completer.complete(data);
        }
      }, function(e){
      
         if (!cancelable.canceled)
         {
            completer.fail(e);
         }
      });    
      return completer.future;
    },
    _checkInitialized : function()
    {
      return this._state === ST_INITIALIZED;
    },
    _throwIfNotIntialized : function()
    {
      if (!this._checkInitialized()) throw new Error("[LocalCacheFS] must be initialized first!");
    },
    _doCacheFile: function (path, options, data)
    {
      var self = this;
      this._cache.cacheFile(path, data);
    },
    _doStoreFileSystemInfo: function (fileSystemInfo)
    {
      log.debug("[LocalCacheFS] _doStoreFileSystemInfo");

      this._cache.storeFileSystemInfo(fileSystemInfo,
        function ()
        {
          log.debug("[LocalCacheFS] fileSystemInfo stored");
        },
        function (e)
        {
          log.error("[LocalCacheFS] unable to store fileSystemInfo");
          log.error(e);
        });
    }
  };


   
}
(vitrium.io,
vitrium.io,
vitrium.async,
vitrium.io.cache,
vitrium.utils.asyncStorage,
vitrium.utils,
vitrium.log,
vitrium.crypto,
_
));

// script:viewer/io/cache-access/stored-documents-cache-adapter.js
/// <reference path="~/build.html" />

(function (exports,fs, _)
{
  "use strict";

  exports.StoredDocumentsCacheAdapter = StoredDocumentsCacheAdapter;

  function StoredDocumentsCacheAdapter(db, fileSystemManager, cacheManager)
  {
    this.db = db;
    this.fileSystemManager = fileSystemManager;
    this.cacheManager = cacheManager;
  }

  StoredDocumentsCacheAdapter.prototype = {
    loadDocument: function (success, error, reqID)
    {
      var self = this;
      this.db.readTransaction(function (tx)
      {
        self.fileSystemManager.load(tx, function (tx, fileList)
        {
          var _id = reqID;
          var found = null;
          for (var i = 0, len = fileList.length; i < len; ++i)
          {
            var file = fileList[i];
            if (file.id === _id && file.type === "document")
            {
              found = file;
              break;
            }
          }

          if (found)
          {
            self.cacheManager.loadExtendedData(tx, function (tx, extendedData)
            {
              var result = extendedData[found.url];
              self.cacheManager.loadStats(tx, function (tx, stats)
              {
                var info = stats.files[found.url];
                result.info = info;
                success(result, tx);
              }, error);
            }, error);
          }
          else
          {
            error("document-not-found", tx);
          }
        }, error);
      }, error);
    },
    load: function (success, error, reqID, write)
    {
      if (!this.db)
      {
        error("db is not opened");
        return;
      }


      var self = this;
      if (write)
      {
        this.db.transaction(executeTransaction, error);
      }
      else
      {
        this.db.readTransaction(executeTransaction, error);
      }
      function executeTransaction(tx)
      {
        self.fileSystemManager.load(tx, function (tx, fileList)
        {
          var _id = reqID;
          if (_id)
          {
            var found = null;
            for (var i = 0, len = fileList.length; i < len; ++i)
            {
              var file = fileList[i];
              if (file.id === _id && file.type === "document")
              {
                found = file;
                break;
              }
            }

            if (found)
            {
              self.cacheManager.loadExtendedData(tx, function (tx, extendedData)
              {
                found.extendedData = extendedData;
                success(fileList, tx);
              }, error);
            }
            else
            {
              success(fileList, tx);
            }
          }
          else
          {
            success(fileList, tx);
          }
        }, error);
      }
    },
    save: function (nodes, success, error, tx)
    {
      var self = this;
      if (tx)
      {
        save(tx);
      }
      else
      {
        this.db.transaction(save, error);
      }

      function save(tx)
      {
        self.fileSystemManager.save(tx, nodes, success, error);
      }
    },
    deleteItems: function (toDelete, nodes, tx, success, error)
    {
      // arguments for _.without
      var args = [nodes];
      args.push.apply(args, toDelete);

      var newNodes = _.without.apply(_, args);
      nodes.splice(0);

      // to change input argument
      nodes.push.apply(nodes, newNodes);

      for (var i = 0, len = toDelete.length; i < len; ++i)
      {
        var node = toDelete[i];
        if (node.type === "document" && node.url)
        {
          this.cacheManager.forceInvalidate(node.url, function () {}, function () {});
        }
      }

      this.save(newNodes, success, error, tx);
      var self = this;
    },
    deleteDocumentByUrl: function (url, success, error)
    {
      this.load(_.bind(function (fileList, tx)
      {
        var file = fs.findFileByUrl(fileList, url);
        if (file)
        {
          this.deleteItems([file], fileList, tx, function (fileList, tx) { success(true, tx); }, error);
        }
        else
        {
          success(false, tx);
        }
      }, this), error, null, true);
    }
  };

}
(vitrium.io.documents,
vitrium.fs,
_
));

// script:viewer/io/file-system/package-fs.js
/// <reference path="~/build.html" />

(function (exports, backends, async, log, zip, g4s, _)
{
  "use strict";

  exports.PackageFS = PackageFS;
  exports.indexEntries = indexEntries;

  var ST_FRESH = 0;
  var ST_INITIALIZING = 1;
  var ST_INITIALIZED = 2;
  var ST_FS_INFO_LOADED = 3;
  var ST_DESTROY = 4;

  function PackageFS(fileSystemContext)
  {
    this.context = fileSystemContext;
    var BackendClass = backends.WebworkerBackend || backends.DirectBackend;
    this._backend = new BackendClass(fileSystemContext.passwordProvider ? fileSystemContext.passwordProvider : null);
    if (BackendClass === backends.WebworkerBackend)
       log.debug("[PackageFS] backend=WebworkerBackend");
    else
       log.debug("[PackageFS] backend=DirectBackend");
     
    this._remoteFile = null;
    this._fileSystemInfo = null;
    this._entriesReader = null;
    this._packageHeaderBytes = null;
    this._indexedEntries = null;
    this._initFuture = null;
    this._state = ST_FRESH;

    this._checkingForChanges = false;
    this._lastCheckingForChanges = 0;
  }

  PackageFS.prototype = {
    destroy : function()
    {
      if (this._initFuture !== null) this._initFuture.cancel();
      this._backend.destroy();
    },
    init : function()
    {
      if (this._state === ST_FRESH)
      {
        var cancelable = new async.Cancelable();
        var completer = new async.Completer(cancelable.cancelCallback);
        this._state = ST_INITIALIZING;
        var url = this.context.url;
        var remoteFile = this._remoteFile = this._backend.createRemoteFileInstanceForURL(url);
        var self = this;

        

        // first 24 bytes are requested (G4S header)
        cancelable.asyncTask = remoteFile.init(
          function (size, etag, headerBytes, directDecodeSupport)
          {
             log.debug("[PackageFS] init callback");

            self._initFuture = null;
            var format = null;
            if (headerBytes.length === 24)
            {
              if ((headerBytes[0] === 0x50 && headerBytes[1] === 0x4B) || (headerBytes[0] === 0x56 && headerBytes[1] === 0x53))
              {
                self._entriesReader = zip;//.readEntries(remoteFile, _.bind(this._onEntriesLoaded, this), _.bind(this.errorHandler, this));
                format = "zip";
                log.debug("[PackageFS] The package is a ZIP file.");

              }
                //does it contain 4S
              else if (headerBytes[0] === 0x34 && headerBytes[1] === 0x53)
              {
                self._entriesReader = g4s;
                self._packageHeaderBytes = headerBytes;
                format = "g4s";

                log.debug("[PackageFS] The package is a G4S file.");
                //g4s.readEntries(remoteFile, _.bind(this._onEntriesLoaded, this), _.bind(this.errorHandler, this), headerBytes);
              }
              else
              {
                log.error("[PackageFS] The package is not ZIP nor G4S.");
                self._state = ST_FRESH;
                self.trigger("fileSystem:error", "package", 1551);
                completer.fail(1551);
                return;
              }
              self._state = ST_INITIALIZED;

              self._fileSystemInfo = {
                url: url,
                size: size,
                etag: etag,
                format: format,
                ddSupport: directDecodeSupport,
                globalFlags : null,
                entries : null
              };

              completer.complete(etag);
              log.debug("[PackageFS] state="+self._state);
            }
            else
            {
              self._state = ST_FRESH;

              if (headerBytes.length > 24)
              {
                log.error("[PackageFS] Your WebServer does not support the byte range access. You have to enable it.");
                self.trigger("fileSystem:error", "server", 1550);
                completer.fail(1550);
              }
              else
              {
                log.error("[PackageFS] The package is not valid. It is too small.");
                self.trigger("fileSystem:error", "package", 1551);
                completer.fail(1551);
              }
            }
          },
          function () {
            log.error("[PackageFS] remoteFile.init failed");

            self._state = ST_FRESH;
            self._initFuture = null;
            completer.fail.apply(completer, arguments);
          }, 23);

        this._initFuture = completer.future;

        completer.future.catchError(function (code)
        {
          self.trigger("fileSystem:error", "server", code);
        });

        return completer.future;
      }
      else
      {
        throw new Error("[PackageFS] is not fresh!");
      }
    },
    loadFileSystemInfo : function()
    {
      log.debug("[PackageFS] loadFileSystemInfo state=" + this._state);
      var cancelable = new async.Cancelable();
      var completer = new async.Completer(cancelable.cancelCallback);

      if (this._state === ST_FS_INFO_LOADED)
      {
        log.debug("[PackageFS] state=ST_FS_INFO_LOADED");
        async.asyncSuccess(completer, this._fileSystemInfo);
      }
      else if (this._state === ST_INITIALIZED)
      {
        log.debug("[PackageFS] state=ST_INITIALIZED");
        var self = this;
        cancelable.asyncTask = this._entriesReader.readEntries(this._remoteFile,
        function (entries, globalFlags)
        {
           log.debug("[PackageFS] entries loaded: count="+(entries? entries.length: "null") +" globalFlags="+globalFlags);

          self._initFuture = null;

          self._fileSystemInfo.entries = entries;
          self._fileSystemInfo.globalFlags = globalFlags;

          if (isDirectDecodeImpossible(globalFlags))
          {
             self._fileSystemInfo.ddSupport = false;
          }
         
          self._indexedEntries = indexEntries(entries);

          self._backend.init(self._fileSystemInfo, self._entriesReader);
          log.debug("[PackageFS] direct decode opt", self._fileSystemInfo);
          self._state = ST_FS_INFO_LOADED;
          log.debug("[PackageFS] state=ST_FS_INFO_LOADED");
          completer.complete(self._fileSystemInfo);
        }
        ,
        function (e)
        {
          log.debug("[PackageFS] loadFileSystemInfo failed: "+e);
          self._initFuture = null;
          completer.fail.apply(completer, arguments);
        },
        this._packageHeaderBytes);

        log.debug("[PackageFS] entries requested");
      }
      else
      {
        log.error("[PackageFS] is not initialized");
        throw new Error("[PackageFS] must be initialized first to call loadFileSystemInfo");
      }

      this._initFuture = completer.future;
      return completer.future;
    },
    attachFileSystemInfo : function(fi)
    {
       log.debug("[PackageFS] attachFileSystemInfo state="+this._state);

      var attached = false;
      if (this._state === ST_FRESH)
      {

        this._fileSystemInfo = {
          url: fi.url,
          size: fi.size,
          etag: fi.etag,
          format: fi.format,
          ddSupport: fi.directDecodeSupport,
          globalFlags: fi.globalFlags,
          entries: fi.entries
        };
        attached = true;
      }
      else if (this._state === ST_INITIALIZED)
      {
        var cInfo = this._fileSystemInfo;
        cInfo.globalFlags = fi.globalFlags;
        cInfo.entries = fi.entries;
        attached = true;
      }
      
      if (isDirectDecodeImpossible(fi.globalFlags))
      {
         this._fileSystemInfo.ddSupport = false;
      }
      log.debug("[PackageFS] direct decode opt =" + self._fileSystemInfo.ddSupport);

      if (attached)
      {
         this._state = ST_FS_INFO_LOADED;

         log.debug("[PackageFS] state=ST_FS_INFO_LOADED");

        this._indexedEntries = indexEntries(fi.entries);
        this._remoteFile = this._backend.createRemoteFileInstanceForFileSystemInfo(this._fileSystemInfo);
        this._backend.init(this._fileSystemInfo, fi.format === "g4s" ? g4s : zip);

        log.debug("[PackageFS] backend init requested");
      }
      else if (this._state !== ST_FS_INFO_LOADED)
      {
        throw new Error("[PackageFS] Unable to attach file system info!");
      }
      else
      {
         log.debug("[PackageFS] file system info has not been attached");
      }
    },
    read : function(path, options)
    {
      this._checkFileSystemInfoLoaded();
      var entry = this._indexedEntries[path];
      if (entry)
      {
        var self = this;
        self.trigger("fileSystem:remoteRead", "requested", entry.compressedSize, entry.uncompressedSize, path);

        var future = this._backend.read(entry, options);
        future.then(function ()
        {
          self.trigger("fileSystem:remoteRead", "finished", entry.compressedSize, entry.uncompressedSize, path);
        }).
        catchError(function (code)
        {
          self.trigger("fileSystem:remoteRead", "failed", entry.compressedSize, entry.uncompressedSize, path);

          if (code === 0xffff)
          {
            self.trigger("fileSystem:changed", "package");
          }
          else
          {
            if (_.isNumber(code))
            {
              self.trigger("fileSystem:error", "server", code);
            }
            else
            {
              self.trigger("fileSystem:error", "package", code);
            }            
          }          
        });
        return future;
      }
      else
      {
        var completer = new async.Completer();
        async.asyncError(completer, 1404);
        return completer.future;
      }
    },
    list : function()
    {
      this._checkFileSystemInfoLoaded();
      var completer = new async.Completer();
      async.asyncSuccess(completer, this._fileSystemInfo.entries);

      return completer.future;
    },
    listPaths : function()
    {
      this._checkFileSystemInfoLoaded();
      var completer = new async.Completer();
      async.asyncSuccess(completer, _.pluck(this._fileSystemInfo.entries, "filename"));

      return completer.future;
    },
    trigger : function()
    {
      if ("trigger" in this.context)
      {
        this.context.trigger.apply(this.context, arguments);
      }
    },
    checkForChanges : function()
    {
      if (this._state === ST_FS_INFO_LOADED && !this._checkingForChanges)
      {        
        if (Date.now() - this._lastCheckingForChanges > (this.context.checkForChangesInterval || 10000))
        {
          this._checkingForChanges = true;

          var self = this;
          this._remoteFile.checkETag(function (ok)
          {
            self._checkingForChanges = false;
            self._lastCheckingForChanges = Date.now();

            self.trigger("fileSystem:checked", ok);

            if (!ok)
            {
              self.trigger("fileSystem:changed", "package");
            }
          },
          function (err)
          {
            self.trigger("fileSystem:error", "server", err);
          });
        }
      }      
    },
    _checkFileSystemInfoLoaded : function()
    {
      if (this._state !== ST_FS_INFO_LOADED)
      {
        throw new Error("[PackageFS] File system info must be loaded or attached first!");
      }
    }
  };

  function isDirectDecodeImpossible(globalFlags)
  {
     return (globalFlags & (1 | 2)) !== 0;
  }
  
  function indexEntries(entries)
  {
    var indexed = {};
    for (var i = 0, len= entries.length; i < len;++i)
    {
      var entry = entries[i];
      indexed[entry.filename] = entry;
    }
    return indexed;
  }
}
(
vitrium.io,
vitrium.io.package,
vitrium.async,
vitrium.log,
vitrium.zip,
vitrium.g4s,
_
));

// script:viewer/io/file-system/package-fs-webworker-backend.js
/// <reference path="~/build.html" />

(function (exports, io, utils, async, log, bin, _, global)
{
  "use strict";
  var SUCCESS = 0x1234;
  var ERROR = 0xDEAD;

  if ("Worker" in global)
  {
    // let's define WebworkerBackend  only if it is supported
    exports.WebworkerBackend = WebworkerBackend;
  }

  
  
  function WebworkerBackend(passwordProvider)
  {
    var completer = new async.Completer();
    this.passwordProvider = passwordProvider;
    this.decompressor = new utils.Pool(1, utils.Pool.workerPath("zip-web-worker.js"), _.bind(completer.complete, completer));
    var future = this._initFuture = completer.future;
    future.then(_.bind(this._onPoolInitialized, this));

    this.backgroundKeyGenerator = null;
    this._initializationRequested = false;

    log.debug("[WebworkerBackend] constructor end");
  }

  WebworkerBackend.prototype = {
    destroy : function()
    {
      this.decompressor.stop();
      this.decompressor = null;
      
      if (this.backgroundKeyGenerator !== null) this.backgroundKeyGenerator.destroy();
    },
    createRemoteFileInstanceForURL: function (url)
    {
      return new bin.RemoteFile(url, null);
    },
    createRemoteFileInstanceForFileSystemInfo : function(fileSystemInfo)
    {
      var file = new bin.RemoteFile(fileSystemInfo.url, null);
      file.etag = fileSystemInfo.etag;
      file.size = fileSystemInfo.size;

      return file;
    },
    init: function (fileSystemInfo)
    {
      log.debug("[WebworkerBackend] init", fileSystemInfo);

      if (this._initializationRequested)
      {
        throw new Error("[WebworkerBackend] initialization already requested!");
      }
      else
      {
        if ((fileSystemInfo.globalFlags & (1|2)) !== 0)
        {
          if (this.passwordProvider === null) throw new Error("[WebworkerBackend] encrypted archives are unsupported.");

          this.backgroundKeyGenerator = new BackgroundKeyGenerator(this.passwordProvider, fileSystemInfo.entries, fileSystemInfo.globalFlags);
        }

        var clonedInfo = _.clone(fileSystemInfo);
        clonedInfo.url = this._toAbsoluteUrl(fileSystemInfo.url);
        clonedInfo.parser = clonedInfo.format;
        this.decompressor.start(clonedInfo);
        this._initializationRequested = true;  
      }
    },
    read : function(entry, options)
    {
      var cancelable = new async.Cancelable();
      var completer = new async.Completer(cancelable.cancelCallback);
      
      this._doRead(entry, options ? options : null, completer, cancelable);

      return completer.future;
    },
    _createWaitForEntryReadCallback : function(entry, options, completer, cancelable)
    {
      return _.bind(function(){ 
        if (!cancelable.canceled)
        {
          this._doRead(entry, options, completer, cancelable);
        }
      }, this);
    },
    _doRead: function(entry, options, completer, cancelable)
    {
      if (this._initFuture !== null)
      {
        this._initFuture.then(this._createWaitForEntryReadCallback(entry,options, completer, cancelable));
      }
      else if ((entry.flags & (2 | 4)) && entry.aesDerivedKey === null)
      {
        this.backgroundKeyGenerator.waitForKey(entry, this._createWaitForEntryReadCallback(entry, options, completer, cancelable));
      }
      else
      {
        var job = this.decompressor.createJob(entry.filename);
        cancelable.asyncTask = job;
        job.on("message", _.bind(function(msg) {
          var message = msg.data;
          switch(message.id) 
          {
            case SUCCESS:
              completer.complete(message.data, entry.filename);
              break;
            case ERROR:
              if (message.reason[0] === "Wrong password.")
              {
                this.backgroundKeyGenerator.waitForKey(entry, this._createWaitForEntryReadCallback(entry, completer, cancelable));
                this.backgroundKeyGenerator.reportInvalidKey();
                cancelable.asyncTask = null;                
              }
              else
              {
                var code = message.reason[1] !== null ? message.reason[1] : message.reason[0];
                completer.fail(code, entry.filename);
              }
              break;
          }
        }, this));
        
        job.postMessage({ entry: entry, options: options });
      }
    },
    _onPoolInitialized : function ()
    {
      this._initFuture = null;
    },
    _toAbsoluteUrl: function(url)
    {
      var resultUrl = null;
      if (url[0] === "/")
      {
        // url is absolute
        resultUrl = url;
      }
      else
      {
        var globalURL =global.location.pathname;

        //url is relative, so we make that absolute
        var urlSplitted = globalURL.split("/");
        urlSplitted[urlSplitted.length-1] = url;
          
        url  = urlSplitted.join("/");
      }

      return url;
    }
  };

  var KCMD_INIT = 1;
  var KCMD_GEN_KEYS = 2;
  var KCMD_FINISHED = 3;
  var KCMD_PWD_VERIFY_AND_DERIVE_KEYS = 4;
  var KCMD_PWD_VERIFICATION_FAILED = 5;
  var KCMD_PRIORITIZE = 6;
  var KCMD_LOG_DEBUG = 7;

  var ST_WAIT_FOR_PASSWORD = 0;
  var ST_WAIT_FOR_KEYS = 1;
  var ST_DONE = 2;
  
  function BackgroundKeyGenerator(passwordProvider, entries, globalFlags)
  {
    var worker = this.worker = new Worker(utils.Pool.workerPath("g4s-aes-key-worker.js"));
    worker.onmessage = _.bind(this._onMessage, this);
    worker.onerror = _.bind(this._onError, this);
    worker.postMessage({ cmd: KCMD_INIT, data: { entries: entries, globalFlags: globalFlags } });

    this._state = ST_WAIT_FOR_PASSWORD;
    this._passwordProvider = passwordProvider;
    passwordProvider.requestNewPassword(_.bind(this.verifyPassword, this));

    this._keyRequests = {};
    this._indexedEntries = io.indexEntries(entries);
  }

  BackgroundKeyGenerator.prototype =
  {
    destroy: function()
    {
      this.worker.terminate();
      this.worker = null;
    },
    verifyPassword : function(password)
    {
      if (this._state === ST_WAIT_FOR_PASSWORD)
      {
        this.worker.postMessage({ cmd: KCMD_PWD_VERIFY_AND_DERIVE_KEYS, data: password });
        this._state = ST_WAIT_FOR_KEYS;
      }
      else
      {
        throw new Error("[BackgroundKeyGenerator] Invalid state: "+ this._state);
      }
    },
    prioritizeEntry : function(entryName)
    {
      this.worker.postMessage({ cmd: KCMD_PRIORITIZE, data: entryName });
    },
    reportInvalidKey : function()
    {
      if (this._state !== ST_WAIT_FOR_PASSWORD)
      {
        this._state = ST_WAIT_FOR_PASSWORD;
        this._passwordProvider.requestNewPassword(_.bind(this.verifyPassword, this));
      }
    },
    _onError : function(event)
    {
      this._passwordProvider.reportKeyDerivationError(event.message + " (" + event.filename + ":" + event.lineno + ")");
    },
    _onMessage : function(event)
    {
      var msg = event.data;
      var cmd = msg.cmd;
      var data = msg.data;

      switch (cmd)
      {
        case KCMD_GEN_KEYS:
          this.onKeysGenerated(data);
          break;
        case KCMD_PWD_VERIFICATION_FAILED:
          this._state = ST_WAIT_FOR_PASSWORD;

          if (data && data.invalidPassword)
          {
            log.warn("[BackgroundKeyGenerator] password verification has failed [invalid password]");
            this._passwordProvider.requestNewPassword(_.bind(this.verifyPassword, this));
          }
          else
          {
            log.error("[BackgroundKeyGenerator] password verification has failed [" + data + "]");
            this._passwordProvider.reportKeyDerivationError(data);
          }         
          break;
        case KCMD_LOG_DEBUG:
          log.debug("[BackgroundKeyGenerator worker] " + data);
          break;
        case KCMD_FINISHED:
          this._state = ST_DONE;
          log.debug("[BackgroundKeyGenerator] key derivation has finished")
          break;
      };
    },
    waitForKey : function(entry, callback)
    {
       var filename = entry.filename;
//
      this.prioritizeEntry(filename);
      if (!(filename in this._keyRequests))
      {
        this._keyRequests[filename] = [];
      }
      this._keyRequests[filename].push(callback);
    },
    onKeysGenerated : function(entriesWithKeys)
    {
//
      for (var i = 0, len = entriesWithKeys.length; i < len;++i)
      {
         var updatedEntry = entriesWithKeys[i]         
        var localEntry = this._indexedEntries[updatedEntry.filename];

        localEntry.aesPV = updatedEntry.aesPV;
        localEntry.aesDerivedKey = updatedEntry.aesDerivedKey;
        localEntry.hmacKey = updatedEntry.hmacKey;
        
        this._finishKeyRequests(localEntry);
      }
    },
    _finishKeyRequests : function(localEntry)
    {
      var requests = this._keyRequests[localEntry.filename];
      for(var i = 0, len= requests ? requests.length : 0; i < len; ++i)
      {
        requests[i]();
      }        
    }
  };

//
}
(
vitrium.io.package,
vitrium.io,
vitrium.utils,
vitrium.async,
vitrium.log,
vitrium.bin,
_,
__globals__));

// script:viewer/io/file-system/package-fs-direct-backend.js
/// <reference path="~/build.html" />

(function (exports, io, utils, async, log, bin, g4s, _, global)
{
  "use strict";

  exports.DirectBackend = DirectBackend;
  /**
  This backend is used when webworkers are not available (MSIE9)
  */

  function DirectBackend(passwordProvider)
  {
    this._passwordProvider = passwordProvider;
    // allows two requests at the time
    this._scheduler = new bin.IOScheduler(2);
    this._remoteFile = null;
    this._entriesReader = null;
    this._keyDerivationExecutor = null;
    this._fileSystemInfo = null;

    
  }

  DirectBackend.prototype = {
    destroy : function()
    {
      if (this._keyDerivationExecutor) this._keyDerivationExecutor.destroy();
    },
    init : function(fileSystemInfo, entriesReader)
    {
      this._entriesReader = entriesReader;
      if ((fileSystemInfo.globalFlags & (1|2)) !== 0)
      {
        this._keyDerivationExecutor = new KeyDerivationExecutor(this._passwordProvider, fileSystemInfo.entries, fileSystemInfo.globalFlags);
      }
      this._fileSystemInfo = fileSystemInfo;
    },
    createRemoteFileInstanceForURL: function (url)
    {
      return (this._remoteFile = new bin.RemoteFile(url, this._scheduler));
    },
    createRemoteFileInstanceForFileSystemInfo: function (fileSystemInfo)
    {
      var file = new bin.RemoteFile(fileSystemInfo.url, this._scheduler);
      file.etag = fileSystemInfo.etag;
      file.size = fileSystemInfo.size;

      this._remoteFile = file;
      return this._remoteFile;
    },
    read : function(entry, options)
    {
      var cancelable = new async.Cancelable();
      var completer = new async.Completer(cancelable.cancelCallback);
      var self = this;
      if ((entry.flags & (2|4)) && entry.aesDerivedKey === null)
      {
        this._deriveAesKeyThenRead(entry, options, completer, cancelable, false);
      }
      else
      {
        this._doRead(entry, options, completer, cancelable);
      }

      return completer.future;
    },
    _deriveAesKeyThenRead : function(entry, options, completer, cancelable, prepend)
    {
      this._keyDerivationExecutor.waitForKey(entry, cancelable, _.bind(function () { this._doRead(entry, options, completer, cancelable); }, this), prepend);
    },
    _doRead : function(entry, options, completer, cancelable)
    {
      var ddSupport = false;
      if (this._fileSystemInfo.format === "g4s" && !(entry.flags & (2 | 4)))
      {
        // direct decode is posible to enable only when content is not encrypted
        ddSupport = this._fileSystemInfo.ddSupport;
      }

      var DecoderClass = bin.Utf8Decoder;
      if (ddSupport)
      {
        DecoderClass = function ()
        {
          this.init = function (call) { call(); };
        };
      }

      if (options && options.type === "BinaryImage")
      {
        DecoderClass = bin.Base64BinaryImageDecoder;
        ddSupport = false; // I need binary data
      }
      var self = this;
      var abortFunction = this._entriesReader.readEntry(this._remoteFile, entry, {
        ddSupport: ddSupport,
        writer: new DecoderClass(entry.uncompressedSize, entry),
        onerror: function (msg, reason)
        {
          if (msg === "Wrong password.")
          {
            cancelable.asyncTask = null;
            entry.aesDerivedKey = null;
            //reset the original password
            self._keyDerivationExecutor.reportWrongKey();
            self._deriveAesKeyThenRead(entry, options, completer, cancelable, true);
          }
          else
          {
            if (self._keyDerivationExecutor !== null) self._keyDerivationExecutor.scheduleNextStep();
            completer.fail(typeof reason === "undefined" ? msg : reason , entry.filename);
          }
        },
        onend: function (data)
        {
          if (self._keyDerivationExecutor !== null) self._keyDerivationExecutor.scheduleNextStep();

          completer.complete(data, entry.filename);
          
        }
      });

      cancelable.asyncTask = { cancel: abortFunction };
    }
  };

  function KeyDerivationExecutor(passwordProvider, entries, globalFlags)
  {
    this._queue = [];
    this._passwordProvider = passwordProvider;
    this._keyDerivation = new g4s.SinglePasswordKeyDerivation(entries, globalFlags);
    this._scheduledStep = null;
    this._passwordRequested = false;
    this.step = _.bind(this._step, this);
  }

  KeyDerivationExecutor.prototype = {
    destroy : function()
    {
      this._step = null;
      this._queue = null;
      clearTimeout(this._scheduledStep);
      this._scheduledStep = null;

      
      this._keyDerivation.setPassword(null);
    },
    waitForKey: function (entry, cancelable, callback, prepend)
    {
      if (prepend)
      {
        this._queue.unshift({ entry: entry, cancelable: cancelable, callback: callback });
      }
      else
      {
        this._queue.push({ entry: entry, cancelable: cancelable, callback: callback });
      }
      
      this.scheduleNextStep();
    },
    _step : function()
    {
      var task = this._queue.shift();
      if (task && !task.cancelable.canceled)
      {
        log.debug("[KeyDerivationExecutor] deriving key for " + task.entry.filename);
        if (this._keyDerivation.deriveKeyForEntry(task.entry))
        {
          task.callback();

          if (this._keyDerivation.singleKey)
          {
            for (var i = 0, len = this._queue.length; i < len; ++i)
            {
              task = this._queue[i];
              if (!task.cancelable.canceled) task.callback();
            }
            this._queue = [];
          }
        }
        else
        {
          this._queue.unshift(task);
          this.reportWrongKey();
        }
      }
      else if (this._queue.length > 0)
      {
        // let's pick another one
        this._step();
      }
      this._scheduledStep = null;

      // I do not schedule next step at the end of this function. I wait when data from this entry are decrypted.
    },
    scheduleNextStep : function()
    {
      if (this._scheduledStep === null && !this._passwordRequested && this._queue.length > 0)
      {
        this._scheduledStep = setTimeout(this.step, 0);
      }

    },
    _onPasswordResponse : function(password)
    {
      this._passwordRequested = false;
      this._keyDerivation.setPassword(password);
      this.scheduleNextStep();
    },
    reportWrongKey : function()
    {
      if (!this._passwordRequested)
      {
        this._passwordRequested = true;
        clearTimeout(this._scheduledStep);
        this._scheduledStep = null;

        this._passwordProvider.requestNewPassword(_.bind(this._onPasswordResponse, this));
      }      
    }
  };
}
(
vitrium.io.package,
vitrium.io,
vitrium.utils,
vitrium.async,
vitrium.log,
vitrium.bin,
vitrium.g4s,
_,
__globals__));

// script:viewer/io/file-system/cachable-file-system.js
/// <reference path="~/build.html" />

(function (exports, io, async, log, _)
{
  "use strict";

  exports.CachableFileSystem = CachableFileSystem;

  var ST_FRESH = 0;
  var ST_INITIALIZING = 1;
  var ST_INITIALIZED = 2;
  var ST_DESTROYED = 3;

  function CachableFileSystem(fileSystemContext)
  {
    this.context = fileSystemContext;
    this.cacheFileSystem = fileSystemContext.cacheFileSystem || new io.LocalCacheFS(fileSystemContext);
    this.remoteFileSystem = fileSystemContext.remoteFileSystem || new io.PackageFS(fileSystemContext);

    this._state = ST_FRESH;
    this._doRead = null;
    this._initFuture = null;

    this._entries = null;
    this._paths = null;  
  }

  CachableFileSystem.prototype =
  {
    get entries()
    {
      if (this._state === ST_INITIALIZED)
      {
        return this._entries;
      }
      throw new Error("[CachableFileSystem] must be initialized");
    },
    get initialized()
    {
       return this._state === ST_INITIALIZED;
    },
    init : function()
    {
      var self = this;
      var asyncs = [];
      var remoteFailed = false;
      var cacheFailed = false;
      var cacheErrorDetails = null;
      var remoteErrorDetails = null;

      var completer = new async.Completer(function(){
        _.each(asyncs, function(a){a.cancel();});
        self._state = ST_FRESH;
      });

      if (this._state === ST_FRESH)
      {
        this._state = ST_INITIALIZING;
        var cacheInitFuture = _async(this.cacheFileSystem.init());
        var remoteFileSystemFuture = _async(this.remoteFileSystem.init());
        var cacheLoadFileSystemInfoFuture = null;
        var remoteFileSystemInfoFuture = null;
        
        var cacheInitialized = false;
        var initCompleted = false;
        cacheInitFuture.catchError(_cacheError).then(function ()
        {
          log.debug("[CachableFileSystem] cache intitialized");
          cacheInitialized = true;
        });
        
        remoteFileSystemFuture.then(function (tagVersion)
        {
           log.debug("[CachableFileSystem] remote file system intitialized tag="+tagVersion);
          cacheInitFuture.runWhenSucceed(function ()
          {
             if (self.cacheFileSystem.verifyCache(tagVersion)) {
                log.debug("[CachableFileSystem] cache is valid for tag=" + tagVersion);

                // entries and file info are already loaded by remoteFileSystem
                if (initCompleted) return;

                cacheLoadFileSystemInfoFuture = _async(self.cacheFileSystem.loadFileSystemInfo()).then(function _onCacheFileSystemInfoLoaded(fileSystemInfo) {
                   if (remoteFileSystemInfoFuture !== null) remoteFileSystemInfoFuture.cancel();
                   // attach entries and other info from cache
                   self.remoteFileSystem.attachFileSystemInfo(fileSystemInfo);
                   log.debug("[CachableFileSystem] remote file system info attached");
                   _async(self.cacheFileSystem.list()).then(_entriesListed).catchError(_cacheError);
                })
                .catchError(_cacheError);
             }
             else {
                log.debug("[CachableFileSystem] cache is not valid for tag=" + tagVersion);
             }
          });

          remoteFileSystemInfoFuture = _async(self.remoteFileSystem.loadFileSystemInfo()).then(function (fileSystemInfo)
          {
            log.debug("[CachableFileSystem] remote file system info loaded");
             
            if (cacheLoadFileSystemInfoFuture !== null) cacheLoadFileSystemInfoFuture.cancel();
            cacheInitFuture.runWhenSucceed(function ()
            {
               self.cacheFileSystem.attachFileSystemInfo(fileSystemInfo);
               log.debug("[CachableFileSystem] cache file system info attached");
            });

            _async(self.remoteFileSystem.list()).then(_entriesListed).catchError(_remoteError);
          })
          .catchError(_remoteError);

        })
        .catchError(_remoteError)
        .catchError(function()
        {
           log.debug("[CachableFileSystem] intializing fallback caching");
          // unable to reach the remote resource
          cacheInitFuture.runWhenSucceed(function ()
          {
            cacheLoadFileSystemInfoFuture = _async(self.cacheFileSystem.loadFileSystemInfo()).then(function _onCacheFileSystemInfoLoaded(fileSystemInfo)
            {
              // attach entries and other info from cache
               self.remoteFileSystem.attachFileSystemInfo(fileSystemInfo);
               log.debug("[CachableFileSystem] remote file system info attached");

              _async(self.cacheFileSystem.list()).then(_entriesListed).catchError(_cacheError);
            }).catchError(_cacheError);
          });
        });
                
        this._initFuture = completer.future;
        return completer.future;
      }
      else
      {
        throw new Error("[CachableFileSystem] is not fresh!");
      }

      function _async(task)
      {
        // this function adds task to cancelable 
        asyncs.push(task);
        return task;
      }

      function _remoteError(e)
      {
        log.error("[CachableFileSystem] unable to initialize remote file system ("+e+")");
        remoteFailed = true;
        if (e) remoteErrorDetails = e;
        _failIfErrors();
      }

      function _cacheError(e)
      {
        log.error("[CachableFileSystem] unable to initialize cache("+e+")");
        cacheFailed = true;
        if (e)  cacheErrorDetails = e;
        _failIfErrors();
      }

      function _failIfErrors()
      {
        if (remoteFailed && cacheFailed)
        {
          self.trigger("fileSystem:error", "init", remoteErrorDetails, cacheErrorDetails);
          completer.fail(remoteErrorDetails, cacheErrorDetails);
          self._state = ST_FRESH;
          self._initFuture = null;
        }
      }

      function _entriesListed(entries)
      {
        if (cacheFailed || !cacheInitialized)
        {
           self._doRead = self._doReadRemoteOnly;
           log.debug("[CachableFileSystem] remote reading strategy used");
        }
        else
        {
           self._doRead = self._doReadCacheFirst;
           log.debug("[CachableFileSystem] cache first reading strategy used");
        }

        if (!cacheInitialized && !cacheFailed)
        {
           log.debug("[CachableFileSystem] cache intialization is slower than remote response");

          // remoteFS has been faster, it is posible that database is just slower
          // or it can fail later
          cacheInitFuture.then(function ()
          {
             log.debug("[CachableFileSystem] switched cache first reading strategy used");
             self._doRead = self._doReadCacheFirst;
          });
        }

        self._entries = entries;
        self._paths = _.pluck(entries, "filename");
        self._state = ST_INITIALIZED;
        self._initFuture = null;
        initCompleted = true;
        completer.complete();

        self.trigger("file-system-initialized");
        log.debug("[CachableFileSystem] ST_INITIALIZED");
      }
    },
    destroy : function()
    {
      this._entries = null;
      if (this._initFuture !== null) this._initFuture.cancel();
      this._initFuture = null;
      this.remoteFileSystem.destroy();
      this.cacheFileSystem.destroy();
      this._state = ST_DESTROYED;
    },
    trigger: function ()
    {
      if ("trigger" in this.context)
      {
        this.context.trigger.apply(this.context, arguments);
      }
    },
    _checkInitialized : function()
    {
      if (this._state !== ST_INITIALIZED) throw new Error("[CachableFileSystem] is not initialized");
    },
    read : function(path, options)
    {
      this._checkInitialized();
      if (this._paths.indexOf(path) === -1)
      {
        var completer = new async.Completer();
        async.asyncError(completer, 1404);
        return completer.future;
      }
      else
      {
        return this._doRead(path, options ? options : null);
      }
    },
    list : function()
    {
      this._checkInitialized();
      var completer = new async.Completer();
      async.asyncSuccess(completer, _.clone(this._entries));
      return completer.future;
    },
    listPaths : function()
    {
      this._checkInitialized();
      var completer = new async.Completer();
      async.asyncSuccess(completer, _.clone(this._paths));
      return completer.future;
    },
    checkForChanges : function()
    {
      this.remoteFileSystem.checkForChanges();
    },
    _doReadRemoteOnly : function(path, options)
    {
      return this.remoteFileSystem.read(path, options);
    },
    _doReadCacheFirst : function(path, options)
    {
      var cancelable = new async.Cancelable();
      var completer = new async.Completer(cancelable.cancelCallback);

      cancelable.asyncTask = this.cacheFileSystem.read(path, options)
          .then(_.bind(function ()
          {
            this.remoteFileSystem.checkForChanges();
          }, this))
          .catchError(_.bind(function ()
          {
            cancelable.asyncTask = this.remoteFileSystem.read(path, options)
              .then(_.bind(function (data)
              {
                this.cacheFileSystem.cacheFile(path, options, data);
              }, this))
                .chainSuccess(completer)
                .chainError(completer);
            }, this))
      .chainSuccess(completer);
      
      
      return completer.future;
    }
  };



}
(vitrium.io,
vitrium.io,
 vitrium.async,
 vitrium.log,
 _
));

// script:viewer/io/file-system/cachable-file-system-context.js
/// <reference path="~/build.html" />

(function (exports, io, async, Backbone, _)
{
  "use strict";

  exports.CachableFileSystemContext = CachableFileSystemContext;


  function CachableFileSystemContext(url)
  {
    this.url = url;
    this.cacheEnabled = true;
    this.offlineStorage = true;
    this.encryptionKey = null;

    this.cacheFileSystem = new io.LocalCacheFS(this);
    this.passwordProvider = null;
  }
  CachableFileSystemContext.getCacheManager = function ()
  {
    return CachableFileSystemContext.prototype.cacheManager;
  };

  CachableFileSystemContext.prototype = {
    cacheManager: new io.CacheManager(),
    destroy : function()
    {
      // break cycles
      this.cacheFileSystem = null;
    },
    tryToGetDownloaded : function()
    {
      return this.cacheFileSystem.tryToGetDownloadedState() === io.CACHE_STATE.DOWNLOADED;
    },
    openStorage : function()
    {
       var completer = new async.Completer();
       this.cacheManager.openCache(this.url, function (cache) {
          completer.complete(cache);
       }, function (e) {
          completer.fail(e);
       });

       return completer.future;
    }
  };
  _.extend(CachableFileSystemContext.prototype, Backbone.Events);
  



}
(vitrium.io,
 vitrium.io,
 vitrium.async,
 Backbone,
 _
));

// script:viewer/io/binary-image-decoder.js
(function (exports, log, _, global) 
{
	"use strict";

	_.extend(exports, {
		Base64BinaryImageDecoder :  Base64BinaryImageDecoder,
		ChunkBuffer: ChunkBuffer
	});
	
	
	//
	function ChunkBuffer() {		
		this.tmp_arr = null; 
	}
	
	var CB = ChunkBuffer.prototype;
	CB.init = function(callback) 
	{
		this.tmp_arr = [];
		callback();
	};
	
	CB.writeUint8Array = function(arrays, callback) 
	{
		for (var i = 0, len = arrays.length; i < len; ++i)
		{
			this.tmp_arr.push(arrays[i]);	
		}
		
		callback();
	};
	
	CB.getData = function(callback, onerror) 
	{	
		callback(this.tmp_arr);
	};
	
	
	var LOOKUP_TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("");
	function Base64BinaryImageDecoder(len, entry) {		
		this.tmp_arr = null; 
		this.len = len;
		this.o1 = this.o2 = this.o3 = this.ac = this.pos = 0;
		this.userData = entry.userData;
	}

	var UDP = Base64BinaryImageDecoder.prototype;
		UDP.init = function(callback) 
		{
			this.tmp_arr = new Array(this.len);
			callback();
		};
		
		UDP.free = function()
		{
			this.tmp_arr = null;
		};
		
		UDP.writeUint8Array = function(arrays, callback) 
		{
			if (this.tmp_arr === null) {	return;	}
		
			for (var i = 0, len = arrays.length; i < len; ++i)
			{
					this.addToBase64(arrays[i]);
			}
		
			callback();
		};
		
		UDP.getData = function(callback, onerror) 
		{	
			var b64 = LOOKUP_TABLE;
			var step = this.pos % 3;
			var tmp_arr = this.tmp_arr;
			if (step !== 0)
			{
				var o1 = this.o1, o2 = this.o2, o3 = this.o3;
				switch(step)
				{
					case 1: 
						o2 = 0;
					case 2:
						o3 = 0;
					break;			
				}
				
				var bits =  o1 << 16 | o2 << 8 | o3;
				var h1 = bits >> 18 & 0x3f;
				var h2 = bits >> 12 & 0x3f;
				var h3 = bits >> 6 & 0x3f;
				var h4 = bits & 0x3f;
				
				switch(step)
				{
					case 1: 
						h3 = h4 = 64;
					case 2:
						h4 = 64;
					break;			
				}
				
				var ac = this.ac;
				tmp_arr[ac] = b64[h1] + b64[h2] + b64[h3] + b64[h4];
			}
		
			
			var userData = this.userData;
			callback([{ 
				key : userData.key,
				data : "data:"+userData.mimetype+";base64,"+tmp_arr.join(''), 
				level : 0,
				dpi : userData.dpi
			}]);
		};
		
		UDP.addToBase64 = function(array) {
			var b64 = LOOKUP_TABLE;
			var o1 = this.o1,
			o2 = this.o2, 
			o3 = this.o3, 
			ac = this.ac,
			pos = this.pos;
			
			var tmp_arr = this.tmp_arr;
			var len = array.length;
	
			var h1 = 0,
			h2 = 0,
			h3 = 0,
			h4 = 0,
			bits = 0; 
		
			if (array.readNumber)
			{
				
				for (var i = 0; i < len; ++i) 
				{	
					var step = (pos + i + 1) % 3;
					var b = array.readNumber(1, i);
					switch (step)
					{
						case 1:
							o1 =  b;
						break;
						case 2: 
							o2 =  b;
						break;
						case 0:
							o3 = b;
							
							bits =  o1 << 16 | o2 << 8 | o3;
							
							h1 = bits >> 18 & 0x3f;
							h2 = bits >> 12 & 0x3f;
							h3 = bits >> 6 & 0x3f;
							h4 = bits & 0x3f;
							
							tmp_arr[ac++] = b64[h1] + b64[h2] + b64[h3] + b64[h4];
						break;						
					}	
				}	
			}
			else
			{	
				for (var i = 0; i < len; ++i) 
				{	
					var step = (pos + i + 1) % 3;
					var b = array[i];
					switch (step)
					{
						case 1:
							o1 =  b;
						break;
						case 2: 
							o2 =  b;
						break;
						case 0:
							o3 = b;
							
							bits =  o1 << 16 | o2 << 8 | o3;
							
							h1 = bits >> 18 & 0x3f;
							h2 = bits >> 12 & 0x3f;
							h3 = bits >> 6 & 0x3f;
							h4 = bits & 0x3f;
							
							tmp_arr[ac++] = b64[h1] + b64[h2] + b64[h3] + b64[h4];
						break;						
					}	
				}	
			}
		
		this.pos = pos + len;
		this.ac = ac;
		this.o1 = o1;
		this.o2 = o2;
		this.o3 = o3;
	};
	
	
	
}(
vitrium.bin,
vitrium.log, 
_, 
__globals__
));
// script:viewer/io/image-opacity-mask.js
(function (exports, vitrium, globals)
{
	"use strict";
	
	exports.applyOpacityMask = applyOpacityMask;
	
	function applyOpacityMask(brushImageData, mask)
	{
		var data;
		if (!brushImageData.data)
		{
			data = new Uint8ClampedArray(brushImageData);
		}
		else
		{
			data = brushImageData.data;
		}
		
		var maskData;
		
		if (!mask.data)
		{
			maskData = new Uint8ClampedArray(mask);
		}
		else
		{
			maskData = mask.data;
		}
		
		for (var i = 0, n = data.length, ml= maskData.length; i < n && i < ml; i += 4)
		{
			data[i + 3] = maskData[i+3];
		}
	}
	
	if (vitrium.Task)
	{
	
		var OpacityMaskProcess = function OpacityMaskProcess(brushImageData, mask, callback)
		{	
			vitrium.Task.call(this);
			this.data = brushImageData.data;
			this.maskData = mask.data;
			this.callback = callback;
			
			this.i = 0;
		};
				
		OpacityMaskProcess.prototype = {
			step : function()
			{		
				if (this.parentTask !== null && this.parentTask.interrupted)
				{
					this.done = true;
					this.maskData = null;
					this.data = null;
				//	this.callback(false);
					return;
				}
			
				var beg;
				var i =  beg = this.i,
				maskData = this.maskData,
				data = this.data;
				var l = data.length,
				mL = maskData.length;

				var mLen = this.maskData.length;
				var more;
				
				for (;(more = i < l && i < mL) && (i-beg) < 100000;i+= 4)
				{
					data[i + 3] = maskData[i+3];
				}
				
				this.i = i;
				
				if (!more)
				{
					this.done = true;
					this.maskData = null;
					this.data = null;
					this.callback(data);
				}
			}
		};
		
		exports.OpacityMaskProcess = OpacityMaskProcess;
	}
	
	
}(
vitrium.utils,
vitrium,
__globals__
));
// script:viewer/io/image-async-service-client.js
(function(exports, utils, vitrium, globals, $)
{

	"use strict";
	
	exports["ImageAsyncServiceClient"] = ImageAsyncServiceClient;
	
	var MSG_INIT = 1;
	var MSG_CREATE_BLOB_URL = 2;
	var MSG_CREATE_BLOB_URL_ERROR = 3;
	var MSG_APPLY_OPACITY_MASK = 4;
	var MSG_APPLY_OPACITY_MASK_TRANSFERABLE = 5;
	

	var ST_INITIALIZING = 0;
	var ST_INIT_CANCELED = 1;
	var ST_INITIALIZED = 2;
	
	function ImageAsyncServiceClient()
	{
		this.transferableObjectsSupported = false;
		if (!!globals.Worker)
		{
			this.worker = new globals.Worker(workerPath() + "image-decoder-web-worker.js");
			this.worker.onmessage = _.bind(this.onmessage, this);
			this.worker.postMessage({ cmd : MSG_INIT });
			this.worker.postMessage = this.worker.webkitPostMessage || this.worker.postMessage;
			
			
			try
			{
				var ab = new ArrayBuffer(1);
				this.worker.postMessage({ cmd : -1, array:ab}, [ab]);
				if (ab.byteLength === 0 && $.browser.chrome){
					this.transferableObjectsSupported = true;
				}
			} catch(e){};
			
			this.requests = [];
			this.state = ST_INITIALIZING;
		}
		else
		{
			this.state = ST_INIT_CANCELED;
		}
		
		this.blobLevel = 0;
	};
	var globalInstance = null;
	ImageAsyncServiceClient.getInstance = function()
	{
		if (globalInstance !== null) return globalInstance;
		globalInstance = new ImageAsyncServiceClient();
		
		return globalInstance;
	};
	
	ImageAsyncServiceClient.prototype =  {
		onmessage : function(evt)
		{
			var msg = evt.data;
			if (msg.cmd === MSG_INIT)
			{
				this.blobLevel = msg.blobLevel;
			
				this.onInit();
				
			}
			else if (msg.cmd === MSG_CREATE_BLOB_URL)
			{
				var req = this.requests.shift();
				req.callback(msg.blobURL, true);
			}
			else if (msg.cmd === MSG_APPLY_OPACITY_MASK)
			{
				var req = this.requests.shift();
				var context = req.context;
				context.putImageData(msg.brushImageData, 0, 0);
				req.callback(context);
			}
			else if (msg.cmd === MSG_APPLY_OPACITY_MASK_TRANSFERABLE)
			{
				var req = this.requests.shift();
				var context = req.context;
				req.brushImageData.data.buffer = msg.brushImageData;
				context.putImageData(req.brushImageData, 0, 0);
				req.callback(context);
			}
			else if (msg.cmd === -1)
			{}
			else
			{
				vitrium.log.error("Unable to create blob URL:"+msg.msg);

				// falling back to dataURL
				var req = this.requests.shift();
				req.callback(req.dataURL, false);
			}
		},
		decode : function(dataURL, callback)
		{
			switch(this.state)
			{
				case ST_INITIALIZED:
					if (this.blobLevel === 0)
					{
						setTimeout(callback(dataURL, false), 0);
					}
					else
					{
						setTimeout(function(){callback(dataURL, false);}, 0);
						//this.requests.push({dataURL : dataURL, callback : callback});
						//this.worker.postMessage({ cmd : MSG_CREATE_BLOB_URL, dataURL : dataURL});
					}
				break;
				case ST_INITIALIZING:
					this.requests.push({cmd : MSG_CREATE_BLOB_URL, dataURL : dataURL, callback : callback});
				break;
				default:
					setTimeout(function(){callback(dataURL, false);}, 0);
				break;
			}	
		},
		applyOpacityMask : function(context , maskCtx, callback)
		{	/*	
			switch(this.state)
			{
				case ST_INITIALIZED:
					var maskCanvas = maskCtx.canvas;
					var maskImageData = maskCtx.getImageData(0,0,maskCanvas.width, maskCanvas.height);
					var canvas = context.canvas;
					var brushImageData = context.getImageData(0,0,canvas.width, canvas.height);
					
					this.requests.push({context : context, callback : callback, brushImageData: brushImageData});
					
					if (this.transferableObjectsSupported)
					{
						this.worker.postMessage({ cmd : MSG_APPLY_OPACITY_MASK_TRANSFERABLE, maskImageData : maskImageData.data.buffer, brushImageData:brushImageData.data.buffer}, [maskImageData.data.buffer,brushImageData.data.buffer] );
					}
					else
					{
						this.worker.postMessage({ cmd : MSG_APPLY_OPACITY_MASK, maskImageData : maskImageData, brushImageData:brushImageData});
					}
				break;
				case ST_INITIALIZING:
					this.requests.push({cmd : MSG_APPLY_OPACITY_MASK, context : context, maskCtx : maskCtx, callback : callback});
				break;
				default:
					setTimeout(function(){
						var maskCanvas = maskCtx.canvas;
						var maskImageData = maskCtx.getImageData(0,0,maskCanvas.width, maskCanvas.height);
						var canvas = context.canvas;
						var brushImageData = context.getImageData(0,0,canvas.width, canvas.height);
						
						utils.applyOpacityMask(brushImageData, maskImageData);
						context.putImageData(brushImageData, 0, 0);
						callback(context);
					}, 0);
				break;}*/
				
				setTimeout(function(){
						var maskCanvas = maskCtx.canvas;
						var maskImageData = maskCtx.getImageData(0,0,maskCanvas.width, maskCanvas.height);
						var canvas = context.canvas;
						var brushImageData = context.getImageData(0,0,canvas.width, canvas.height);
						
						utils.applyOpacityMask(brushImageData, maskImageData);
						context.putImageData(brushImageData, 0, 0);
						callback(context);
					}, 0);
				
		},
		onInit : function()
		{
			this.state = ST_INITIALIZED;
			var requests =this.requests.splice(0);
			for (var i = 0, len=requests.length; i < len; ++i)
			{
				var req = requests[i];
				if (req.msg === MSG_CREATE_BLOB_URL)
				{
					this.decode(req.dataURL, req.callback);
				}
				else if (req.msg === MSG_APPLY_OPACITY_MASK)
				{
					this.applyOpacityMask(req.context, req.maskCtx, req.callback);
				}
			}
		},
		destroy : function()
		{
			if (this.state ===  ST_INITIALIZING)
			{
				this.state = ST_INIT_CANCELED;
			}
			
			this.requests = null;
			this.worker.terminate();
		}
	};
	
	
	function workerPath()
	{		
		var path = globals.ZIP_WORKER_PATH;
		if (!path)
		{
			path = vitrium.base_path;
		}
		
		return path;	
	}

}(
vitrium.viewer,
vitrium.utils, 
vitrium, 
__globals__,
jQuery
));

// script:viewer/io/image-decoder.js
(function (exports,bin,vitrium,log, _) 
{
	"use strict";
   
	exports.DataImageDecoder = DataImageDecoder;

  function strStartsWith(str, starts)
  {
    return str.length >= starts.length && str.slice(0, starts.length) === starts;
  }
	
	function DataImageDecoder(provider)
	{
		this.imageIndex = provider.imageIndex;
		//this.decoder = exports.ImageAsyncServiceClient.getInstance();
	}
	
	DataImageDecoder.prototype = { 
		getParser : function()
		{
			return _.bind(this.parse, this);
		},
		parse : function(data, callback, errorcallback)
		{
			var images = null;
			if (_.isString(data))
			{
				 images = JSON.parse(data);
			}
			else
			{
				images = data;
			}
			
			if (_.isArray(images))
			{
				
				
				var i;
				var len = images.length;
				var imageIndex = this.imageIndex;
				var remain = len;
				var result = [];
				var onload = function()
				{
					var obj = this.metadata;
					imageIndex.indexObject(obj);
					
					result.push(obj);
					
          // remove circular reference
					this.metadata.data = null;
					this.onload = null;
					this.onerror = null;
					--remain;
					
					if (remain === 0)
					{
						callback(result);
					}
				};
				
				var onerror = function()
				{
					this.metadata = null;
					this.onload = null;
					this.onerror = null;
					this.metadata = null;
					--remain;
					if (remain === 0)
					{
						callback(result);
					}
				};
					
					
				var URL = vitrium.features.Blob.URL;
				for (i = 0; i < len; ++i)
				{
					var img = images[i];
					var image = new Image();
					var level = img.level;
					if (!level)
					{
						level = 0;
					}

					image.onload = onload;
					image.onerror = onerror;
										
					var url = img.data;
					if (url === null)
					{
						image.onerror();
					}
					else 
					{
          
						if (level === 1)
						{
							url = URL.createObjectURL(url);
						}
            		
            image.metadata = { 
                                                  key : img.key, 
                                                  data : image, 
                                                  level : level , 
                                                  vDPI : img.vDpi ? img.vDpi : 96, 
                                                  hDPI : img.hDpi ? img.hDpi : 96          
                                                };
            image.src = url;
          }
				}		
			}
			else
			{
				errorcallback("invalid Images file");
			}
		}/*,
		decode : function(url, img, image)
		{
			this.decoder.decode(url, function(convertedURL, isBlobURL)
			{
				image.metadata.level = isBlobURL ? 2 : 0;
				image.src = convertedURL;
			});
		}*/
	};
}(
vitrium.viewer,
vitrium.bin, 
vitrium, 
vitrium.log, 
_));
// script:viewer/vitrium-document-package-format-manager.js
(function (exports, async, vitrium, zip, _, $, global)
{
  "use strict";

  exports.VitriumDocumentPackageFormatManager = VitriumDocumentPackageFormatManager;
  function VitriumDocumentPackageFormatManager(fileSystem, fontsManager)
  {
     this.fileSytem = fileSystem;
     this.fontsManager = fontsManager;
    //this.remoteFile = new vitrium.bin.RemoteFile(this.url, new vitrium.bin.IOScheduler(5));
    this.imageIndex = new Index();
    this.resourceIndex = new Index();

    this.fileIndex = null;
    this.relIndex = null;
    this.pages = null;

    this.imageFileFreedCallback = _.bind(onImageFileFreed, this);
    this.onMandatoryPageFilesLoaded = _.bind(onMandatoryPageFilesLoaded, this);
    this.onMandatoryPageFilesLoadFailed = _.bind(onMandatoryPageFilesLoadFailed, this);
    this.onPageImageFilesLoaded = _.bind(onPageImageFilesLoaded, this);
    //this.onDocumentFullyDownloaded = _.bind(onDocumentFullyDownloaded, this);
  }

  VitriumDocumentPackageFormatManager.prototype = {
    destroy : function()
    {
      var p = this.pages;
      for (var i = 0, len = p ? p.length : 0	; i < len; ++i)
      {
        if (p[i].state !== 0)
        {
          this.freePage(i);
        }
      }

      this.imageIndex = null;
      this.resourceIndex = null;

      this.fileIndex = null;
      this.relIndex = null;
      this.pages = null;

      this.imageFileFreedCallback = null;
      this.onMandatoryPageFilesLoaded = null;
      this.onMandatoryPageFilesLoadFailed = null;
      this.onPageImageFilesLoaded = null;
      this.fileSytem = null;
    },
    loadInfo: function ()
    {
      var cancelable = new async.Cancelable();
      var completer = new async.Completer(cancelable.cancelCallback);
      var self = this;
      
      cancelable.asyncTask = this.fileSytem.listPaths().then(function (paths)
      {
        if (paths.indexOf("index.js") === -1)
        {
          completer.fail("index.js file not found, invalid document format");
        }
        else 
        {
          var index = self.fileIndex = new FileIndex(self.fileSytem);
          for (var i = 0, len = paths.length; i < len; ++i)
          {
            index.index(paths[i]);
          }

          cancelable.asyncTask = self.fileSytem.read("index.js").then(function (data)
          {
            cancelable.asyncTask = null;
            try
            {
              completer.complete(self._processInfo(JSON.parse(data)));
            }
            catch(e)
            {
              completer.fail(e);
            }     
          }).chainError(completer);
        }

      })
      .chainError(completer);

      return completer.future;
    },
    _processInfo : function(info)
    {
      if (info.documentType === "FixedDocument")
      {
        var fIndex = this.fileIndex;
        indexObjects(fIndex, info.objects, this.imageFileFreedCallback);
        
        var relationshipIndex = this.relIndex = new RelationshipsIndex(fIndex);
        indexObjects(relationshipIndex, info.relationships);
        
        var pages = info.pageContentsMetadata;
        var len = pages.length;
        var pmap = this.pages = new Array(len);

        var pagesById = {};

        for (var i = len; i--;)
        {
          var p = pages[i];
          var pn = p.number - 1;
          pagesById[p.pageContentId] = pn;

          pmap[pn] = {
            idx: pn,
            id: p.pageContentId,
            thumbnailKey: p.thumbnailKey,
            req: null,
            dep: null,
            state: 0,
            referencedFiles: null
          };
        }

        var resources = info.contentResourcesMetadata;
        var rIndex = this.resourceIndex;
        if (resources)
        {

          for (var i = resources.length; i--;)
          {
            var r = resources[i];
            rIndex.indexObject({ key: r.key, data: fIndex.get(r.contentResourceId) });
          }
        }

        var linkTargets = info.linkTargets;
        var targetPages = {};
        if (linkTargets)
        {
          var linkTargetsLen = linkTargets.length;

          for (var i = linkTargetsLen; i--;)
          {
            var target = linkTargets[i];
            targetPages[target.name] = pagesById[target.pageContentId];
          }
        }
        return {
          title: info.title,
          author: info.author,
          documentType: info.documentType,
          nonascii: info.nonascii,
          pages: info.pageContentsMetadata,
          linkTargets: targetPages,
          watermarks: info.watermarks || []
        };
      }
      else
      {
        throw new Error("Unsupported document type: " + info.documentType);
      }
    },
    loadPage: function (options)
    {
      var idx = options.idx;
      var pageObject = this.pages[idx];
      if (pageObject)
      {

        if (pageObject.state >= 3)
        {
          options.success(pageObject.idx, pageObject.state, this.fileIndex.get(pageObject.id).data);
        }
        else
        {
          var dep;
          if (!(dep = pageObject.dep))
          {
            dep = pageObject.dep = this.relIndex.get(pageObject.id);
          }
          var request = pageObject.req = new FileRequest({
            success: this.onMandatoryPageFilesLoaded,
            error: this.onMandatoryPageFilesLoadFailed,
            userdata: { pageObject: pageObject, request: new FileRequest(options) }
          });

          pageObject.state = 1;

          var queue = request.files;
          var thumbnails = dep.Thumbnails;
          for (var i = thumbnails.length; i--;)
          {
            var thumb = thumbnails[i];
            queue[thumb] = thumb;
          }

          var ImageDecoder = vitrium.viewer.DataImageDecoder;
          for (var i = thumbnails.length; i--;)
          {
            var thumb = thumbnails[i];
            thumb.parser = new ImageDecoder(this).getParser();
            thumb.request(request);
          }

          if (thumbnails.length === 0)
          {
            //oh no... no thumbnail, just load page content
            onMandatoryPageFilesLoaded.call(this, [], request);
          }

        }
      }
      else
      {
        options.error("index out of bounds");
      }
    },
    freePage: function (idx)
    {
      var pageObject = this.pages[idx];
      if (pageObject && pageObject.state > 0)
      {
        var files = pageObject.referencedFiles;
        if (files) // pageObject.state == 1
        {
          for (var i = files.length; i--;)
          {
            var f = files[i];
            files[i].decRef();
          }
        }

        pageObject.referencedFiles = [];
        pageObject.state = 0;

        if (pageObject.req)
        {
          pageObject.req.abort();
          pageObject.req = null;
        }
      }
    },
    loadDocumentFonts: function (options)
    {
      return this._loadByType("Fonts", options);
    },
    loadDocumentOutline: function (options)
    {
      return this._loadByType("DocumentOutline", options);
    },
    loadTextIndex: function (options)
    {
      var idx = options.idx;
      var pageObject = this.pages[idx];
      if (pageObject)
      {
        var dep = this.relIndex.get(pageObject.id);
        if (_.isEmpty(dep.Text))
        {
          var t = setTimeout(function ()
          {
            options.success("no-text", { userdata: { idx: idx } });
          }, 0);

          return function ()
          {
            clearTimeout(t);
          };

        }
        else
        {
          var textIndexObj = dep.Text[0]; // there is just one text index
          var request = new FileRequest(_.extend({ "userdata": { "idx": idx } }, options));

          textIndexObj.request(request);
          return _.bind(textIndexObj.free, textIndexObj);
        }
      }
      else
      {
        options.error("index out of bounds");
        return null;
      }
    },
    tryGetThumbnail : function(idx)
    {
      var pageObject = this.pages[idx];
      var img = this.imageIndex.get(pageObject.thumbnailKey);

      return img ? img : null;
    },
    getImage : function(key)
    {
      return this.imageIndex ? this.imageIndex.get(key) : null;
    },
    getResource : function(key)
    {
      return this.resourceIndex ? this.resourceIndex.get(key).data : null;
    },
    getNumberOfPages: function()
    {
      return this.pages.length;
    },
    loadFirstPageThumbnail : function()
    {
      var cancelable = new async.Cancelable();
      var completer = new async.Completer(cancelable.cancelCallback);
      var thumb = this.tryGetThumbnail(0);
      if (thumb !== null)
      {
        async.asyncSuccess(completer, thumb.src);
      }
      else
      {
        var pageObject = this.pages[0];
        var dep = this.relIndex.get(pageObject.id);

        if (dep.Thumbnails.length > 0)
        {
          cancelable.asyncTask = this.fileSytem.read(dep.Thumbnails[0].path).then(function (stringData)
          {
            try
            {
              var data = JSON.parse(stringData);
              var thumb = _.find(data, function (thumb)
              {
                return thumb.key === pageObject.thumbnailKey;
              });

              if (thumb)
              {
                completer.complete(thumb.data);
              }
              else
              {
                completer.complete(null);
              }
            }
            catch (e)
            {
              completer.complete(null);
            }
          }).chainError(completer);
        }
        else
        {
          async.asyncSuccess(completer, null);
        }
      }

      return completer.future;
    },
    listFilesForDownload : function()
    {
      var pages = this.pages;
      var result = [];
      if (!pages) return result;

      function addToResult(file) { if (result.indexOf(file.path) === -1) { result.push(file.path); } }

      for (var i = 0, len = pages.length; i < len; ++i)
      {
        var pageObject = pages[i];
        var filePageObject = this.fileIndex.get(pageObject.id);
        result.push(filePageObject.path);

        
        var dep = this.relIndex.get(pageObject.id);
        _.each(dep.Images, addToResult);
        _.each(dep.Thumbnails, addToResult);
        _.each(dep.Fonts, addToResult);
        _.each(dep.ContentResource, addToResult);
        _.each(dep.Text, addToResult);
      }
       
      result.push("index.js");

      return result;
    },
    _loadByType: function (type, options)
    {
      var files = this.fileIndex.getByType(type);
      var request = new FileRequest(options);

      var len = files.length;
      var queue = request.files;
      for (var i = 0; i < len; ++i)
      {
        var ff = files[i];
        queue[ff] = ff;
      }

      for (var i = 0; i < len; ++i)
      {
        var ff = files[i];
        ff.request(request);
      }

      if (len === 0)
      {
        options.complete([], request);
      }

      return request;
    }
  };


  function onMandatoryPageFilesLoaded(files, request)
  {
    incRefFiles(files);
    if (!this.fileIndex) return;

    var userdata = request.userdata;
    var pageObject = userdata.pageObject;

    pageObject.referencedFiles = _.clone(files);

    var state = pageObject.state = 2;
    if (!_.isEmpty(pageObject["thumbnailKey"]))
    {
      userdata.request.success(pageObject.idx, state, this.getImage(pageObject["thumbnailKey"]));
    }

    var imReq = new FileRequest({ success: this.onPageImageFilesLoaded, error: this.onMandatoryPageFilesLoadFailed, userdata: userdata });
    pageObject.req = imReq;
    var queue = imReq.files;

    var filePageObject = this.fileIndex.get(pageObject.id);
    queue[filePageObject] = filePageObject;

    var dep = pageObject.dep;
    var fonts = this.fontsManager.initPageFonts(pageObject.idx, dep.Fonts);
    userdata.fonts = fonts;

    for (var i = fonts.length; i--;)
    {
       var font = fonts[i];
       queue[font] = font;
    }


    var res = dep.ContentResource;
    for (var i = res.length; i--;)
    {
      var f = res[i];
      queue[f] = f;
    }

    var ImageDecoder = vitrium.viewer.DataImageDecoder;

    var imgs = dep.Images;
    for (var i = imgs.length; i--;)
    {
      var img = imgs[i];
      img.parser = new ImageDecoder(this).getParser();
      queue[img] = img;
    }


    var bimgs = pageObject.dep.BinaryImage;
    for (var i = bimgs.length; i--;)
    {
      var img = bimgs[i];
      img.parser = new ImageDecoder(this).getParser();
      queue[img] = img;
    }


     // request queue is ready, just perform all requests

    for (var i = fonts.length; i--;)
    {
       fonts[i].request(imReq);
    } 

    filePageObject.request(imReq);
    for (var i = res.length; i--;)
    {
      res[i].request(imReq);
    }

    for (var i = imgs.length; i--;)
    {
      imgs[i].request(imReq);
    }

    for (var i = bimgs.length; i--;)
    {
      bimgs[i].request(imReq);
    }
  }

  function incRefFiles(files)
  {
    for (var i = files.length; i--;)
    {
      var file = files[i];
      //vitrium.log.debug("incRef [incRefFiles] "+file.name+" c: "+ file.counter);
      file.incRef();
    }
  }

  function onMandatoryPageFilesLoadFailed(failedFiles, request)
  {
    if (!this.fileIndex) return;
    var userdata = request.userdata;
    var pageObject = userdata.pageObject;


    var state = pageObject.state = -1;
    for (var i = 0, len = failedFiles.length; i < len; ++i)
    {
      if (failedFiles[i].error[1] === 0xFFFF)
      {
        state = pageObject.state = -2;
        break;
      }
    }

    pageObject.req = null;

    userdata.request.error(pageObject.idx, state);
  }

  function onPageImageFilesLoaded(files, request)
  {
    if (!this.fileIndex) return;

    
    incRefFiles(files);
    var userdata = request.userdata;
    var pageObject = userdata.pageObject;
    pageObject.req = null;

    this.fontsManager.pushFonts(userdata.fonts);
    pageObject.referencedFiles.push.apply(pageObject.referencedFiles, files);
    var state = pageObject.state = 3;

    userdata.request.success(pageObject.idx, state, this.fileIndex.get(pageObject.id).data);
  }


  function freePage(idx)
  {
    var pageObject = this.pages[idx];
    if (pageObject && pageObject.state > 0)
    {
      var files = pageObject.referencedFiles;
      if (files) // pageObject.state == 1
      {
        for (var i = files.length; i--;)
        {
          var f = files[i];

          //vitrium.log.debug("decRef [freePage] "+f.name+" c: "+ f.counter);

          files[i].decRef();


        }
      }


      pageObject.referencedFiles = [];
      pageObject.state = 0;

      if (pageObject.req)
      {
        pageObject.req.abort();
        pageObject.req = null;
      }
    }
  }

  function downloadToCache()
  {

  }



  function FileRequest(options)
  {
    this.reset();

    this.success = options.success || noop;
    this.error = options.error || noop;
    this.complete = options.complete || noop;
    this.progress = options.progress || noop;

    this.onpassword = options.onpassword || noop;
    this.userdata = options.userdata;
    this.completeHandler = false;
  }

  var FP = FileRequest.prototype;
  FP.onRequestedCompleted = function (file)
  {
    //vitrium.log.debug("complete handler begin");
    this.completeHandler = true;
    delete this.files[file];

    if (this.isCompleted())
    {
      var failed = this.failed;
      var succeeded = this.succeeded;
      //console.log("success: "+succeeded.join(","));
      if (_.isEmpty(failed))
      {
        this.success(succeeded, this);
      }
      else
      {
        this.error(failed, this);
      }

      this.complete(succeeded, failed, this);

      var len = failed.length;
      for (var i = 0; i < len; ++i)
      {
        var f = failed[i].file;
        //vitrium.log.debug("decRef [failed] "+f.name+" c: "+ f.counter);
        if (f.counter > 0) f.decRef();
      }

      len = succeeded.length;
      for (var i = 0; i < len; ++i)
      {
        var f = succeeded[i];
        //vitrium.log.debug("decRef [succeeded] "+f.name+" c: "+ f.counter);		
        if (f.counter > 0) f.decRef();
      }
    }

    this.completeHandler = false;

    //vitrium.log.debug("complete handler end");
  };

  FP.onSucceeded = function (file)
  {
    if (!this.completeHandler)
    {
      this.progress(file, true);
      this.succeeded.push(file);
      this.onRequestedCompleted(file);
    }
    else
    {
      vitrium.log.warn("success handler not called for the file: " + file);
    }
  };

  FP.onFailed = function (file, error)
  {
    if (!this.completeHandler && file)
    {
      this.progress(file, false, error);
      this.failed.push({ file: file, error: error });
      this.onRequestedCompleted(file);

    }
    else
    {
      if (file)
      {
        vitrium.log.error("error handler cannot be dispatched: " + file.path + " " + error.toString());
        vitrium.log.error(error);
        if (error.stack)
        {
          vitrium.log.error(error.stack);
        }
      }
    }
  };

  FP.onRequested = function (file)
  {
    this.files[file] = file;
    //vitrium.log.debug("incRef [onRequested] "+file.name+" c: "+ file.counter);
    file.incRef();
  };

  FP.reset = function ()
  {
    this.files = {};

    this.succeeded = [];
    this.failed = [];
  };

  FP.abort = function ()
  {
    _.each(this.files, _.bind(this.abortCallback, this));
  };

  FP.abortCallback = function (file)
  {
    file.abort(this);

    //vitrium.log.debug("decRef [abort] "+file.name+" c: "+ file.counter);
    if (file.counter > 0) file.decRef();
  };

  FP.isCompleted = function ()
  {
    return _.isEmpty(this.files);
  };




  function JSONParser(data, callback)
  {
    callback(JSON.parse(data));
  }

  function File(path, fileSystem , parser)
  {
    this.path = path;

    this.id = null;
    this.fileSystem = fileSystem;
    this.counter = 0;    
    this.data = null;
    this.type = null;
    this.onFree = null;

    this.requests = [];
    this.abortRequest = null;
    //this.range = null;

    //use this to extend
    this.userData = null;
    this.parser = parser || JSONParser;

    this.onLoadedCallback = _.bind(this.onLoaded, this);
    this.onFailedCallback = _.bind(this.onFailed, this);
    this.onParsedCallback = _.bind(this.onParsed, this);
    //this.onRangeCallback = _.bind(this.onRange, this);
  }


  var FileP = File.prototype;
  FileP.toString = function ()
  {
    if (this)
    {
      return "F[" + this.id + "]:" + this.path;
    }
    return null;
  };

  FileP.incRef = function ()
  {
    ++this.counter;
  };

  FileP.decRef = function ()
  {
    var c = --this.counter;
    if (c === 0)
    {
      this.free();
    }

    if (c < 0)
    {
      throw new Error("something went wrong, the counter must be >= 0 " + this.path);
    }
  };

  FileP.free = function ()
  {
    var onFree = this.onFree;
    if (_.isFunction(onFree))
    {
      onFree(this);
    }

    this.data = null;
    if (this.abortRequest)
    {
      this.abortRequest();
    }
  };

  /**
    True destructor, object cannot be used anymore after this!
  */
  FileP.destroy = function ()
  {
    this.fileSystem = null;
    this.requests = null;
    this.abortRequest = null;
    this.onLoadedCallback = null;
    this.onLoadedCallback = null;
    this.onFailedCallback = null;
    this.onParsedCallback = null;
  };

  /**
    req is FileRequest
  */
  FileP.request = function (req)
  {
    var bl = 0; //vitrium.features.Blob.level;
    req.onRequested(this);

    if (this.data)
    {
      req.onSucceeded(this);
    }
    else
    {
      var reqs = this.requests;
      reqs.push(req);

      if (reqs.length === 1)
      {
        var request = this.fileSystem.read(this.path,
          {
            type: this.type,
            blobLevel: bl,
            userData: this.userData
          })
          .then(this.onLoadedCallback)
          .catchError(this.onFailedCallback);

        this.abortRequest = _.bind(request.cancel, request);
      }
    }
  };


  FileP.onLoaded = function (data)
  {
    try
    {
      this.abortRequest = null;
      this.parser(data, this.onParsedCallback, this.onFailedCallback);
    }
    catch (parseError)
    {
      this.onFailedCallback(parseError);
    }
  };

  FileP.onParsed = function (data)
  {
    this.data = data;

    var reqs = this.requests;
    var len = reqs.length;

    for (var i = 0; i < len; ++i)
    {
      reqs[i].onSucceeded(this);
    }
    this.requests = [];
  };

  FileP.onFailed = function (error)
  {
    this.abortRequest = null;

    var reqs = this.requests;
    var len = reqs.length;

    for (var i = 0; i < len; ++i)
    {
      reqs[i].onFailed(this, error);
    }

    this.requests = [];
  };

  FileP.abort = function (req)
  {
    this.requests = _.without(this.requests, req);
  };


  function FileIndex(fileSystem)
  {
    this.fileSystem = fileSystem;
    this.seq = [];
    this.files = {};
    this.objects = {};
  }

  var FileIndexP = FileIndex.prototype;
  FileIndexP.index = function (path)
  {
    var f = new File(path, this.fileSystem);
    this.seq.push(this.files["/"+path] = f);

    return f;
  };

  FileIndexP.indexObject = function (object)
  {
    var uri = object.uri;
    if (uri.indexOf("/") === 0)
    {
      var file = this.files[uri];
      if (!file)
      {
        throw new Error("file is not in package: " + object.uri);
      }
      else
      {
        var id = object.id;
        file.type = object.type;
        file.id = id;

        this.objects[id] = file;

        return file;
      }
    }
    else
    {
      vitrium.log.warn("object uri not valid: " + uri);
    }
    return null;
  };

  FileIndexP.getByType = function (type)
  {
    var result = [];
    var seq = this.seq;
    var len = seq.length;

    for (var i = 0; i < len; ++i)
    {
      var f = seq[i];
      if (f.type === type)
      {
        result.push(f);
      }
    }

    return result;
  };

  FileIndexP.get = function (key)
  {
    return this.objects[key];
  };

  FileIndexP.getFile = function (path)
  {
    return this.files[path];
  };


  function RelIndexEntry()
  {
    this.Images = [];
    this.Thumbnails = [];
    this.ContentResource = [];
    this.Fonts = [];
    this.Text = [];
    this.BinaryImage = [];
  }

  function RelationshipsIndex(fileIndex)
  {
    this.fileIndex = fileIndex;
    this.objects = {};

    this.empty = new RelIndexEntry();
  }

  var RelationshipsIndexP = RelationshipsIndex.prototype;
  RelationshipsIndexP.indexObject = function (relationship)
  {
    var objects = this.objects;
    var id = relationship.sourceId;
    var targetId = relationship.targetId;
    var relations = this.objects[id];
    if (!relations)
    {
      relations = objects[id] = new RelIndexEntry();
    }

    var file = this.fileIndex.get(targetId);
    var relrepository = relations[file.type];

    if (relrepository)
    {
      relrepository.push(file);
    }
  };

  RelationshipsIndexP.get = function (id)
  {
    var result = this.objects[id];
    if (!result)
    {
      result = this.empty;
    }
    else
    {

      var tmp = new RelIndexEntry();
      var imgs = _.clone(result.Images);
      var fonts = _.clone(result.Fonts);
      var text = _.clone(result.Text);
      var binimg = _.clone(result.BinaryImage);
      var thumbnails = _.clone(result.Thumbnails);

      if (!_.isEmpty(result.ContentResource))
      {
        var resources = tmp.ContentResource = _.clone(result.ContentResource);
        var len = resources.length;
        for (var i = 0; i < len; ++i)
        {
          var r = resources[i];
          var dep = this.get(r.id);

          imgs.push.apply(imgs, dep.Images);
          fonts.push.apply(fonts, dep.Fonts);
          text.push.apply(text, dep.Text);
          binimg.push.apply(binimg, dep.BinaryImage);
          thumbnails.push.apply(thumbnails, dep.Thumbnails);
        }
      }

      tmp.Images = _.uniq(imgs);
      tmp.Fonts = _.uniq(fonts);
      tmp.Text = _.uniq(text);
      tmp.BinaryImage = _.uniq(binimg);
      tmp.Thumbnails = _.uniq(thumbnails);

      result = tmp;
    }

    return result;
  };



  function Index()
  {
    this.objects = {};
  }

  var IIP = Index.prototype;
  IIP.indexObject = function (object)
  {
    // vitrium.log.debug("indexObject:" + object.key);
    this.objects[object.key] = object.data;
  };

  IIP.removeObject = function (object)
  {
    // vitrium.log.debug("removeObject:" + object.key);
    delete this.objects[object.key];
  };

  IIP.get = function (key)
  {
    var objects = this.objects;
    if (key in objects)
    {
      return this.objects[key];
    }
    else
    {
      return null;
    }
  };

  function indexObjects(ind, objects, imageFileFreedCallback)
  {
    if (!objects) return;

    var len = objects.length;

    if (imageFileFreedCallback)
    {
      for (var i = 0; i < len; ++i)
      {
        var object = objects[i];
        var f = ind.indexObject(object);

        if (f && f.type === "Images" || f.type === "Thumbnails")
        {
          f.onFree = imageFileFreedCallback;
        }
        else if (f && f.type === "BinaryImage")
        {
          f.onFree = imageFileFreedCallback;
          f.userData = { key: object.key, mimetype: object.mimetype, dpi: object.dpi };
        }
      }
    }
    else
    {
      for (var i = 0; i < len; ++i)
      {
        var object = objects[i];
        ind.indexObject(object);
      }
    }
  }

  function onImageFileFreed(file)
  {
    var images = file.data;
    var URL = vitrium.features.Blob.URL;
    if (images)
    {
      var len = images.length;
      var ii = this.imageIndex;

      var browserIsMobileSafari = $.browser.safari && vitrium.is_mobile;

      for (var i = 0; i < len; ++i)
      {
        var imageFile = images[i];
        if (imageFile.data)
        {
          var data = imageFile.data;
          if (imageFile.level > 0)
          {
            URL.revokeObjectURL(data.src);
          }

          if (browserIsMobileSafari)
          {
            data.src = null;
          }
        }

        ii.removeObject(imageFile);
      }
    }
  }

  function noop() { };

  function NoopParser(data, callback)
  {
    callback(data);
  }
}(
vitrium.viewer,
vitrium.async,
vitrium,
vitrium.zip,
_,
jQuery,
__globals__));


// script:viewer/benchmark.js
(function(exports, vitrium, $)
{
	"use strict";
	exports.Benchmark = Benchmark;
  

	function Benchmark(viewer)
	{
		this.data = {};
		this.viewer = viewer;
		
		this.startTime = null;
		this.onPageRequested = _.bind(this.pageRequested, this);
		this.onPageRenderedBegin = _.bind(this.pageRenderedBegin, this);
		this.onPageRenderedEnd = _.bind(this.pageRenderedEnd, this);
		
		this.remoteLogger = null; 
		this.runs = 0;
	}
	
	var B = Benchmark.prototype;
	B.start = function()
	{
		
		vitrium.benchmark = true;
		if (!this.remoteLogger)
		{
			this.remoteLogger = new vitrium.utils.RemoteLogger();
		}
		
		var viewer = this.viewer;
		viewer.changeDocumentRenderer(vitrium.viewer.OnePageDocumentRenderer);
		viewer.on("page:requested", this.onPageRequested);
		viewer.on("page-render:begin", this.onPageRenderedBegin);
		viewer.on("page-render:end", this.onPageRenderedEnd);

		this.data = {};
		this.startTime = new Date().getTime();
	};
	
	B.pageRequested = function(idx)
	{
		if (!this.data[idx])
		{
			this.data[idx] = { requested:  new Date().getTime(), renderedBegin : 0, renderedEnd: 0, state : 0 };
		}
	};
	
	B.pageRenderedBegin = function(idx, state)
	{
		var info = this.data[idx];
		info.renderedBegin = new Date().getTime();
		info.state = state;		
	};
	
	B.pageRenderedEnd = function(idx, state)
	{
		var info = this.data[idx];
		info.renderedEnd = new Date().getTime();
		
		if (state === 3 && this.viewer.documentInfo.pages.length -1 === idx)
		{
			this.stop();
		}
		else	if (state === 3 )
		{
			var viewer = this.viewer;
			setTimeout(function()
			{
				viewer.scrollTo(idx + 1);
			}, 500);
		}
	};
	
	B.stop = function()
	{	
		vitrium.benchmark = false;
		var duration = new Date().getTime() - this.startTime;
		viewer.off("page:requested", this.onPageRequested);
		viewer.off("page-render:begin", this.onPageRenderedBegin);
		viewer.off("page-render:end", this.onPageRenderedEnd);
		
		
		var data = this.data;
		var keys = _.keys(data);
		var log = vitrium.log;
		
		var sumLoadTime = 0;
		var sumRenderTime = 0;
		var browser = "";
		_.each(jQuery.browser, function(value, key)
		{
			browser+= key+"="+value+",";
		});
		
		var table = "data:text/html,<table>\
		<caption>"+window.location.hash+"["+browser+"]</caption>\
		<tr>\
		<th style='text-align:left;'>page</th><th style='text-align:left;'>load time</th><th style='text-align:left;'>render time</th>\
		<tr>";
		
		var maxLoadingTime = -1;
		var maxLoadingTimePage = -1;
		var minLoadingTime = 60*60*60*24;
		var minLoadingTimePage = -1;
		
		var maxRenderingTime = -1;
		var maxRenderingPage = -1;
		var minRenderingTime = 60*60*60*24;
		var minRenderingTimePage = -1;
		
		for (var i = 0, len = keys.length; i < len; ++i)
		{
			var record = data[i];
			var loadTime = record.renderedBegin - record.requested;
			var renderTime = record.renderedEnd- record.renderedBegin;
			
			sumLoadTime+= loadTime;
			sumRenderTime+= renderTime;
			
			maxLoadingTime = Math.max(loadTime, maxLoadingTime);
			if (maxLoadingTime === loadTime)
			{
				maxLoadingTimePage = i;
			}
			
			minLoadingTime = Math.min(loadTime, minLoadingTime);
			if (minLoadingTime === loadTime)
			{
				minLoadingTimePage = i;
			}
			
			maxRenderingTime = Math.max(renderTime, maxRenderingTime);
			if (maxRenderingTime === renderTime)
			{
				maxRenderingPage = i;
			}
			
			minRenderingTime = Math.min(renderTime, minRenderingTime);
			if (minRenderingTime === renderTime)
			{
				minRenderingTimePage = i;
			}		
						
			
			table += "<tr><td style='text-align:right;'>"+keys[i]+"</td><td style='text-align:right;'>"+loadTime+"</td><td style='text-align:right;'>"+renderTime+"</td>";
		}
		
		var avgLoadTime = sumLoadTime / keys.length;
		var avgRenderTime = sumRenderTime / keys.length;
		
		table += "</table>";
		table += "<table>\
		<tr><th style='text-align:left;'>Duration</th><td style='text-align:right;'>"+duration+"</td></tr>\
		<tr><th style='text-align:left;'>Sum loading time</th><td style='text-align:right;'>"+sumLoadTime+"</td></tr>\
		<tr><th style='text-align:left;'>Sum rendering time</th><td style='text-align:right;'>"+sumRenderTime+"</td></tr>\
		<tr><th style='text-align:left;'>Avg loading time</th><td style='text-align:right;'>"+avgLoadTime+"</td></tr>\
		<tr><th style='text-align:left;'>Avg rendering time</th><td style='text-align:right;'>"+avgRenderTime+"</td></tr>\
		<tr><th style='text-align:left;'>Max loading time</th><td style='text-align:right;'>"+maxLoadingTime+" ["+maxLoadingTimePage+"]</td></tr>\
		<tr><th style='text-align:left;'>Min loading time</th><td style='text-align:right;'>"+minLoadingTime+" ["+minLoadingTimePage+"]</td></tr>\
		<tr><th style='text-align:left;'>Max rendering time</th><td style='text-align:right;'>"+maxRenderingTime+" ["+maxRenderingPage+"]</td></tr>\
		<tr><th style='text-align:left;'>Min rendering time</th><td style='text-align:right;'>"+minRenderingTime+" ["+minRenderingTimePage+"]</td></tr>";
		
		
		//window.open(table);
		this.remoteLogger.debug(window.location.toString(),$.browser.name+"["+$.browser.version+"]", this.runs, duration, sumLoadTime, sumRenderTime, avgLoadTime, avgRenderTime, maxLoadingTime, minLoadingTime, maxRenderingTime, minRenderingTime);
		
		this.data = {};		
		
		if (this.runs < 10)
		{
			this.runs += 1;
			this.start();
			viewer.scrollTo(0);
		}
	};
  
  
  
  
}(vitrium.utils, vitrium, jQuery));
// script:viewer/io/multiple-key-object-loader.js
(function(exports)
{
  "use strict";
  
  exports.loadByMultipleKeys = function(storage, keys, success, fail)
  {
    storage.readTransaction(function(tx)
    {
       var result = {};
       var count = keys.length;
       var error = false;
       
       for (var i = 0; i < count; ++i)
       {
          tx.getItem(keys[i], function(tx, val, key) {
          
            result[key] = val === null ? null : JSON.parse(val);
            --count;
            if (count === 0)
            {
              setTimeout(function(){success(result);}, 0); 
            }
          }, errorHandler);
       }
       
      function errorHandler(e)
      {
        if (!error) {
          error = true;
          fail(e);
        }          
      }
    }, fail);
  };

}
(vitrium.utils));
// script:viewer/dynamic-environment.js
(function(exports, utils, service, log, asyncStorage, Backbone, _)
{
  "use strict";

    
  exports.DynamicEnvironment = DynamicEnvironment;
  
  /**
    modelDescription = [
      { 
        service : <service name>,
        action: <action name>,
        updateEvent : "<CHANNEL>:<EVENT>",
        model: <result model>,
        optional : <true|false>
      },
      .
      .
      .
      . 
    ]
  */
  function DynamicEnvironment(url, modelDescription, serviceCaller, pollAgent, args)
  {
      this.url = url;
      this.modelDescription = modelDescription;
      this.serviceCaller = serviceCaller;
      this.storage = new StorageManager(url, modelDescription);
      this.pollAgent = pollAgent;
      this.completer = null;

      this.args = args;
  }
  
  DynamicEnvironment.prototype = {
     getDbContextId : function()
     {
        if (this.args.has("documentId"))
           return this.args.get("documentId");
        else
           return this.args.get("documentUrl");
     },
    destroy : function()
    {
      this.unbindUpdateEvents();
    },
    callRemote : function(remoteResults, serviceCaller, description)
    {
      var key = get_key(description);          
      var future = serviceCaller.call(description.service, description.action, {})
            .then(function(data)
            {
              remoteResults[key] = data;
            })
            .catchError(function(e)
            {
               remoteResults[key] = null;

               //offline errors are ignored
               if (e !== 0 && _.isFunction(description.remoteErrorHandler))
               {
                  description.remoteErrorHandler(e, key);
               }
            });

      return future;
    },
    propagateData : function(data)
    {

    },
    init : function()
    {
      var self = this;
      var serviceCaller = this.serviceCaller;
      if (serviceCaller  === null)
      {
          throw new Error("[DynamicEnvironment.serviceCaller] must be not null");
      }
      
      if (this.completer === null)
      {
        var completer =  this.completer = new service.Completer();
        var remoteResults = {};
                
        var modelDescription = this.modelDescription;          
        for (var i = 0, len = modelDescription.length; i < len; ++i)
        {            
            this.callRemote(remoteResults, serviceCaller, modelDescription[i]);
        }
        
        var storage = this.storage;
        var storageInitFuture = storage.init();
        
        var waitForLoad = false;
        serviceCaller.send()
          .then(function()
          {
            storageInitFuture
            .runWhenSucceed(function()
            {
               // I don't care when it is done
               storage.save(remoteResults).then(function() {
                  log.debug("[StorageManager.init] saved");
               })
               .catchError(function()
               {
                 log.warn("[StorageManager.init] unable to save defaults");
               });
            })
            .runWhenFailed(function(){ 
              // it is just a warning, we have our data, but we are unable to save them
              log.warn("[StorageManager.init] unable to init storage for defaults");
            });
            propageData(remoteResults);
          })
         .catchError(function(e)
         {
            storageInitFuture.runWhenSucceed(function()
            {
               storage.load().then(propageData).catchError(function(e)
               {
                  log.error("[StorageManager.load] failed", e);
                  completer.fail();
               });
            })
            .runWhenFailed(function(){ 
              log.error("[StorageManager.init] failed");
              completer.fail();
            });
         });
        
        var propageData = function(data)
        {
          var error = false;
          _.each(data, function(val, key) {
            if (val === null)
            {
              var desc = _.find(modelDescription, function(d){ return get_key(d) === key; });
              if (!desc.optional)
              {
                error = true;
              }
            }
          });
          
          if (!error)
          {
            _.each(data, function(val, key)
            {
                var desc = _.find(modelDescription, function(d){ return get_key(d) === key; });
                desc.model.set(val);
            });
            
            self.bindUpdateEvents();
            completer.complete();
          }
          else
          {
            completer.fail();
          }
        };
        
        completer.future.whenComplete(_.bind(function() {
          this.completer = null;
        }, this));
        
        return completer.future;        
      }
      else
      {
        throw new Error("[DocumentDescriptionProvider.init] can be called only once!");
      }
    },
    /**
    it updates evironment model  state
    data = {
      "<service>.<action>" : { data }
      }
    */
    update : function(data)
    {      
      var modelDescription = this.modelDescription;      
      this.storage.save(data).then(function()
      {
        _.each(data, function(val, key)
        {
          var desc = _.find(modelDescription, function(d){ return get_key(d) === key; });    
          desc.model.set(val);
        });
      }).catchError(function()
      {
        log.error("[StorageManager.save] update environment failed");
      });
         
    },
    bindUpdateEvents : function()
    {
      _.each(this.modelDescription, _.bind(function(description, key)
      {
        if (_.isString(description.updateEvent))
        {
          //TODO override instead of replace
          this.pollAgent.on(description.updateEvent, function(data) {
            var updateObj ={};
            updateObj[get_key(description)] = data;
            this.update(updateObj);            
          }, this);
        }
      }, this));
    },
    unbindUpdateEvents : function()
    {
      this.pollAgent.off(null, null, this);
    },
    refresh: function(key)
    {
      var modelDesc = _.find(this.modelDescription, function (d)
      {
        return get_key(d) === key;
      });

      if (modelDesc)
      {
        var result = {};
        var future = this.callRemote(result, this.serviceCaller, modelDesc);
        future.then(_.bind(function ()
        {
          this.update(result);
        }, this));

        this.serviceCaller.send();
        return future;
      }
      else
      {
        throw new Error("Unable to find " + key);
      }
    },
    store : function(key, val)
    {
     var desc = _.find(this.modelDescription, function (d)
      {
        return get_key(d) === key;
     });

     if (desc && desc.store)
     {
       var m = {};
       m[key] = val;
       return this.storage.save(m);
     }
     else
     {
       throw new Error("Unable to store");
     }
    }
  };
  
  
  var ST_INITIALIZED = 3;
  var ST_LOADING = 2;
  var ST_SAVING = 4;
  var ST_OPENING = 1;
  var ST_NONE = 0;
  var ST_FAILED = -1;
  var ST_CANCELED = -2;
  
  function StorageManager(url, modelDescription)
  {
    this.url = url;
    this.modelDescription = modelDescription;
    this.storage = null;
    this.state = ST_NONE;
    this.completer = null;
  }
  
  StorageManager.prototype = {
    init : function()
    {
        this.completer = new service.Completer();
        this.state = ST_OPENING;
        
        asyncStorage.create("env:"+this.url, _.bind(this.onDbInit, this), _.bind(this.onDbInitFailed, this));
        
        return this.completer.future;
    },
    load : function()
    {
      if (this.state === ST_INITIALIZED)
      {
        this.completer = new service.Completer();
        this.state = ST_LOADING;
        utils.loadByMultipleKeys(this.storage, this.buildKeys(), _.bind(this.onDataLoaded, this), _.bind(this.onDataLoadFailed, this));
        return this.completer.future;
      }
      else
      {
         var completer = new service.Completer();
         this.completer.future.then(_.bind(function () {
            this.load().then(function () {
               completer.complete.call(completer, arguments);
            }).
            catchError(function () {
               completer.fail.call(completer, arguments);
            });
         }, this));

         return completer.future;
      }
    },
    save : function(data)
    {
      if (this.state === ST_INITIALIZED)
      {
        var completer = new service.Completer();
        
        var counter = 0;
        var failed = false;
        var failonce = _.bind(function(e)
        {
          if (!failed) {
            completer.fail(e);
          }
          failed = true;
        }, this);
        
        var success = _.bind(function()
        {
          if (--counter === 0)
          {
            completer.complete(0);
          }
        }, this);
        
        this.storage.transaction(function(tx)
        {
           _.each(data, function () {
              ++counter;
           });

          _.each(data, function(val, key)
          {
            tx.setItem(key, JSON.stringify(val), success, failonce);
          });
          
        }, 
        _.bind(completer.fail, completer));
        
      
        
        return completer.future;
      }
      else if (this.state === ST_FAILED)
      {
        //means that we are unable to initialize storage (private mode or IE9)
        var completer = new service.Completer();
        setTimeout(function(){ completer.complete(); }, 0);
        return completer.future;
      }
      else
      {
         var completer = new service.Completer();
         this.completer.future.then(_.bind(function () {
            this.save(data).then(function () {
               completer.complete.call(completer, arguments);
            }).
            catchError(function(){
               completer.fail.call(completer, arguments);
            });
         }, this));

         return completer.future;
      }
    },
    buildKeys : function()
    {
      var modelDescription = this.modelDescription;
      var keys = [];
      for (var i = 0, len = modelDescription.length; i < len; ++i)
      {
        var c =modelDescription[i];
        keys[i] = get_key(c);
      }
      
      return keys;   
    },
    onDbInit : function(db)
    {    
      var storage = this.storage = new utils.VerifiableStorage(db);
      this.state = ST_INITIALIZED;
      this.completer.complete(null);
    },
    onDataLoaded : function(data)
    {
        this.state = ST_INITIALIZED;
        this.completer.complete(data);        
    },
    onDataLoadFailed : function()
    {
      this.state = ST_INITIALIZED;
      this.completer.complete(null);
    },
    onDbInitFailed : function()
    {
      //db is either locked or it does not support transactions (IE9)
      // I fail only once per the initialization request 
      if (this.state !== ST_FAILED)
      {
        this.state = ST_FAILED;
        this.completer.fail(0);
      }
    }
  };
  
  function get_key(desc)
  {
    return desc.service + "."+desc.action;
  }
}
(
vitrium.viewer, 
vitrium.utils, 
vitrium.service,
vitrium.log,
vitrium.utils.asyncStorage,
Backbone,
_));
// script:viewer/poll-agent.js
(function(exports, log, Backbone, _)
{
  "use strict";
  exports.PollAgent = PollAgent;
  
  function PollAgent(serviceCaller)
  {
    this.sc = serviceCaller;
    this.interval = null;
    this.pollMsg = null;
    this.requested = false;
  }
  
  PollAgent.prototype = {
    destroy: function()
    {
      this._cancelTimer();
      this.sc = null;
    },
    init : function(data)
    {
       this._cancelTimer();
      if (data)
      {
         this.pollMsg= data;
         this.interval = setInterval(_.bind(this.poll, this), data.pollingIntervalSeconds*1000);
      }
    },
    poll : function()
    {
      if (this.requested) return;
      
      this.requested = true;
      this.sc.call("Event", "poll", this.pollMsg).then(_.bind(this.onPollResult, this)).catchError(_.bind(this.onError, this));
      this.sc.send();
    },
    onPollResult : function(result)
    {
      this.requested = false;
      var channels = this.channels;
      var events = result.events;
      
      for (var i = 0, len = events.length; i < len; ++i)
      {
          var e = events[i];
          this.trigger(e.channel+":"+e.name, e.data);
      }
    },
    onError : function(e)
    {
      this.requested = false;      
      this.trigger("poll:error", e);
      log.error("[PollAgent] ERROR response: "+e);
    },
    _cancelTimer: function(e)
    {
       if (this.interval !== null)
       {
          clearInterval(this.interval);
          this.interval = null;
          log.debug("[PollAgent] timer canceled");

       }
    }
  };
  
  _.extend(PollAgent.prototype, Backbone.Events);
  
}
(
vitrium.viewer, 
vitrium.log, 
Backbone,
_));

// script:viewer/window-opener.js
(function(exports)
{
  "use strict";
  
  exports.openNewWindow = function(url)
  {           
    var document  = window.document;
    var a = document.createElement('a');
    a.setAttribute("href", url);
    a.setAttribute("target", "_blank");

    var dispatch = document.createEvent("HTMLEvents")
    dispatch.initEvent("click", true, true);
    a.dispatchEvent(dispatch);
  };

}
(vitrium.utils));
// script:viewer/dialog-actions.js
(function(exports, utils)
{
  "use strict";
  
  exports.executeDialogAction = executeDialogAction;
  
  function executeDialogAction(action)
  {
    if (startsWith(action, "redirect:"))
    {
      var link = getLink("redirect:", action);
      window.location = link;
    }
    else if (startsWith(action, "open:"))
    {
      var link = getLink("open:", action);
      utils.openNewWindow(link);
    }
    else if (action === "refresh")
    {
      window.location.reload();
    }
  }
  
  function startsWith(str, start)
  {
    return start === str.substr( 0, start.length ) ;
  }

  function getLink(action, actionStr)
  {
    return actionStr.substring(action.length, actionStr.length);
  }
}
(vitrium.actions,
 vitrium.utils
));
// script:viewer/channels/interaction-handler.js
(function(exports, viewer, i18n,actions, log, _)
{
  "use strict";
  exports.InteractionChannelHandler = InteractionChannelHandler;
  
  function InteractionChannelHandler(dViewer, pollAgent)
  {
    this.viewer = dViewer;
    this.pollAgent = pollAgent;
    
    pollAgent.on("INTERACTION:BOX_SHOW_REQUESTED", this.onBoxShowRequested, this);
  }
  InteractionChannelHandler.prototype = {
    destroy : function()
    {
      this.pollAgent.off("INTERACTION:BOX_SHOW_REQUESTED", this.onBoxShowRequested, this);
    },
    onBoxShowRequested : function(boxMessage)
    {
      if (!_.isString(boxMessage.title) || !_.isString(boxMessage.body))
      {
        log.error("[InteractionChannelHandler] Fields title and body are required to complete this task");
        return;
      }
      else
      {
    
        var type = "";
        if (_.isString(boxMessage.type))
        {
          type = boxMessage.type;
        }
        
        var buttons = null;
        var handlers = [];
        if (_.isArray(boxMessage.buttons))
        {
          var buttonsDef = boxMessage.buttons;
          buttons = [];
          for (var i = 0, len = buttonsDef.length; i < len; ++i)
          {
            var def = buttonsDef[i];
            var cssClasses = [];
            if (def["default"] || len === 1)
            {             
              cssClasses.push( "btn-primary");
            }
            
            if (_.isString(def.cssClass))
            {
              cssClasses.push(def.cssClass);
            }
            
            if (!_.isString(def.label))
            {
              log.error("[InteractionChannelHandler] button label field is required");
              continue;
            }
            
            var button = { 
              id : "id-"+i,
              cssClass : cssClasses.join(" "),
              title : def.label,
              action : def.action
              };
               
            buttons.push(button);
             
          }
        }

       var bindActions = true;
       if (!buttons || buttons.length === 0)
       {
        bindActions  = false;
        buttons = [ { id : "close", title : i18n._T("fs-close"), cssClass : "btn-primary"}];
       }
            
        var box = viewer.showDismissBox(this.viewer, type, 
            boxMessage.title,
            boxMessage.body,
            {
            buttons :  buttons
          });
        
        if (bindActions)
        {
          for (var i = 0, len = buttons.length; i < len; ++i)
          {
            var button = buttons[i];
            if (button.action && button.action.length > 0)
            {
              bindAction(box, button.id, button.action);
             }
          }
        }
          
      }
    }
  };
  
  function bindAction(box, id, action)
  {
    box.on("button:"+id, function(evt)
    {
      actions.executeDialogAction(action);
    });
  }

}
(
vitrium.viewer,
vitrium.viewer,
vitrium.i18n,
vitrium.actions,
vitrium.log,
_));
// script:viewer/analytics/uuid.js
/// <reference path="~/build.html" />

(function (exports) {
   "use strict";

   /**
 * UUID.js: The RFC-compliant UUID generator for JavaScript.
 *
 * @fileOverview
 * @author  LiosK
 * @version 3.2
 * @license The MIT License: Copyright (c) 2010-2012 LiosK.
 */

   /** @constructor */
   var UUID;

   UUID = (function (overwrittenUUID) {

      // Core Component {{{

      /** @lends UUID */
      function UUID() { }

      /**
       * The simplest function to get an UUID string.
       * @returns {string} A version 4 UUID string.
       */
      UUID.generate = function () {
         var rand = UUID._getRandomInt, hex = UUID._hexAligner;
         return hex(rand(32), 8)          // time_low
               + "-"
               + hex(rand(16), 4)          // time_mid
               + "-"
               + hex(0x4000 | rand(12), 4) // time_hi_and_version
               + "-"
               + hex(0x8000 | rand(14), 4) // clock_seq_hi_and_reserved clock_seq_low
               + "-"
               + hex(rand(48), 12);        // node
      };

      /**
       * Returns an unsigned x-bit random integer.
       * @param {int} x A positive integer ranging from 0 to 53, inclusive.
       * @returns {int} An unsigned x-bit random integer (0 <= f(x) < 2^x).
       */
      UUID._getRandomInt = function (x) {
         if (x < 0) return NaN;
         if (x <= 30) return (0 | Math.random() * (1 << x));
         if (x <= 53) return (0 | Math.random() * (1 << 30))
                           + (0 | Math.random() * (1 << x - 30)) * (1 << 30);
         return NaN;
      };

      /**
       * Returns a function that converts an integer to a zero-filled string.
       * @param {int} radix
       * @returns {function(num&#44; length)}
       */
      UUID._getIntAligner = function (radix) {
         return function (num, length) {
            var str = num.toString(radix), i = length - str.length, z = "0";
            for (; i > 0; i >>>= 1, z += z) { if (i & 1) { str = z + str; } }
            return str;
         };
      };

      UUID._hexAligner = UUID._getIntAligner(16);

      // }}}

      // UUID Object Component {{{

      /**
       * Names of each UUID field.
       * @type string[]
       * @constant
       * @since 3.0
       */
      UUID.FIELD_NAMES = ["timeLow", "timeMid", "timeHiAndVersion",
                          "clockSeqHiAndReserved", "clockSeqLow", "node"];

      /**
       * Sizes of each UUID field.
       * @type int[]
       * @constant
       * @since 3.0
       */
      UUID.FIELD_SIZES = [32, 16, 16, 8, 8, 48];

      /**
       * Generates a version 4 {@link UUID}.
       * @returns {UUID} A version 4 {@link UUID} object.
       * @since 3.0
       */
      UUID.genV4 = function () {
         var rand = UUID._getRandomInt;
         return new UUID()._init(rand(32), rand(16), // time_low time_mid
                                 0x4000 | rand(12),  // time_hi_and_version
                                 0x80 | rand(6),   // clock_seq_hi_and_reserved
                                 rand(8), rand(48)); // clock_seq_low node
      };

      /**
       * Converts hexadecimal UUID string to an {@link UUID} object.
       * @param {string} strId UUID hexadecimal string representation ("xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx").
       * @returns {UUID} {@link UUID} object or null.
       * @since 3.0
       */
      UUID.parse = function (strId) {
         var r, p = /^\s*(urn:uuid:|\{)?([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{2})([0-9a-f]{2})-([0-9a-f]{12})(\})?\s*$/i;
         if (r = p.exec(strId)) {
            var l = r[1] || "", t = r[8] || "";
            if (((l + t) === "") ||
                (l === "{" && t === "}") ||
                (l.toLowerCase() === "urn:uuid:" && t === "")) {
               return new UUID()._init(parseInt(r[2], 16), parseInt(r[3], 16),
                                       parseInt(r[4], 16), parseInt(r[5], 16),
                                       parseInt(r[6], 16), parseInt(r[7], 16));
            }
         }
         return null;
      };

      /**
       * Initializes {@link UUID} object.
       * @param {uint32} [timeLow=0] time_low field (octet 0-3).
       * @param {uint16} [timeMid=0] time_mid field (octet 4-5).
       * @param {uint16} [timeHiAndVersion=0] time_hi_and_version field (octet 6-7).
       * @param {uint8} [clockSeqHiAndReserved=0] clock_seq_hi_and_reserved field (octet 8).
       * @param {uint8} [clockSeqLow=0] clock_seq_low field (octet 9).
       * @param {uint48} [node=0] node field (octet 10-15).
       * @returns {UUID} this.
       */
      UUID.prototype._init = function () {
         var names = UUID.FIELD_NAMES, sizes = UUID.FIELD_SIZES;
         var bin = UUID._binAligner, hex = UUID._hexAligner;

         /**
          * List of UUID field values (as integer values).
          * @type int[]
          */
         this.intFields = new Array(6);

         /**
          * List of UUID field values (as binary bit string values).
          * @type string[]
          */
         this.bitFields = new Array(6);

         /**
          * List of UUID field values (as hexadecimal string values).
          * @type string[]
          */
         this.hexFields = new Array(6);

         for (var i = 0; i < 6; i++) {
            var intValue = parseInt(arguments[i] || 0);
            this.intFields[i] = this.intFields[names[i]] = intValue;
            this.bitFields[i] = this.bitFields[names[i]] = bin(intValue, sizes[i]);
            this.hexFields[i] = this.hexFields[names[i]] = hex(intValue, sizes[i] / 4);
         }

         /**
          * UUID version number defined in RFC 4122.
          * @type int
          */
         this.version = (this.intFields.timeHiAndVersion >> 12) & 0xF;

         /**
          * 128-bit binary bit string representation.
          * @type string
          */
         this.bitString = this.bitFields.join("");

         /**
          * UUID hexadecimal string representation ("xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx").
          * @type string
          */
         this.hexString = this.hexFields[0] + "-" + this.hexFields[1] + "-" + this.hexFields[2]
                        + "-" + this.hexFields[3] + this.hexFields[4] + "-" + this.hexFields[5];

         /**
          * UUID string representation as a URN ("urn:uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx").
          * @type string
          */
         this.urn = "urn:uuid:" + this.hexString;

         return this;
      };

      UUID._binAligner = UUID._getIntAligner(2);

      /**
       * Returns UUID string representation.
       * @returns {string} {@link UUID#hexString}.
       */
      UUID.prototype.toString = function () { return this.hexString; };

      /**
       * Tests if two {@link UUID} objects are equal.
       * @param {UUID} uuid
       * @returns {bool} True if two {@link UUID} objects are equal.
       */
      UUID.prototype.equals = function (uuid) {
         if (!(uuid instanceof UUID)) { return false; }
         for (var i = 0; i < 6; i++) {
            if (this.intFields[i] !== uuid.intFields[i]) { return false; }
         }
         return true;
      };

      // }}}

      // UUID Version 1 Component {{{

      /**
       * Generates a version 1 {@link UUID}.
       * @returns {UUID} A version 1 {@link UUID} object.
       * @since 3.0
       */
      UUID.genV1 = function () {
         var now = new Date().getTime(), st = UUID._state;
         if (now != st.timestamp) {
            if (now < st.timestamp) { st.sequence++; }
            st.timestamp = now;
            st.tick = UUID._getRandomInt(4);
         } else if (Math.random() < UUID._tsRatio && st.tick < 9984) {
            // advance the timestamp fraction at a probability
            // to compensate for the low timestamp resolution
            st.tick += 1 + UUID._getRandomInt(4);
         } else {
            st.sequence++;
         }

         // format time fields
         var tf = UUID._getTimeFieldValues(st.timestamp);
         var tl = tf.low + st.tick;
         var thav = (tf.hi & 0xFFF) | 0x1000;  // set version '0001'

         // format clock sequence
         st.sequence &= 0x3FFF;
         var cshar = (st.sequence >>> 8) | 0x80; // set variant '10'
         var csl = st.sequence & 0xFF;

         return new UUID()._init(tl, tf.mid, thav, cshar, csl, st.node);
      };

      /**
       * Re-initializes version 1 UUID state.
       * @since 3.0
       */
      UUID.resetState = function () {
         UUID._state = new UUID._state.constructor();
      };

      /**
       * Probability to advance the timestamp fraction: the ratio of tick movements to sequence increments.
       * @type float
       */
      UUID._tsRatio = 1 / 4;

      /**
       * Persistent state for UUID version 1.
       * @type UUIDState
       */
      UUID._state = new function UUIDState() {
         var rand = UUID._getRandomInt;
         this.timestamp = 0;
         this.sequence = rand(14);
         this.node = (rand(8) | 1) * 0x10000000000 + rand(40); // set multicast bit '1'
         this.tick = rand(4);  // timestamp fraction smaller than a millisecond
      };

      /**
       * @param {Date|int} time ECMAScript Date Object or milliseconds from 1970-01-01.
       * @returns {object}
       */
      UUID._getTimeFieldValues = function (time) {
         var ts = time - Date.UTC(1582, 9, 15);
         var hm = ((ts / 0x100000000) * 10000) & 0xFFFFFFF;
         return {
            low: ((ts & 0xFFFFFFF) * 10000) % 0x100000000,
            mid: hm & 0xFFFF, hi: hm >>> 16, timestamp: ts
         };
      };

      // }}}

      // Misc. Component {{{

      /**
       * Reinstalls {@link UUID.generate} method to emulate the interface of UUID.js version 2.x.
       * @since 3.1
       * @deprecated Version 2.x. compatible interface is not recommended.
       */
      UUID.makeBackwardCompatible = function () {
         var f = UUID.generate;
         UUID.generate = function (o) {
            return (o && o.version == 1) ? UUID.genV1().hexString : f.call(UUID);
         };
         UUID.makeBackwardCompatible = function () { };
      };

      /**
       * Preserves the value of 'UUID' global variable set before the load of UUID.js.
       * @since 3.2
       * @type object
       */
      UUID.overwrittenUUID = overwrittenUUID;

      // }}}

      return UUID;

   })(UUID);

   exports.UUID = UUID;
   // vim: et ts=2 sw=2 fdm=marker fmr&
}
(vitrium.analytics));




// script:viewer/analytics/page-left-calculator.js
/// <reference path="~/build.html" />

(function (exports, _) {
   "use strict";
   exports.PageLeftCalculator = PageLeftCalculator;

   var MIN_VISITATION_TIME = 5 * 1000;

   function PageChangedStamp(page, totalPageCount)
   {
      this.page = page;
      this.totalPageCount = totalPageCount;
      this.visitedAt = Date.now();
      this.duration = null;
      this.destinationPage = null;
   }

   
   function PageLeftCalculator(viewer, analyticsProcessor)
   {
      viewer.on("change:currentPage", this.onPageChanged, this);
      viewer.on("change:pageCount", this.onPageCountChanged, this);
      
      this._viewer = viewer;
      this._analyticsProcessor = analyticsProcessor;
      this._pageCount = null;

      this._lastChange = null;
      this._pendingChange = null;

      
      this._beaconInterval = null;

      this._viewer.initialPageLoadCompleter.future.runWhenSucceed(_.bind(function () {
          
          if (this._lastChange !== null) {
              this._lastChange.page = this._viewer.currentPage;

              if (this._pendingChange !== null) {
                  clearTimeout(this._pendingChange);
                  this._pendingChange = null;
              }

              this.fireBeacon();
          }
         this._beaconInterval = setInterval(_.bind(this.fireBeacon, this), 60000);
      }, this));
   }


   PageLeftCalculator.prototype.destroy = function () {
       this._viewer.off("change:currentPage", this.onPageChanged, this);
       this._viewer.off("change:pageCount", this.onPageCountChanged, this);
   };

   PageLeftCalculator.prototype.onPageCountChanged = function (pageCount) {
       this._pageCount = pageCount;
   };

   PageLeftCalculator.prototype.onPageChanged = function (page)
   {
      if (this._lastChange === null)
      {
         this._lastChange = new PageChangedStamp(page, this._pageCount);
         this._beaconInterval = setInterval(_.bind(this.fireBeacon, this), 60000);
      }
      else if (this._lastChange.page !== page)
      {
         if (this._beaconInterval !== null) {
            clearInterval(this._beaconInterval);
            this._beaconInterval = null;
         }

         var change = new PageChangedStamp(page, this._pageCount);

         if (this._pendingChange !== null)
            clearTimeout(this._pendingChange);
         

         if (this._lastChange.duration === null)
         {
             var duration = change.visitedAt - this._lastChange.visitedAt;
            this._lastChange.duration = duration;
         }

         this._pendingChange = setTimeout(_.bind(function () {
            var pageLeftChange = this._lastChange;
            this._lastChange = change;
            pageLeftChange.destinationPage = change.page;
            this._analyticsProcessor.processPageLeft(pageLeftChange);
            this._pendingChange = null;

            this._beaconInterval = setInterval(_.bind(this.fireBeacon, this), 60000);

         }, this), MIN_VISITATION_TIME);
      }
      else if (this._pendingChange !== null)
      {
         // I returned to the original page within the MIN_VISITATION_TIME so act as never happend
         this._lastChange.duration = null;
         clearTimeout(this._pendingChange);
         this._pendingChange = null;
      }
   };

   PageLeftCalculator.prototype.fireBeacon = function ()
   {
       this._analyticsProcessor.processPageBeacon({ page: this._lastChange.page, totalPageCount: this._pageCount });
   };
}
(
vitrium.analytics,
_));

// script:viewer/analytics/analytics-processor.js
/// <reference path="~/build.html" />

(function (exports, analytics, async, log,$) {
   "use strict";

   exports.AnalyticsProcessor = AnalyticsProcessor;
   var SYNC_AFTER_FAIL = 30 * 1000;

   function AnalyticsProcessor(url, storage)
   {
      this._url = url;
      this._acceptedEvents = [];

      this._storage = storage !== null ? new ObjectStore(storage) :  new DummyStore();
      this._trackSession = analytics.UUID.generate();
      this._repeatSyncTimer = null;
   }

   AnalyticsProcessor.prototype.setAcceptedEvents = function (events) {
      this._acceptedEvents = events;
   };

   AnalyticsProcessor.prototype.init = function () {
      this._restoreSync();
   };

   AnalyticsProcessor.prototype.processPageLeft = function (event)
   {
      log.debug("[AnalyticsProcessor] page-left ", event.page, event.duration, "=>", event.destinationPage);
      this._notifyServer(this._trackSession, "page-left", event, false);
   };

   AnalyticsProcessor.prototype.processPageBeacon = function (event)
   {
      log.debug("[AnalyticsProcessor] page-beacon ", event.page);
      this._notifyServer(this._trackSession, "page-beacon", event, true);
   };

   AnalyticsProcessor.prototype.processViewerOpened = function () {
       log.debug("[AnalyticsProcessor] viewer-opened ");
       this._notifyServer(this._trackSession, "viewer-opened", null, true);
   };


   AnalyticsProcessor.prototype._notifyServer = function (trackId, eventName, event, canFail) {
      var eventObject = {
         time: Date.now(),
         trackId: trackId,
         eventName: eventName,
         data: event
      };

      this._postEvents([eventObject], true, canFail);
   };

   AnalyticsProcessor.prototype._handleFailedNotification = function (events) {
      var self = this;
      this._storage.add(events).then(function () {
         self._repeatSync();
      });
   };

   AnalyticsProcessor.prototype._postEvents = function (events, isNew, canFail) {
      var originalEvents = events;
      events = _.filter(events, function (e) { return this._acceptedEvents.indexOf(e.eventName) !== -1; }, this);

      var completer = new async.Completer();
      if (events.length !== 0)
      {
         if (this._repeatSyncTimer !== null && isNew) {
            log.debug("[AnalyticsProcessor] _postEvents buffering mode");
            this._handleFailedNotification(events);
            
            _.defer(function () { completer.complete(); });
         }
         else {
            var self = this;
            $.ajax({
               type: "POST",
               url: this._url,
               data: JSON.stringify(events),
               dataType: "json"
            })
            .success(function () {
               completer.complete();
            })
            .fail(function (e) {
               if (!canFail) {
                  self._handleFailedNotification(events);
               }
               completer.fail(e);
            });

         }
      }
      else
      {
         if (originalEvents.length !== 0)
            log.debug("[AnalyticsProcessor] all events were filtered out");

         _.defer(function () { completer.complete(); });
      }

      return completer.future;
   }

   AnalyticsProcessor.prototype._restoreSync = function () {
     if (this._repeatSyncTimer !== null)
       clearTimeout(this._repeatSyncTimer);

     this._repeatSyncTimer = null;

      var self = this;
      this._storage.getAndRemove().then(function (events) {
         if (events.length !== 0) {
            self._postEvents(events, false, true).then(function () {
               // make sure that everything is synced
               self._restoreSync();
            });
         }
      });
   };

   AnalyticsProcessor.prototype._repeatSync = function () {
      if (this._repeatSyncTimer === null)
      {
         this._repeatSyncTimer = setTimeout(_.bind(this._restoreSync, this), SYNC_AFTER_FAIL);
      }
   };

   function ObjectStore(storage) {
      this._storage = storage;
   }

   ObjectStore.prototype.add = function (events) {
      var completer = new async.Completer();
      this._storage.transaction(function (tx) {
         // save it back to db
         _.each(events, function (e) { tx.put(e); });

         tx.future
            .chainSuccess(completer)
            .chainError(completer);
      });

      return completer.future;
   };

   ObjectStore.prototype.getAndRemove = function () {
      var completer = new async.Completer();
      this._storage.transaction(function (tx) {
         tx.getAll().then(function (events) {
            if (events.length !== 0) {
               events.sort(function (a, b) {
                  if (a.time < b.time) return -1;
                  if (a.time > b.time) return 1;
                  return 0;
               });

               // remove from db during synchronization
               // data loss is not as important as not synchronize multiple events twice
               _.each(events, function (e) {
                  tx.remove(e.rowid);
               });  
            }

            completer.complete(events);
         });

         tx.future.chainError(completer);
      });

      return completer.future;
   };


   function DummyStore()
   {
      this._data = [];
   }

   DummyStore.prototype.add = function (events) {
      var completer = new async.Completer();
      var self = this;
      async.callDefered(function () {
         _.each(events, function (e) { self._data.push(e); });

         completer.complete();
      });

      return completer.future;
   };

   DummyStore.prototype.getAndRemove = function () {
      var completer = new async.Completer();
      var self = this;
      async.callDefered(function () {
         var data = self._data;
         self._data = [];

         completer.complete(data);

      });

      return completer.future;
   };
}
(vitrium.analytics,
vitrium.analytics,
vitrium.async,
vitrium.log,
jQuery
));

// script:viewer/side-toolbar-counted-guard.js
/// <reference path="~/build.html" />

(function (exports, ui)
{
  "use strict";

  exports.SideToolbarCountedGuard = SideToolbarCountedGuard;

  /**
    Assume that containerWidget has BasicLayoutManagerAttached
  */
  function SideToolbarCountedGuard(containerWidget)
  {
    this.left = new SinglePanelGuard(containerWidget, "left");
    this.right = new SinglePanelGuard(containerWidget, "right");
    this.bottom = new SinglePanelGuard(containerWidget, "bottom");
  }


  function SinglePanelGuard(containerWidget, direction)
  {
    this._containerWidget = containerWidget;
    this._direction = direction;
    this._counter = 0;

    this._sidePanel = new ui.SideToolbar();
  }

  SinglePanelGuard.prototype = {
    incRef : function()
    {
      if (this._counter == 0)
      {
        this._containerWidget.layoutManager[this._direction] = this._containerWidget.add(this._sidePanel);
      }

      ++this._counter;
      
      return this._sidePanel;
    },
    decRef: function()
    {
      --this._counter;

      if (this._counter < 0)
      {
        this._counter = 0;
        throw new Error("Unable to decRef! The count does not match");
      }

      if (this._counter === 0)
      {
        this._containerWidget.remove(this._sidePanel);
        this._containerWidget.layoutManager[this._direction] = null;
      }
      return this._sidePanel;
    }
  };



}
(
vitrium.viewer,
vitrium.ui));

// script:viewer/fullscreen-controller.js
/// <reference path="~/build.html" />

(function (exports) {
   "use strict";

   var de = document.documentElement;
   var requestFullscreen = de.webkitRequestFullscreen || de.mozRequestFullScreen || de.requestFullscreen;
   if (requestFullscreen)
   {
      requestFullscreen = _.bind(requestFullscreen, de);
   }

   exports.FullScreenController = FullScreenController;
   exports.isFullScreenSupported = !!requestFullscreen;

   function FullScreenController(el)
   {
      this.el = el;
   }

   FullScreenController.prototype.requestFullScreen = function () {
      if (exports.isFullScreenSupported)
      {
         toggleFullScreen(this.el);
      }
      else
      {
         throw new Error("FullScreen API is not supported!");
      }
   };

   function toggleFullScreen(el) {
      if (!document.fullscreenElement &&    // alternative standard method
          !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {  // current working methods
         if (document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen(el);
         } else if (document.documentElement.msRequestFullscreen) {
            document.documentElement.msRequestFullscreen(el);
         } else if (document.documentElement.mozRequestFullScreen) {
            document.documentElement.mozRequestFullScreen(el);
         } else if (document.documentElement.webkitRequestFullscreen) {
            document.documentElement.webkitRequestFullscreen(el);
         }
      } else {
         if (document.exitFullscreen) {
            document.exitFullscreen();
         } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
         } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
         } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
         }
      }
   }

}
(vitrium.utils));

// script:viewer/webviewer-ui.js
/// <reference path="~/build.html" />

(function (exports, vitrium, v, utils, ui, log)
{
  "use strict";

  exports.WebViewerUI = WebViewerUI;

  function WebViewerUI()
  {
    this.dynamicEnv = null;
    this.serviceCaller = null;
 
    this.annotationsRelatedInstances = null;
    var glyphRectangleStorage = new v.TextFlowRectangleStorage();
    var glyphRectangleProcessorFactory = new v.GlyphsToRectanglesProcessorFactory(glyphRectangleStorage);

    var linksRectangleStorage = new v.RectangleStorage();
    var refNamesRectangleStorage = new v.RectangleStorage();
    var linkRectangleProcessorFactory = new v.LinkRectangleProcessorFactory(linksRectangleStorage, refNamesRectangleStorage);

    var uiLoop = this._uiLoop = new ui.UILoop({});
    var root = this._root = new ui.RootContainerWidget(this._uiLoop);
    var layoutManager = root.layoutManager = new ui.BasicLayoutManager(root);
    var sideToolbars = this.sideToolbars = new v.SideToolbarCountedGuard(root);
     

    var dViewer = this.viewer = new v.DocumentViewer({
      layers: [
        glyphRectangleProcessorFactory.getInstance,
        linkRectangleProcessorFactory.getInstance
      ]
    });

    var cursorModel = this.cursorModel = new v.CursorModel();
    new v.CursorView(dViewer, this.cursorModel);

    var textSelectionModel = this._textSelectionModel = new v.TextSelectionModel();
    var textSelectionController = this._textSelectionController = new v.TextSelectionController(glyphRectangleStorage, dViewer, textSelectionModel);

    dViewer.textSelectionModel = textSelectionModel;
    dViewer.textSelectionController = textSelectionController;

    new v.events.PinchToZoom(dViewer);
    new v.events.JoystickScroll(dViewer);
    new v.events.MouseScrollbar(dViewer);
    new v.events.TouchTextSelection(dViewer, textSelectionController, textSelectionModel, 4);
    new v.events.TouchScrollbar(dViewer);
    new v.events.TouchScroll(dViewer);
    new v.events.MouseTextSelection(dViewer, textSelectionController);
    new v.events.MouseWheelScroll(dViewer);
    new v.events.KeyScroll(dViewer);



    layoutManager.center = root.add(dViewer);
    new v.LinkController(linksRectangleStorage, refNamesRectangleStorage, dViewer, cursorModel);

    var searchModel = new v.SearchModel();
    var searchController = new v.SearchController(searchModel, glyphRectangleStorage, dViewer);

    var toolsModel = new v.MenuItemsModel();
    var defaultChoices = [{ id: "search", title: "Search", icon: "<i class='fa fa-search'></i>" }];
    if (utils.isFullScreenSupported) {
       defaultChoices.push({ id: "request-fullscreen", title: "Fullscreen", icon: "<i class='fa fa-arrows-alt'></i>", priority: -1, toolHidden: 1|2 });
       var fullScreenController = new utils.FullScreenController(root.el);

       toolsModel.on("action:request-fullscreen", function () {
          root.broadcastEvent("action:HideToolsMenu");
          fullScreenController.requestFullScreen();
       });
    }
    toolsModel.set("defaultChoices", defaultChoices);


    this.toolbar = new v.Toolbar(dViewer, {
      controller: searchController,
      model: searchModel
    }, toolsModel);

    if (utils.isFullScreenSupported) {
       var fullscreenBtn = $('<button class="btn" title="Fullscreen" type="button"><i class="fa fa-arrows-alt"></i></button>')
          .appendTo(this.toolbar.scaleControls.$el);

       fullscreenBtn.on("tap click", function () {
          toolsModel.trigger("action:request-fullscreen");
       });
              
    }

    
    var search = new v.SearchControls(searchController, searchModel, dViewer);
    root.add(search);


    toolsModel.on("action:search", function () {
       root.broadcastEvent("action:HideToolsMenu");
       search.searchClicked();       
    });

    layoutManager.top = root.add(this.toolbar);


  //  left.addPanel(new v.ThumbnailsPanel());
    
    //left.addPanel(new v.BookmarksPanel());
   // left.addPanel(new ui.LabeledSidePanel(ui.icon("pencil"), "pen"));

    var watermarksModel = this.watermarksModel = new v.WatermarksModel();

    dViewer.addCanvasLayer(new v.RectangleRendererLayer(searchModel, "result", "changed"));
    dViewer.addCanvasLayer(new v.RectangleRendererLayer(textSelectionModel, "selection", "changed"));
    dViewer.addCanvasLayer(new v.RectangleRendererLayer(textSelectionModel, "queryRect"));
    dViewer.addCanvasLayer(new v.WatermarksLayer(dViewer, watermarksModel));
    dViewer.addCanvasLayer(new v.TextSelectionTouchHandlesLayer(textSelectionModel, 4));


    dViewer.initUI();

    

    if (vitrium.is_mobile)
    {
      dViewer.changeDocumentRenderer(v.CanvasDocumentRenderer);
    }

    dViewer.on("document:detached", function (doc)
    {
      setTimeout(function ()
      {
        doc.destroy();
      }, 0);
    });

    dViewer.on("document:attached", function (doc)
    {
       doc.on("document-outline:loaded", function (outline) {
          var sideToolbar = sideToolbars.left.incRef();
          var model = new v.BookmarksListModel(outline);

          var bookmarksPanel = sideToolbar.addPanel(new v.BookmarksPanel(model), 3);
          dViewer.on("change:viewport", onViewportChanged);

          dViewer.on("document:detached", function destroyBookmarks() {
             sideToolbars.left.decRef().removePanel(bookmarksPanel);
             dViewer.off("document:detached", destroyBookmarks);
             dViewer.off("change:viewport", onViewportChanged);
          });
          function onViewportChanged(dirty, pages) {
             //  var pageNumbers = _.pluck(pages, "number");
             model.setVisiblePages(pages);
          }
       });

       doc.on("page:loaded", function initialPageLoaded(idx, page, status) {
             uiLoop.trigger("initialPageLoaded", doc);
             doc.off("page:loaded", initialPageLoaded);
       });

    });

    this._uiLoop.on("viewer:focused", function ()
    {
      //I have to delay it because of annotation selection depends on it
      setTimeout(function () { dViewer.broadcastEvent("action:ClosePanelIfDetached"); }, 0);      
    });

    this._copyFakeView = null;

    new v.PageSaver(dViewer);
   // this.initAnnotations();
   // setTimeout(_.bind(function () { this._root.refresh(); }, this), 1000);
  }

  WebViewerUI.prototype = {
   get eventHub()
   {
      return this._uiLoop;
   }, 
    get el()
    {
      return this._root.el;
    },
    get textCopyEnabled()
    {
      return this._copyFakeView !== null;
    },
    set textCopyEnabled(copyEnabled)
    {
      if (copyEnabled && !this.textCopyEnabled)
      {
        this._copyFakeView = new v.CopyFakeView(this.viewer, this._textSelectionModel, this._textSelectionController);
      }
      else if (!copyEnabled && this.textCopyEnabled)
      {
        this._copyFakeView.destroy();
        this._copyFakeView = null;
      }
    },
    get annotationsEnabled()
    {
        return this.annotationsRelatedInstances !== null;
    },
    set annotationsEnabled(enabled)
    {
        if (this.annotationsEnabled && !enabled)
        {
            this.destroyAnnotations();
        }
        else if (!this.annotationsEnabled && enabled)
        {
            this.initAnnotations();
        }
    },
    destroy : function()
    {
      this.viewer.destroy();
      this._root.destroy();
      this._uiLoop.destroy();
      var parent = this.el.parentElement;
      if (parent !== null)
      {
        parent.removeChild(this.el);
      }
    },
    executeAction: function(name)
    {
      this._root.broadcastEvent("action:" + name);
    },
    showToolsMenu: function ()
    {
      this.executeAction("ShowToolsMenu");
    },
    hideToolsMenu : function()
    {
      this.executeAction("HideToolsMenu");
    },
    downloadCurrentDocument : function()
    {
      this.executeAction("DownloadCurrentDocument");
    },
    updateUiAfterDomChange : function()
    {
       this._root.refresh();
    },
    showDismissBox : function()
    {
      var args = [this.viewer];
      for (var i = 0, len = arguments.length; i < len; ++i)
      {
        args.push(arguments[i]);
      }

      return v.showDismissBox.apply(this, args);
    },
    destroyAnnotations : function()
    {       
        if (this.annotationsRelatedInstances !== null)
        {
            _.each(this.annotationsRelatedInstances, function (instance)
            {
                if ("destroy" in instance) instance.destroy();
                if ("off" in instance) instance.off();
            });

            _.each(this, function (instance, key)
            {
                if (this.annotationsRelatedInstances.indexOf(instance) !== -1)
                {
                    this[key] = null;
                }
            }, this);

            this.sideToolbars.left.decRef();
        }
      this.annotationsRelatedInstances = null;
    },
    initAnnotations  : function()
    {
      var sidePanel = this.sideToolbars.left.incRef();
      var d = this.annotationsRelatedInstances = [];
      var model = this.annotationsModel = new utils.HistoryModel(new v.AnnotationsModel());
      d.push(model);

      var selectionModel = new v.AnnotationSelectionModel();
      d.push(selectionModel);

      this.annotationControllerModel = new v.AnnotationsControlerModel(null, this.viewer.textSelectionModel);
      d.push(this.annotationControllerModel);

      this.annotationController = new v.AnnotationsController(this.viewer, this.annotationControllerModel, this.annotationsModel);
      d.push(this.annotationController);

      // this has circular reference so we should figure out how to avoid it
      this.annotationControllerModel.annotationsController = this.annotationController;

      d.push(new v.NotesInteractionController(this.viewer, this.annotationsModel, selectionModel, this.annotationController, this.cursorModel));

      var annotationsLayer = new v.AnnotationsLayerView(this.annotationsModel, this.viewer, selectionModel);
      this.viewer.addCanvasLayer(annotationsLayer);
      d.push(annotationsLayer);
      d.push({ destroy: _.bind(function () { this.viewer.removeCanvasLayer(annotationsLayer); }, this) });

      d.push(new v.AnnotationsActionCursorView(this.viewer, this.annotationControllerModel, this.cursorModel));
      
      var panels = [];
      var highlightPanel = new v.HighlightPanel(this.annotationController, this.annotationControllerModel);
      panels.push(sidePanel.addPanel(highlightPanel));
      panels.push(sidePanel.addPanel(new v.NotesPanel(this.annotationController, this.annotationControllerModel, this.annotationsModel, selectionModel)));

      d.push({
        destroy: function ()
        {
          _.each(panels, function (p) { sidePanel.removePanel(p); });
        }
      });


      var historyControls = ui.ContainerWidget.prototype.add.call(sidePanel.toolbar,new v.HistoryControls(model));
      historyControls.dim = historyControls.dim;

      d.push({
        destroy: function ()
        {
          sidePanel.toolbar.remove(historyControls);
        }
      });

      var selectedTextActionBar = new vitrium.viewer.SelectedTextActionBar();
      var wasActive = false;
      this.viewer.textSelectionModel.on("changed", onSelectionChanged, this);

      this._uiLoop.on("viewer:focused", onViewerFocused, this);

      this._uiLoop.on("action:text-selection-done", this.viewer.textSelectionController.cancelSelection, this.viewer.textSelectionController);
      this._uiLoop.on("action:text-selection-highlight", highlightAfterTextSelection, this);

      d.push({
          destroy: _.bind(function ()
          {
              this.viewer.textSelectionModel.off("changed", onSelectionChanged, this);
              this._uiLoop.off("viewer:focused", onViewerFocused, this);
              this._uiLoop.off("action:text-selection-done", this.viewer.textSelectionController.cancelSelection, this.viewer.textSelectionController);
              this._uiLoop.off("action:text-selection-highlight", highlightAfterTextSelection, this);

          }, this)
      });


      this.annotationControllerModel.on("change:activatedAction", function (model, val)
      {
        if (selectionModel.get("selected") !== null && val !== null)
        {
          selectionModel.select(null);
        }
      }, this);

      this.annotationControllerModel.on("click:toolSelection", closeIfPanelIsDetached);
      this.annotationControllerModel.get("colorSelectorModel").on("click:colorSelection", closeIfPanelIsDetached);

      selectionModel.on("change:selected", function (model, val)
      {
        if (val !== null)
        {
          this.annotationController.deactivate();
        }
      }, this);

      function highlightAfterTextSelection()
      {
          this.viewer.textSelectionController.finish();
          this.annotationController.activate("texthighlight", this.annotationControllerModel.get("colorSelectorModel"));
          this.annotationController.deactivate();
      }
      function onViewerFocused()
      {
          if (sidePanel.isOpenDetached())
          {
              sidePanel.closePanelIfDetached();
          }
          else
          {
              selectionModel.select(null);
          }        
      }

      function onSelectionChanged(pages, active)
      {
          setTimeout(_.bind(function ()
          {
          
              if (!wasActive && active)
              {
                  if (this.viewer.textSelectionModel.get("mode") === this.viewer.textSelectionModel.MODE.TOUCH)
                  {
                      this.toolbar.showActionBar(selectedTextActionBar);
                      wasActive = true;
                  }
              }
              else if (wasActive && !active)
              {
                  this.toolbar.showStatusView();
                  wasActive = false;
              }
          }, this), 0);
        
      }

      function closeIfPanelIsDetached()
      {
        sidePanel.broadcastEvent("action:ClosePanelIfDetached");
      }

      var serviceCaller = this.serviceCaller;
      if (serviceCaller)
      {
        var queueId = window.location.pathname;

        if (!this.dynamicEnv)
        {
            log.warn("Set dynamicEnv property on WebViewerUI object instance to enable annotation synchronization.");
        }
         else
        {
           queueId = this.dynamicEnv.getDbContextId();
        }

        var sync = new v.AnnotationServiceSync(model, serviceCaller, queueId);
        d.push(sync);
        
        sync
        .on("error:sync", function ()
        {
         // sync.cancelSync();
        }, this)
        .on("model:refresh", function ()
        {
          if (this.dynamicEnv)
          {
            this.dynamicEnv.refresh("Annotation.describe");
          }
        }, this)
        .on("model:synced", function (model)
        {
          if (this.dynamicEnv)
          {
            this.dynamicEnv.store("Annotation.describe", model).then(function () { log.debug("annotations saved");});;
          }
        }, this);
        this.annotationsSync = sync;

        this._root.layoutManager.center.add(new ui.SyncDisplay(sync));

      }
      else
      {
          log.warn("Set serviceCaller property on WebViewerUI object instance to enable annotation synchronization.");
      }

      
    }
  };


}
(
vitrium.viewer,
vitrium,
vitrium.viewer,
vitrium.utils,
vitrium.ui,
vitrium.log));

// script:viewer/public-api-actions.js
(function(exports)
{
  "use strict";
  exports.validateServerActions = validateServerActions;
  exports.validateServerAction = validateServerAction;
  exports.executeAction = executeAction;
  
	function validateServerAction(action)
	{
		if (_.isFunction(action))
		{
			return action;
		}
		else	if (action === "refresh")
		{
			return action;
		}
		else if (action.indexOf("redirect:") === 0)
		{
			return action;
		}
		
		vitrium.log.warn("specified action is not supported! (" +action+")");
		return null;
	}
	
	function validateServerActions(actions)
	{
		_.each(actions, function (value, key)
		{
			actions[key] = validateServerAction(value);
		});
		
		return actions;
	}
	
	function executeAction(defaultAction, actions, code)
	{
		var action = actions ? actions[code] || defaultAction : defaultAction;
		if (_.isFunction(action))
		{
			action(code);
		}
    else if (action === "refresh")
		{
			window.location.reload();
		}
		else if (action.indexOf("redirect:") === 0)
		{
			var url = action.substring(9, action.length);
			window.location = url;
		}
		
	}
}
(vitrium.actions));
// script:viewer/exception-handler.js
/// <reference path="~/build.html" />

(function (exports, actions, i18n, ui, io, asyncStorage)
{
  "use strict";

  exports.ExceptionHandler = ExceptionHandler;
  function ExceptionHandler(viewerUI, options)
  {
    this._viewerUI = viewerUI;

    this._alwaysTreatHttp404AsError = !!options.alwaysTreatHttp404AsError;
    this._defaultActionForServerError = actions.validateServerAction(options.defaultActionForServerError || "refresh");
    this._expiredDocumentDeletedAction = actions.validateServerAction(options.expiredDocumentDeletedAction || "refresh");
    this._actionsForServerErrors = actions.validateServerActions(_.isObject(options.actionsForServerErrors) ? actionsForServerErrors : {});

    this._globalErrorHandler = _.isFunction(options.globalServerErrorHandler) ? options.globalServerErrorHandler : function () { return false; };

    this._fileSystemContext = null;
    this._errorBox = null;
    this._fileSystemEventGuard = new ui.EventLifecycleManager();
    this._documentEventGuard = new ui.EventLifecycleManager();
    this._documentModel = null;
    this._wasDownloaded = false;
    this._wasChanged = false;

  }

  ExceptionHandler.prototype =
  {
    bindFileSystemContext: function (fileSystemContext)
    {
      this.unBindFileSystemContext();
      this._fileSystemContext = fileSystemContext;

      this._fileSystemEventGuard
        .on(fileSystemContext, "fileSystem:error", this.onServerError, this)
        .on(fileSystemContext, "fileSystem:changed", this.onFileSystemChanged, this);
    },
    unBindFileSystemContext: function()
    {
      if (this._fileSystemContext !== null)
      {
        this._fileSystemEventGuard.offAll();
        this._fileSystemContext.destroy();
        this._fileSystemContext = null;
      }      
    },
    bindDocumentModel : function(documentModel)
    {
      this.unBindDocumentModel();
      this._documentModel = documentModel;
      this._documentEventGuard
        .on(documentModel, "loading:error", this.onDocumentLoadingFailed, this)
        .on(documentModel, "info:loaded", this.onInfoLoaded, this)
        .on(documentModel, "offline-invalidated", this.onOfflineStorageInvalidated, this);
    },
    unBindDocumentModel : function()
    {
      this._documentEventGuard.offAll();
      this._documentModel = null;
    },
    onDocumentLoadingFailed : function(code)
    {
      // document info, this will display an error only if it was not caused by the connection
      if (code === 2) this.onServerError(code);
    },
    onServerError : function(type, code)
    {
      switch(type)
      {
        case "init":
          this._displayErrorBox(code);
          break;
         case "server":
            if (!this._globalErrorHandler(code)) {
               if (code == 404 && this._alwaysTreatHttp404AsError) {
                  this._displayErrorBox(code);
               }
               else if (code !== 404 && code !== 0) {
                  if (code == 401 || code == 403 || code == 409) {
                     this._eraseLocalStorage();
                  }
                  this._displayErrorBox(code);
               }
               else {
                  this._displayErrorIfDocumentIsAvailableOffline(code);
               }
            }
          break;
        case "package":
          this._displayErrorBox(code);
          break;
        default:
          this._displayErrorBox(type + "-" + code);
          break;
      }

    },
    _eraseLocalStorage: function()
    {
       asyncStorage.eraseLocalData(Date.now(), function () {}, function(){});
    },
    _displayErrorIfDocumentIsAvailableOffline: function (code)
    {
      if (this._errorBox === null)
      {
        var self = this;
        var cache = this._fileSystemContext.cacheManager.openCache(this._fileSystemContext.url, function ()
        {
          if (cache.downloadState !== io.CACHE_STATE.DOWNLOADED)
          {
            self._displayErrorBox(code);
          }
        },
        function ()
        {
          self._displayErrorBox(code);
        });
      }
      
    },
    _displayErrorBox : function(reason)
    {
      if (this._errorBox === null)
      {
         var self = this;
        //HACK -> I treat 403 as a info message - because I use it as SSO related message
        var box = this._errorBox = this._viewerUI.showDismissBox(reason === 403 ? "info" : "error",
          i18n._TG("server-error-message-title", [reason]),
          i18n._TG("server-error-message", [reason]),
          {
            buttons: [
              {
                id: "close",
                title: i18n._TG("server-error-button-title", [reason]),
                cssClass: "btn-primary"
              }]
          });

        box.on("button:close", function ()
        {
          self._errorBox = null;
          actions.executeAction(self._defaultActionForServerError, self._actionsForServerErrors, reason);
        });
      }
    },
    onKeyDerivationError : function()
    {
      this._displayErrorBox("key-derivation");
    },
    onFileSystemChanged : function(source)
    {
      if (!this._wasChanged)
      {
        this._wasDownloaded = this._fileSystemContext.tryToGetDownloaded();

        if (source === "package")
        {
          this._wasChanged = true; //this flag is read in onInfoLoaded method
          this._documentModel.trigger("reload-requested");
        }
        else if (source === "cache-verification" && this._wasDownloaded)
        {
          this.onDocumentChanged(true);
        }
      }
    },
    onInfoLoaded : function()
    {
   //   console.log(this._documentModel.fileProvider().listFilesForDownload());
      if (this._wasChanged)
      {
        this._wasChanged = false;
        this.onDocumentChanged(this._wasDownloaded);
        this._wasDownloaded = false;
      }
    },
    onDocumentChanged : function(wasDownloaded)
    {
      if (wasDownloaded)
      {
        var box = this._viewerUI.showDismissBox("warn",
          i18n._T("message-document-updated-title"),
          i18n._T("message-document-updated-previous-copy-deleted"),
          {
            buttons: [
              { id: "close", title: i18n._T("document-updated-dont-save-button") },
              { id: "save", title: i18n._T("document-updated-save-button"), cssClass: "btn-primary" }
            ]
          });

          var self = this;
          box.on("button:save", function (evt)
          {
            evt.preventDefault();
            box.hide();
            self._viewerUI.downloadCurrentDocument();
          });
      }
      else
      {
        this._viewerUI.showDismissBox("warn",
          i18n._T("message-document-updated-title"),
          i18n._T("message-document-updated"));
      }
    },
    onOfflineStorageInvalidated : function(wasDeleted)
    {
      if (wasDeleted)
      {
        var expiredDocumentDeletedAction = this._expiredDocumentDeletedAction;
        var box = this._viewerUI.showDismissBox("info",
          i18n._T("web-viewer-deleted-expired-document-title"),
          i18n._T("web-viewer-deleted-expired-document"),
         {
           buttons: [{
             id: "close",
             title: i18n._T("web-viewer-deleted-expired-document-button"),
             cssClass: "btn-primary"
           }]
         });

        var self = this;
        box.on("button:close", function ()
        {
           self._errorBox = null;
           actions.executeAction(expiredDocumentDeletedAction);
        });

        this._errorBox = box;
      }
    },
    onApplicationUpdated : function()
    {
      var box = this._viewerUI.showDismissBox("info",
        i18n._T("web-viewer-updated-title"),
        i18n._T("web-viewer-updated"),
         {
           buttons: [
             {
               id: "close",
               title: i18n._T("web-viewer-updated-button"),
               cssClass: "btn-primary"
             }]
         });
        box.on("button:close", function ()
        {
          window.location.reload();
        });
    }
  };

}
(
vitrium.viewer,
vitrium.actions,
vitrium.i18n,
vitrium.ui,
vitrium.io,
vitrium.utils.asyncStorage
));
// script:viewer/password-provider.js
/// <reference path="~/build.html" />

(function (exports, Backbone, _) {
   "use strict";
   exports.PasswordProvider = PasswordProvider;

   function PasswordProvider(exceptionHandler, globalEventHub) {
      this._exceptionHandler = exceptionHandler;
      this._globalEventHub = globalEventHub;
      this._pwdAttempt = 0;

      this.password = null;
   }

   PasswordProvider.prototype.requestNewPassword = function (callback) {
      var self = this;
      this.password = null;
      if (this._pwdAttempt !== 0) this.trigger("invalidPassword");

      this._globalEventHub.trigger("documentPasswordRequested", _pwdSetter, this._pwdAttempt++);
      function _pwdSetter(pwd) {
         self.setCurrentPwd(pwd);
         callback(pwd);
      }
   };

   PasswordProvider.prototype.reportKeyDerivationError = function (e) {
      this._exceptionHandler.onKeyDerivationError(e);
   };

   PasswordProvider.prototype.setCurrentPwd = function (pwd) {
      this.password = pwd;
      this.trigger("passwordEntered", pwd);
   };
   _.extend(PasswordProvider.prototype, Backbone.Events);


}
(vitrium.viewer,
 Backbone,
 _
));

// script:viewer/public-api.js
/// <reference path="~/build.html" />
(function(exports, vitrium, _, Backbone, $)
{
  "use strict";
   exports["WebViewer"] = WebViewer;
   //vitrium.log.setLevel(0);
  
   var viewer = vitrium.viewer;
   var events = viewer.events;
  
  var ArgumentsModel = Backbone.Model.extend({
    defaults : 
    {
      lang : "en-US",
      documentUrl: null, 
      documentId: null,
      documentObject: null,
      encryptionKey: null
    }
  });
  
  var SafeArgumentsModel = Backbone.Model.extend({
    defaults : 
    {
      cacheEnabled : false,
      communicationUrl: null,
      rsaModulus : null,
      rsaExponent : null,
      offlineExpiryDate: null,
      copyEnabled: false,

      annotationsEnabled: false,
      printEnabled: false,
      analyticsEvents: null
    }
  });
  
   _.extend(WebViewer.prototype, Backbone.Events);
  function WebViewer(id, options)
   {
      document.body.style.overflow = "hidden";
    var completer = new vitrium.service.Completer();
    completer.future
    .then(_.bind(function()
    {
       this.trigger("initialized", this);
    }, this))
    .catchError(_.bind(function()
    {
      this.trigger("initialization-failed", this);
    }, this));
    
    var viewerUI = new viewer.WebViewerUI();
     //
    var exceptionHandler = new viewer.ExceptionHandler(viewerUI, options);

    if (_.isNumber(options.loggingLevel))
    {
       vitrium.log.setLevel(options.loggingLevel);
    }
     
    viewerUI._uiLoop.on("initialPageLoaded", function () {
       this.trigger("initialPageLoaded");
    }, this);

    updateDOM(id, viewerUI.el);

   var documentInfoFields = ["title", "author", "publisher"];
    if (_.isArray(options.documentInfoFields))
   {
      documentInfoFields.push.apply(documentInfoFields, options.documentInfoFields);
   }

    var dViewer = viewerUI.viewer;
    if (options.analyticsUrl)
        initAnalytics(dViewer, options.analyticsUrl);

    var watermarksModel = viewerUI.watermarksModel;
    
    var openedDocument = null;
    var openedDocumentUrl = null;
    var checkForFileChangesInterval = null;

    var args = new ArgumentsModel();
    var safeArgs = new SafeArgumentsModel();
    var textSelectionModel = null;
    var textSelectionController = null; 

    var remoteDocumentInfo =  createDocumentInfo(options);
    var copyCtrl = null;
    var serviceCaller = null;
    var metadata = {};
    var dynamicEnv = null;
    init.call(this, id, options);
    
    
    var loadDocument = _.bind(this.loadDocument, this);
    var shInit = 0;
    var showToolsMenu = _.bind(function()
    {
     dViewer.initDocumentRenderer();
      this.showToolsMenu();	
    }, this);
    
    var pollAgent = null;
    safeArgs.on("change:copyEnabled", function (model, val)
    {
      viewerUI.textCopyEnabled = val;
    });
    setOptions(options);

    safeArgs.on("change", _.bind(function () {
       setTimeout(_.bind(function () {
          this.trigger("envChanged", safeArgs.toJSON());
       }, this), 0);
    }, this));

    var triggerInfoChanged = _.bind(function (info) {
       this.trigger("infoChanged", info);
    }, this);
    
    new vitrium.viewer.OfflineStorageGuard(safeArgs, dViewer);
   

    if (safeArgs.has("communicationUrl"))
    {     
      args.on("change:documentUrl", reinit);
           
      this.loadDocument = function(options)
      {
          args.set(_.pick(options, _.keys(ArgumentsModel.prototype.defaults)));
      };
      
      var signatureCalculator = null;
      if (safeArgs.has("rsaModulus") && safeArgs.has("rsaExponent"))
      {
        signatureCalculator = new vitrium.crypto.SignatureCalulator(safeArgs.get("rsaModulus"),safeArgs.get("rsaExponent"));
      }
      /*
      serviceCaller = new vitrium.service.HTTPServiceCaller(
        safeArgs.get("communicationUrl"), 
        signatureCalculator,
        args.get("lang"),
        metadata
        );*/

      serviceCaller = vitrium.viewer.createRestCompatibleServiceCaller(safeArgs.get("communicationUrl"));
      viewerUI.serviceCaller = serviceCaller;
       
      safeArgs.on("change:annotationsEnabled", function (model, val)
      {
          if (!safeArgs.has("communicationUrl") && val)
          {
              vitrium.log.error("Communications URL must be set to enable annotations!")
          }
          else
          {
              viewerUI.annotationsEnabled = val;
              if (val && dynamicEnv !== null)
              {
                  // if annotations got enabled after webviewer initialization it is necessary to refresh it
                  dynamicEnv.refresh("Annotation.describe");
              }
          }
      });

      var analyticsInitialized = false;
      safeArgs.on("change:analyticsEvents", function (model, supportedEvents) {
         if (dViewer.analyticsFuture !== null)
         {
            dViewer.analyticsFuture.then(doInit);
         }
         else
         {
            doInit();
         }

         function doInit()
         {
            dViewer.analyticsProcessor.setAcceptedEvents(_.isArray(supportedEvents) ? supportedEvents : []);
            if (!analyticsInitialized) {
               dViewer.analyticsProcessor.init();
               analyticsInitialized = true;

               // viewer opened one time event
               dViewer.analyticsProcessor.processViewerOpened();
            }
         }
      });

      if (safeArgs.get("annotationsEnabled"))
      {
          safeArgs.trigger("change:annotationsEnabled", safeArgs, true);
      }
      
      pollAgent = new vitrium.viewer.PollAgent(serviceCaller);
      initRemoteEventHandlers.call(this, dViewer, pollAgent);
      pollAgent.on("poll:error", function (e) {
         if (e == 401 || e == 403)
         {
            exceptionHandler.onServerError("server", e);
            // I treat to 401 unauthorized as fatal error (page has to be refreshed)
            pollAgent.destroy();
         }
      });

      safeInit();
    }
    else if (args.has("documentUrl"))
    {
      loadDocument(_.extend(args.toJSON(), safeArgs.toJSON()));
      setTimeout(function(){  completer.complete(); },0);
    }
    else if (args.get("showMenuWhenNoDocument"))
    {
      showToolsMenu();
    }
    
    function reinit()
    {
      clearTimeout(shInit);
      shInit = setTimeout(safeInit, 0);
    }
    
    function safeInit()
    {
      //try { throw new Error(); } catch(e) { console.log(e.stack); }

      vitrium.log.debug("safeInit");
      var initServices = null;
      if (args.has("documentUrl"))
      {
         initServices =  [
            {
               service: "Document", action: "describe", model: { set: setRemoteOptions }, optional: false, updateEvent: "DOCUMENT:SETTINGS_CHANGED", remoteErrorHandler: function (e)
               {
                  exceptionHandler.onServerError("server", e);
               }
            },
            { service : "Document", action : "getWatermarks", model: { set : function(val) { watermarksModel.setWatermarks(val); }}, optional : true, updateEvent: "WATERMARK:CHANGED"},
            { service: "Event", action: "subscribe", model: { set: function (val) { pollAgent.init(val); } }, optional: true },
            {
              service: "Annotation", action: "describe", model: {
                set: function (val)
                {
                  if (val !== null && viewerUI.annotationsEnabled)
                  {
                    viewerUI.annotationsSync.replaceModel(val);
                  }
                }
              }, optional: true, updateEvent: "ANNOTATION:CHANGED", store : true
            }
          ];
      }
      else
      {
        initServices =  [
            { service : "Event", action : "subscribe", model : { set: function(val) { pollAgent.init(val); } }, optional : true}
          ];
      }
      
      if (dynamicEnv)
      {
        dynamicEnv.destroy();
      }
      
      dynamicEnv = new vitrium.viewer.DynamicEnvironment(window.location.toString(), initServices, serviceCaller, pollAgent, args);    
      viewerUI.dynamicEnv = dynamicEnv;

      metadata.documentUrl = args.get("documentUrl");
      if (args.has("documentId")) metadata.documentId = args.get("documentId");
      
      dynamicEnv.init().then(function()
      {
        if (metadata.documentUrl && metadata.documentUrl === args.get("documentUrl"))
        {
          loadDocument(_.extend(args.toJSON(), safeArgs.toJSON()));
          completer.complete();
        }
        else if (!args.has("documentUrl"))
        {
           showToolsMenu();	
           completer.complete();
        }
        safeArgs.trigger("dynamicEnv:initialized", dynamicEnv);
      })
      .catchError(function(e)
      {
        safeArgs.set("offlineExpiryDate", "1970-01-01T00:00:00");
        loadDocument(_.extend(args.toJSON(), safeArgs.toJSON()));

        vitrium.log.warn("Unable to contact webviewer service. Safe mode is active.");
        
        exceptionHandler.onDocumentLoadingFailed(e);
        //viewerUI.showDismissBox( "error", vitrium.i18n._T("web-viewer-service-unable-to-connect-title"), vitrium.i18n._T("web-viewer-service-unable-to-connect"));	
        completer.fail();
       });   
    }
    
    function setOptions(options)
    {
      args.set(_.pick(options, _.keys(ArgumentsModel.prototype.defaults)));
      safeArgs.set(_.pick(options, _.keys(SafeArgumentsModel.prototype.defaults)));
      
      
    }
    
    function setRemoteOptions(options)
    {
        // properties bellow are not allowed to change remotely
      delete options.rsaModulus;
      delete options.rsaExponent;
      delete options.communicationUrl;
      delete options.documentUrl;
      

      setOptions(options);
      
      remoteDocumentInfo = _.pick(options, documentInfoFields);
      if (openedDocument && args.has("documentUrl") && openedDocumentUrl === args.get("documentUrl"))
      {
        openedDocument.setDocumentInfo(remoteDocumentInfo);
      }

      triggerInfoChanged(remoteDocumentInfo);
    }
    
    function init(id, options)
    {
      var alwaysTreatHttp404AsError = !!options.alwaysTreatHttp404AsError;
      var defaultActionForServerError = vitrium.actions.validateServerAction(options.defaultActionForServerError || "refresh");
      var expiredDocumentDeletedAction = vitrium.actions.validateServerAction(options.expiredDocumentDeletedAction || "refresh");
      var actionsForServerErrors  = vitrium.actions.validateServerActions(_.isObject(options.actionsForServerErrors ) ? actionsForServerErrors  : {});
          
         
      if (window.applicationCache) {
        applicationCache.addEventListener('updateready', _.bind(exceptionHandler.onApplicationUpdated, exceptionHandler));
      }
            
      this.destroy = function ()
      {
        if (dynamicEnv) dynamicEnv.destroy();
        if (dViewer) dViewer.destroy();
        if (viewerDOM) viewerDOM.remove();
        if (pollAgent) pollAgent.destroy();

        viewerDOM = null;
        dViewer = null;
        dynamicEnv = null;
        pollAgent = null;
        
        for (var key in this)
        {
          delete this[key];
        }
      };
     
     this.setToolsHook = function(hookFunct)
     {
      viewerUI.eventHub.on("ToolsMenuChange", hookFunct);
     };

     this.onAction = function (actionName, funct) {
         viewerUI.eventHub.on("action:" + actionName, funct);
     };

     this.offAction = function (actionName, funct) {
         viewerUI.eventHub.off("action:" + actionName, funct);
     };

     this.refreshTools = function () {
        viewerUI.eventHub.trigger("menuRefreshRequested");
     };
         
      this.closeDocument = function ()
      {
        openedDocumentUrl = null;
        openedDocument = null;
        dViewer.dettachDocument();
      };

      this.loadDocument = function ld(options)
      {
        viewerUI.hideToolsMenu();

        var fsContext = new vitrium.io.CachableFileSystemContext(options["documentUrl"]);
        fsContext.passwordProvider = new viewer.PasswordProvider(exceptionHandler, this);
         

        if ("cacheEnabled" in options) fsContext.cacheEnabled = options["cacheEnabled"];
        if ("encryptionKey" in options) fsContext.encryptionKey = options["encryptionKey"];

        var packageFs = new vitrium.io.CachableFileSystem(fsContext);
        var documentModel = new viewer.VitriumDocumentModel(packageFs, fsContext);
        documentModel.setDocumentInfo(remoteDocumentInfo);
        var reloadRequestor = _.bind(function ()
        {
          documentModel.off("reload-requested", reloadRequestor);
          ld.call(this, options);
        }, this);

        clearInterval(checkForFileChangesInterval);
        checkForFileChangesInterval = setInterval(function ()
        {
          packageFs.checkForChanges();
        }, 62000);

        

        documentModel.on("reload-requested", reloadRequestor);

        openedDocumentUrl  =  options['documentUrl'];
        openedDocument = documentModel;
        
        dViewer.attachDocument(documentModel);
        exceptionHandler.bindFileSystemContext(fsContext);
        exceptionHandler.bindDocumentModel(documentModel);
      
        

        var page = options["page"];
        if (page)
        {
          documentModel.on("info:loaded" ,function(info)
          {
            var p = Math.min(info.pages.length-1,  Math.max(page-1, 0));
            dViewer.scrollTo(p);				
          });
        }
        
        packageFs.init().then(function ()
        {
          documentModel.load();
        });
      /*  .catchError(function()
        {
          // listening in exeception handler
        });*/
      };
      
      this.getWatermarks = function()
      {
        return watermarksModel.getWatermarks();
      };
      
      this.setWatermarks = function (watermarks)
      {
        watermarksModel.setWatermarks(watermarks);
      };
      
      this.showToolsMenu = function()
      {
        viewerUI.showToolsMenu();
      };
      
      this.showModalDialogBox = function (options)
      {
        
        
        var box = viewerUI.showDismissBox( options.type || "info", 
                  options.title, 
                  options.content,
                  options);	
                  
        return box;
      };
      
      this.getSavedDocumentCount = function (callback)
      {
        if (_.isFunction(callback))
        {
          var cacheManager = vitrium.io.CachableFileSystemContext.getCacheManager();
          cacheManager.init().then(function ()
          {
            cacheManager.getOfflineDownloadedDocumentsCount(callback, error);
          }).
          catchError(error);
        }
        
        function error()
        {
          // there is an error
          callback(0)
        }
      };

      this.eraseStorage = function (callback) {
         vitrium.utils.asyncStorage.eraseLocalData(Date.now(), callback, callback);
      };

      this.updateUiAfterDomChange = function () {
         viewerUI.updateUiAfterDomChange();
      };
    }
   }

    function initRemoteEventHandlers(dViewer, pollAgent)
    {
      new viewer.InteractionChannelHandler(dViewer, pollAgent);
      var getSavedDocumentCount = this.getSavedDocumentCount;
      
      pollAgent.on("APPLICATION:CLEAR_PRIVATE_DATA_REQUESTED", function(data)
      {
        if (_.isNumber(data.eraseId))
        {
          var canceled = dViewer.cancelCurrentStorageAction();
                    
          getSavedDocumentCount (function(count)
          {
            if (count > 0 || canceled)
            {
               viewerUI.showDismissBox( "warn", vitrium.i18n._T("message-documents-erased-title"), vitrium.i18n._T("message-documents-erased"));		
            }
          });
          
          setTimeout(function()
          {
            vitrium.utils.asyncStorage.eraseLocalData(data.eraseId,function(){ vitrium.log.info("local data has been erased"); }, function(){ vitrium.log.error("local data has not been erased"); });
          }, 100);
        }
        else
        {
          vitrium.log.error("APPLICATION:CLEAR_PRIVATE_DATA_REQUESTED must contain the 'eraseId' field.");
        }
      });
    }

    
    function updateDOM(id, uiEl)
    {
      var el = document.getElementById(id);
      if (el === null)
      {
        uiEl.id = id;
        
        var body = document.body;
        var first = body.firstChild;
        if (first === null)
        {
          body.appendChild(uiEl);
        }
        else
        {
          body.insertBefore(uiEl, first);
        }
      }
      else
      {
        el.appendChild(uiEl);
      }     
    }

    function createDocumentInfo(options)
    {
      var documentInfo = {};
      _.each(options, function(val, key)
      {
        if (key === "documentTitle")
        {
          documentInfo.title = val;
        }
        else if (key === "documentAuthor")
        {
          documentInfo.author = val;
        }
        else if (key === "documentPublisher")
        {
          documentInfo.publisher = val;
        }
      });
      
      return documentInfo;
    }
   
    WebViewer.checkBrowserSupport = function(options)
    {	
      var success = options.success;
      var error = options.error;
      if (!success || !error)
      {
        throw new Error("You have to provide a success callback and an error callback");
      }
      vitrium.require(["canvas-woff-support"], success, error);
    };

    function initAnalytics(viewer, url)
    {
       viewer.analyticsFuture = vitrium.utils.ObjectDatabase.open(url)
          .then(initStorage)
          .catchError(function () { initStorage(null); });

       function initStorage(storage)
       {
          viewer.analyticsFuture = null;
          var processor = viewer.analyticsProcessor = new vitrium.analytics.AnalyticsProcessor(url, storage);
          new vitrium.analytics.PageLeftCalculator(viewer, processor);

       }       
    }
}(
__globals__, 
vitrium, 
_, 
Backbone, 
jQuery));
// script:easy-render-api.js
/// <reference path="~/build.html" />

(function (exports, viewer, async)
{
  "use strict";
  
  exports.openDocument = function(url, callback, error, passwordProvider)
  {
       var fsContext = new vitrium.io.CachableFileSystemContext(url);
       if (passwordProvider)
       {
          fsContext.passwordProvider = passwordProvider;
          fsContext.encryptionKey = passwordProvider.encryptionKey;
       }


       var packageFs = new vitrium.io.CachableFileSystem(fsContext);
       var documentModel = new viewer.VitriumDocumentModel(packageFs, fsContext);

       
        documentModel.on("loading:error", error);
        documentModel.on("server:error", error);
        documentModel.on("change:documentInfo", function ()
        {
             callback({ 
               info : documentModel.info, 
               renderPageToCanvas : function (canvas, idx, scale,callback)
               {
                  var fontsReady = false;
                  var pageContent = null;
                  documentModel.on("page-fonts:initialized", function fontsInitialized(pages)
                  {
                     fontsReady = pages[idx];
                     if (fontsReady)
                     {
                        documentModel.off("page-fonts:initialized", fontsInitialized);

                        if (pageContent)
                           renderPage(pageContent);
                     }
                  })

                  documentModel.on("page:loaded", function pageLoaded(idx, page, status)
                  {
                    if (this.idx === idx && page.tagName !== "IMG")
                    {
                       documentModel.off("page:loaded", pageLoaded, this);
                       pageContent = page;
                       if (fontsReady)
                       {
                          renderPage(pageContent);
                       }
                    }
                  },
                  {
                    idx : idx
                  });
                  
                  documentModel.requestPage(idx);

                  function renderPage(page)
                  {
                     var renderer = new viewer.PageRenderer(documentModel, documentModel.fileProvider(), []);
                     renderer.renderPage(canvas, scale, idx, documentModel.info.pages[idx], page, false);
                     callback(canvas, idx);
                  }
               },
               loadPageTextContent: function(idx)
               {
                  var completer = new async.Completer();

                  documentModel.on("textindex:loaded", function (idx, fileArray)
                  {
                     if (idx == this.idx)
                     {
                        documentModel.off("textindex:loaded", null, this);

                        if (fileArray === "no-text")
                        {
                           completer.complete("");
                        }
                        else
                        {
                           var file = fileArray[0].data;
                           
                           for (var i = 0, len = file.length; i !== len; ++i)
                           {
                              var f = file[i];
                              var pageNumber = parseInt(f.page, 10) - 1;
                              if (pageNumber === this.idx)
                              {
                                 completer.complete(f.text);
                                 return;
                              }
                           }
                        }
                     }
                  },
                  {
                     idx : idx
                  });

                  documentModel.requestTextIndexFileForPage(idx);

                  return completer.future;
               }
             });
        });
        
        packageFs.init().then(function () {
           documentModel.load();
        });
  };
}
(
vitrium.easy, 
vitrium.viewer,
vitrium.async));
// script:viewer/aria-viewer.js
/// <reference path="~/build.html" />

(function (exports, easy, Backbone, _) {
   "use strict";

   var ST_DOCUMENT_LOADING = 0;
   var ST_PAGE_LOADING = 1;
   var ST_PAGE_LOADED = 2;
   var ST_ERROR = 3;

   exports.AriaView = AriaView;
   exports.AriaModel = AriaModel;
   exports.AriaController = AriaController;

   function AriaView(model, controller)
   {  
      this._controller = controller;
      this._model = model;
      

      model.on("change:state", this.onStateChanged, this);
      model.on("change:pageImage", this.onPageImageChanged, this);
      this._initUi();
   }

   AriaView.prototype._initUi = function () {
      this.$el = $("<div>");
      this.$toolbar = $("<div id='toolbar' aria-controls='page-content'></div>").appendTo(this.$el);
      this.$status = $("<div id='status' aria-live='polite'></div>").appendTo(this.$el);
      this.$pageContent = $("<div id='page-content' aria-live='polite'></div>").appendTo($("<div id='page-wrapper'></div>").appendTo(this.$el));
      this.$pageImage = $("<div id='page-image'></div>").appendTo(this.$el);
   };

   AriaView.prototype.onPageImageChanged = function () {
      this.$pageImage.empty().append(this._model.pageImage);
   };

   AriaView.prototype.onStateChanged = function () {
      switch (this._model.state)
      {
         case ST_DOCUMENT_LOADING:
            this.$toolbar.empty();
            this.$pageContent.empty();
            this.setStatusText("The document is loading.");
            break;
         case ST_PAGE_LOADING:
            if (this._model.lastState == ST_DOCUMENT_LOADING)
            {
               $("<button type='button' class='btn'>Previous page</button>")
                  .click(_.bind(this._controller.prevPage, this._controller))
                  .appendTo(this.$toolbar);

               $("<button type='button' class='btn'>Next page</button>")
                  .click(_.bind(this._controller.nextPage, this._controller))
                  .appendTo(this.$toolbar).focus();

               
               this.setStatusText("The document contains "+this._model.pageCount+" pages. The page 1 is loading.");
            }
            else
            {
               this.setStatusText("The page " + (this._model.pageIdx + 1) + " is requested.");
            }
            this.$pageContent.empty();
         break;
         case ST_PAGE_LOADED:
            this.setStatusText("The page " + (this._model.pageIdx + 1) + " is loaded.");
            this.$pageContent.empty().append(this._model.pageContent);
            break;
         case ST_ERROR:
            var errorMsg = "The loading of a page has failed!";
            if (this._model.lastState == ST_DOCUMENT_LOADING)
            {
               errorMsg = "The loading of a document has failed!";
            }
               
            this.setStatusText(errorMsg);
            break;
      }
   };

   AriaView.prototype.setStatusText = function (text) {
      this.$status.empty().append($("<p>").text(text));
   };



   function AriaModel()
   {
      this.state = null;
      this.lastState = null;
      this.pageIdx = 0;
      this.pageCount = 0;
      this.pageContent = "";
      this.pageImage = null;
   }
   _.extend(AriaModel.prototype, Backbone.Events);

   AriaModel.prototype.updateState = function(state)
   {
      this.lastState = this.state;
      this.state = state;

      this.trigger("change:state");
   }

   AriaModel.prototype.updatePageImage = function (image) {
      this.pageImage = image;
      this.trigger("change:pageImage");
   }


   function AriaController(model, passwordProvider)
   {
      this._model = model;
      this._doc = null;
      this._passwordProvider = passwordProvider;
   }

   AriaController.prototype.loadDocument = function (url) {
      this._model.updateState(ST_DOCUMENT_LOADING);
      easy.openDocument(url, _.bind(function (doc) {
         this._doc = doc;
         this._model.pageCount = doc.info.pages.length;
      
         this.loadPage(0);
      }, this), _.bind(this.onError, this), this._passwordProvider);
   };

   AriaController.prototype.loadPage = function (idx) {
      this._model.pageIdx = idx;
      this._model.pageContent = "";

      this._model.updateState(ST_PAGE_LOADING);
      
      this._doc.loadPageTextContent(idx)
         .then(_.bind(function (text) {
            this._model.pageContent = $("<p>").text(text).append("<p>End of page</p>");
            this._model.updateState(ST_PAGE_LOADED);
         }, this))
         .error(_.bind(this.onError, this));

      var canvas = document.createElement("canvas");
      var pageInfo = this._doc.info.pages[idx];
      canvas.width = pageInfo.width | 0;
      canvas.height = pageInfo.height | 0;

      this._doc.renderPageToCanvas(canvas, idx, 1.0, _.bind(function () {
         this._model.updatePageImage(canvas);
      }, this));
   };

   AriaController.prototype.nextPage = function() {
      var idx = Math.min(this._model.pageIdx + 1, this._model.pageCount - 1);
      if (idx !== this._model.pageIdx)      
      {
         this.loadPage(idx);
      }
   };

   AriaController.prototype.prevPage = function () {
      var idx = Math.max(this._model.pageIdx - 1, 0);
      if (idx !== this._model.pageIdx)
      {
         this.loadPage(idx);
      }
   };

   AriaController.prototype.onError = function () {
      this._model.updateState(ST_ERROR);
   };

}
(vitrium.aria,
vitrium.easy,
Backbone, 
_));

// script:viewer/version.js
(function(version)
{
	version.major = 1;
	version.minor = 1;
	version.build = 403;
	version.buildTime = "2016-09-22T15:19:19.913000";

	version.toString = function() {
		return this.major+"."+this.minor + "."+ this.build;
	};

}(vitrium.viewer.version));
__globals__["vitrium"] = {};
_.extend(__globals__["vitrium"], { "i18n" : vitrium.i18n});
_.extend(__globals__["vitrium"], { "crypto" : vitrium.crypto});
_.extend(__globals__["vitrium"], { "codec" : vitrium.codec});
_.extend(__globals__["vitrium"], { "aria" : vitrium.aria});
_.extend(__globals__["vitrium"], { "log" : vitrium.log});

}.call(this, this));
    